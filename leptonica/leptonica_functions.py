
#coding: utf-8

import ctypes
from .leptonica_structures import *
#import .leptonica_structures as structs


# hide warnings
import os

try:
    import StringIO
except ImportError:
    from io import StringIO
os.stderr = StringIO()


try:
    leptonica = ctypes.cdll.LoadLibrary("liblept.so")
    libc = ctypes.cdll.LoadLibrary("libc.so.6")
except OSError: 
    # Known issue: liblept.so fails to load in ctypes with
    # Ubuntu 10.10 package - probably due to a missing dependence
    #Windows: untested ! 
    import ctypes.util
    leptonica = ctypes.cdll.LoadLibrary("liblept.dll")
    libc = ctypes.cdll.LoadLibrary(ctypes.util.find_msvcrt())

free = libc.free

def _convert_params(*args):
    new_args = []
    for arg in args:
        if isinstance(arg, LeptonObject):
            arg = arg._address_
        new_args.append(arg)
    return tuple(new_args)



class pixconv(object):
    """  pixconv.c

      These functions convert between images of different types
      without scaling.

      Conversion from 8 bpp grayscale to 1, 2, 4 and 8 bpp
           PIX        *pixThreshold8()

      Conversion from colormap to full color or grayscale
           PIX        *pixRemoveColormapGeneral()
           PIX        *pixRemoveColormap()

      Add colormap losslessly (8 to 8)
           l_int32     pixAddGrayColormap8()
           PIX        *pixAddMinimalGrayColormap8()

      Conversion from RGB color to grayscale
           PIX        *pixConvertRGBToLuminance()
           PIX        *pixConvertRGBToGray()
           PIX        *pixConvertRGBToGrayFast()
           PIX        *pixConvertRGBToGrayMinMax()
           PIX        *pixConvertRGBToGraySatBoost()

      Conversion from grayscale to colormap
           PIX        *pixConvertGrayToColormap()  -- 2, 4, 8 bpp
           PIX        *pixConvertGrayToColormap8()  -- 8 bpp only

      Colorizing conversion from grayscale to color
           PIX        *pixColorizeGray()  -- 8 bpp or cmapped

      Conversion from RGB color to colormap
           PIX        *pixConvertRGBToColormap()

      Quantization for relatively small number of colors in source
           l_int32     pixQuantizeIfFewColors()

      Conversion from 16 bpp to 8 bpp
           PIX        *pixConvert16To8()

      Conversion from grayscale to false color
           PIX        *pixConvertGrayToFalseColor()

      Unpacking conversion from 1 bpp to 2, 4, 8, 16 and 32 bpp
           PIX        *pixUnpackBinary()
           PIX        *pixConvert1To16()
           PIX        *pixConvert1To32()

      Unpacking conversion from 1 bpp to 2 bpp
           PIX        *pixConvert1To2Cmap()
           PIX        *pixConvert1To2()

      Unpacking conversion from 1 bpp to 4 bpp
           PIX        *pixConvert1To4Cmap()
           PIX        *pixConvert1To4()

      Unpacking conversion from 1, 2 and 4 bpp to 8 bpp
           PIX        *pixConvert1To8()
           PIX        *pixConvert2To8()
           PIX        *pixConvert4To8()

      Unpacking conversion from 8 bpp to 16 bpp
           PIX        *pixConvert8To16()

      Top-level conversion to 1 bpp
           PIX        *pixConvertTo1()
           PIX        *pixConvertTo1BySampling()

      Top-level conversion to 8 bpp
           PIX        *pixConvertTo8()
           PIX        *pixConvertTo8BySampling()
           PIX        *pixConvertTo8Color()

      Top-level conversion to 16 bpp
           PIX        *pixConvertTo16()

      Top-level conversion to 32 bpp (RGB)
           PIX        *pixConvertTo32()   ***
           PIX        *pixConvertTo32BySampling()   ***
           PIX        *pixConvert8To32()  ***

      Top-level conversion to 8 or 32 bpp, without colormap
           PIX        *pixConvertTo8Or32

      Conversion between 24 bpp and 32 bpp rgb
           PIX        *pixConvert24To32()
           PIX        *pixConvert32To24()

      Removal of alpha component by blending with white background
           PIX        *pixRemoveAlpha()

      Addition of alpha component to 1 bpp
           PIX        *pixAddAlphaTo1bpp()

      Lossless depth conversion (unpacking)
           PIX        *pixConvertLossless()

      Conversion for printing in PostScript
           PIX        *pixConvertForPSWrap()

      Scaling conversion to subpixel RGB
           PIX        *pixConvertToSubpixelRGB()
           PIX        *pixConvertGrayToSubpixelRGB()
           PIX        *pixConvertColorToSubpixelRGB()

      *** indicates implicit assumption about RGB component ordering

"""
    
    try:
        leptonica.pixConvertTo8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'cmapflag')       
  pixConvertTo8()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) This is a top-level function, with simple default values
          for unpacking.
      (2) The result, pixd, is made with a colormap if specified.
          It is always a new image -- never a clone.  For example,
          if d == 8, and cmapflag matches the existence of a cmap
          in pixs, the operation is lossless and it returns a copy.
      (3) The default values used are:
          - 1 bpp: val0 = 255, val1 = 0
          - 2 bpp: 4 bpp:  even increments over dynamic range
          - 8 bpp: lossless if cmap matches cmapflag
          - 16 bpp: use most significant byte
      (4) If 32 bpp RGB, this is converted to gray.  If you want
          to do color quantization, you must specify the type
          explicitly, using the color quantization code.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8(*args)
    
    

    try:
        leptonica.pixConvertTo1BySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertTo1BySampling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo1BySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo1BySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'threshold')       
  pixConvertTo1BySampling()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              factor (submsampling factor; integer >= 1)
              threshold (for final binarization, relative to 8 bpp)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This is a fast, quick/dirty, top-level converter.
      (2) See pixConvertTo1() for default values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo1BySampling(*args)
    
    

    try:
        leptonica.pixConvertRGBToColormap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertRGBToColormap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertRGBToColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToColormap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       
  pixConvertRGBToColormap()

      Input:  pixs (32 bpp rgb)
              ditherflag (1 to dither, 0 otherwise)
      Return: pixd (2, 4 or 8 bpp with colormap), or null on error

  Notes:
      (1) This function has two relatively simple modes of color
          quantization:
            (a) If the image is made orthographically and has not more
                than 256 'colors' at the level 4 octcube leaves,
                it is quantized nearly exactly.  The ditherflag
                is ignored.
            (b) Most natural images have more than 256 different colors;
                in that case we use adaptive octree quantization,
                with dithering if requested.
      (2) If there are not more than 256 occupied level 4 octcubes,
          the color in the colormap that represents all pixels in
          one of those octcubes is given by the first pixel that
          falls into that octcube.
      (3) If there are more than 256 colors, we use adaptive octree
          color quantization.
      (4) Dithering gives better visual results on images where
          there is a color wash (a slow variation of color), but it
          is about twice as slow and results in significantly larger
          files when losslessly compressed (e.g., into png).


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToColormap(*args)
    
    

    try:
        leptonica.pixConvert8To16.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert8To16.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert8To16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert8To16(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'leftshift')       
  pixConvert8To16()

      Input:  pixs (8 bpp; colormap removed to gray)
              leftshift (number of bits: 0 is no shift;
                         8 replicates in MSB and LSB of dest)
      Return: pixd (16 bpp), or null on error

  Notes:
      (1) For left shift of 8, the 8 bit value is replicated in both
          the MSB and the LSB of the pixels in pixd.  That way, we get
          proportional mapping, with a correct map from 8 bpp white
          (0xff) to 16 bpp white (0xffff).


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert8To16(*args)
    
    

    try:
        leptonica.pixConvertRGBToGrayFast.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToGrayFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertRGBToGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGrayFast(*args):
        """
        ('PIX', '*pixs')       
  pixConvertRGBToGrayFast()

      Input:  pix (32 bpp RGB)
      Return: 8 bpp pix, or null on error

  Notes:
      (1) This function should be used if speed of conversion
          is paramount, and the green channel can be used as
          a fair representative of the RGB intensity.  It is
          several times faster than pixConvertRGBToGray().
      (2) To combine RGB to gray conversion with subsampling,
          use pixScaleRGBToGrayFast() instead.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGrayFast(*args)
    
    

    try:
        leptonica.pixConvert16To8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert16To8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert16To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert16To8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  pixConvert16To8()

      Input:  pixs (16 bpp)
              type (L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_255)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) For each dest pixel, use either the LSB, the MSB, or the
          min(val, 255) for each 16-bit src pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert16To8(*args)
    
    

    try:
        leptonica.pixAddAlphaTo1bpp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddAlphaTo1bpp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddAlphaTo1bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddAlphaTo1bpp(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixAddAlphaTo1bpp()

      Input:  pixd (<optional> 1 bpp, can be null or equal to pixs
              pixs (1 bpp)
      Return: pixd (1 bpp with colormap and non-opaque alpha),
                    or null on error

  Notes:
      (1) We don't use 1 bpp colormapped images with alpha in leptonica,
          but we support generating them (here), writing to png, and reading
          the png.  On reading, they are converted to 32 bpp RGBA.
      (2) The background pixels in pixs become fully transparent, and the
          foreground pixels are fully opaque.  Thus, this is a compact
          1 bpp representation of a stencil, to paint over pixels of
          a backing image that are masked by the foreground in pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddAlphaTo1bpp(*args)
    
    

    try:
        leptonica.pixConvert1To16.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint16, ctypes.c_uint16]
        leptonica.pixConvert1To16.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To16(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint16', 'val0')       
('l_uint16', 'val1')       
  pixConvert1To16()

      Input:  pixd (<optional> 16 bpp, can be null)
              pixs (1 bpp)
              val0 (16 bit value to be used for 0s in pixs)
              val1 (16 bit value to be used for 1s in pixs)
      Return: pixd (16 bpp)

  Notes:
      (1) If pixd is null, a new pix is made.
      (2) If pixd is not null, it must be of equal width and height
          as pixs.  It is always returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To16(*args)
    
    

    try:
        leptonica.pixConvertRGBToGraySatBoost.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertRGBToGraySatBoost.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertRGBToGraySatBoost not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGraySatBoost(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'refval')       
  pixConvertRGBToGraySatBoost()

      Input:  pixs (32 bpp rgb)
              refval (between 1 and 255; typ. less than 128)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) This returns the max component value, boosted by
          the saturation. The maximum boost occurs where
          the maximum component value is equal to some reference value.
          This particular weighting is due to Dany Qumsiyeh.
      (2) For gray pixels (zero saturation), this returns
          the intensity of any component.
      (3) For fully saturated pixels ('fullsat'), this rises linearly
          with the max value and has a slope equal to 255 divided
          by the reference value; for a max value greater than
          the reference value, it is clipped to 255.
      (4) For saturation values in between, the output is a linear
          combination of (2) and (3), weighted by saturation.
          It falls between these two curves, and does not exceed 255.
      (5) This can be useful for distinguishing an object that has nonzero
          saturation from a gray background.  For this, the refval
          should be chosen near the expected value of the background,
          to achieve maximum saturation boost there.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGraySatBoost(*args)
    
    

    try:
        leptonica.pixConvertTo32.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo32(*args):
        """
        ('PIX', '*pixs')       
  pixConvertTo32()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
      Return: pixd (32 bpp), or null on error

  Usage: Top-level function, with simple default values for unpacking.
      1 bpp:  val0 = 255, val1 = 0
              and then replication into R, G and B components
      2 bpp:  if colormapped, use the colormap values; otherwise,
              use val0 = 0, val1 = 0x55, val2 = 0xaa, val3 = 255
              and replicate gray into R, G and B components
      4 bpp:  if colormapped, use the colormap values; otherwise,
              replicate 2 nybs into a byte, and then into R,G,B components
      8 bpp:  if colormapped, use the colormap values; otherwise,
              replicate gray values into R, G and B components
      16 bpp: replicate MSB into R, G and B components
      24 bpp: unpack the pixels, maintaining word alignment on each scanline
      32 bpp: makes a copy

  Notes:
      (1) Never returns a clone of pixs.
      (2) Implicit assumption about RGB component ordering.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo32(*args)
    
    

    try:
        leptonica.pixConvert2To8.argtypes = [ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_int32]
        leptonica.pixConvert2To8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert2To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert2To8(*args):
        """
        ('PIX', '*pixs')       
('l_uint8', 'val0')       
('l_uint8', 'val1')       
('l_uint8', 'val2')       
('l_uint8', 'val3')       
('l_int32', 'cmapflag')       
  pixConvert2To8()

      Input:  pixs (2 bpp)
              val0 (8 bit value to be used for 00 in pixs)
              val1 (8 bit value to be used for 01 in pixs)
              val2 (8 bit value to be used for 10 in pixs)
              val3 (8 bit value to be used for 11 in pixs)
              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)
      Return: pixd (8 bpp), or null on error

  Notes:
      - A simple unpacking might use val0 = 0,
        val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.
      - If cmapflag is TRUE:
          - The 8 bpp image is made with a colormap.
          - If pixs has a colormap, the input values are ignored and
            the 8 bpp image is made using the colormap
          - If pixs does not have a colormap, the input values are
            used to build the colormap.
      - If cmapflag is FALSE:
          - The 8 bpp image is made without a colormap.
          - If pixs has a colormap, the input values are ignored,
            the colormap is removed, and the values stored in the 8 bpp
            image are from the colormap.
          - If pixs does not have a colormap, the input values are
            used to populate the 8 bpp image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert2To8(*args)
    
    

    try:
        leptonica.pixConvertGrayToColormap8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertGrayToColormap8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertGrayToColormap8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToColormap8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'mindepth')       
  pixConvertGrayToColormap8()

      Input:  pixs (8 bpp grayscale)
              mindepth (of pixd; valid values are 2, 4 and 8)
      Return: pixd (2, 4 or 8 bpp with colormap), or null on error

  Notes:
      (1) Returns a copy if pixs already has a colormap.
      (2) This is a lossless transformation; there is no quantization.
          We compute the number of different gray values in pixs,
          and construct a colormap that has exactly these values.
      (3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,
          pixd will always be 8 bpp.  Let the number of different
          gray values in pixs be ngray.  If mindepth == 4, we attempt
          to save pixd as a 4 bpp image, but if ngray > 16,
          pixd must be 8 bpp.  Likewise, if mindepth == 2,
          the depth of pixd will be 2 if ngray <= 4 and 4 if ngray > 4
          but <= 16.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToColormap8(*args)
    
    

    try:
        leptonica.pixConvertToSubpixelRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConvertToSubpixelRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertToSubpixelRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToSubpixelRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'order')       
  pixConvertToSubpixelRGB()

      Input:  pixs (8 bpp grayscale, 32 bpp rgb, or colormapped)
              scalex, scaley (anisotropic scaling permitted between
                              source and destination)
              order (of subpixel rgb color components in composition of pixd:
                     L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,
                     L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR)

      Return: pixd (32 bpp), or null on error

  Notes:
      (1) If pixs has a colormap, it is removed based on its contents
          to either 8 bpp gray or rgb.
      (2) For horizontal subpixel splitting, the input image
          is rescaled by @scaley vertically and by 3.0 times
          @scalex horizontally.  Then each horizontal triplet
          of pixels is mapped back to a single rgb pixel, with the
          r, g and b values being assigned based on the pixel triplet.
          For gray triplets, the r, g, and b values are set equal to
          the three gray values.  For color triplets, the r, g and b
          values are set equal to the components from the appropriate
          subpixel.  Vertical subpixel splitting is handled similarly.
      (3) See pixConvertGrayToSubpixelRGB() and
          pixConvertColorToSubpixelRGB() for further details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToSubpixelRGB(*args)
    
    

    try:
        leptonica.pixConvert1To32.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixConvert1To32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To32(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'val0')       
('l_uint32', 'val1')       
  pixConvert1To32()

      Input:  pixd (<optional> 32 bpp, can be null)
              pixs (1 bpp)
              val0 (32 bit value to be used for 0s in pixs)
              val1 (32 bit value to be used for 1s in pixs)
      Return: pixd (32 bpp)

  Notes:
      (1) If pixd is null, a new pix is made.
      (2) If pixd is not null, it must be of equal width and height
          as pixs.  It is always returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To32(*args)
    
    

    try:
        leptonica.pixConvertTo8Color.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo8Color.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo8Color not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8Color(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dither')       
  pixConvertTo8Color()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              dither (1 to dither if necessary; 0 otherwise)
      Return: pixd (8 bpp, cmapped), or null on error

  Notes:
      (1) This is a top-level function, with simple default values
          for unpacking.
      (2) The result, pixd, is always made with a colormap.
      (3) If d == 8, the operation is lossless and it returns a copy.
      (4) The default values used for increasing depth are:
          - 1 bpp: val0 = 255, val1 = 0
          - 2 bpp: 4 bpp:  even increments over dynamic range
      (5) For 16 bpp, use the most significant byte.
      (6) For 32 bpp RGB, use octcube quantization with optional dithering.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8Color(*args)
    
    

    try:
        leptonica.pixConvert1To8.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixConvert1To8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To8(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint8', 'val0')       
('l_uint8', 'val1')       
  pixConvert1To8()

      Input:  pixd (<optional> 8 bpp, can be null)
              pixs (1 bpp)
              val0 (8 bit value to be used for 0s in pixs)
              val1 (8 bit value to be used for 1s in pixs)
      Return: pixd (8 bpp)

  Notes:
      (1) If pixd is null, a new pix is made.
      (2) If pixd is not null, it must be of equal width and height
          as pixs.  It is always returned.
      (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.
      (4) In a typical application where one wants to use a colormap
          with the dest, you can use val0 = 0, val1 = 1 to make a
          non-cmapped 8 bpp pix, and then make a colormap and set 0
          and 1 to the desired colors.  Here is an example:
             pixd = pixConvert1To8(NULL, pixs, 0, 1);
             cmap = pixCreate(8);
             pixcmapAddColor(cmap, 255, 255, 255);
             pixcmapAddColor(cmap, 0, 0, 0);
             pixSetColormap(pixd, cmap);


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To8(*args)
    
    

    try:
        leptonica.pixConvert1To2Cmap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert1To2Cmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To2Cmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To2Cmap(*args):
        """
        ('PIX', '*pixs')       
  pixConvert1To2Cmap()

      Input:  pixs (1 bpp)
      Return: pixd (2 bpp, cmapped)

  Notes:
      (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To2Cmap(*args)
    
    

    try:
        leptonica.pixConvert1To4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvert1To4.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To4(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'val0')       
('l_int32', 'val1')       
  pixConvert1To4()

      Input:  pixd (<optional> 4 bpp, can be null)
              pixs (1 bpp)
              val0 (4 bit value to be used for 0s in pixs)
              val1 (4 bit value to be used for 1s in pixs)
      Return: pixd (4 bpp)

  Notes:
      (1) If pixd is null, a new pix is made.
      (2) If pixd is not null, it must be of equal width and height
          as pixs.  It is always returned.
      (3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.
      (4) If you want a colormapped pixd, use pixConvert1To4Cmap().


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To4(*args)
    
    

    try:
        leptonica.pixConvertColorToSubpixelRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConvertColorToSubpixelRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertColorToSubpixelRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertColorToSubpixelRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'order')       
  pixConvertColorToSubpixelRGB()

      Input:  pixs (32 bpp or colormapped)
              scalex, scaley
              order (of subpixel rgb color components in composition of pixd:
                     L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,
                     L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR)

      Return: pixd (32 bpp), or null on error

  Notes:
      (1) If pixs has a colormap, it is removed to 32 bpp rgb.
          If the colormap has no color, pixConvertGrayToSubpixelRGB()
          should be called instead, because it will give the same result
          more efficiently.  The function pixConvertToSubpixelRGB()
          will do the best thing for all cases.
      (2) For horizontal subpixel splitting, the input rgb image
          is rescaled by @scaley vertically and by 3.0 times
          @scalex horizontally.  Then for each horizontal triplet
          of pixels, the r component of the final pixel is selected
          from the r component of the appropriate pixel in the triplet,
          and likewise for g and b.  Vertical subpixel splitting is
          handled similarly.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertColorToSubpixelRGB(*args)
    
    

    try:
        leptonica.pixConvertTo8BySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertTo8BySampling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo8BySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8BySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'cmapflag')       
  pixConvertTo8BySampling()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              factor (submsampling factor; integer >= 1)
              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) This is a fast, quick/dirty, top-level converter.
      (2) See pixConvertTo8() for default values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8BySampling(*args)
    
    

    try:
        leptonica.pixConvertForPSWrap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertForPSWrap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertForPSWrap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertForPSWrap(*args):
        """
        ('PIX', '*pixs')       
  pixConvertForPSWrap()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)
      Return: pixd (1, 8, or 32 bpp), or null on error

  Notes:
      (1) For wrapping in PostScript, we convert pixs to
          1 bpp, 8 bpp (gray) and 32 bpp (RGB color).
      (2) Colormaps are removed.  For pixs with colormaps, the
          images are converted to either 8 bpp gray or 32 bpp
          RGB, depending on whether the colormap has color content.
      (3) Images without colormaps, that are not 1 bpp or 32 bpp,
          are converted to 8 bpp gray.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertForPSWrap(*args)
    
    

    try:
        leptonica.pixConvert1To2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvert1To2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To2(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'val0')       
('l_int32', 'val1')       
  pixConvert1To2()

      Input:  pixd (<optional> 2 bpp, can be null)
              pixs (1 bpp)
              val0 (2 bit value to be used for 0s in pixs)
              val1 (2 bit value to be used for 1s in pixs)
      Return: pixd (2 bpp)

  Notes:
      (1) If pixd is null, a new pix is made.
      (2) If pixd is not null, it must be of equal width and height
          as pixs.  It is always returned.
      (3) A simple unpacking might use val0 = 0 and val1 = 3.
      (4) If you want a colormapped pixd, use pixConvert1To2Cmap().


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To2(*args)
    
    

    try:
        leptonica.pixConvertRGBToGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixConvertRGBToGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertRGBToGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       
  pixConvertRGBToGray()

      Input:  pix (32 bpp RGB)
              rwt, gwt, bwt  (non-negative; these should add to 1.0,
                              or use 0.0 for default)
      Return: 8 bpp pix, or null on error

  Notes:
      (1) Use a weighted average of the RGB values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGray(*args)
    
    

    try:
        leptonica.pixConvert1To4Cmap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert1To4Cmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert1To4Cmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To4Cmap(*args):
        """
        ('PIX', '*pixs')       
  pixConvert1To4Cmap()

      Input:  pixs (1 bpp)
      Return: pixd (4 bpp, cmapped)

  Notes:
      (1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To4Cmap(*args)
    
    

    try:
        leptonica.pixConvertTo16.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo16.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo16(*args):
        """
        ('PIX', '*pixs')       
  pixConvertTo16()

      Input:  pixs (1, 8 bpp)
      Return: pixd (16 bpp), or null on error

  Usage: Top-level function, with simple default values for unpacking.
      1 bpp:  val0 = 0xffff, val1 = 0
      8 bpp:  replicates the 8 bit value in both the MSB and LSB
              of the 16 bit pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo16(*args)
    
    

    try:
        leptonica.pixConvert32To24.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert32To24.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert32To24 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert32To24(*args):
        """
        ('PIX', '*pixs')       
  pixConvert32To24()

      Input:  pixs (32 bpp rgb)
      Return: pixd (24 bpp rgb), or null on error

  Notes:
      (1) See pixconvert24To32().


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert32To24(*args)
    
    

    try:
        leptonica.pixConvert24To32.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert24To32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert24To32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert24To32(*args):
        """
        ('PIX', '*pixs')       
  pixConvert24To32()

      Input:  pixs (24 bpp rgb)
      Return: pixd (32 bpp rgb), or null on error

  Notes:
      (1) 24 bpp rgb pix are not supported in leptonica, except for a small
          number of formatted write operations.  The data is a byte array,
          with pixels in order r,g,b, and padded to 32 bit boundaries
          in each line.
      (2) Because 24 bpp rgb pix are conveniently generated by programs
          such as xpdf (which has SplashBitmaps that store the raster
          data in consecutive 24-bit rgb pixels), it is useful to provide
          24 bpp pix that simply incorporate that data.  The only things
          we can do with these are:
            (a) write them to file in png, jpeg, tiff and pnm
            (b) interconvert between 24 and 32 bpp in memory (for testing).


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert24To32(*args)
    
    

    try:
        leptonica.pixRemoveColormap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRemoveColormap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveColormap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  pixRemoveColormap()

      Input:  pixs (see restrictions below)
              type (REMOVE_CMAP_TO_BINARY,
                    REMOVE_CMAP_TO_GRAYSCALE,
                    REMOVE_CMAP_TO_FULL_COLOR,
                    REMOVE_CMAP_WITH_ALPHA,
                    REMOVE_CMAP_BASED_ON_SRC)
      Return: pixd (without colormap), or null on error

  Notes:
      (1) If pixs does not have a colormap, a clone is returned.
      (2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.
      (3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.
      (4) For grayscale conversion from RGB, use a weighted average
          of RGB values, and always return an 8 bpp pix, regardless
          of whether the input pixs depth is 2, 4 or 8 bpp.
      (5) REMOVE_CMAP_TO_FULL_COLOR ignores the alpha component and
          returns a 32 bpp pix with spp == 3 and the alpha bytes are 0.
      (6) For REMOVE_CMAP_BASED_ON_SRC, if there is no color, this
          returns either a 1 bpp or 8 bpp grayscale pix.
          If there is color, this returns a 32 bpp pix, with either:
           * 3 spp, if the alpha values are all 255 (opaque), or
           * 4 spp (preserving the alpha), if any alpha values are not 255.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveColormap(*args)
    
    

    try:
        leptonica.pixConvertRGBToLuminance.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToLuminance.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertRGBToLuminance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToLuminance(*args):
        """
        ('PIX', '*pixs')       
  pixConvertRGBToLuminance()

      Input:  pix (32 bpp RGB)
      Return: 8 bpp pix, or null on error

  Notes:
      (1) Use a standard luminance conversion.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToLuminance(*args)
    
    

    try:
        leptonica.pixAddGrayColormap8.argtypes = [ctypes.c_void_p]
        leptonica.pixAddGrayColormap8.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAddGrayColormap8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddGrayColormap8(*args):
        """
        ('PIX', '*pixs')       
  pixAddGrayColormap8()

      Input:  pixs (8 bpp)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If pixs has a colormap, this is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddGrayColormap8(*args)
    
    

    try:
        leptonica.pixConvertTo1.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo1.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo1(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'threshold')       
  pixConvertTo1()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              threshold (for final binarization, relative to 8 bpp)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This is a top-level function, with simple default values
          used in pixConvertTo8() if unpacking is necessary.
      (2) Any existing colormap is removed.
      (3) If the input image has 1 bpp and no colormap, the operation is
          lossless and a copy is returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo1(*args)
    
    

    try:
        leptonica.pixColorizeGray.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixColorizeGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorizeGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorizeGray(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'color')       
('l_int32', 'cmapflag')       
  pixColorizeGray()

      Input:  pixs (8 bpp gray; 2, 4 or 8 bpp colormapped)
              color (32 bit rgba pixel)
              cmapflag (1 for result to have colormap; 0 for RGB)
      Return: pixd (8 bpp colormapped or 32 bpp rgb), or null on error

  Notes:
      (1) This applies the specific color to the grayscale image.
      (2) If pixs already has a colormap, it is removed to gray
          before colorizing.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorizeGray(*args)
    
    

    try:
        leptonica.pixConvertTo32BySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo32BySampling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo32BySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo32BySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixConvertTo32BySampling()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              factor (submsampling factor; integer >= 1)
      Return: pixd (32 bpp), or null on error

  Notes:
      (1) This is a fast, quick/dirty, top-level converter.
      (2) See pixConvertTo32() for default values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo32BySampling(*args)
    
    

    try:
        leptonica.pixAddMinimalGrayColormap8.argtypes = [ctypes.c_void_p]
        leptonica.pixAddMinimalGrayColormap8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddMinimalGrayColormap8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddMinimalGrayColormap8(*args):
        """
        ('PIX', '*pixs')       
  pixAddMinimalGrayColormap8()

      Input:  pixs (8 bpp)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This generates a colormapped version of the input image
          that has the same number of colormap entries as the
          input image has unique gray levels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddMinimalGrayColormap8(*args)
    
    

    try:
        leptonica.pixRemoveColormapGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveColormapGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveColormapGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveColormapGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'ifnocmap')       
  pixRemoveColormapGeneral()

      Input:  pixs (any depth, with or without colormap)
              type (REMOVE_CMAP_TO_BINARY,
                    REMOVE_CMAP_TO_GRAYSCALE,
                    REMOVE_CMAP_TO_FULL_COLOR,
                    REMOVE_CMAP_WITH_ALPHA,
                    REMOVE_CMAP_BASED_ON_SRC)
              ifnocmap (L_CLONE, L_COPY)
      Return: pixd (always a new pix; without colormap), or null on error

  Notes:
      (1) Convenience function that allows choice between returning
          a clone or a copy if pixs does not have a colormap.
      (2) See pixRemoveColormap().


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveColormapGeneral(*args)
    
    

    try:
        leptonica.pixThreshold8.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThreshold8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThreshold8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThreshold8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'd')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       
  pixThreshold8()

      Input:  pix (8 bpp grayscale)
              d (destination depth: 1, 2, 4 or 8)
              nlevels (number of levels to be used for colormap)
              cmapflag (1 if makes colormap; 0 otherwise)
      Return: pixd (thresholded with standard dest thresholds),
              or null on error

  Notes:
      (1) This uses, by default, equally spaced "target" values
          that depend on the number of levels, with thresholds
          halfway between.  For N levels, with separation (N-1)/255,
          there are N-1 fixed thresholds.
      (2) For 1 bpp destination, the number of levels can only be 2
          and if a cmap is made, black is (0,0,0) and white
          is (255,255,255), which is opposite to the convention
          without a colormap.
      (3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap
          is made; otherwise, we take the most significant bits
          from the src that will fit in the dest.
      (4) For 8 bpp, the input pixs is quantized to nlevels.  The
          dest quantized with that mapping, either through a colormap
          table or directly with 8 bit values.
      (5) Typically you should not use make a colormap for 1 bpp dest.
      (6) This is not dithering.  Each pixel is treated independently.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThreshold8(*args)
    
    

    try:
        leptonica.pixRemoveAlpha.argtypes = [ctypes.c_void_p]
        leptonica.pixRemoveAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveAlpha(*args):
        """
        ('PIX', '*pixs')       
  pixRemoveAlpha()

      Input:  pixs (any depth)
      Return: pixd (if 32 bpp rgba, pixs blended over a white background;
                    a clone of pixs otherwise), and null on error

  Notes:
      (1) This is a wrapper on pixAlphaBlendUniform()


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveAlpha(*args)
    
    

    try:
        leptonica.pixConvertGrayToSubpixelRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConvertGrayToSubpixelRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertGrayToSubpixelRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToSubpixelRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'order')       
  pixConvertGrayToSubpixelRGB()

      Input:  pixs (8 bpp or colormapped)
              scalex, scaley
              order (of subpixel rgb color components in composition of pixd:
                     L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,
                     L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR)

      Return: pixd (32 bpp), or null on error

  Notes:
      (1) If pixs has a colormap, it is removed to 8 bpp.
      (2) For horizontal subpixel splitting, the input gray image
          is rescaled by @scaley vertically and by 3.0 times
          @scalex horizontally.  Then each horizontal triplet
          of pixels is mapped back to a single rgb pixel, with the
          r, g and b values being assigned from the triplet of gray values.
          Similar operations are used for vertical subpixel splitting.
      (3) This is a form of subpixel rendering that tends to give the
          resulting text a sharper and somewhat chromatic display.
          For horizontal subpixel splitting, the observable difference
          between @order=L_SUBPIXEL_ORDER_RGB and
          @order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers
          in the display that make the pixel color appear to emerge
          from the entire pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToSubpixelRGB(*args)
    
    

    try:
        leptonica.pixConvertRGBToGrayMinMax.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertRGBToGrayMinMax.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertRGBToGrayMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGrayMinMax(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  pixConvertRGBToGrayMinMax()

      Input:  pix (32 bpp RGB)
              type (L_CHOOSE_MIN, L_CHOOSE_MAX or L_CHOOSE_MAX_MIN_DIFF)
      Return: 8 bpp pix, or null on error

  Notes:
      (1) This chooses the min, the max, or the difference between
          the max and the min, of the three RGB sample values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGrayMinMax(*args)
    
    

    try:
        leptonica.pixConvertTo8Or32.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertTo8Or32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertTo8Or32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8Or32(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'copyflag')       
('l_int32', 'warnflag')       
  pixConvertTo8Or32()

      Input:  pixs (1, 2, 4, 8, 16, with or without colormap; or 32 bpp rgb)
              copyflag (use 0 to return clone if pixs does not need to
                         be changed; 1 to return a copy in those situations)
              warnflag (1 to issue warning if colormap is removed; else 0)
      Return: pixd (8 bpp grayscale or 32 bpp rgb), or null on error

  Notes:
      (1) If there is a colormap, the colormap is removed to 8 or 32 bpp,
          depending on whether the colors in the colormap are all gray.
      (2) If the input is either rgb or 8 bpp without a colormap,
          this returns either a clone or a copy, depending on @copyflag.
      (3) Otherwise, the pix is converted to 8 bpp grayscale.
          In all cases, pixd does not have a colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8Or32(*args)
    
    

    try:
        leptonica.pixConvertGrayToColormap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertGrayToColormap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertGrayToColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToColormap(*args):
        """
        ('PIX', '*pixs')       
  pixConvertGrayToColormap()

      Input:  pixs (2, 4 or 8 bpp grayscale)
      Return: pixd (2, 4 or 8 bpp with colormap), or null on error

  Notes:
      (1) This is a simple interface for adding a colormap to a
          2, 4 or 8 bpp grayscale image without causing any
          quantization.  There is some similarity to operations
          in grayquant.c, such as pixThresholdOn8bpp(), where
          the emphasis is on quantization with an arbitrary number
          of levels, and a colormap is an option.
      (2) Returns a copy if pixs already has a colormap.
      (3) For 8 bpp src, this is a lossless transformation.
      (4) For 2 and 4 bpp src, this generates a colormap that
          assumes full coverage of the gray space, with equally spaced
          levels: 4 levels for d = 2 and 16 levels for d = 4.
      (5) In all cases, the depth of the dest is the same as the src.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToColormap(*args)
    
    

    try:
        leptonica.pixConvert4To8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert4To8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert4To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert4To8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'cmapflag')       
  pixConvert4To8()

      Input:  pixs (4 bpp)
              cmapflag (TRUE if pixd is to have a colormap; FALSE otherwise)
      Return: pixd (8 bpp), or null on error

  Notes:
      - If cmapflag is TRUE:
          - pixd is made with a colormap.
          - If pixs has a colormap, it is copied and the colormap
            index values are placed in pixd.
          - If pixs does not have a colormap, a colormap with linear
            trc is built and the pixel values in pixs are placed in
            pixd as colormap index values.
      - If cmapflag is FALSE:
          - pixd is made without a colormap.
          - If pixs has a colormap, it is removed and the values stored
            in pixd are from the colormap (converted to gray).
          - If pixs does not have a colormap, the pixel values in pixs
            are used, with shift replication, to populate pixd.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert4To8(*args)
    
    

    try:
        leptonica.pixUnpackBinary.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUnpackBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnpackBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnpackBinary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'depth')       
('l_int32', 'invert')       
  pixUnpackBinary()

      Input:  pixs (1 bpp)
              depth (of destination: 2, 4, 8, 16 or 32 bpp)
              invert (0:  binary 0 --> grayscale 0
                          binary 1 --> grayscale 0xff...
                      1:  binary 0 --> grayscale 0xff...
                          binary 1 --> grayscale 0)
      Return: pixd (2, 4, 8, 16 or 32 bpp), or null on error

  Notes:
      (1) This function calls special cases of pixConvert1To*(),
          for 2, 4, 8, 16 and 32 bpp destinations.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnpackBinary(*args)
    
    

    try:
        leptonica.pixConvertGrayToFalseColor.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixConvertGrayToFalseColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertGrayToFalseColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToFalseColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'gamma')       
  pixConvertGrayToFalseColor()

      Input:  pixs (8 or 16 bpp grayscale)
              gamma factor (0.0 or 1.0 for default; > 1.0 for brighter;
                            2.0 is quite nice)
      Return: pixd (8 bpp with colormap), or null on error

  Notes:
      (1) For 8 bpp input, this simply adds a colormap to the input image.
      (2) For 16 bpp input, it first converts to 8 bpp, using the MSB,
          and then adds the colormap.
      (3) The colormap is modeled after the Matlab "jet" configuration.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToFalseColor(*args)
    
    

    try:
        leptonica.pixConvertLossless.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertLossless.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertLossless not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertLossless(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'd')       
  pixConvertLossless()

      Input:  pixs (1, 2, 4, 8 bpp, not cmapped)
              d (destination depth: 2, 4 or 8)
      Return: pixd (2, 4 or 8 bpp), or null on error

  Notes:
      (1) This is a lossless unpacking (depth-increasing)
          conversion.  If ds is the depth of pixs, then
           - if d < ds, returns NULL
           - if d == ds, returns a copy
           - if d > ds, does the unpacking conversion
      (2) If pixs has a colormap, this is an error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertLossless(*args)
    
    

    try:
        leptonica.pixQuantizeIfFewColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixQuantizeIfFewColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixQuantizeIfFewColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuantizeIfFewColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxcolors')       
('l_int32', 'mingraycolors')       
('l_int32', 'octlevel')       
('PIX', '**ppixd')       
  pixQuantizeIfFewColors()

      Input:  pixs (8 bpp gray or 32 bpp rgb)
              maxcolors (max number of colors allowed to be returned
                         from pixColorsForQuantization(); use 0 for default)
              mingraycolors (min number of gray levels that a grayscale
                             image is quantized to; use 0 for default)
              octlevel (for octcube quantization: 3 or 4)
              &pixd (2, 4 or 8 bpp quantized; null if too many colors)
      Return: 0 if OK, 1 on error or if pixs can't be quantized into
              a small number of colors.

  Notes:
      (1) This is a wrapper that tests if the pix can be quantized
          with good quality using a small number of colors.  If so,
          it does the quantization, defining a colormap and using
          pixels whose value is an index into the colormap.
      (2) If the image has color, it is quantized with 8 bpp pixels.
          If the image is essentially grayscale, the pixels are
          either 4 or 8 bpp, depending on the size of the required
          colormap.
      (3) @octlevel = 4 generates a larger colormap and larger
          compressed image than @octlevel = 3.  If image quality is
          important, you should use @octlevel = 4.
      (4) If the image already has a colormap, it returns a clone.


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuantizeIfFewColors(*args)
    
    

    try:
        leptonica.pixConvert8To32.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert8To32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvert8To32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert8To32(*args):
        """
        ('PIX', '*pixs')       
  pixConvert8To32()

      Input:  pix (8 bpp)
      Return: 32 bpp rgb pix, or null on error

  Notes:
      (1) If there is no colormap, replicates the gray value
          into the 3 MSB of the dest pixel.
      (2) Implicit assumption about RGB component ordering.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert8To32(*args)
    




class paintcmap(object):
    """  paintcmap.c

      These in-place functions paint onto colormap images.

      Repaint selected pixels in region
           l_int32     pixSetSelectCmap()

      Repaint non-white pixels in region
           l_int32     pixColorGrayRegionsCmap()
           l_int32     pixColorGrayCmap()
           l_int32     addColorizedGrayToCmap()

      Repaint selected pixels through mask
           l_int32     pixSetSelectMaskedCmap()

      Repaint all pixels through mask
           l_int32     pixSetMaskedCmap()


  The 'set select' functions condition the setting on a specific
  pixel value (i.e., index into the colormap) of the underyling
  Pix that is being modified.  The same conditioning is used in
  pixBlendCmap().

  The pixColorGrayCmap() function sets all truly gray (r = g = b) pixels,
  with the exception of either black or white pixels, to a new color.

  The pixSetSelectMaskedCmap() function conditions pixel painting
  on both a specific pixel value and location within the fg mask.
  By contrast, pixSetMaskedCmap() sets all pixels under the
  mask foreground, without considering the initial pixel values.

"""
    
    try:
        leptonica.pixColorGrayRegionsCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayRegionsCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorGrayRegionsCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayRegionsCmap(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixColorGrayRegionsCmap()

      Input:  pixs (8 bpp, with colormap)
              boxa (of regions in which to apply color)
              type (L_PAINT_LIGHT, L_PAINT_DARK)
              rval, gval, bval (target color)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
          preserving antialiasing.
          If type == L_PAINT_DARK, it colorizes non-white pixels,
          preserving antialiasing.  See pixColorGrayCmap() for details.
      (3) This can also be called through pixColorGrayRegions().
      (4) This increases the colormap size by the number of
          different gray (non-black or non-white) colors in the
          selected regions of pixs.  If there is not enough room in
          the colormap for this expansion, it returns 1 (error),
          and the caller should check the return value.
      (5) Because two boxes in the boxa can overlap, pixels that
          are colorized in the first box must be excluded in the
          second because their value exceeds the size of the map.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayRegionsCmap(*args)
    
    

    try:
        leptonica.pixSetMaskedCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetMaskedCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetMaskedCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMaskedCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixSetMaskedCmap()

      Input:  pixs (2, 4 or 8 bpp, colormapped)
              pixm (<optional> 1 bpp mask; no-op if NULL)
              x, y (origin of pixm relative to pixs; can be negative)
              rval, gval, bval (new color to set at each masked pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) It paints a single color through the mask (as a stencil).
      (3) The mask origin is placed at (x,y) on pixs, and the
          operation is clipped to the intersection of the mask and pixs.
      (4) If pixm == NULL, a warning is given.
      (5) Typically, pixm is a small binary mask located somewhere
          on the larger pixs.
      (6) If the color is in the colormap, it is used.  Otherwise,
          it is added if possible; an error is returned if the
          colormap is already full.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMaskedCmap(*args)
    
    

    try:
        leptonica.pixColorGrayCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorGrayCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayCmap(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixColorGrayCmap()

      Input:  pixs (2, 4 or 8 bpp, with colormap)
              box (<optional> region to set color; can be NULL)
              type (L_PAINT_LIGHT, L_PAINT_DARK)
              rval, gval, bval (target color)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
          preserving antialiasing.
          If type == L_PAINT_DARK, it colorizes non-white pixels,
          preserving antialiasing.
      (3) box gives the region to apply color; if NULL, this
          colorizes the entire image.
      (4) If the cmap is only 2 or 4 bpp, pixs is converted in-place
          to an 8 bpp cmap.  A 1 bpp cmap is not a valid input pix.
      (5) This can also be called through pixColorGray().
      (6) This operation increases the colormap size by the number of
          different gray (non-black or non-white) colors in the
          input colormap.  If there is not enough room in the colormap
          for this expansion, it returns 1 (error), and the caller
          should check the return value.
      (7) Using the darkness of each original pixel in the rect,
          it generates a new color (based on the input rgb values).
          If type == L_PAINT_LIGHT, the new color is a (generally)
          darken-to-black version of the  input rgb color, where the
          amount of darkening increases with the darkness of the
          original pixel color.
          If type == L_PAINT_DARK, the new color is a (generally)
          faded-to-white version of the  input rgb color, where the
          amount of fading increases with the brightness of the
          original pixel color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayCmap(*args)
    
    

    try:
        leptonica.addColorizedGrayToCmap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.addColorizedGrayToCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function addColorizedGrayToCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def addColorizedGrayToCmap(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('NUMA', '**pna')       
  addColorizedGrayToCmap()

      Input:  cmap (from 2 or 4 bpp pix)
              type (L_PAINT_LIGHT, L_PAINT_DARK)
              rval, gval, bval (target color)
              &na (<optional return> table for mapping new cmap entries)
      Return: 0 if OK; 1 on error; 2 if new colors will not fit in cmap.

  Notes:
      (1) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
          preserving antialiasing.
          If type == L_PAINT_DARK, it colorizes non-white pixels,
          preserving antialiasing.
      (2) This increases the colormap size by the number of
          different gray (non-black or non-white) colors in the
          input colormap.  If there is not enough room in the colormap
          for this expansion, it returns 1 (treated as a warning);
          the caller should check the return value.
      (3) This can be used to determine if the new colors will fit in
          the cmap, using null for &na.  Returns 0 if they fit; 2 if
          they don't fit.
      (4) The mapping table contains, for each gray color found, the
          index of the corresponding colorized pixel.  Non-gray
          pixels are assigned the invalid index 256.
      (5) See pixColorGrayCmap() for usage.


        """
        args = _convert_params(*args)
        
        return leptonica.addColorizedGrayToCmap(*args)
    
    

    try:
        leptonica.pixSetSelectCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetSelectCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetSelectCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetSelectCmap(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'sindex')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixSetSelectCmap()

      Input:  pixs (1, 2, 4 or 8 bpp, with colormap)
              box (<optional> region to set color; can be NULL)
              sindex (colormap index of pixels to be changed)
              rval, gval, bval (new color to paint)
      Return: 0 if OK, 1 on error

  Note:
      (1) This is an in-place operation.
      (2) It sets all pixels in region that have the color specified
          by the colormap index 'sindex' to the new color.
      (3) sindex must be in the existing colormap; otherwise an
          error is returned.
      (4) If the new color exists in the colormap, it is used;
          otherwise, it is added to the colormap.  If it cannot be
          added because the colormap is full, an error is returned.
      (5) If box is NULL, applies function to the entire image; otherwise,
          clips the operation to the intersection of the box and pix.
      (6) An example of use would be to set to a specific color all
          the light (background) pixels within a certain region of
          a 3-level 2 bpp image, while leaving light pixels outside
          this region unchanged.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetSelectCmap(*args)
    
    

    try:
        leptonica.pixSetSelectMaskedCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetSelectMaskedCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetSelectMaskedCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetSelectMaskedCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'sindex')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixSetSelectMaskedCmap()

      Input:  pixs (2, 4 or 8 bpp, with colormap)
              pixm (<optional> 1 bpp mask; no-op if NULL)
              x, y (UL corner of mask relative to pixs)
              sindex (colormap index of pixels in pixs to be changed)
              rval, gval, bval (new color to substitute)
      Return: 0 if OK, 1 on error

  Note:
      (1) This is an in-place operation.
      (2) This paints through the fg of pixm and replaces all pixels
          in pixs that have a particular value (sindex) with the new color.
      (3) If pixm == NULL, a warning is given.
      (4) sindex must be in the existing colormap; otherwise an
          error is returned.
      (5) If the new color exists in the colormap, it is used;
          otherwise, it is added to the colormap.  If the colormap
          is full, an error is returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetSelectMaskedCmap(*args)
    




class graphics(object):
    """  graphics.c

      Pta generation for arbitrary shapes built with lines
          PTA        *generatePtaLine()
          PTA        *generatePtaWideLine()
          PTA        *generatePtaBox()
          PTA        *generatePtaBoxa()
          PTA        *generatePtaHashBox()
          PTA        *generatePtaHashBoxa()
          PTAA       *generatePtaaBoxa()
          PTAA       *generatePtaaHashBoxa()
          PTA        *generatePtaPolyline()
          PTA        *convertPtaLineTo4cc()
          PTA        *generatePtaFilledCircle()
          PTA        *generatePtaFilledSquare()
          PTA        *generatePtaLineFromPt()
          l_int32     locatePtRadially()

      Rendering function plots directly on images
          l_int32     pixRenderPlotFromNuma()
          l_int32     pixRenderPlotFromNumaGen()
          PTA        *makePlotPtaFromNuma()
          PTA        *makePlotPtaFromNumaGen()

      Pta rendering
          l_int32     pixRenderPta()
          l_int32     pixRenderPtaArb()
          l_int32     pixRenderPtaBlend()

      Rendering of arbitrary shapes built with lines
          l_int32     pixRenderLine()
          l_int32     pixRenderLineArb()
          l_int32     pixRenderLineBlend()

          l_int32     pixRenderBox()
          l_int32     pixRenderBoxArb()
          l_int32     pixRenderBoxBlend()

          l_int32     pixRenderBoxa()
          l_int32     pixRenderBoxaArb()
          l_int32     pixRenderBoxaBlend()

          l_int32     pixRenderHashBox()
          l_int32     pixRenderHashBoxArb()
          l_int32     pixRenderHashBoxBlend()

          l_int32     pixRenderHashBoxa()
          l_int32     pixRenderHashBoxaArb()
          l_int32     pixRenderHashBoxaBlend()

          l_int32     pixRenderPolyline()
          l_int32     pixRenderPolylineArb()
          l_int32     pixRenderPolylineBlend()

          l_int32     pixRenderRandomCmapPtaa()

      Rendering and filling of polygons
          PIX        *pixRenderPolygon()
          PIX        *pixFillPolygon()

      Contour rendering on grayscale images
          PIX        *pixRenderContours()
          PIX        *fpixAutoRenderContours()
          PIX        *fpixRenderContours()

  The line rendering functions are relatively crude, but they
  get the job done for most simple situations.  We use the pta
  (array of points) as an intermediate data structure.  For example,
  to render a line we first generate a pta.

  Some rendering functions come in sets of three.  For example
       pixRenderLine() -- render on 1 bpp pix
       pixRenderLineArb() -- render on 32 bpp pix with arbitrary (r,g,b)
       pixRenderLineBlend() -- render on 32 bpp pix, blending the
               (r,g,b) graphic object with the underlying rgb pixels.

  There are also procedures for plotting a function, computed
  from the row or column pixels, directly on the image.

"""
    
    try:
        leptonica.pixFillPolygon.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFillPolygon.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFillPolygon not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillPolygon(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*pta')       
('l_int32', 'xmin')       
('l_int32', 'ymin')       
  pixFillPolygon()

      Input:  pixs (1 bpp, with 4-connected polygon outline)
              pta (vertices of the polygon)
              xmin, ymin (min values of vertices of polygon)
      Return: pixd (with outline filled), or null on error

  Notes:
      (1) This fills the interior of the polygon, returning a
          new pix.  It works for both convex and non-convex polygons.
      (2) To generate a filled polygon from a pta:
            PIX *pixt = pixRenderPolygon(pta, 1, &xmin, &ymin);
            PIX *pixd = pixFillPolygon(pixt, pta, xmin, ymin);
            pixDestroy(&pixt);


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillPolygon(*args)
    
    

    try:
        leptonica.generatePtaBox.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.generatePtaBox.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaBox(*args):
        """
        ('BOX', '*box')       
('l_int32', 'width')       
  generatePtaBox()

      Input:  box
              width (of line)
      Return: ptad, or null on error

  Notes:
      (1) Because the box is constructed so that we don't have any
          overlapping lines, there is no need to remove duplicates.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaBox(*args)
    
    

    try:
        leptonica.pixRenderPolyline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderPolyline.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPolyline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolyline(*args):
        """
        ('PIX', '*pix')       
('PTA', '*ptas')       
('l_int32', 'width')       
('l_int32', 'op')       
('l_int32', 'closeflag')       
  pixRenderPolyline()

      Input:  pix
              ptas
              width  (thickness of line)
              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
              closeflag (1 to close the contour; 0 otherwise)
      Return: 0 if OK, 1 on error

  Note: this renders a closed contour.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolyline(*args)
    
    

    try:
        leptonica.fpixRenderContours.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.fpixRenderContours.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixRenderContours not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRenderContours(*args):
        """
        ('FPIX', '*fpixs')       
('l_float32', 'incr')       
('l_float32', 'proxim')       
  fpixRenderContours()

      Input:  fpixs
              incr  (increment between contours; must be > 0.0)
              proxim (required proximity to target value; default 0.15)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) Values are displayed when val/incr is within +-proxim
          to an integer.  The default value is 0.15; smaller values
          result in thinner contour lines.
      (2) Negative values are rendered in red; positive values as black.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRenderContours(*args)
    
    

    try:
        leptonica.pixRenderBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBox(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'width')       
('l_int32', 'op')       
  pixRenderBox()

      Input:  pix
              box
              width  (thickness of box lines)
              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBox(*args)
    
    

    try:
        leptonica.generatePtaHashBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaHashBox.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaHashBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaHashBox(*args):
        """
        ('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
  generatePtaHashBox()

      Input:  box
              spacing (spacing between lines; must be > 1)
              width  (of line)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
      Return: ptad, or null on error

  Notes:
      (1) The orientation takes on one of 4 orientations (horiz, vertical,
          slope +1, slope -1).
      (2) The full outline is also drawn if @outline = 1.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaHashBox(*args)
    
    

    try:
        leptonica.generatePtaFilledCircle.argtypes = [ctypes.c_int32]
        leptonica.generatePtaFilledCircle.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaFilledCircle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaFilledCircle(*args):
        """
        ('l_int32', 'radius')       
  generatePtaFilledCircle()

      Input:  radius
      Return: pta, or null on error

  Notes:
      (1) The circle is has diameter = 2 * radius + 1.
      (2) It is located with the center of the circle at the
          point (radius, radius).
      (3) Consequently, it typically must be translated if
          it is to represent a set of pixels in an image.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaFilledCircle(*args)
    
    

    try:
        leptonica.generatePtaaBoxa.argtypes = [ctypes.c_void_p]
        leptonica.generatePtaaBoxa.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaaBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaaBoxa(*args):
        """
        ('BOXA', '*boxa')       
  generatePtaaBoxa()

      Input:  boxa
      Return: ptaa, or null on error

  Notes:
      (1) This generates a pta of the four corners for each box in
          the boxa.
      (2) Each of these pta can be rendered onto a pix with random colors,
          by using pixRenderRandomCmapPtaa() with closeflag = 1.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaaBoxa(*args)
    
    

    try:
        leptonica.pixRenderContours.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderContours.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRenderContours not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderContours(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'startval')       
('l_int32', 'incr')       
('l_int32', 'outdepth')       
  pixRenderContours()

      Input:  pixs (8 or 16 bpp; no colormap)
              startval (value of lowest contour; must be in [0 ... maxval])
              incr  (increment to next contour; must be > 0)
              outdepth (either 1 or depth of pixs)
      Return: pixd, or null on error

  Notes:
      (1) The output can be either 1 bpp, showing just the contour
          lines, or a copy of the input pixs with the contour lines
          superposed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderContours(*args)
    
    

    try:
        leptonica.pixRenderBoxaArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderBoxaArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderBoxaArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxaArb(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
  pixRenderBoxaArb()

      Input:  pix
              boxa
              width  (thickness of line)
              rval, gval, bval
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxaArb(*args)
    
    

    try:
        leptonica.pixRenderBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderBoxa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxa(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_int32', 'op')       
  pixRenderBoxa()

      Input:  pix
              boxa
              width  (thickness of line)
              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxa(*args)
    
    

    try:
        leptonica.pixRenderPolylineBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderPolylineBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPolylineBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolylineBlend(*args):
        """
        ('PIX', '*pix')       
('PTA', '*ptas')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
('l_int32', 'closeflag')       
('l_int32', 'removedups')       
  pixRenderPolylineBlend()

      Input:  pix
              ptas
              width  (thickness of line)
              rval, gval, bval
              fract (in [0.0 - 1.0]; complete transparency (no effect)
                     if 0.0; no transparency if 1.0)
              closeflag (1 to close the contour; 0 otherwise)
              removedups  (1 to remove; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolylineBlend(*args)
    
    

    try:
        leptonica.locatePtRadially.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_double, ctypes.c_double, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.locatePtRadially.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function locatePtRadially not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def locatePtRadially(*args):
        """
        ('l_int32', 'xr')       
('l_int32', 'yr')       
('l_float64', 'dist')       
('l_float64', 'radang')       
('l_float64', '*px')       
('l_float64', '*py')       
  locatePtRadially()

      Input:  xr, yr  (reference point)
              radang (angle in radians, CW from horizontal)
              dist (distance of point from reference point along line
                    given by the specified angle)
              &x, &y (<return> location of point)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.locatePtRadially(*args)
    
    

    try:
        leptonica.generatePtaWideLine.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaWideLine.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaWideLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaWideLine(*args):
        """
        ('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
  generatePtaWideLine()

      Input:  x1, y1  (end point 1)
              x2, y2  (end point 2)
              width
      Return: ptaj, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaWideLine(*args)
    
    

    try:
        leptonica.pixRenderPlotFromNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixRenderPlotFromNuma.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPlotFromNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPlotFromNuma(*args):
        """
        ('PIX', '**ppix')       
('NUMA', '*na')       
('l_int32', 'plotloc')       
('l_int32', 'linewidth')       
('l_int32', 'max')       
('l_uint32', 'color')       
  pixRenderPlotFromNuma()

      Input:  &pix (any type; replaced if not 32 bpp rgb)
              numa (to be plotted)
              plotloc (location of plot: L_PLOT_AT_TOP, etc)
              linewidth (width of "line" that is drawn; between 1 and 7)
              max (maximum excursion in pixels from baseline)
              color (plot color: 0xrrggbb00)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Simplified interface for plotting row or column aligned data
          on a pix.
      (2) This replaces @pix with a 32 bpp rgb version if it is not
          already 32 bpp.  It then draws the plot on the pix.
      (3) See makePlotPtaFromNumaGen() for more details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPlotFromNuma(*args)
    
    

    try:
        leptonica.generatePtaLine.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaLine.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaLine(*args):
        """
        ('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
  generatePtaLine()

      Input:  x1, y1  (end point 1)
              x2, y2  (end point 2)
      Return: pta, or null on error

  Notes:
      (1) Uses Bresenham line drawing, which results in an 8-connected line.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaLine(*args)
    
    

    try:
        leptonica.generatePtaaHashBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaaHashBoxa.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaaHashBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaaHashBoxa(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
  generatePtaaHashBoxa()

      Input:  boxa
              spacing (spacing between hash lines; must be > 1)
              width  (hash line width)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
      Return: ptaa, or null on error

  Notes:
      (1) The orientation takes on one of 4 orientations (horiz, vertical,
          slope +1, slope -1).
      (2) The full outline is also drawn if @outline = 1.
      (3) Each of these pta can be rendered onto a pix with random colors,
          by using pixRenderRandomCmapPtaa() with closeflag = 1.



        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaaHashBoxa(*args)
    
    

    try:
        leptonica.pixRenderLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
('l_int32', 'op')       
  pixRenderLine()

      Input:  pix
              x1, y1
              x2, y2
              width  (thickness of line)
              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderLine(*args)
    
    

    try:
        leptonica.generatePtaBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaBoxa.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaBoxa(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'width')       
('l_int32', 'removedups')       
  generatePtaBoxa()

      Input:  boxa
              width
              removedups  (1 to remove, 0 to leave)
      Return: ptad, or null on error

  Notes:
      (1) If the boxa has overlapping boxes, and if blending will
          be used to give a transparent effect, transparency
          artifacts at line intersections can be removed using
          removedups = 1.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaBoxa(*args)
    
    

    try:
        leptonica.convertPtaLineTo4cc.argtypes = [ctypes.c_void_p]
        leptonica.convertPtaLineTo4cc.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function convertPtaLineTo4cc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertPtaLineTo4cc(*args):
        """
        ('PTA', '*ptas')       
  convertPtaLineTo4cc()

      Input:  ptas (8-connected line of points)
      Return: ptad (4-connected line), or null on error

  Notes:
      (1) When a polyline is generated with width = 1, the resulting
          line is not 4-connected in general.  This function adds
          points as necessary to convert the line to 4-cconnected.
          It is useful when rendering 1 bpp on a pix.
      (2) Do not use this for lines generated with width > 1.


        """
        args = _convert_params(*args)
        
        return leptonica.convertPtaLineTo4cc(*args)
    
    

    try:
        leptonica.generatePtaPolyline.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaPolyline.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaPolyline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaPolyline(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'width')       
('l_int32', 'closeflag')       
('l_int32', 'removedups')       
  generatePtaPolyline()

      Input:  pta (vertices of polyline)
              width
              closeflag (1 to close the contour; 0 otherwise)
              removedups  (1 to remove, 0 to leave)
      Return: ptad, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaPolyline(*args)
    
    

    try:
        leptonica.pixRenderRandomCmapPtaa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderRandomCmapPtaa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRenderRandomCmapPtaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderRandomCmapPtaa(*args):
        """
        ('PIX', '*pix')       
('PTAA', '*ptaa')       
('l_int32', 'polyflag')       
('l_int32', 'width')       
('l_int32', 'closeflag')       
  pixRenderRandomCmapPtaa()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              ptaa
              polyflag (1 to interpret each Pta as a polyline; 0 to simply
                        render the Pta as a set of pixels)
              width  (thickness of line; use only for polyline)
              closeflag (1 to close the contour; 0 otherwise;
                         use only for polyline mode)
      Return: pixd (cmapped, 8 bpp) or null on error

  Notes:
      (1) This is a debugging routine, that displays a set of
          pixels, selected by the set of Ptas in a Ptaa,
          in a random color in a pix.
      (2) If @polyflag == 1, each Pta is considered to be a polyline,
          and is rendered using @width and @closeflag.  Each polyline
          is rendered in a random color.
      (3) If @polyflag == 0, all points in each Pta are rendered in a
          random color.  The @width and @closeflag parameters are ignored.
      (4) The output pix is 8 bpp and colormapped.  Up to 254
          different, randomly selected colors, can be used.
      (5) The rendered pixels replace the input pixels.  They will
          be clipped silently to the input pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderRandomCmapPtaa(*args)
    
    

    try:
        leptonica.pixRenderPolylineArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_int32]
        leptonica.pixRenderPolylineArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPolylineArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolylineArb(*args):
        """
        ('PIX', '*pix')       
('PTA', '*ptas')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_int32', 'closeflag')       
  pixRenderPolylineArb()

      Input:  pix
              ptas
              width  (thickness of line)
              rval, gval, bval
              closeflag (1 to close the contour; 0 otherwise)
      Return: 0 if OK, 1 on error

  Note: this renders a closed contour.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolylineArb(*args)
    
    

    try:
        leptonica.makePlotPtaFromNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makePlotPtaFromNuma.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function makePlotPtaFromNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePlotPtaFromNuma(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'size')       
('l_int32', 'plotloc')       
('l_int32', 'linewidth')       
('l_int32', 'max')       
  makePlotPtaFromNuma()

      Input:  numa
              size (pix height for horizontal plot; width for vertical plot)
              plotloc (location of plot: L_PLOT_AT_TOP, etc)
              linewidth (width of "line" that is drawn; between 1 and 7)
              max (maximum excursion in pixels from baseline)
      Return: ptad, or null on error

  Notes:
      (1) This generates points from @numa representing y(x) or x(y)
          with respect to a pix.  A horizontal plot y(x) is drawn for
          a function of column position, and a vertical plot is drawn
          for a function x(y) of row position.  The baseline is located
          so that all plot points will fit in the pix.
      (2) See makePlotPtaFromNumaGen() for more details.


        """
        args = _convert_params(*args)
        
        return leptonica.makePlotPtaFromNuma(*args)
    
    

    try:
        leptonica.pixRenderBoxaBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRenderBoxaBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderBoxaBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxaBlend(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
('l_int32', 'removedups')       
  pixRenderBoxaBlend()

      Input:  pix
              boxa
              width  (thickness of line)
              rval, gval, bval
              fract (in [0.0 - 1.0]; complete transparency (no effect)
                     if 0.0; no transparency if 1.0)
              removedups  (1 to remove; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxaBlend(*args)
    
    

    try:
        leptonica.pixRenderHashBoxBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRenderHashBoxBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderHashBoxBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxBlend(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', 'fract')       
  pixRenderHashBoxBlend()

      Input:  pix
              box
              spacing (spacing between lines; must be > 1)
              width  (thickness of box and hash lines)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
              rval, gval, bval
              fract (in [0.0 - 1.0]; complete transparency (no effect)
                     if 0.0; no transparency if 1.0)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxBlend(*args)
    
    

    try:
        leptonica.fpixAutoRenderContours.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixAutoRenderContours.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAutoRenderContours not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAutoRenderContours(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'ncontours')       
  fpixAutoRenderContours()

      Input:  fpix
              ncontours (> 1, < 500, typ. about 50)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) The increment is set to get approximately @ncontours.
      (2) The proximity to the target value for contour display
          is set to 0.15.
      (3) Negative values are rendered in red; positive values as black.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAutoRenderContours(*args)
    
    

    try:
        leptonica.pixRenderHashBoxArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashBoxArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderHashBoxArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxArb(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixRenderHashBoxArb()

      Input:  pix
              box
              spacing (spacing between lines; must be > 1)
              width  (thickness of box and hash lines)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
              rval, gval, bval
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxArb(*args)
    
    

    try:
        leptonica.pixRenderHashBoxaBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRenderHashBoxaBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderHashBoxaBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxaBlend(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', 'fract')       
  pixRenderHashBoxaBlend()

      Input:  pix
              boxa
              spacing (spacing between lines; must be > 1)
              width  (thickness of box and hash lines)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
              rval, gval, bval
              fract (in [0.0 - 1.0]; complete transparency (no effect)
                     if 0.0; no transparency if 1.0)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxaBlend(*args)
    
    

    try:
        leptonica.generatePtaLineFromPt.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_double, ctypes.c_double]
        leptonica.generatePtaLineFromPt.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaLineFromPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaLineFromPt(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_float64', 'length')       
('l_float64', 'radang')       
  generatePtaLineFromPt()

      Input:  x, y  (point of origination)
              length (of line, including starting point)
              radang (angle in radians, CW from horizontal)
      Return: pta, or null on error

  Notes:
      (1) The @length of the line is 1 greater than the distance
          used in locatePtRadially().  Example: a distance of 1
          gives rise to a length of 2.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaLineFromPt(*args)
    
    

    try:
        leptonica.pixRenderLineArb.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderLineArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderLineArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderLineArb(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
  pixRenderLineArb()

      Input:  pix
              x1, y1
              x2, y2
              width  (thickness of line)
              rval, gval, bval
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderLineArb(*args)
    
    

    try:
        leptonica.pixRenderPolygon.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRenderPolygon.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPolygon not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolygon(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'width')       
('l_int32', '*pxmin')       
('l_int32', '*pymin')       
  pixRenderPolygon()

      Input:  ptas (of vertices, none repeated)
              width (of polygon outline)
              &xmin (<optional return> min x value of input pts)
              &ymin (<optional return> min y value of input pts)
      Return: pix (1 bpp, with outline generated), or null on error

  Notes:
      (1) The pix is the minimum size required to contain the origin
          and the polygon.  For example, the max x value of the input
          points is w - 1, where w is the pix width.
      (2) The rendered line is 4-connected, so that an interior or
          exterior 8-c.c. flood fill operation works properly.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolygon(*args)
    
    

    try:
        leptonica.pixRenderLineBlend.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float]
        leptonica.pixRenderLineBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderLineBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderLineBlend(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
  pixRenderLineBlend()

      Input:  pix
              x1, y1
              x2, y2
              width  (thickness of line)
              rval, gval, bval
              fract
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderLineBlend(*args)
    
    

    try:
        leptonica.pixRenderPlotFromNumaGen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixRenderPlotFromNumaGen.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPlotFromNumaGen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPlotFromNumaGen(*args):
        """
        ('PIX', '**ppix')       
('NUMA', '*na')       
('l_int32', 'orient')       
('l_int32', 'linewidth')       
('l_int32', 'refpos')       
('l_int32', 'max')       
('l_int32', 'drawref')       
('l_uint32', 'color')       
  pixRenderPlotFromNumaGen()

      Input:  &pix (any type; replaced if not 32 bpp rgb)
              numa (to be plotted)
              orient (L_HORIZONTAL_LINE, L_VERTICAL_LINE)
              linewidth (width of "line" that is drawn; between 1 and 7)
              refpos (reference position: y for horizontal and x for vertical)
              max (maximum excursion in pixels from baseline)
              drawref (1 to draw the reference line and the normal to it)
              color (plot color: 0xrrggbb00)
      Return: 0 if OK, 1 on error

  Notes:
      (1) General interface for plotting row or column aligned data
          on a pix.
      (2) This replaces @pix with a 32 bpp rgb version if it is not
          already 32 bpp.  It then draws the plot on the pix.
      (3) See makePlotPtaFromNumaGen() for other input parameters.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPlotFromNumaGen(*args)
    
    

    try:
        leptonica.pixRenderPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRenderPta.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPta(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('l_int32', 'op')       
  pixRenderPta()

      Input:  pix
              pta (arbitrary set of points)
              op   (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
      Return: 0 if OK, 1 on error

  Notes:
      (1) L_SET_PIXELS puts all image bits in each pixel to 1
          (black for 1 bpp; white for depth > 1)
      (2) L_CLEAR_PIXELS puts all image bits in each pixel to 0
          (white for 1 bpp; black for depth > 1)
      (3) L_FLIP_PIXELS reverses all image bits in each pixel
      (4) This function clips the rendering to the pix.  It performs
          clipping for functions such as pixRenderLine(),
          pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPta(*args)
    
    

    try:
        leptonica.pixRenderHashBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderHashBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBox(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'op')       
  pixRenderHashBox()

      Input:  pix
              box
              spacing (spacing between lines; must be > 1)
              width  (thickness of box and hash lines)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
              op  (one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBox(*args)
    
    

    try:
        leptonica.generatePtaHashBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaHashBoxa.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaHashBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaHashBoxa(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'removedups')       
  generatePtaHashBoxa()

      Input:  boxa
              spacing (spacing between lines; must be > 1)
              width  (of line)
              orient  (orientation of lines: L_HORIZONTAL_LINE, ...)
              outline  (0 to skip drawing box outline)
              removedups  (1 to remove, 0 to leave)
      Return: ptad, or null on error

  Notes:
      (1) The orientation takes on one of 4 orientations (horiz, vertical,
          slope +1, slope -1).
      (2) The full outline is also drawn if @outline = 1.
      (3) If the boxa has overlapping boxes, and if blending will
          be used to give a transparent effect, transparency
          artifacts at line intersections can be removed using
          removedups = 1.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaHashBoxa(*args)
    
    

    try:
        leptonica.pixRenderBoxArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderBoxArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderBoxArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxArb(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
  pixRenderBoxArb()

      Input:  pix (any depth, cmapped ok)
              box
              width  (thickness of box lines)
              rval, gval, bval
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxArb(*args)
    
    

    try:
        leptonica.pixRenderPtaArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderPtaArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPtaArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPtaArb(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
  pixRenderPtaArb()

      Input:  pix (any depth, cmapped ok)
              pta (arbitrary set of points)
              rval, gval, bval
      Return: 0 if OK, 1 on error

  Notes:
      (1) If pix is colormapped, render this color (or the nearest
          color if the cmap is full) on each pixel.
      (2) If pix is not colormapped, do the best job you can using
          the input colors:
          - d = 1: set the pixels
          - d = 2, 4, 8: average the input rgb value
          - d = 32: use the input rgb value
      (3) This function clips the rendering to the pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPtaArb(*args)
    
    

    try:
        leptonica.pixRenderPtaBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float]
        leptonica.pixRenderPtaBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderPtaBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPtaBlend(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
  pixRenderPtaBlend()

      Input:  pix (32 bpp rgb)
              pta  (arbitrary set of points)
              rval, gval, bval
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function clips the rendering to the pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPtaBlend(*args)
    
    

    try:
        leptonica.makePlotPtaFromNumaGen.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makePlotPtaFromNumaGen.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function makePlotPtaFromNumaGen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePlotPtaFromNumaGen(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'orient')       
('l_int32', 'linewidth')       
('l_int32', 'refpos')       
('l_int32', 'max')       
('l_int32', 'drawref')       
  makePlotPtaFromNumaGen()

      Input:  numa
              orient (L_HORIZONTAL_LINE, L_VERTICAL_LINE)
              linewidth (width of "line" that is drawn; between 1 and 7)
              refpos (reference position: y for horizontal and x for vertical)
              max (maximum excursion in pixels from baseline)
              drawref (1 to draw the reference line and the normal to it)
      Return: ptad, or null on error

  Notes:
      (1) This generates points from @numa representing y(x) or x(y)
          with respect to a pix.  For y(x), we draw a horizontal line
          at the reference position and a vertical line at the edge; then
          we draw the values of @numa, scaled so that the maximum
          excursion from the reference position is @max pixels.
      (2) The start and delx parameters of @numa are used to refer
          its values to the raster lines (L_VERTICAL_LINE) or columns
          (L_HORIZONTAL_LINE).
      (3) The linewidth is chosen in the interval [1 ... 7].
      (4) @refpos should be chosen so the plot is entirely within the pix
          that it will be painted onto.
      (5) This would typically be used to plot, in place, a function
          computed along pixel rows or columns.


        """
        args = _convert_params(*args)
        
        return leptonica.makePlotPtaFromNumaGen(*args)
    
    

    try:
        leptonica.generatePtaFilledSquare.argtypes = [ctypes.c_int32]
        leptonica.generatePtaFilledSquare.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generatePtaFilledSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaFilledSquare(*args):
        """
        ('l_int32', 'side')       
  generatePtaFilledSquare()

      Input:  side
      Return: pta, or null on error

  Notes:
      (1) The center of the square can be chosen to be at
          (side / 2, side / 2).  It must be translated by this amount
          when used for replication.


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaFilledSquare(*args)
    
    

    try:
        leptonica.pixRenderBoxBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float]
        leptonica.pixRenderBoxBlend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRenderBoxBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxBlend(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
  pixRenderBoxBlend()

      Input:  pix
              box
              width  (thickness of box lines)
              rval, gval, bval
              fract (in [0.0 - 1.0]; complete transparency (no effect)
                     if 0.0; no transparency if 1.0)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxBlend(*args)
    




class morphapp(object):
    """  morphapp.c

      These are some useful and/or interesting composite
      image processing operations, of the type that are often
      useful in applications.  Most are morphological in
      nature.

      Extraction of boundary pixels
            PIX       *pixExtractBoundary()

      Selective morph sequence operation under mask
            PIX       *pixMorphSequenceMasked()

      Selective morph sequence operation on each component
            PIX       *pixMorphSequenceByComponent()
            PIXA      *pixaMorphSequenceByComponent()

      Selective morph sequence operation on each region
            PIX       *pixMorphSequenceByRegion()
            PIXA      *pixaMorphSequenceByRegion()

      Union and intersection of parallel composite operations
            PIX       *pixUnionOfMorphOps()
            PIX       *pixIntersectionOfMorphOps()

      Selective connected component filling
            PIX       *pixSelectiveConnCompFill()

      Removal of matched patterns
            PIX       *pixRemoveMatchedPattern()

      Display of matched patterns
            PIX       *pixDisplayMatchedPattern()

      Iterative morphological seed filling (don't use for real work)
            PIX       *pixSeedfillMorph()

      Granulometry on binary images
            NUMA      *pixRunHistogramMorph()

      Composite operations on grayscale images
            PIX       *pixTophat()
            PIX       *pixHDome()
            PIX       *pixFastTophat()
            PIX       *pixMorphGradient()

      Centroid of component
            PTA       *pixaCentroids()
            l_int32    pixCentroid()

"""
    
    try:
        leptonica.pixCentroid.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCentroid.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCentroid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCentroid(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*centtab')       
('l_int32', '*sumtab')       
('l_float32', '*pxave')       
('l_float32', '*pyave')       
  pixCentroid()

      Input:  pix (1 or 8 bpp)
              centtab (<optional> table for finding centroids; can be null)
              sumtab (<optional> table for finding pixel sums; can be null)
              &xave, &yave (<return> coordinates of centroid, relative to
                            the UL corner of the pix)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Any table not passed in will be made internally and destroyed
          after use.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCentroid(*args)
    
    

    try:
        leptonica.pixSeedfillMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillMorph.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'maxiters')       
('l_int32', 'connectivity')       
  pixSeedfillMorph()

      Input:  pixs (seed)
              pixm (mask)
              maxiters (use 0 to go to completion)
              connectivity (4 or 8)
      Return: pixd (after filling into the mask) or null on error

  Notes:
    (1) This is in general a very inefficient method for filling
        from a seed into a mask.  Use it for a small number of iterations,
        but if you expect more than a few iterations, use
        pixSeedfillBinary().
    (2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillMorph(*args)
    
    

    try:
        leptonica.pixUnionOfMorphOps.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixUnionOfMorphOps.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnionOfMorphOps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnionOfMorphOps(*args):
        """
        ('PIX', '*pixs')       
('SELA', '*sela')       
('l_int32', 'type')       
  pixUnionOfMorphOps()

      Input:  pixs (binary)
              sela
              type (L_MORPH_DILATE, etc.)
      Return: pixd (union of the specified morphological operation
                    on pixs for each Sel in the Sela), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnionOfMorphOps(*args)
    
    

    try:
        leptonica.pixDisplayMatchedPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixDisplayMatchedPattern.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayMatchedPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayMatchedPattern(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixp')       
('PIX', '*pixe')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_uint32', 'color')       
('l_float32', 'scale')       
('l_int32', 'nlevels')       
  pixDisplayMatchedPattern()

      Input:  pixs (input image, 1 bpp)
              pixp (pattern to be removed from image, 1 bpp)
              pixe (image after erosion by Sel that approximates pixp, 1 bpp)
              x0, y0 (center of Sel)
              color (to paint the matched patterns; 0xrrggbb00)
              scale (reduction factor for output pixd)
              nlevels (if scale < 1.0, threshold to this number of levels)
      Return: pixd (8 bpp, colormapped), or null on error

  Notes:
    (1) A 4 bpp colormapped image is generated.
    (2) If scale <= 1.0, do scale to gray for the output, and threshold
        to nlevels of gray.
    (3) You can use various functions in selgen to create a Sel
        that will generate pixe from pixs.
    (4) This function is applied after pixe has been computed.
        It finds the centroid of each c.c., and colors the output
        pixels using pixp (appropriately aligned) as a stencil.
        Alignment is done using the origin of the Sel and the
        centroid of the eroded image to place the stencil pixp.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayMatchedPattern(*args)
    
    

    try:
        leptonica.pixSelectiveConnCompFill.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSelectiveConnCompFill.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSelectiveConnCompFill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectiveConnCompFill(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('l_int32', 'minw')       
('l_int32', 'minh')       
  pixSelectiveConnCompFill()

      Input:  pixs (binary)
              connectivity (4 or 8)
              minw  (minimum width to consider; use 0 or 1 for any width)
              minh  (minimum height to consider; use 0 or 1 for any height)
      Return: pix (with holes filled in selected c.c.), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectiveConnCompFill(*args)
    
    

    try:
        leptonica.pixFastTophat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFastTophat.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFastTophat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFastTophat(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xsize')       
('l_int32', 'ysize')       
('l_int32', 'type')       
  pixFastTophat()

      Input:  pixs
              xsize (width of max/min op, smoothing; any integer >= 1)
              ysize (height of max/min op, smoothing; any integer >= 1)
              type   (L_TOPHAT_WHITE: image - min
                      L_TOPHAT_BLACK: max - image)
      Return: pixd, or null on error

  Notes:
      (1) Don't be fooled. This is NOT a tophat.  It is a tophat-like
          operation, where the result is similar to what you'd get
          if you used an erosion instead of an opening, or a dilation
          instead of a closing.
      (2) Instead of opening or closing at full resolution, it does
          a fast downscale/minmax operation, then a quick small smoothing
          at low res, a replicative expansion of the "background"
          to full res, and finally a removal of the background level
          from the input image.  The smoothing step may not be important.
      (3) It does not remove noise as well as a tophat, but it is
          5 to 10 times faster.
          If you need the preciseness of the tophat, don't use this.
      (4) The L_TOPHAT_WHITE flag emphasizes small bright regions,
          whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFastTophat(*args)
    
    

    try:
        leptonica.pixaCentroids.argtypes = [ctypes.c_void_p]
        leptonica.pixaCentroids.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCentroids not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCentroids(*args):
        """
        ('PIXA', '*pixa')       
  pixaCentroids()

      Input:  pixa of components (1 or 8 bpp)
      Return: pta of centroids relative to the UL corner of
              each pix, or null on error

  Notes:
      (1) An error message is returned if any pix has something other
          than 1 bpp or 8 bpp depth, and the centroid from that pix
          is saved as (0, 0).


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCentroids(*args)
    
    

    try:
        leptonica.pixTophat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTophat.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixTophat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTophat(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
('l_int32', 'type')       
  pixTophat()

      Input:  pixs
              hsize (of Sel; must be odd; origin implicitly in center)
              vsize (ditto)
              type   (L_TOPHAT_WHITE: image - opening
                      L_TOPHAT_BLACK: closing - image)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) If hsize = vsize = 1, returns an image with all 0 data.
      (3) The L_TOPHAT_WHITE flag emphasizes small bright regions,
          whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
          The L_TOPHAT_WHITE tophat can be accomplished by doing a
          L_TOPHAT_BLACK tophat on the inverse, or v.v.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTophat(*args)
    
    

    try:
        leptonica.pixaMorphSequenceByComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMorphSequenceByComponent.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaMorphSequenceByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMorphSequenceByComponent(*args):
        """
        ('PIXA', '*pixas')       
('const char', '*sequence')       
('l_int32', 'minw')       
('l_int32', 'minh')       
  pixaMorphSequenceByComponent()

      Input:  pixas (of 1 bpp pix)
              sequence (string specifying sequence)
              minw  (minimum width to consider; use 0 or 1 for any width)
              minh  (minimum height to consider; use 0 or 1 for any height)
      Return: pixad, or null on error

  Notes:
      (1) See pixMorphSequence() for composing operation sequences.
      (2) This operates separately on each c.c. in the input pixa.
      (3) You can specify that the width and/or height must equal
          or exceed a minimum size for the operation to take place.
      (4) The input pixa should have a boxa giving the locations
          of the pix components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMorphSequenceByComponent(*args)
    
    

    try:
        leptonica.pixIntersectionOfMorphOps.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixIntersectionOfMorphOps.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixIntersectionOfMorphOps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixIntersectionOfMorphOps(*args):
        """
        ('PIX', '*pixs')       
('SELA', '*sela')       
('l_int32', 'type')       
  pixIntersectionOfMorphOps()

      Input:  pixs (binary)
              sela
              type (L_MORPH_DILATE, etc.)
      Return: pixd (intersection of the specified morphological operation
                    on pixs for each Sel in the Sela), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixIntersectionOfMorphOps(*args)
    
    

    try:
        leptonica.pixRunHistogramMorph.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRunHistogramMorph.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRunHistogramMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRunHistogramMorph(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'runtype')       
('l_int32', 'direction')       
('l_int32', 'maxsize')       
  pixRunHistogramMorph()

      Input:  pixs
              runtype (L_RUN_OFF, L_RUN_ON)
              direction (L_HORIZ, L_VERT)
              maxsize  (size of largest runlength counted)
      Return: numa of run-lengths


        """
        args = _convert_params(*args)
        
        return leptonica.pixRunHistogramMorph(*args)
    
    

    try:
        leptonica.pixMorphSequenceByRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMorphSequenceByRegion.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphSequenceByRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceByRegion(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('const char', '*sequence')       
('l_int32', 'connectivity')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('BOXA', '**pboxa')       
  pixMorphSequenceByRegion()

      Input:  pixs (1 bpp)
              pixm (mask specifying regions)
              sequence (string specifying sequence)
              connectivity (4 or 8, used on mask)
              minw  (minimum width to consider; use 0 or 1 for any width)
              minh  (minimum height to consider; use 0 or 1 for any height)
              &boxa (<optional> return boxa of c.c. in pixm)
      Return: pixd, or null on error

  Notes:
      (1) See pixMorphCompSequence() for composing operation sequences.
      (2) This operates separately on the region in pixs corresponding
          to each c.c. in the mask pixm.  It differs from
          pixMorphSequenceByComponent() in that the latter does not have
          a pixm (mask), but instead operates independently on each
          component in pixs.
      (3) Dilation will NOT increase the region size; the result
          is clipped to the size of the mask region.  This is necessary
          to make regions independent after the operation.
      (4) You can specify that the width and/or height of a region must
          equal or exceed a minimum size for the operation to take place.
      (5) Use NULL for @pboxa to avoid returning the boxa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceByRegion(*args)
    
    

    try:
        leptonica.pixHDome.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHDome.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHDome not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHDome(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'height')       
('l_int32', 'connectivity')       
  pixHDome()

      Input:  pixs (8 bpp, filling mask)
              height (of seed below the filling maskhdome; must be >= 0)
              connectivity (4 or 8)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) It is more efficient to use a connectivity of 4 for the fill.
      (2) This fills bumps to some level, and extracts the unfilled
          part of the bump.  To extract the troughs of basins, first
          invert pixs and then apply pixHDome().
      (3) It is useful to compare the HDome operation with the TopHat.
          The latter extracts peaks or valleys that have a width
          not exceeding the size of the structuring element used
          in the opening or closing, rsp.  The height of the peak is
          irrelevant.  By contrast, for the HDome, the gray seedfill
          is used to extract all peaks that have a height not exceeding
          a given value, regardless of their width!
      (4) Slightly more precisely, suppose you set 'height' = 40.
          Then all bumps in pixs with a height greater than or equal
          to 40 become, in pixd, bumps with a max value of exactly 40.
          All shorter bumps have a max value in pixd equal to the height
          of the bump.
      (5) The method: the filling mask, pixs, is the image whose peaks
          are to be extracted.  The height of a peak is the distance
          between the top of the peak and the highest "leak" to the
          outside -- think of a sombrero, where the leak occurs
          at the highest point on the rim.
            (a) Generate a seed, pixd, by subtracting some value, p, from
                each pixel in the filling mask, pixs.  The value p is
                the 'height' input to this function.
            (b) Fill in pixd starting with this seed, clipping by pixs,
                in the way described in seedfillGrayLow().  The filling
                stops before the peaks in pixs are filled.
                For peaks that have a height > p, pixd is filled to
                the level equal to the (top-of-the-peak - p).
                For peaks of height < p, the peak is left unfilled
                from its highest saddle point (the leak to the outside).
            (c) Subtract the filled seed (pixd) from the filling mask (pixs).
          Note that in this procedure, everything is done starting
          with the filling mask, pixs.
      (6) For segmentation, the resulting image, pixd, can be thresholded
          and used as a seed for another filling operation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHDome(*args)
    
    

    try:
        leptonica.pixMorphSequenceByComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMorphSequenceByComponent.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphSequenceByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceByComponent(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'connectivity')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('BOXA', '**pboxa')       
  pixMorphSequenceByComponent()

      Input:  pixs (1 bpp)
              sequence (string specifying sequence)
              connectivity (4 or 8)
              minw  (minimum width to consider; use 0 or 1 for any width)
              minh  (minimum height to consider; use 0 or 1 for any height)
              &boxa (<optional> return boxa of c.c. in pixs)
      Return: pixd, or null on error

  Notes:
      (1) See pixMorphSequence() for composing operation sequences.
      (2) This operates separately on each c.c. in the input pix.
      (3) The dilation does NOT increase the c.c. size; it is clipped
          to the size of the original c.c.   This is necessary to
          keep the c.c. independent after the operation.
      (4) You can specify that the width and/or height must equal
          or exceed a minimum size for the operation to take place.
      (5) Use NULL for boxa to avoid returning the boxa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceByComponent(*args)
    
    

    try:
        leptonica.pixMorphSequenceMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMorphSequenceMasked.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphSequenceMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
  pixMorphSequenceMasked()

      Input:  pixs (1 bpp)
              pixm (<optional> 1 bpp mask)
              sequence (string specifying sequence of operations)
              dispsep (horizontal separation in pixels between
                       successive displays; use zero to suppress display)
      Return: pixd, or null on error

  Notes:
      (1) This applies the morph sequence to the image, but only allows
          changes in pixs for pixels under the background of pixm.
      (5) If pixm is NULL, this is just pixMorphSequence().


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceMasked(*args)
    
    

    try:
        leptonica.pixExtractBoundary.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBoundary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractBoundary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBoundary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  pixExtractBoundary()

      Input:  pixs (1 bpp)
              type (0 for background pixels; 1 for foreground pixels)
      Return: pixd, or null on error

  Notes:
      (1) Extracts the fg or bg boundary pixels for each component.
          Components are assumed to end at the boundary of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBoundary(*args)
    
    

    try:
        leptonica.pixaMorphSequenceByRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMorphSequenceByRegion.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaMorphSequenceByRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMorphSequenceByRegion(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixam')       
('const char', '*sequence')       
('l_int32', 'minw')       
('l_int32', 'minh')       
  pixaMorphSequenceByRegion()

      Input:  pixs (1 bpp)
              pixam (of 1 bpp mask elements)
              sequence (string specifying sequence)
              minw  (minimum width to consider; use 0 or 1 for any width)
              minh  (minimum height to consider; use 0 or 1 for any height)
      Return: pixad, or null on error

  Notes:
      (1) See pixMorphSequence() for composing operation sequences.
      (2) This operates separately on each region in the input pixs
          defined by the components in pixam.
      (3) You can specify that the width and/or height of a mask
          component must equal or exceed a minimum size for the
          operation to take place.
      (4) The input pixam should have a boxa giving the locations
          of the regions in pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMorphSequenceByRegion(*args)
    
    

    try:
        leptonica.pixRemoveMatchedPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveMatchedPattern.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveMatchedPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveMatchedPattern(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixp')       
('PIX', '*pixe')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_int32', 'dsize')       
  pixRemoveMatchedPattern()

      Input:  pixs (input image, 1 bpp)
              pixp (pattern to be removed from image, 1 bpp)
              pixe (image after erosion by Sel that approximates pixp, 1 bpp)
              x0, y0 (center of Sel)
              dsize (number of pixels on each side by which pixp is
                     dilated before being subtracted from pixs;
                     valid values are {0, 1, 2, 3, 4})
      Return: 0 if OK, 1 on error

  Notes:
    (1) This is in-place.
    (2) You can use various functions in selgen to create a Sel
        that is used to generate pixe from pixs.
    (3) This function is applied after pixe has been computed.
        It finds the centroid of each c.c., and subtracts
        (the appropriately dilated version of) pixp, with the center
        of the Sel used to align pixp with pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveMatchedPattern(*args)
    
    

    try:
        leptonica.pixMorphGradient.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMorphGradient.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphGradient not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphGradient(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
('l_int32', 'smoothing')       
  pixMorphGradient()

      Input:  pixs
              hsize (of Sel; must be odd; origin implicitly in center)
              vsize (ditto)
              smoothing  (half-width of convolution smoothing filter.
                          The width is (2 * smoothing + 1), so 0 is no-op.
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphGradient(*args)
    




class numabasic(object):
    """   numabasic.c

      Numa creation, destruction, copy, clone, etc.
          NUMA        *numaCreate()
          NUMA        *numaCreateFromIArray()
          NUMA        *numaCreateFromFArray()
          void        *numaDestroy()
          NUMA        *numaCopy()
          NUMA        *numaClone()
          l_int32      numaEmpty()

      Add/remove number (float or integer)
          l_int32      numaAddNumber()
          static l_int32  numaExtendArray()
          l_int32      numaInsertNumber()
          l_int32      numaRemoveNumber()
          l_int32      numaReplaceNumber()

      Numa accessors
          l_int32      numaGetCount()
          l_int32      numaSetCount()
          l_int32      numaGetIValue()
          l_int32      numaGetFValue()
          l_int32      numaSetValue()
          l_int32      numaShiftValue()
          l_int32     *numaGetIArray()
          l_float32   *numaGetFArray()
          l_int32      numaGetRefcount()
          l_int32      numaChangeRefcount()
          l_int32      numaGetParameters()
          l_int32      numaSetParameters()
          l_int32      numaCopyParameters()

      Convert to string array
          SARRAY      *numaConvertToSarray()

      Serialize numa for I/O
          NUMA        *numaRead()
          NUMA        *numaReadStream()
          l_int32      numaWrite()
          l_int32      numaWriteStream()

      Numaa creation, destruction, truncation
          NUMAA       *numaaCreate()
          NUMAA       *numaaCreateFull()
          NUMAA       *numaaTruncate()
          void        *numaaDestroy()

      Add Numa to Numaa
          l_int32      numaaAddNuma()
          l_int32      numaaExtendArray()

      Numaa accessors
          l_int32      numaaGetCount()
          l_int32      numaaGetNumaCount()
          l_int32      numaaGetNumberCount()
          NUMA       **numaaGetPtrArray()
          NUMA        *numaaGetNuma()
          NUMA        *numaaReplaceNuma()
          l_int32      numaaGetValue()
          l_int32      numaaAddNumber()

      Serialize numaa for I/O
          NUMAA       *numaaRead()
          NUMAA       *numaaReadStream()
          l_int32      numaaWrite()
          l_int32      numaaWriteStream()

      Numa2d creation, destruction
          NUMA2D      *numa2dCreate()
          void        *numa2dDestroy()

      Numa2d Accessors
          l_int32      numa2dAddNumber()
          l_int32      numa2dGetCount()
          NUMA        *numa2dGetNuma()
          l_int32      numa2dGetFValue()
          l_int32      numa2dGetIValue()

      NumaHash creation, destruction
          NUMAHASH    *numaHashCreate()
          void        *numaHashDestroy()

      NumaHash Accessors
          NUMA        *numaHashGetNuma()
          void        *numaHashAdd()

    (1) The Numa is a struct holding an array of floats.  It can also
        be used to store l_int32 values, with some loss of precision
        for floats larger than about 10 million.  Use the L_Dna instead
        if integers larger than a few million need to be stored.

    (2) Always use the accessors in this file, never the fields directly.

    (3) Storing and retrieving numbers:

       * to append a new number to the array, use numaAddNumber().  If
         the number is an int, it will will automatically be converted
         to l_float32 and stored.

       * to reset a value stored in the array, use numaSetValue().

       * to increment or decrement a value stored in the array,
         use numaShiftValue().

       * to obtain a value from the array, use either numaGetIValue()
         or numaGetFValue(), depending on whether you are retrieving
         an integer or a float.  This avoids doing an explicit cast,
         such as
           (a) return a l_float32 and cast it to an l_int32
           (b) cast the return directly to (l_float32 *) to
               satisfy the function prototype, as in
                 numaGetFValue(na, index, (l_float32 *)&ival);   [ugly!]

    (4) int <--> float conversions:

        Tradition dictates that type conversions go automatically from
        l_int32 --> l_float32, even though it is possible to lose
        precision for large integers, whereas you must cast (l_int32)
        to go from l_float32 --> l_int32 because you're truncating
        to the integer value.

    (5) As with other arrays in leptonica, the numa has both an allocated
        size and a count of the stored numbers.  When you add a number, it
        goes on the end of the array, and causes a realloc if the array
        is already filled.  However, in situations where you want to
        add numbers randomly into an array, such as when you build a
        histogram, you must set the count of stored numbers in advance.
        This is done with numaSetCount().  If you set a count larger
        than the allocated array, it does a realloc to the size requested.

    (6) In situations where the data in a numa correspond to a function
        y(x), the values can be either at equal spacings in x or at
        arbitrary spacings.  For the former, we can represent all x values
        by two parameters: startx (corresponding to y[0]) and delx
        for the change in x for adjacent values y[i] and y[i+1].
        startx and delx are initialized to 0.0 and 1.0, rsp.
        For arbitrary spacings, we use a second numa, and the two
        numas are typically denoted nay and nax.

    (7) The numa is also the basic struct used for histograms.  Every numa
        has startx and delx fields, initialized to 0.0 and 1.0, that can
        be used to represent the "x" value for the location of the
        first bin and the bin width, respectively.  Accessors are the
        numa*Parameters() functions.  All functions that make numa
        histograms must set these fields properly, and many functions
        that use numa histograms rely on the correctness of these values.

"""
    
    try:
        leptonica.numa2dGetIValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numa2dGetIValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numa2dGetIValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dGetIValue(*args):
        """
        ('NUMA2D', '*na2d')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_int32', 'index')       
('l_int32', '*pval')       
  numa2dGetIValue()

      Input:  na2d
              row of 2d array
              col of 2d array
              index (into numa)
              &val (<return> integer value)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dGetIValue(*args)
    
    

    try:
        leptonica.numaaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaWrite(*args):
        """
        ('const char', '*filename')       
('NUMAA', '*naa')       
  numaaWrite()

      Input:  filename, naa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaWrite(*args)
    
    

    try:
        leptonica.numaaReplaceNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaaReplaceNuma.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaReplaceNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaReplaceNuma(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
('NUMA', '*na')       
  numaaReplaceNuma()

      Input:  naa
              index  (to the index-th numa)
              numa (insert and replace any existing one)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Any existing numa is destroyed, and the input one
          is inserted in its place.
      (2) If the index is invalid, return 1 (error)


        """
        args = _convert_params(*args)
        
        return leptonica.numaaReplaceNuma(*args)
    
    

    try:
        leptonica.numaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.numaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetCount(*args):
        """
        ('NUMA', '*na')       
  numaGetCount()

      Input:  na
      Return: count, or 0 if no numbers or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetCount(*args)
    
    

    try:
        leptonica.numaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.numaaTruncate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaTruncate(*args):
        """
        ('NUMAA', '*naa')       
  numaaTruncate()

      Input:  naa
      Return: 0 if OK, 1 on error

  Notes:
      (1) This identifies the largest index containing a numa that
          has any numbers within it, destroys all numa above that index,
          and resets the count.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaTruncate(*args)
    
    

    try:
        leptonica.numaaGetPtrArray.argtypes = [ctypes.c_void_p]
        leptonica.numaaGetPtrArray.restype = ctypes.c_void_p
    except AttributeError:
        os.stderr.write("Warning - function numaaGetPtrArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetPtrArray(*args):
        """
        ('NUMAA', '*naa')       
  numaaGetPtrArray()

      Input:  naa
      Return: the internal array of ptrs to Numa, or null on error

  Notes:
      (1) This function is convenient for doing direct manipulation on
          a fixed size array of Numas.  To do this, it sets the count
          to the full size of the allocated array of Numa ptrs.
          The originating Numaa owns this array: DO NOT free it!
      (2) Intended usage:
            Numaa *naa = numaaCreate(n);
            Numa **array = numaaGetPtrArray(naa);
             ...  [manipulate Numas directly on the array]
            numaaDestroy(&naa);
      (3) Cautions:
           - Do not free this array; it is owned by tne Numaa.
           - Do not call any functions on the Numaa, other than
             numaaDestroy() when you're finished with the array.
             Adding a Numa will force a resize, destroying the ptr array.
           - Do not address the array outside its allocated size.
             With the bare array, there are no protections.  If the
             allocated size is n, array[n] is an error.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetPtrArray(*args)
    
    

    try:
        leptonica.numaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.numaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetCount(*args):
        """
        ('NUMAA', '*naa')       
  numaaGetCount()

      Input:  naa
      Return: count (number of numa), or 0 if no numa or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetCount(*args)
    
    

    try:
        leptonica.numaClone.argtypes = [ctypes.c_void_p]
        leptonica.numaClone.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaClone(*args):
        """
        ('NUMA', '*na')       
  numaClone()

      Input:  na
      Return: ptr to same numa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaClone(*args)
    
    

    try:
        leptonica.numaaRead.argtypes = [ctypes.c_void_p]
        leptonica.numaaRead.restype = lambda address: NUMAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaRead(*args):
        """
        ('const char', '*filename')       
  numaaRead()

      Input:  filename
      Return: naa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaRead(*args)
    
    

    try:
        leptonica.numaCreateFromFArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaCreateFromFArray.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaCreateFromFArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreateFromFArray(*args):
        """
        ('l_float32', '*farray')       
('l_int32', 'size')       
('l_int32', 'copyflag')       
  numaCreateFromFArray()

      Input:  farray (float)
              size (of the array)
              copyflag (L_INSERT or L_COPY)
      Return: na, or null on error

  Notes:
      (1) With L_INSERT, ownership of the input array is transferred
          to the returned numa, and all @size elements are considered
          to be valid.


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreateFromFArray(*args)
    
    

    try:
        leptonica.numaCopy.argtypes = [ctypes.c_void_p]
        leptonica.numaCopy.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCopy(*args):
        """
        ('NUMA', '*na')       
  numaCopy()

      Input:  na
      Return: copy of numa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCopy(*args)
    
    

    try:
        leptonica.numa2dGetNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numa2dGetNuma.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numa2dGetNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dGetNuma(*args):
        """
        ('NUMA2D', '*na2d')       
('l_int32', 'row')       
('l_int32', 'col')       
  numa2dGetNuma()

      Input:  na2d
              row of 2d array
              col of 2d array
      Return: na (a clone of the numa if it exists) or null if it doesn't

  Notes:
      (1) This does not give an error if the index is out of bounds.


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dGetNuma(*args)
    
    

    try:
        leptonica.numa2dAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.numa2dAddNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numa2dAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dAddNumber(*args):
        """
        ('NUMA2D', '*na2d')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_float32', 'val')       
  numa2dAddNumber()

      Input:  na2d
              row of 2d array
              col of 2d array
              val  (float or int to be added; stored as a float)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dAddNumber(*args)
    
    

    try:
        leptonica.numaEmpty.argtypes = [ctypes.c_void_p]
        leptonica.numaEmpty.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaEmpty not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEmpty(*args):
        """
        ('NUMA', '*na')       
  numaEmpty()

      Input:  na
      Return: 0 if OK; 1 on error

  Notes:
      (1) This does not change the allocation of the array.
          It just clears the number of stored numbers, so that
          the array appears to be empty.


        """
        args = _convert_params(*args)
        
        return leptonica.numaEmpty(*args)
    
    

    try:
        leptonica.numa2dGetFValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numa2dGetFValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numa2dGetFValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dGetFValue(*args):
        """
        ('NUMA2D', '*na2d')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_int32', 'index')       
('l_float32', '*pval')       
  numa2dGetFValue()

      Input:  na2d
              row of 2d array
              col of 2d array
              index (into numa)
              &val (<return> float value)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dGetFValue(*args)
    
    

    try:
        leptonica.numaAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.numaAddNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddNumber(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'val')       
  numaAddNumber()

      Input:  na
              val  (float or int to be added; stored as a float)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddNumber(*args)
    
    

    try:
        leptonica.numaGetIValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetIValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetIValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetIValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_int32', '*pival')       
  numaGetIValue()

      Input:  na
              index (into numa)
              &ival  (<return> integer value; 0 on error)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Caller may need to check the function return value to
          decide if a 0 in the returned ival is valid.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetIValue(*args)
    
    

    try:
        leptonica.numaaGetNumberCount.argtypes = [ctypes.c_void_p]
        leptonica.numaaGetNumberCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaGetNumberCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetNumberCount(*args):
        """
        ('NUMAA', '*naa')       
  numaaGetNumberCount()

      Input:  naa
      Return: count (total number of numbers in the numaa),
                     or 0 if no numbers or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetNumberCount(*args)
    
    

    try:
        leptonica.numa2dCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.numa2dCreate.restype = lambda address: NUMA2D(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numa2dCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dCreate(*args):
        """
        ('l_int32', 'nrows')       
('l_int32', 'ncols')       
('l_int32', 'initsize')       
  numa2dCreate()

      Input:  nrows (of 2d array)
              ncols (of 2d array)
              initsize (initial size of each allocated numa)
      Return: numa2d, or null on error

  Notes:
      (1) The numa2d holds a doubly-indexed array of numa.
      (2) The numa ptr array is initialized with all ptrs set to NULL.
      (3) The numas are created only when a number is to be stored
          at an index (i,j) for which a numa has not yet been made.


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dCreate(*args)
    
    

    try:
        leptonica.numaaGetValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaaGetValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaGetValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetValue(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'i')       
('l_int32', 'j')       
('l_float32', '*pfval')       
('l_int32', '*pival')       
  numaaGetValue()

      Input:  naa
              i (index of numa within numaa)
              j (index into numa)
              fval (<optional return> float value)
              ival (<optional return> int value)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetValue(*args)
    
    

    try:
        leptonica.numaSetValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaSetValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSetValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSetValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       
  numaSetValue()

      Input:  na
              index   (to element to be set)
              val  (to set element)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSetValue(*args)
    
    

    try:
        leptonica.numaReplaceNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaReplaceNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaReplaceNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReplaceNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       
  numaReplaceNumber()

      Input:  na
              index (element to be replaced)
              val (new value to replace old one)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaReplaceNumber(*args)
    
    

    try:
        leptonica.numaGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetParameters(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pstartx')       
('l_float32', '*pdelx')       
  numaGetParameters()

      Input:  na
              &startx (<optional return> startx)
              &delx (<optional return> delx)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetParameters(*args)
    
    

    try:
        leptonica.numaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWriteStream(*args):
        """
        ('FILE', '*fp')       
('NUMA', '*na')       
  numaWriteStream()

      Input:  stream, na
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaWriteStream(*args)
    
    

    try:
        leptonica.numaShiftValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaShiftValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaShiftValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaShiftValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'diff')       
  numaShiftValue()

      Input:  na
              index (to element to change relative to the current value)
              diff  (increment if diff > 0 or decrement if diff < 0)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaShiftValue(*args)
    
    

    try:
        leptonica.numaInsertNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaInsertNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaInsertNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInsertNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       
  numaInsertNumber()

      Input:  na
              index (location in na to insert new value)
              val  (float32 or integer to be added)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts na[i] --> na[i + 1] for all i >= index,
          and then inserts val as na[index].
      (2) It should not be used repeatedly on large arrays,
          because the function is O(n).



        """
        args = _convert_params(*args)
        
        return leptonica.numaInsertNumber(*args)
    
    

    try:
        leptonica.numaGetIArray.argtypes = [ctypes.c_void_p]
        leptonica.numaGetIArray.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function numaGetIArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetIArray(*args):
        """
        ('NUMA', '*na')       
  numaGetIArray()

      Input:  na
      Return: a copy of the bare internal array, integerized
              by rounding, or null on error
  Notes:
      (1) A copy of the array is always made, because we need to
          generate an integer array from the bare float array.
          The caller is responsible for freeing the array.
      (2) The array size is determined by the number of stored numbers,
          not by the size of the allocated array in the Numa.
      (3) This function is provided to simplify calculations
          using the bare internal array, rather than continually
          calling accessors on the numa.  It is typically used
          on an array of size 256.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetIArray(*args)
    
    

    try:
        leptonica.numaaExtendArray.argtypes = [ctypes.c_void_p]
        leptonica.numaaExtendArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaExtendArray(*args):
        """
        ('NUMAA', '*naa')       
  numaaExtendArray()

      Input:  naa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaExtendArray(*args)
    
    

    try:
        leptonica.numaaGetNumaCount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaaGetNumaCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaGetNumaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetNumaCount(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
  numaaGetNumaCount()

      Input:  naa
              index (of numa in naa)
      Return: count of numbers in the referenced numa, or 0 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetNumaCount(*args)
    
    

    try:
        leptonica.numaHashCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.numaHashCreate.restype = lambda address: NUMAHASH(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaHashCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHashCreate(*args):
        """
        ('l_int32', 'nbuckets')       
('l_int32', 'initsize')       
  numaHashCreate()

      Input: nbuckets (the number of buckets in the hash table,
                       which should be prime.)
             initsize (initial size of each allocated numa; 0 for default)
      Return: ptr to new nahash, or null on error

  Note: actual numa are created only as required by numaHashAdd()


        """
        args = _convert_params(*args)
        
        return leptonica.numaHashCreate(*args)
    
    

    try:
        leptonica.numaGetFArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaGetFArray.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        os.stderr.write("Warning - function numaGetFArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetFArray(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'copyflag')       
  numaGetFArray()

      Input:  na
              copyflag (L_NOCOPY or L_COPY)
      Return: either the bare internal array or a copy of it,
              or null on error

  Notes:
      (1) If copyflag == L_COPY, it makes a copy which the caller
          is responsible for freeing.  Otherwise, it operates
          directly on the bare array of the numa.
      (2) Very important: for L_NOCOPY, any writes to the array
          will be in the numa.  Do not write beyond the size of
          the count field, because it will not be accessable
          from the numa!  If necessary, be sure to set the count
          field to a larger number (such as the alloc size)
          BEFORE calling this function.  Creating with numaMakeConstant()
          is another way to insure full initialization.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetFArray(*args)
    
    

    try:
        leptonica.numaCreateFromIArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaCreateFromIArray.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaCreateFromIArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreateFromIArray(*args):
        """
        ('l_int32', '*iarray')       
('l_int32', 'size')       
  numaCreateFromIArray()

      Input:  iarray (integer)
              size (of the array)
      Return: na, or null on error

  Notes:
      (1) We can't insert this int array into the numa, because a numa
          takes a float array.  So this just copies the data from the
          input array into the numa.  The input array continues to be
          owned by the caller.


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreateFromIArray(*args)
    
    

    try:
        leptonica.numaaCreateFull.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.numaaCreateFull.restype = lambda address: NUMAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaaCreateFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaCreateFull(*args):
        """
        ('l_int32', 'ntop')       
('l_int32', 'n')       
  numaaCreateFull()

      Input:  ntop: size of numa ptr array to be alloc'd
              n: size of individual numa arrays to be alloc'd (0 for default)
      Return: naa, or null on error

  Notes:
      (1) This allocates numaa and fills the array with allocated numas.
          In use, after calling this function, use
              numaaAddNumber(naa, index, val);
          to add val to the index-th numa in naa.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaCreateFull(*args)
    
    

    try:
        leptonica.numaGetFValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetFValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetFValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetFValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', '*pval')       
  numaGetFValue()

      Input:  na
              index (into numa)
              &val  (<return> float value; 0.0 on error)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Caller may need to check the function return value to
          decide if a 0.0 in the returned ival is valid.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetFValue(*args)
    
    

    try:
        leptonica.numaCreate.argtypes = [ctypes.c_int32]
        leptonica.numaCreate.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreate(*args):
        """
        ('l_int32', 'n')       
  numaCreate()

      Input:  size of number array to be alloc'd (0 for default)
      Return: na, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreate(*args)
    
    

    try:
        leptonica.numaConvertToSarray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaConvertToSarray.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaConvertToSarray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToSarray(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'size1')       
('l_int32', 'size2')       
('l_int32', 'addzeros')       
('l_int32', 'type')       
  numaConvertToSarray()

      Input:  na
              size1 (size of conversion field)
              size2 (for float conversion: size of field to the right
                     of the decimal point)
              addzeros (for integer conversion: to add lead zeros)
              type (L_INTEGER_VALUE, L_FLOAT_VALUE)
      Return: a sarray of the float values converted to strings
              representing either integer or float values; or null on error.

  Notes:
      (1) For integer conversion, size2 is ignored.
          For float conversion, addzeroes is ignored.


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToSarray(*args)
    
    

    try:
        leptonica.numaaCreate.argtypes = [ctypes.c_int32]
        leptonica.numaaCreate.restype = lambda address: NUMAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaCreate(*args):
        """
        ('l_int32', 'n')       
  numaaCreate()

      Input:  size of numa ptr array to be alloc'd (0 for default)
      Return: naa, or null on error



        """
        args = _convert_params(*args)
        
        return leptonica.numaaCreate(*args)
    
    

    try:
        leptonica.numaaAddNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaaAddNuma.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaAddNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaAddNuma(*args):
        """
        ('NUMAA', '*naa')       
('NUMA', '*na')       
('l_int32', 'copyflag')       
  numaaAddNuma()

      Input:  naa
              na   (to be added)
              copyflag  (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaAddNuma(*args)
    
    

    try:
        leptonica.numaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaChangeRefcount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaChangeRefcount(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'delta')       
  numaChangeRefCount()

      Input:  na
              delta (change to be applied)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaChangeRefcount(*args)
    
    

    try:
        leptonica.numa2dGetCount.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numa2dGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numa2dGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dGetCount(*args):
        """
        ('NUMA2D', '*na2d')       
('l_int32', 'row')       
('l_int32', 'col')       
  numa2dGetCount()

      Input:  na2d
              row of 2d array
              col of 2d array
      Return: size of numa at [row][col], or 0 if the numa doesn't exist
              or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dGetCount(*args)
    
    

    try:
        leptonica.numaaAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaaAddNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaAddNumber(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
('l_float32', 'val')       
  numaaAddNumber()

      Input:  naa
              index (of numa within numaa)
              val  (float or int to be added; stored as a float)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Adds to an existing numa only.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaAddNumber(*args)
    
    

    try:
        leptonica.numaHashDestroy.argtypes = [ctypes.c_void_p]
        leptonica.numaHashDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function numaHashDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHashDestroy(*args):
        """
        ('NUMAHASH', '**pnahash')       
  numaHashDestroy()

      Input:  &nahash (<to be nulled, if it exists>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.numaHashDestroy(*args)
    
    

    try:
        leptonica.numaRemoveNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaRemoveNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaRemoveNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRemoveNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
  numaRemoveNumber()

      Input:  na
              index (element to be removed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts na[i] --> na[i - 1] for all i > index.
      (2) It should not be used repeatedly on large arrays,
          because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.numaRemoveNumber(*args)
    
    

    try:
        leptonica.numaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('NUMAA', '*naa')       
  numaaWriteStream()

      Input:  stream, naa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaWriteStream(*args)
    
    

    try:
        leptonica.numaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.numaaReadStream.restype = lambda address: NUMAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaReadStream(*args):
        """
        ('FILE', '*fp')       
  numaaReadStream()

      Input:  stream
      Return: naa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaReadStream(*args)
    
    

    try:
        leptonica.numaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.numaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function numaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDestroy(*args):
        """
        ('NUMA', '**pna')       
  numaDestroy()

      Input:  &na (<to be nulled if it exists>)
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the numa.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.numaDestroy(*args)
    
    

    try:
        leptonica.numaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.numaReadStream.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReadStream(*args):
        """
        ('FILE', '*fp')       
  numaReadStream()

      Input:  stream
      Return: numa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaReadStream(*args)
    
    

    try:
        leptonica.numaSetCount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSetCount(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'newcount')       
  numaSetCount()

      Input:  na
              newcount
      Return: 0 if OK, 1 on error

  Notes:
      (1) If newcount <= na->nalloc, this resets na->n.
          Using newcount = 0 is equivalent to numaEmpty().
      (2) If newcount > na->nalloc, this causes a realloc
          to a size na->nalloc = newcount.
      (3) All the previously unused values in na are set to 0.0.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSetCount(*args)
    
    

    try:
        leptonica.numaaGetNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaaGetNuma.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaaGetNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetNuma(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       
  numaaGetNuma()

      Input:  naa
              index  (to the index-th numa)
              accessflag   (L_COPY or L_CLONE)
      Return: numa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetNuma(*args)
    
    

    try:
        leptonica.numaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWrite(*args):
        """
        ('const char', '*filename')       
('NUMA', '*na')       
  numaWrite()

      Input:  filename, na
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaWrite(*args)
    
    

    try:
        leptonica.numaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.numaaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function numaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaDestroy(*args):
        """
        ('NUMAA', '**pnaa')       
  numaaDestroy()

      Input: &numaa <to be nulled if it exists>
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.numaaDestroy(*args)
    
    

    try:
        leptonica.numaRead.argtypes = [ctypes.c_void_p]
        leptonica.numaRead.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRead(*args):
        """
        ('const char', '*filename')       
  numaRead()

      Input:  filename
      Return: na, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRead(*args)
    
    

    try:
        leptonica.numaSetParameters.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaSetParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSetParameters(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'startx')       
('l_float32', 'delx')       
  numaSetParameters()

      Input:  na
              startx (x value corresponding to na[0])
              delx (difference in x values for the situation where the
                    elements of na correspond to the evaulation of a
                    function at equal intervals of size @delx)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSetParameters(*args)
    
    

    try:
        leptonica.numaHashAdd.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_float]
        leptonica.numaHashAdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaHashAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHashAdd(*args):
        """
        ('NUMAHASH', '*nahash')       
('l_uint32', 'key')       
('l_float32', 'value')       
  numaHashAdd()

      Input:  nahash
              key  (key to be hashed into a bucket number)
              value  (float value to be appended to the specific numa)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaHashAdd(*args)
    
    

    try:
        leptonica.numaGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.numaGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetRefcount(*args):
        """
        ('NUMA', '*na')       
  numaGetRefCount()

      Input:  na
      Return: refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetRefcount(*args)
    
    

    try:
        leptonica.numa2dDestroy.argtypes = [ctypes.c_void_p]
        leptonica.numa2dDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function numa2dDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numa2dDestroy(*args):
        """
        ('NUMA2D', '**pna2d')       
  numa2dDestroy()

      Input:  &numa2d (<to be nulled if it exists>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.numa2dDestroy(*args)
    
    

    try:
        leptonica.numaCopyParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaCopyParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaCopyParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCopyParameters(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       
  numaCopyParameters()

      Input:  nad (destination Numa)
              nas (source Numa)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCopyParameters(*args)
    
    

    try:
        leptonica.numaHashGetNuma.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.numaHashGetNuma.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaHashGetNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHashGetNuma(*args):
        """
        ('NUMAHASH', '*nahash')       
('l_uint32', 'key')       
  numaHashGetNuma()

      Input:  nahash
              key  (key to be hashed into a bucket number)
      Return: ptr to numa


        """
        args = _convert_params(*args)
        
        return leptonica.numaHashGetNuma(*args)
    




class numafunc1(object):
    """   numafunc1.c

      Arithmetic and logic
          NUMA        *numaArithOp()
          NUMA        *numaLogicalOp()
          NUMA        *numaInvert()
          l_int32      numaSimilar()
          l_int32      numaAddToNumber()

      Simple extractions
          l_int32      numaGetMin()
          l_int32      numaGetMax()
          l_int32      numaGetSum()
          NUMA        *numaGetPartialSums()
          l_int32      numaGetSumOnInterval()
          l_int32      numaHasOnlyIntegers()
          NUMA        *numaSubsample()
          NUMA        *numaMakeDelta()
          NUMA        *numaMakeSequence()
          NUMA        *numaMakeConstant()
          NUMA        *numaMakeAbsValue()
          NUMA        *numaAddBorder()
          NUMA        *numaAddSpecifiedBorder()
          NUMA        *numaRemoveBorder()
          l_int32      numaGetNonzeroRange()
          l_int32      numaGetCountRelativeToZero()
          NUMA        *numaClipToInterval()
          NUMA        *numaMakeThresholdIndicator()
          NUMA        *numaUniformSampling()
          NUMA        *numaReverse()

      Signal feature extraction
          NUMA        *numaLowPassIntervals()
          NUMA        *numaThresholdEdges()
          NUMA        *numaGetSpanValues()
          NUMA        *numaGetEdgeValues()

      Interpolation
          l_int32      numaInterpolateEqxVal()
          l_int32      numaInterpolateEqxInterval()
          l_int32      numaInterpolateArbxVal()
          l_int32      numaInterpolateArbxInterval()

      Functions requiring interpolation
          l_int32      numaFitMax()
          l_int32      numaDifferentiateInterval()
          l_int32      numaIntegrateInterval()

      Sorting
          NUMA        *numaSortGeneral()
          NUMA        *numaSortAutoSelect()
          NUMA        *numaSortIndexAutoSelect()
          l_int32      numaChooseSortType()
          NUMA        *numaSort()
          NUMA        *numaBinSort()
          NUMA        *numaGetSortIndex()
          NUMA        *numaGetBinSortIndex()
          NUMA        *numaSortByIndex()
          l_int32      numaIsSorted()
          l_int32      numaSortPair()
          NUMA        *numaInvertMap()

      Random permutation
          NUMA        *numaPseudorandomSequence()
          NUMA        *numaRandomPermutation()

      Functions requiring sorting
          l_int32      numaGetRankValue()
          l_int32      numaGetMedian()
          l_int32      numaGetBinnedMedian()
          l_int32      numaGetMode()
          l_int32      numaGetMedianVariation()

      Numa combination
          l_int32      numaJoin()
          l_int32      numaaJoin()
          NUMA        *numaaFlattenToNuma()


    Things to remember when using the Numa:

    (1) The numa is a struct, not an array.  Always use accessors
        (see numabasic.c), never the fields directly.

    (2) The number array holds l_float32 values.  It can also
        be used to store l_int32 values.  See numabasic.c for
        details on using the accessors.

    (3) If you use numaCreate(), no numbers are stored and the size is 0.
        You have to add numbers to increase the size.
        If you want to start with a numa of a fixed size, with each
        entry initialized to the same value, use numaMakeConstant().

    (4) Occasionally, in the comments we denote the i-th element of a
        numa by na[i].  This is conceptual only -- the numa is not an array!

"""
    
    try:
        leptonica.numaGetMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMax.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMax(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pmaxval')       
('l_int32', '*pimaxloc')       
  numaGetMax()

      Input:  na
              &maxval (<optional return> max value)
              &imaxloc (<optional return> index of max location)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMax(*args)
    
    

    try:
        leptonica.numaLogicalOp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaLogicalOp.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaLogicalOp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaLogicalOp(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'op')       
  numaLogicalOp()

      Input:  nad (<optional> can be null or equal to na1 (in-place)
              na1
              na2
              op (L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR)
      Return: nad (always: operation applied to na1 and na2)

  Notes:
      (1) The sizes of na1 and na2 must be equal.
      (2) nad can only null or equal to na1.
      (3) This is intended for use with indicator arrays (0s and 1s).
          Input data is extracted as integers (0 == false, anything
          else == true); output results are 0 and 1.
      (4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical
          arithmetic this is (val1 & ~val2), but because these values
          are integers, we use (val1 && !val2).


        """
        args = _convert_params(*args)
        
        return leptonica.numaLogicalOp(*args)
    
    

    try:
        leptonica.numaRemoveBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaRemoveBorder.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaRemoveBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRemoveBorder(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'left')       
('l_int32', 'right')       
  numaRemoveBorder()

      Input:  nas
              left, right (number of elements to remove from each side)
      Return: nad (with removed elements at left and right), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRemoveBorder(*args)
    
    

    try:
        leptonica.numaSortGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaSortGeneral.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSortGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortGeneral(*args):
        """
        ('NUMA', '*na')       
('NUMA', '**pnasort')       
('NUMA', '**pnaindex')       
('NUMA', '**pnainvert')       
('l_int32', 'sortorder')       
('l_int32', 'sorttype')       
  numaSortGeneral()

      Input:  na (source numa)
              nasort (<optional> sorted numa)
              naindex (<optional> index of elements in na associated
                       with each element of nasort)
              nainvert (<optional> index of elements in nasort associated
                        with each element of na)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
              sorttype (L_SHELL_SORT or L_BIN_SORT)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Sorting can be confusing.  Here's an array of five values with
          the results shown for the 3 output arrays.

          na      nasort   naindex   nainvert
          -----------------------------------
          3         9         2         3
          4         6         3         2
          9         4         1         0
          6         3         0         1
          1         1         4         4

          Note that naindex is a LUT into na for the sorted array values,
          and nainvert directly gives the sorted index values for the
          input array.  It is useful to view naindex is as a map:
                 0  -->  2
                 1  -->  3
                 2  -->  1
                 3  -->  0
                 4  -->  4
          and nainvert, the inverse of this map:
                 0  -->  3
                 1  -->  2
                 2  -->  0
                 3  -->  1
                 4  -->  4

          We can write these relations symbolically as:
              nasort[i] = na[naindex[i]]
              na[i] = nasort[nainvert[i]]


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortGeneral(*args)
    
    

    try:
        leptonica.numaMakeThresholdIndicator.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.numaMakeThresholdIndicator.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeThresholdIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeThresholdIndicator(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
  numaMakeThresholdIndicator()

      Input:  nas (input numa)
              thresh (threshold value)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
      Output: nad (indicator array: values are 0 and 1)

  Notes:
      (1) For each element in nas, if the constraint given by 'type'
          correctly specifies its relation to thresh, a value of 1
          is recorded in nad.


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeThresholdIndicator(*args)
    
    

    try:
        leptonica.numaSortIndexAutoSelect.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSortIndexAutoSelect.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaSortIndexAutoSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortIndexAutoSelect(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       
  numaSortIndexAutoSelect()

      Input:  nas
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: nad (indices of nas, sorted by value in nas), or null on error

  Notes:
      (1) This does either a shell sort or a bin sort, depending on
          the number of elements in nas and the dynamic range.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortIndexAutoSelect(*args)
    
    

    try:
        leptonica.numaGetRankValue.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetRankValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetRankValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetRankValue(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'fract')       
('NUMA', '*nasort')       
('l_int32', 'usebins')       
('l_float32', '*pval')       
  numaGetRankValue()

      Input:  na
              fract (use 0.0 for smallest, 1.0 for largest)
              nasort (<optional> increasing sorted version of na)
              usebins (0 for general sort; 1 for bin sort)
              &val  (<return> rank val)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Computes the rank value of a number in the @na, which is
          the number that is a fraction @fract from the small
          end of the sorted version of @na.
      (2) If you do this multiple times for different rank values,
          sort the array in advance and use that for @nasort;
          if you're only calling this once, input @nasort == NULL.
      (3) If @usebins == 1, this uses a bin sorting method.
          Use this only where:
           * the numbers are non-negative integers
           * there are over 100 numbers
           * the maximum value is less than about 50,000
      (4) The advantage of using a bin sort is that it is O(n),
          instead of O(nlogn) for general sort routines.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetRankValue(*args)
    
    

    try:
        leptonica.numaGetBinSortIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaGetBinSortIndex.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaGetBinSortIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetBinSortIndex(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       
  numaGetBinSortIndex()

      Input:  na (of non-negative integers with a max that is typically
                  less than 1,000,000)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: na (sorted), or null on error

  Notes:
      (1) This creates an array (or lookup table) that contains
          the sorted position of the elements in the input Numa.
      (2) Because it uses a bin sort with buckets of size 1, it
          is not appropriate for sorting either small arrays or
          arrays containing very large integer values.  For such
          arrays, use a standard general sort function like
          numaGetSortIndex().


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetBinSortIndex(*args)
    
    

    try:
        leptonica.numaHasOnlyIntegers.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaHasOnlyIntegers.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaHasOnlyIntegers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHasOnlyIntegers(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxsamples')       
('l_int32', '*pallints')       
  numaHasOnlyIntegers()

      Input:  na
              maxsamples (maximum number of samples to check)
              &allints (<return> 1 if all sampled values are ints; else 0)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Set @maxsamples == 0 to check every integer in na.  Otherwise,
          this samples no more than @maxsamples.


        """
        args = _convert_params(*args)
        
        return leptonica.numaHasOnlyIntegers(*args)
    
    

    try:
        leptonica.numaClipToInterval.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaClipToInterval.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaClipToInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaClipToInterval(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'first')       
('l_int32', 'last')       
  numaClipToInterval()

      Input:  numa
              first, last (clipping interval)
      Return: numa with the same values as the input, but clipped
              to the specified interval

  Note: If you want the indices of the array values to be unchanged,
        use first = 0.
  Usage: This is useful to clip a histogram that has a few nonzero
         values to its nonzero range.


        """
        args = _convert_params(*args)
        
        return leptonica.numaClipToInterval(*args)
    
    

    try:
        leptonica.numaInterpolateEqxInterval.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaInterpolateEqxInterval.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaInterpolateEqxInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateEqxInterval(*args):
        """
        ('l_float32', 'startx')       
('l_float32', 'deltax')       
('NUMA', '*nasy')       
('l_int32', 'type')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       
  numaInterpolateEqxInterval()

      Input:  startx (xval corresponding to first element in nas)
              deltax (x increment between array elements in nas)
              nasy  (numa of ordinate values, assumed equally spaced)
              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)
              x0 (start value of interval)
              x1 (end value of interval)
              npts (number of points to evaluate function in interval)
              &nax (<optional return> array of x values in interval)
              &nay (<return> array of y values in interval)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Considering nasy as a function of x, the x values
          are equally spaced.
      (2) This creates nay (and optionally nax) of interpolated
          values over the specified interval (x0, x1).
      (3) If the interval (x0, x1) lies partially outside the array
          nasy (as interpreted by startx and deltax), it is an
          error and returns 1.
      (4) Note that deltax is the intrinsic x-increment for the input
          array nasy, whereas delx is the intrinsic x-increment for the
          output interpolated array nay.


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateEqxInterval(*args)
    
    

    try:
        leptonica.numaSubsample.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSubsample.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaSubsample not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSubsample(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'subfactor')       
  numaSubsample()

      Input:  nas
              subfactor (subsample factor, >= 1)
      Return: nad (evenly sampled values from nas), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSubsample(*args)
    
    

    try:
        leptonica.numaUniformSampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaUniformSampling.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaUniformSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaUniformSampling(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'nsamp')       
  numaUniformSampling()

      Input:  nas (input numa)
              nsamp (number of samples)
      Output: nad (resampled array), or null on error

  Notes:
      (1) This resamples the values in the array, using @nsamp
          equal divisions.


        """
        args = _convert_params(*args)
        
        return leptonica.numaUniformSampling(*args)
    
    

    try:
        leptonica.numaAddSpecifiedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaAddSpecifiedBorder.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaAddSpecifiedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddSpecifiedBorder(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'type')       
  numaAddSpecifiedBorder()

      Input:  nas
              left, right (number of elements to add on each side)
              type (L_CONTINUED_BORDER, L_MIRRORED_BORDER)
      Return: nad (with added elements at left and right), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddSpecifiedBorder(*args)
    
    

    try:
        leptonica.numaChooseSortType.argtypes = [ctypes.c_void_p]
        leptonica.numaChooseSortType.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaChooseSortType not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaChooseSortType(*args):
        """
        ('NUMA', '*nas')       
  numaChooseSortType()

      Input:  na (to be sorted)
      Return: sorttype (L_SHELL_SORT or L_BIN_SORT), or UNDEF on error.

  Notes:
      (1) This selects either a shell sort or a bin sort, depending on
          the number of elements in nas and the dynamic range.
      (2) If there are negative values in nas, it selects shell sort.


        """
        args = _convert_params(*args)
        
        return leptonica.numaChooseSortType(*args)
    
    

    try:
        leptonica.numaAddToNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaAddToNumber.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaAddToNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddToNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       
  numaAddToNumber()

      Input:  na
              index (element to be changed)
              val (new value to be added)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is useful for accumulating sums, regardless of the index
          order in which the values are made available.
      (2) Before use, the numa has to be filled up to @index.  This would
          typically be used by creating the numa with the full sized
          array, initialized to 0.0, using numaMakeConstant().


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddToNumber(*args)
    
    

    try:
        leptonica.numaLowPassIntervals.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaLowPassIntervals.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaLowPassIntervals not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaLowPassIntervals(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'thresh')       
('l_float32', 'maxn')       
  numaLowPassIntervals()

      Input:  nas (input numa)
              thresh (threshold fraction of max; in [0.0 ... 1.0])
              maxn (for normalizing; set maxn = 0.0 to use the max in nas)
      Output: nad (interval abscissa pairs), or null on error

  Notes:
      (1) For each interval where the value is less than a specified
          fraction of the maximum, this records the left and right "x"
          value.


        """
        args = _convert_params(*args)
        
        return leptonica.numaLowPassIntervals(*args)
    
    

    try:
        leptonica.numaInvertMap.argtypes = [ctypes.c_void_p]
        leptonica.numaInvertMap.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaInvertMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInvertMap(*args):
        """
        ('NUMA', '*nas')       
  numaInvertMap()

      Input:  nas
      Return: nad (the inverted map), or null on error or if not invertible

  Notes:
      (1) This requires that nas contain each integer from 0 to n-1.
          The array is typically an index array into a sort or permutation
          of another array.


        """
        args = _convert_params(*args)
        
        return leptonica.numaInvertMap(*args)
    
    

    try:
        leptonica.numaInterpolateArbxVal.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaInterpolateArbxVal.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaInterpolateArbxVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateArbxVal(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'type')       
('l_float32', 'xval')       
('l_float32', '*pyval')       
  numaInterpolateArbxVal()

      Input:  nax (numa of abscissa values)
              nay (numa of ordinate values, corresponding to nax)
              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)
              xval
              &yval (<return> interpolated value)
      Return: 0 if OK, 1 on error (e.g., if xval is outside range)

  Notes:
      (1) The values in nax must be sorted in increasing order.
          If, additionally, they are equally spaced, you can use
          numaInterpolateEqxVal().
      (2) Caller should check for valid return.
      (3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
          for formulas.


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateArbxVal(*args)
    
    

    try:
        leptonica.numaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSortByIndex.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortByIndex(*args):
        """
        ('NUMA', '*nas')       
('NUMA', '*naindex')       
  numaSortByIndex()

      Input:  nas
              naindex (na that maps from the new numa to the input numa)
      Return: nad (sorted), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortByIndex(*args)
    
    

    try:
        leptonica.numaGetEdgeValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetEdgeValues.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetEdgeValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetEdgeValues(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'edge')       
('l_int32', '*pstart')       
('l_int32', '*pend')       
('l_int32', '*psign')       
  numaGetEdgeValues()

      Input:  na (numa that is output of numaThresholdEdges())
              edge (edge number, zero-based)
              &start (<optional return> location of start of transition)
              &end (<optional return> location of end of transition)
              &sign (<optional return> transition sign: +1 is rising,
                     -1 is falling)
      Output: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetEdgeValues(*args)
    
    

    try:
        leptonica.numaGetMedian.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMedian.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMedian(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pval')       
  numaGetMedian()

      Input:  na
              &val  (<return> median value)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Computes the median value of the numbers in the numa, by
          sorting and finding the middle value in the sorted array.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMedian(*args)
    
    

    try:
        leptonica.numaGetSpanValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetSpanValues.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetSpanValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSpanValues(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'span')       
('l_int32', '*pstart')       
('l_int32', '*pend')       
  numaGetSpanValues()

      Input:  na (numa that is output of numaLowPassIntervals())
              span (span number, zero-based)
              &start (<optional return> location of start of transition)
              &end (<optional return> location of end of transition)
      Output: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSpanValues(*args)
    
    

    try:
        leptonica.numaIsSorted.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaIsSorted.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaIsSorted not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaIsSorted(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       
('l_int32', '*psorted')       
  numaIsSorted()

      Input:  nas
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
              &sorted (<return> 1 if sorted; 0 if not)
      Return: 1 if OK; 0 on error

  Notes:
      (1) This is a quick O(n) test if nas is sorted.  It is useful
          in situations where the array is likely to be already
          sorted, and a sort operation can be avoided.


        """
        args = _convert_params(*args)
        
        return leptonica.numaIsSorted(*args)
    
    

    try:
        leptonica.numaArithOp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaArithOp.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaArithOp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaArithOp(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'op')       
  numaArithOp()

      Input:  nad (<optional> can be null or equal to na1 (in-place)
              na1
              na2
              op (L_ARITH_ADD, L_ARITH_SUBTRACT,
                  L_ARITH_MULTIPLY, L_ARITH_DIVIDE)
      Return: nad (always: operation applied to na1 and na2)

  Notes:
      (1) The sizes of na1 and na2 must be equal.
      (2) nad can only null or equal to na1.
      (3) To add a constant to a numa, or to multipy a numa by
          a constant, use numaTransform().


        """
        args = _convert_params(*args)
        
        return leptonica.numaArithOp(*args)
    
    

    try:
        leptonica.numaGetSumOnInterval.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetSumOnInterval.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetSumOnInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSumOnInterval(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_float32', '*psum')       
  numaGetSumOnInterval()

      Input:  na
              first (beginning index)
              last (final index)
              &sum (<return> sum of values in the index interval range)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSumOnInterval(*args)
    
    

    try:
        leptonica.numaGetBinnedMedian.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetBinnedMedian.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetBinnedMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetBinnedMedian(*args):
        """
        ('NUMA', '*na')       
('l_int32', '*pval')       
  numaGetBinnedMedian()

      Input:  na
              &val  (<return> integer median value)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Computes the median value of the numbers in the numa,
          using bin sort and finding the middle value in the sorted array.
      (2) See numaGetRankValue() for conditions on na for which
          this should be used.  Otherwise, use numaGetMedian().


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetBinnedMedian(*args)
    
    

    try:
        leptonica.numaaFlattenToNuma.argtypes = [ctypes.c_void_p]
        leptonica.numaaFlattenToNuma.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaaFlattenToNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaFlattenToNuma(*args):
        """
        ('NUMAA', '*naa')       
  numaaFlattenToNuma()

      Input:  numaa
      Return: numa, or null on error

  Notes:
      (1) This 'flattens' the Numaa to a Numa, by joining successively
          each Numa in the Numaa.
      (2) It doesn't make any assumptions about the location of the
          Numas in the Numaa array, unlike most Numaa functions.
      (3) It leaves the input Numaa unchanged.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaFlattenToNuma(*args)
    
    

    try:
        leptonica.numaAddBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.numaAddBorder.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaAddBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddBorder(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_float32', 'val')       
  numaAddBorder()

      Input:  nas
              left, right (number of elements to add on each side)
              val (initialize border elements)
      Return: nad (with added elements at left and right), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddBorder(*args)
    
    

    try:
        leptonica.numaIntegrateInterval.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaIntegrateInterval.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaIntegrateInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaIntegrateInterval(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('l_float32', '*psum')       
  numaIntegrateInterval()

      Input:  nax (numa of abscissa values)
              nay (numa of ordinate values, corresponding to nax)
              x0 (start value of interval)
              x1 (end value of interval)
              npts (number of points to evaluate function in interval)
              &sum (<return> integral of function over interval)
      Return: 0 if OK, 1 on error (e.g., if x0 or x1 is outside range)

  Notes:
      (1) The values in nax must be sorted in increasing order.
          If they are not sorted, it is done in the interpolation
          step, and a warning is issued.
      (2) Caller should check for valid return.


        """
        args = _convert_params(*args)
        
        return leptonica.numaIntegrateInterval(*args)
    
    

    try:
        leptonica.numaGetMode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMode.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetMode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMode(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pval')       
('l_int32', '*pcount')       
  numaGetMode()

      Input:  na
              &val  (<return> mode val)
              &count  (<optional return> mode count)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Computes the mode value of the numbers in the numa, by
          sorting and finding the value of the number with the
          largest count.
      (2) Optionally, also returns that count.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMode(*args)
    
    

    try:
        leptonica.numaSort.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSort.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSort(*args):
        """
        ('NUMA', '*naout')       
('NUMA', '*nain')       
('l_int32', 'sortorder')       
  numaSort()

      Input:  naout (output numa; can be NULL or equal to nain)
              nain (input numa)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: naout (output sorted numa), or null on error

  Notes:
      (1) Set naout = nain for in-place; otherwise, set naout = NULL.
      (2) Source: Shell sort, modified from K&R, 2nd edition, p.62.
          Slow but simple O(n logn) sort.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSort(*args)
    
    

    try:
        leptonica.numaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaJoin(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  numaJoin()

      Input:  nad  (dest numa; add to this one)
              nas  (<optional> source numa; add from this one)
              istart  (starting index in nas)
              iend  (ending index in nas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (2) iend < 0 means 'read to the end'
      (3) if nas == NULL, this is a no-op


        """
        args = _convert_params(*args)
        
        return leptonica.numaJoin(*args)
    
    

    try:
        leptonica.numaMakeDelta.argtypes = [ctypes.c_void_p]
        leptonica.numaMakeDelta.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeDelta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeDelta(*args):
        """
        ('NUMA', '*nas')       
  numaMakeDelta()

      Input:  nas (input numa)
      Return: numa (of difference values val[i+1] - val[i]),
                    or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeDelta(*args)
    
    

    try:
        leptonica.numaInvert.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaInvert.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaInvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInvert(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       
  numaInvert()

      Input:  nad (<optional> can be null or equal to nas (in-place)
              nas
      Return: nad (always: 'inverts' nas)

  Notes:
      (1) This is intended for use with indicator arrays (0s and 1s).
          It gives a boolean-type output, taking the input as
          an integer and inverting it:
              0              -->  1
              anything else  -->   0


        """
        args = _convert_params(*args)
        
        return leptonica.numaInvert(*args)
    
    

    try:
        leptonica.numaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaJoin(*args):
        """
        ('NUMAA', '*naad')       
('NUMAA', '*naas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  numaaJoin()

      Input:  naad  (dest naa; add to this one)
              naas  (<optional> source naa; add from this one)
              istart  (starting index in nas)
              iend  (ending index in naas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (2) iend < 0 means 'read to the end'
      (3) if naas == NULL, this is a no-op


        """
        args = _convert_params(*args)
        
        return leptonica.numaaJoin(*args)
    
    

    try:
        leptonica.numaInterpolateEqxVal.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaInterpolateEqxVal.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaInterpolateEqxVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateEqxVal(*args):
        """
        ('l_float32', 'startx')       
('l_float32', 'deltax')       
('NUMA', '*nay')       
('l_int32', 'type')       
('l_float32', 'xval')       
('l_float32', '*pyval')       
  numaInterpolateEqxVal()

      Input:  startx (xval corresponding to first element in array)
              deltax (x increment between array elements)
              nay  (numa of ordinate values, assumed equally spaced)
              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)
              xval
              &yval (<return> interpolated value)
      Return: 0 if OK, 1 on error (e.g., if xval is outside range)

  Notes:
      (1) Considering nay as a function of x, the x values
          are equally spaced
      (2) Caller should check for valid return.

  For linear Lagrangian interpolation (through 2 data pts):
         y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)

  For quadratic Lagrangian interpolation (through 3 data pts):
         y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
                y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
                y3(x-x1)(x-x2)/((x3-x1)(x3-x2))



        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateEqxVal(*args)
    
    

    try:
        leptonica.numaDifferentiateInterval.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaDifferentiateInterval.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaDifferentiateInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDifferentiateInterval(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('NUMA', '**pnadx')       
('NUMA', '**pnady')       
  numaDifferentiateInterval()

      Input:  nax (numa of abscissa values)
              nay (numa of ordinate values, corresponding to nax)
              x0 (start value of interval)
              x1 (end value of interval)
              npts (number of points to evaluate function in interval)
              &nadx (<optional return> array of x values in interval)
              &nady (<return> array of derivatives in interval)
      Return: 0 if OK, 1 on error (e.g., if x0 or x1 is outside range)

  Notes:
      (1) The values in nax must be sorted in increasing order.
          If they are not sorted, it is done in the interpolation
          step, and a warning is issued.
      (2) Caller should check for valid return.


        """
        args = _convert_params(*args)
        
        return leptonica.numaDifferentiateInterval(*args)
    
    

    try:
        leptonica.numaGetMedianVariation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMedianVariation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetMedianVariation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMedianVariation(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pmedval')       
('l_float32', '*pmedvar')       
  numaGetMedianVariation()

      Input:  na
              &medval  (<optional return> median value)
              &medvar  (<return> median variation from median val)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Finds the median of the absolute value of the variation from
          the median value in the array.  Why take the absolute value?
          Consider the case where you have values equally distributed
          about both sides of a median value.  Without taking the absolute
          value of the differences, you will get 0 for the variation,
          and this is not useful.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMedianVariation(*args)
    
    

    try:
        leptonica.numaThresholdEdges.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.numaThresholdEdges.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaThresholdEdges not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaThresholdEdges(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'thresh1')       
('l_float32', 'thresh2')       
('l_float32', 'maxn')       
  numaThresholdEdges()

      Input:  nas (input numa)
              thresh1 (low threshold as fraction of max; in [0.0 ... 1.0])
              thresh2 (high threshold as fraction of max; in [0.0 ... 1.0])
              maxn (for normalizing; set maxn = 0.0 to use the max in nas)
      Output: nad (edge interval triplets), or null on error

  Notes:
      (1) For each edge interval, where where the value is less
          than @thresh1 on one side, greater than @thresh2 on
          the other, and between these thresholds throughout the
          interval, this records a triplet of values: the
          'left' and 'right' edges, and either +1 or -1, depending
          on whether the edge is rising or falling.
      (2) No assumption is made about the value outside the array,
          so if the value at the array edge is between the threshold
          values, it is not considered part of an edge.  We start
          looking for edge intervals only after leaving the thresholded
          band.


        """
        args = _convert_params(*args)
        
        return leptonica.numaThresholdEdges(*args)
    
    

    try:
        leptonica.numaGetSortIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaGetSortIndex.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaGetSortIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSortIndex(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'sortorder')       
  numaGetSortIndex()

      Input:  na
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: na giving an array of indices that would sort
              the input array, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSortIndex(*args)
    
    

    try:
        leptonica.numaPseudorandomSequence.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.numaPseudorandomSequence.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaPseudorandomSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaPseudorandomSequence(*args):
        """
        ('l_int32', 'size')       
('l_int32', 'seed')       
  numaPseudorandomSequence()

      Input:  size (of sequence)
              seed (for random number generation)
      Return: na (pseudorandom on {0,...,size - 1}), or null on error

  Notes:
      (1) This uses the Durstenfeld shuffle.
          See: http://en.wikipedia.org/wiki/Fisher–Yates_shuffle.
          Result is a pseudorandom permutation of the sequence of integers
          from 0 to size - 1.


        """
        args = _convert_params(*args)
        
        return leptonica.numaPseudorandomSequence(*args)
    
    

    try:
        leptonica.numaMakeSequence.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.numaMakeSequence.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeSequence(*args):
        """
        ('l_float32', 'startval')       
('l_float32', 'increment')       
('l_int32', 'size')       
  numaMakeSequence()

      Input:  startval
              increment
              size (of sequence)
      Return: numa of sequence of evenly spaced values, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeSequence(*args)
    
    

    try:
        leptonica.numaFitMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaFitMax.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaFitMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFitMax(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pmaxval')       
('NUMA', '*naloc')       
('l_float32', '*pmaxloc')       
  numaFitMax()

      Input:  na  (numa of ordinate values, to fit a max to)
              &maxval (<return> max value)
              naloc (<optional> associated numa of abscissa values)
              &maxloc (<return> abscissa value that gives max value in na;
                   if naloc == null, this is given as an interpolated
                   index value)
      Return: 0 if OK; 1 on error

  Note: if naloc is given, there is no requirement that the
        data points are evenly spaced.  Lagrangian interpolation
        handles that.  The only requirement is that the
        data points are ordered so that the values in naloc
        are either increasing or decreasing.  We test to make
        sure that the sizes of na and naloc are equal, and it
        is assumed that the correspondences na[i] as a function
        of naloc[i] are properly arranged for all i.

  The formula for Lagrangian interpolation through 3 data pts is:
       y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
              y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
              y3(x-x1)(x-x2)/((x3-x1)(x3-x2))

  Then the derivative, using the constants (c1,c2,c3) defined below,
  is set to 0:
       y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0


        """
        args = _convert_params(*args)
        
        return leptonica.numaFitMax(*args)
    
    

    try:
        leptonica.numaSortPair.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSortPair.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSortPair not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortPair(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'sortorder')       
('NUMA', '**pnasx')       
('NUMA', '**pnasy')       
  numaSortPair()

      Input:  nax, nay (input arrays)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
              &nasx (<return> sorted)
              &naxy (<return> sorted exactly in order of nasx)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function sorts the two input arrays, nax and nay,
          together, using nax as the key for sorting.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortPair(*args)
    
    

    try:
        leptonica.numaSortAutoSelect.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSortAutoSelect.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaSortAutoSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortAutoSelect(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       
  numaSortAutoSelect()

      Input:  nas (input numa)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: naout (output sorted numa), or null on error

  Notes:
      (1) This does either a shell sort or a bin sort, depending on
          the number of elements in nas and the dynamic range.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortAutoSelect(*args)
    
    

    try:
        leptonica.numaSimilar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaSimilar.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSimilar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSimilar(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_float32', 'maxdiff')       
('l_int32', '*psimilar')       
  numaSimilar()

      Input:  na1
              na2
              maxdiff (use 0.0 for exact equality)
              &similar (<return> 1 if similar; 0 if different)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Float values can differ slightly due to roundoff and
          accumulated errors.  Using @maxdiff > 0.0 allows similar
          arrays to be identified.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSimilar(*args)
    
    

    try:
        leptonica.numaMakeAbsValue.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaMakeAbsValue.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeAbsValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeAbsValue(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       
  numaMakeAbsValue()

      Input:  nad (can be null for new array, or the same as nas for inplace)
              nas (input numa)
      Return: nad (with all numbers being the absval of the input),
              or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeAbsValue(*args)
    
    

    try:
        leptonica.numaGetMin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetMin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMin(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pminval')       
('l_int32', '*piminloc')       
  numaGetMin()

      Input:  na
              &minval (<optional return> min value)
              &iminloc (<optional return> index of min location)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMin(*args)
    
    

    try:
        leptonica.numaGetNonzeroRange.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetNonzeroRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetNonzeroRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetNonzeroRange(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'eps')       
('l_int32', '*pfirst')       
('l_int32', '*plast')       
  numaGetNonzeroRange()

      Input:  numa
              eps (largest value considered to be zero)
              &first, &last (<return> interval of array indices
                             where values are nonzero)
      Return: 0 if OK, 1 on error or if no nonzero range is found.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetNonzeroRange(*args)
    
    

    try:
        leptonica.numaMakeConstant.argtypes = [ctypes.c_float, ctypes.c_int32]
        leptonica.numaMakeConstant.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeConstant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeConstant(*args):
        """
        ('l_float32', 'val')       
('l_int32', 'size')       
  numaMakeConstant()

      Input:  val
              size (of numa)
      Return: numa (of given size with all entries equal to 'val'),
              or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeConstant(*args)
    
    

    try:
        leptonica.numaBinSort.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaBinSort.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaBinSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaBinSort(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       
  numaBinSort()

      Input:  nas (of non-negative integers with a max that is
                   typically less than 50,000)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: na (sorted), or null on error

  Notes:
      (1) Because this uses a bin sort with buckets of size 1, it
          is not appropriate for sorting either small arrays or
          arrays containing very large integer values.  For such
          arrays, use a standard general sort function like
          numaSort().


        """
        args = _convert_params(*args)
        
        return leptonica.numaBinSort(*args)
    
    

    try:
        leptonica.numaReverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaReverse.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReverse(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       
  numaReverse()

      Input:  nad (<optional> can be null or equal to nas)
              nas (input numa)
      Output: nad (reversed), or null on error

  Notes:
      (1) Usage:
            numaReverse(nas, nas);   // in-place
            nad = numaReverse(NULL, nas);  // makes a new one


        """
        args = _convert_params(*args)
        
        return leptonica.numaReverse(*args)
    
    

    try:
        leptonica.numaInterpolateArbxInterval.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaInterpolateArbxInterval.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaInterpolateArbxInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateArbxInterval(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'type')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('NUMA', '**pnadx')       
('NUMA', '**pnady')       
  numaInterpolateArbxInterval()

      Input:  nax (numa of abscissa values)
              nay (numa of ordinate values, corresponding to nax)
              type (L_LINEAR_INTERP, L_QUADRATIC_INTERP)
              x0 (start value of interval)
              x1 (end value of interval)
              npts (number of points to evaluate function in interval)
              &nadx (<optional return> array of x values in interval)
              &nady (<return> array of y values in interval)
      Return: 0 if OK, 1 on error (e.g., if x0 or x1 is outside range)

  Notes:
      (1) The values in nax must be sorted in increasing order.
          If they are not sorted, we do it here, and complain.
      (2) If the values in nax are equally spaced, you can use
          numaInterpolateEqxInterval().
      (3) Caller should check for valid return.
      (4) We don't call numaInterpolateArbxVal() for each output
          point, because that requires an O(n) search for
          each point.  Instead, we do a single O(n) pass through
          nax, saving the indices to be used for each output yval.
      (5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
          for formulas.


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateArbxInterval(*args)
    
    

    try:
        leptonica.numaGetSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetSum.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSum(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*psum')       
  numaGetSum()

      Input:  na
              &sum (<return> sum of values)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSum(*args)
    
    

    try:
        leptonica.numaGetCountRelativeToZero.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetCountRelativeToZero.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetCountRelativeToZero not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetCountRelativeToZero(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'type')       
('l_int32', '*pcount')       
  numaGetCountRelativeToZero()

      Input:  numa
              type (L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO)
              &count (<return> count of values of given type)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetCountRelativeToZero(*args)
    
    

    try:
        leptonica.numaGetPartialSums.argtypes = [ctypes.c_void_p]
        leptonica.numaGetPartialSums.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaGetPartialSums not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetPartialSums(*args):
        """
        ('NUMA', '*na')       
  numaGetPartialSums()

      Input:  na
      Return: nasum, or null on error

  Notes:
      (1) nasum[i] is the sum for all j <= i of na[j].
          So nasum[0] = na[0].
      (2) If you want to generate a rank function, where rank[0] - 0.0,
          insert a 0.0 at the beginning of the nasum array.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetPartialSums(*args)
    
    

    try:
        leptonica.numaRandomPermutation.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaRandomPermutation.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaRandomPermutation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRandomPermutation(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'seed')       
  numaRandomPermutation()

      Input:  nas (input array)
              seed (for random number generation)
      Return: nas (randomly shuffled array), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRandomPermutation(*args)
    




class numafunc2(object):
    """   numafunc2.c

      Morphological (min/max) operations
          NUMA        *numaErode()
          NUMA        *numaDilate()
          NUMA        *numaOpen()
          NUMA        *numaClose()

      Other transforms
          NUMA        *numaTransform()
          l_int32      numaWindowedStats()
          NUMA        *numaWindowedMean()
          NUMA        *numaWindowedMeanSquare()
          l_int32      numaWindowedVariance()
          NUMA        *numaConvertToInt()

      Histogram generation and statistics
          NUMA        *numaMakeHistogram()
          NUMA        *numaMakeHistogramAuto()
          NUMA        *numaMakeHistogramClipped()
          NUMA        *numaRebinHistogram()
          NUMA        *numaNormalizeHistogram()
          l_int32      numaGetStatsUsingHistogram()
          l_int32      numaGetHistogramStats()
          l_int32      numaGetHistogramStatsOnInterval()
          l_int32      numaMakeRankFromHistogram()
          l_int32      numaHistogramGetRankFromVal()
          l_int32      numaHistogramGetValFromRank()
          l_int32      numaDiscretizeRankAndIntensity()
          l_int32      numaGetRankBinValues()

      Splitting a distribution
          l_int32      numaSplitDistribution()

      Comparing two histograms
          l_int32      numaEarthMoverDistance()

      Extrema finding
          NUMA        *numaFindPeaks()
          NUMA        *numaFindExtrema()
          l_int32     *numaCountReversals()

      Threshold crossings and frequency analysis
          l_int32      numaSelectCrossingThreshold()
          NUMA        *numaCrossingsByThreshold()
          NUMA        *numaCrossingsByPeaks()
          NUMA        *numaEvalBestHaarParameters()
          l_int32      numaEvalHaarSum()

    Things to remember when using the Numa:

    (1) The numa is a struct, not an array.  Always use accessors
        (see numabasic.c), never the fields directly.

    (2) The number array holds l_float32 values.  It can also
        be used to store l_int32 values.  See numabasic.c for
        details on using the accessors.

    (3) Occasionally, in the comments we denote the i-th element of a
        numa by na[i].  This is conceptual only -- the numa is not an array!

    Some general comments on histograms:

    (1) Histograms are the generic statistical representation of
        the data about some attribute.  Typically they're not
        normalized -- they simply give the number of occurrences
        within each range of values of the attribute.  This range
        of values is referred to as a 'bucket'.  For example,
        the histogram could specify how many connected components
        are found for each value of their width; in that case,
        the bucket size is 1.

    (2) In leptonica, all buckets have the same size.  Histograms
        are therefore specified by a numa of occurrences, along
        with two other numbers: the 'value' associated with the
        occupants of the first bucket and the size (i.e., 'width')
        of each bucket.  These two numbers then allow us to calculate
        the value associated with the occupants of each bucket.
        These numbers are fields in the numa, initialized to
        a startx value of 0.0 and a binsize of 1.0.  Accessors for
        these fields are functions numa*Parameters().  All histograms
        must have these two numbers properly set.

"""
    
    try:
        leptonica.numaCountReversals.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaCountReversals.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaCountReversals not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCountReversals(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'minreversal')       
('l_int32', '*pnr')       
('l_float32', '*pnrpl')       
  numaCountReversals()

      Input:  nas (input values)
              minreversal (relative amount to resolve peaks and valleys)
              &nr (<optional return> number of reversals
              &nrpl (<optional return> reversal density: reversals/length)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The input numa is can be generated from pixExtractAlongLine().
          If so, the x parameters can be used to find the reversal
          frequency along a line.


        """
        args = _convert_params(*args)
        
        return leptonica.numaCountReversals(*args)
    
    

    try:
        leptonica.numaErode.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaErode.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaErode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaErode(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       
  numaErode()

      Input:  nas
              size (of sel; greater than 0, odd; origin implicitly in center)
      Return: nad (eroded), or null on error

  Notes:
      (1) The structuring element (sel) is linear, all "hits"
      (2) If size == 1, this returns a copy
      (3) General comment.  The morphological operations are equivalent
          to those that would be performed on a 1-dimensional fpix.
          However, because we have not implemented morphological
          operations on fpix, we do this here.  Because it is only
          1 dimensional, there is no reason to use the more
          complicated van Herk/Gil-Werman algorithm, and we do it
          by brute force.


        """
        args = _convert_params(*args)
        
        return leptonica.numaErode(*args)
    
    

    try:
        leptonica.numaClose.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaClose.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaClose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaClose(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       
  numaClose()

      Input:  nas
              size (of sel; greater than 0, odd; origin implicitly in center)
      Return: nad (opened), or null on error

  Notes:
      (1) The structuring element (sel) is linear, all "hits"
      (2) If size == 1, this returns a copy
      (3) We add a border before doing this operation, for the same
          reason that we add a border to a pix before doing a safe closing.
          Without the border, a small component near the border gets
          clipped at the border on dilation, and can be entirely removed
          by the following erosion, violating the basic extensivity
          property of closing.


        """
        args = _convert_params(*args)
        
        return leptonica.numaClose(*args)
    
    

    try:
        leptonica.numaNormalizeHistogram.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.numaNormalizeHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaNormalizeHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaNormalizeHistogram(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'tsum')       
  numaNormalizeHistogram()

      Input:  nas (input histogram)
              tsum (target sum of all numbers in dest histogram;
                    e.g., use @tsum= 1.0 if this represents a
                    probability distribution)
      Return: nad (normalized histogram), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaNormalizeHistogram(*args)
    
    

    try:
        leptonica.numaRebinHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaRebinHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaRebinHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRebinHistogram(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'newsize')       
  numaRebinHistogram()

      Input:  nas (input histogram)
              newsize (number of old bins contained in each new bin)
      Return: nad (more coarsely re-binned histogram), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRebinHistogram(*args)
    
    

    try:
        leptonica.numaCrossingsByPeaks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.numaCrossingsByPeaks.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaCrossingsByPeaks not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCrossingsByPeaks(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'delta')       
  numaCrossingsByPeaks()

      Input:  nax (<optional> numa of abscissa values)
              nay (numa of ordinate values, corresponding to nax)
              delta (parameter used to identify when a new peak can be found)
      Return: nad (abscissa pts at threshold), or null on error

  Notes:
      (1) If nax == NULL, we use startx and delx from nay to compute
          the crossing values in nad.


        """
        args = _convert_params(*args)
        
        return leptonica.numaCrossingsByPeaks(*args)
    
    

    try:
        leptonica.numaEvalBestHaarParameters.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaEvalBestHaarParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaEvalBestHaarParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEvalBestHaarParameters(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'relweight')       
('l_int32', 'nwidth')       
('l_int32', 'nshift')       
('l_float32', 'minwidth')       
('l_float32', 'maxwidth')       
('l_float32', '*pbestwidth')       
('l_float32', '*pbestshift')       
('l_float32', '*pbestscore')       
  numaEvalBestHaarParameters()

      Input:  nas (numa of non-negative signal values)
              relweight (relative weight of (-1 comb) / (+1 comb)
                         contributions to the 'convolution'.  In effect,
                         the convolution kernel is a comb consisting of
                         alternating +1 and -weight.)
              nwidth (number of widths to consider)
              nshift (number of shifts to consider for each width)
              minwidth (smallest width to consider)
              maxwidth (largest width to consider)
              &bestwidth (<return> width giving largest score)
              &bestshift (<return> shift giving largest score)
              &bestscore (<optional return> convolution with
                          "Haar"-like comb)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a linear sweep of widths, evaluating at @nshift
          shifts for each width, computing the score from a convolution
          with a long comb, and finding the (width, shift) pair that
          gives the maximum score.  The best width is the "half-wavelength"
          of the signal.
      (2) The convolving function is a comb of alternating values
          +1 and -1 * relweight, separated by the width and phased by
          the shift.  This is similar to a Haar transform, except
          there the convolution is performed with a square wave.
      (3) The function is useful for finding the line spacing
          and strength of line signal from pixel sum projections.
      (4) The score is normalized to the size of nas divided by
          the number of half-widths.  For image applications, the input is
          typically an array of pixel projections, so one should
          normalize by dividing the score by the image width in the
          pixel projection direction.


        """
        args = _convert_params(*args)
        
        return leptonica.numaEvalBestHaarParameters(*args)
    
    

    try:
        leptonica.numaMakeHistogramAuto.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaMakeHistogramAuto.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeHistogramAuto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeHistogramAuto(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxbins')       
  numaMakeHistogramAuto()

      Input:  na (numa of floats; these may be integers)
              maxbins (max number of histogram bins; >= 1)
      Return: na consisiting of histogram of quantized float values,
              or null on error.

  Notes:
      (1) This simple interface is designed for accurate binning
          of both integer and float data.
      (2) If the array data is integers, and the range of integers
          is smaller than @maxbins, they are binned as they fall,
          with binsize = 1.
      (3) If the range of data, (maxval - minval), is larger than
          @maxbins, or if the data is floats, they are binned into
          exactly @maxbins bins.
      (4) Unlike numaMakeHistogram(), these bins in general have
          non-integer location and width, even for integer data.


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeHistogramAuto(*args)
    
    

    try:
        leptonica.numaDiscretizeRankAndIntensity.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaDiscretizeRankAndIntensity.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaDiscretizeRankAndIntensity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDiscretizeRankAndIntensity(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'nbins')       
('NUMA', '**pnarbin')       
('NUMA', '**pnam')       
('NUMA', '**pnar')       
('NUMA', '**pnabb')       
  numaDiscretizeRankAndIntensity()

      Input:  na (normalized histogram of probability density vs intensity)
              nbins (number of bins at which the rank is divided)
              &pnarbin (<optional return> rank bin value vs intensity)
              &pnam (<optional return> median intensity in a bin vs
                     rank bin value, with @nbins of discretized rank values)
              &pnar (<optional return> rank vs intensity; this is
                     a cumulative norm histogram)
              &pnabb (<optional return> intensity at the right bin boundary
                      vs rank bin)
      Return: 0 if OK, 1 on error

  Notes:
      (1) We are inverting the rank(intensity) function to get
          the intensity(rank) function at @nbins equally spaced
          values of rank between 0.0 and 1.0.  We save integer values
          for the intensity.
      (2) We are using the word "intensity" to describe the type of
          array values, but any array of non-negative numbers will work.
      (3) The output arrays give the following mappings, where the
          input is a normalized histogram of array values:
             array values     -->  rank bin number  (narbin)
             rank bin number  -->  median array value in bin (nam)
             array values     -->  cumulative norm = rank  (nar)
             rank bin number  -->  array value at right bin edge (nabb)


        """
        args = _convert_params(*args)
        
        return leptonica.numaDiscretizeRankAndIntensity(*args)
    
    

    try:
        leptonica.numaGetHistogramStatsOnInterval.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetHistogramStatsOnInterval.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetHistogramStatsOnInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetHistogramStatsOnInterval(*args):
        """
        ('NUMA', '*nahisto')       
('l_float32', 'startx')       
('l_float32', 'deltax')       
('l_int32', 'ifirst')       
('l_int32', 'ilast')       
('l_float32', '*pxmean')       
('l_float32', '*pxmedian')       
('l_float32', '*pxmode')       
('l_float32', '*pxvariance')       
  numaGetHistogramStatsOnInterval()

      Input:  nahisto (histogram: y(x(i)), i = 0 ... nbins - 1)
              startx (x value of first bin: x(0))
              deltax (x increment between bins; the bin size; x(1) - x(0))
              ifirst (first bin to use for collecting stats)
              ilast (last bin for collecting stats; use 0 to go to the end)
              &xmean (<optional return> mean value of histogram)
              &xmedian (<optional return> median value of histogram)
              &xmode (<optional return> mode value of histogram:
                     xmode = x(imode), where y(xmode) >= y(x(i)) for
                     all i != imode)
              &xvariance (<optional return> variance of x)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If the histogram represents the relation y(x), the
          computed values that are returned are the x values.
          These are NOT the bucket indices i; they are related to the
          bucket indices by
                x(i) = startx + i * deltax


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetHistogramStatsOnInterval(*args)
    
    

    try:
        leptonica.numaOpen.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaOpen.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaOpen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaOpen(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       
  numaOpen()

      Input:  nas
              size (of sel; greater than 0, odd; origin implicitly in center)
      Return: nad (opened), or null on error

  Notes:
      (1) The structuring element (sel) is linear, all "hits"
      (2) If size == 1, this returns a copy


        """
        args = _convert_params(*args)
        
        return leptonica.numaOpen(*args)
    
    

    try:
        leptonica.numaMakeHistogramClipped.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaMakeHistogramClipped.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeHistogramClipped not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeHistogramClipped(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'binsize')       
('l_float32', 'maxsize')       
  numaMakeHistogramClipped()

      Input:  na
              binsize (typically 1.0)
              maxsize (of histogram ordinate)
      Return: na (histogram of bins of size @binsize, starting with
                  the na[0] (x = 0.0) and going up to a maximum of
                  x = @maxsize, by increments of @binsize), or null on error

  Notes:
      (1) This simple function generates a histogram of values
          from na, discarding all values < 0.0 or greater than
          min(@maxsize, maxval), where maxval is the maximum value in na.
          The histogram data is put in bins of size delx = @binsize,
          starting at x = 0.0.  We use as many bins as are
          needed to hold the data.


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeHistogramClipped(*args)
    
    

    try:
        leptonica.numaGetRankBinValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetRankBinValues.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetRankBinValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetRankBinValues(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'nbins')       
('NUMA', '**pnarbin')       
('NUMA', '**pnam')       
  numaGetRankBinValues()

      Input:  na (just an array of values)
              nbins (number of bins at which the rank is divided)
              &pnarbin (<optional return> rank bin value vs array value)
              &pnam (<optional return> median intensity in a bin vs
                     rank bin value, with @nbins of discretized rank values)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Simple interface for getting a binned rank representation
          of an input array of values.  This returns two mappings:
             array value     -->  rank bin number  (narbin)
             rank bin number -->  median array value in each rank bin (nam)


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetRankBinValues(*args)
    
    

    try:
        leptonica.numaGetStatsUsingHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetStatsUsingHistogram.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetStatsUsingHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetStatsUsingHistogram(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxbins')       
('l_float32', '*pmin')       
('l_float32', '*pmax')       
('l_float32', '*pmean')       
('l_float32', '*pvariance')       
('l_float32', '*pmedian')       
('l_float32', 'rank')       
('l_float32', '*prval')       
('NUMA', '**phisto')       
  numaGetStatsUsingHistogram()

      Input:  na (an arbitrary set of numbers; not ordered and not
                  a histogram)
              maxbins (the maximum number of bins to be allowed in
                       the histogram; use 0 for consecutive integer bins)
              &min (<optional return> min value of set)
              &max (<optional return> max value of set)
              &mean (<optional return> mean value of set)
              &variance (<optional return> variance)
              &median (<optional return> median value of set)
              rank (in [0.0 ... 1.0]; median has a rank 0.5; ignored
                    if &rval == NULL)
              &rval (<optional return> value in na corresponding to @rank)
              &histo (<optional return> Numa histogram; use NULL to prevent)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a simple interface for gathering statistics
          from a numa, where a histogram is used 'under the covers'
          to avoid sorting if a rank value is requested.  In that case,
          by using a histogram we are trading speed for accuracy, because
          the values in @na are quantized to the center of a set of bins.
      (2) If the median, other rank value, or histogram are not requested,
          the calculation is all performed on the input Numa.
      (3) The variance is the average of the square of the
          difference from the mean.  The median is the value in na
          with rank 0.5.
      (4) There are two situations where this gives rank results with
          accuracy comparable to computing stastics directly on the input
          data, without binning into a histogram:
           (a) the data is integers and the range of data is less than
               @maxbins, and
           (b) the data is floats and the range is small compared to
               @maxbins, so that the binsize is much less than 1.
      (5) If a histogram is used and the numbers in the Numa extend
          over a large range, you can limit the required storage by
          specifying the maximum number of bins in the histogram.
          Use @maxbins == 0 to force the bin size to be 1.
      (6) This optionally returns the median and one arbitrary rank value.
          If you need several rank values, return the histogram and use
               numaHistogramGetValFromRank(nah, rank, &rval)
          multiple times.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetStatsUsingHistogram(*args)
    
    

    try:
        leptonica.numaGetHistogramStats.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetHistogramStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaGetHistogramStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetHistogramStats(*args):
        """
        ('NUMA', '*nahisto')       
('l_float32', 'startx')       
('l_float32', 'deltax')       
('l_float32', '*pxmean')       
('l_float32', '*pxmedian')       
('l_float32', '*pxmode')       
('l_float32', '*pxvariance')       
  numaGetHistogramStats()

      Input:  nahisto (histogram: y(x(i)), i = 0 ... nbins - 1)
              startx (x value of first bin: x(0))
              deltax (x increment between bins; the bin size; x(1) - x(0))
              &xmean (<optional return> mean value of histogram)
              &xmedian (<optional return> median value of histogram)
              &xmode (<optional return> mode value of histogram:
                     xmode = x(imode), where y(xmode) >= y(x(i)) for
                     all i != imode)
              &xvariance (<optional return> variance of x)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If the histogram represents the relation y(x), the
          computed values that are returned are the x values.
          These are NOT the bucket indices i; they are related to the
          bucket indices by
                x(i) = startx + i * deltax


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetHistogramStats(*args)
    
    

    try:
        leptonica.numaDilate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaDilate.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaDilate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDilate(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       
  numaDilate()

      Input:  nas
              size (of sel; greater than 0, odd; origin implicitly in center)
      Return: nad (dilated), or null on error

  Notes:
      (1) The structuring element (sel) is linear, all "hits"
      (2) If size == 1, this returns a copy


        """
        args = _convert_params(*args)
        
        return leptonica.numaDilate(*args)
    
    

    try:
        leptonica.numaCrossingsByThreshold.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.numaCrossingsByThreshold.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaCrossingsByThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCrossingsByThreshold(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'thresh')       
  numaCrossingsByThreshold()

      Input:  nax (<optional> numa of abscissa values; can be NULL)
              nay (numa of ordinate values, corresponding to nax)
              thresh (threshold value for nay)
      Return: nad (abscissa pts at threshold), or null on error

  Notes:
      (1) If nax == NULL, we use startx and delx from nay to compute
          the crossing values in nad.


        """
        args = _convert_params(*args)
        
        return leptonica.numaCrossingsByThreshold(*args)
    
    

    try:
        leptonica.numaEarthMoverDistance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaEarthMoverDistance.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaEarthMoverDistance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEarthMoverDistance(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_float32', '*pdist')       
  numaEarthMoverDistance()

      Input:  na1, na2 (two numas of the same size, typically histograms)
              &dist (<return> EM distance)
      Return: 0 if OK, 1 on error

 Notes:
     (1) The two numas must have the same size.  They do not need to be
         normalized to the same sum before applying the function.
     (2) For a 1D discrete function, the implementation of the EMD
         is trivial.  Just keep filling or emptying buckets in one numa
         to match the amount in the other, moving sequentially along
         both arrays.
     (3) We divide the sum of the absolute value of everything moved
         (by 1 unit at a time) by the sum of the numa (amount of "earth")
         to get the average distance that the "earth" was moved.
         Further normalization, by the number of buckets (minus 1),
         gives the distance as a fraction of the maximum possible
         distance, which is n-1.  This fraction is 1.0 for the situation
         where all the 'earth' in the first array is at one end, and
         all in the second array is at the other end.


        """
        args = _convert_params(*args)
        
        return leptonica.numaEarthMoverDistance(*args)
    
    

    try:
        leptonica.numaWindowedVariance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWindowedVariance.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaWindowedVariance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedVariance(*args):
        """
        ('NUMA', '*nam')       
('NUMA', '*nams')       
('NUMA', '**pnav')       
('NUMA', '**pnarv')       
  numaWindowedVariance()

      Input:  nam (windowed mean values)
              nams (windowed mean square values)
              &pnav (<optional return> numa of variance -- the ms deviation
                     from the mean)
              &pnarv (<optional return> numa of rms deviation from the mean)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The numas of windowed mean and mean square are precomputed,
          using numaWindowedMean() and numaWindowedMeanSquare().
      (2) Either or both of the variance and square-root of variance
          are returned, where the variance is the average over the
          window of the mean square difference of the pixel value
          from the mean:
                <(x - <x>)*(x - <x>)> = <x*x> - <x>*<x>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedVariance(*args)
    
    

    try:
        leptonica.numaWindowedStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWindowedStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaWindowedStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedStats(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'wc')       
('NUMA', '**pnam')       
('NUMA', '**pnams')       
('NUMA', '**pnav')       
('NUMA', '**pnarv')       
  numaWindowedStats()

      Input:  nas (input numa)
              wc (half width of the window)
              &nam (<optional return> mean value in window)
              &nams (<optional return> mean square value in window)
              &pnav (<optional return> variance in window)
              &pnarv (<optional return> rms deviation from the mean)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a high-level convenience function for calculating
          any or all of these derived arrays.
      (2) These statistical measures over the values in the
          rectangular window are:
            - average value: <x>  (nam)
            - average squared value: <x*x> (nams)
            - variance: <(x - <x>)*(x - <x>)> = <x*x> - <x>*<x>  (nav)
            - square-root of variance: (narv)
          where the brackets < .. > indicate that the average value is
          to be taken over the window.
      (3) Note that the variance is just the mean square difference from
          the mean value; and the square root of the variance is the
          root mean square difference from the mean, sometimes also
          called the 'standard deviation'.
      (4) Internally, use mirrored borders to handle values near the
          end of each array.


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedStats(*args)
    
    

    try:
        leptonica.numaConvertToInt.argtypes = [ctypes.c_void_p]
        leptonica.numaConvertToInt.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaConvertToInt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToInt(*args):
        """
        ('NUMA', '*nas')       
  numaConvertToInt()

      Input:  na
      Return: na with all values rounded to nearest integer, or
              null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToInt(*args)
    
    

    try:
        leptonica.numaWindowedMeanSquare.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaWindowedMeanSquare.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaWindowedMeanSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedMeanSquare(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'wc')       
  numaWindowedMeanSquare()

      Input:  nas
              wc (half width of the window)
      Return: nad (containing windowed mean square values), or null on error

  Notes:
      (1) The window has width = 2 * @wc + 1.
      (2) We add a mirrored border of size @wc to each end of the array.


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedMeanSquare(*args)
    
    

    try:
        leptonica.numaHistogramGetRankFromVal.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaHistogramGetRankFromVal.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaHistogramGetRankFromVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHistogramGetRankFromVal(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'rval')       
('l_float32', '*prank')       
  numaHistogramGetRankFromVal()

      Input:  na (histogram)
              rval (value of input sample for which we want the rank)
              &rank (<return> fraction of total samples below rval)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If we think of the histogram as a function y(x), normalized
          to 1, for a given input value of x, this computes the
          rank of x, which is the integral of y(x) from the start
          value of x to the input value.
      (2) This function only makes sense when applied to a Numa that
          is a histogram.  The values in the histogram can be ints and
          floats, and are computed as floats.  The rank is returned
          as a float between 0.0 and 1.0.
      (3) The numa parameters startx and binsize are used to
          compute x from the Numa index i.


        """
        args = _convert_params(*args)
        
        return leptonica.numaHistogramGetRankFromVal(*args)
    
    

    try:
        leptonica.numaSplitDistribution.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSplitDistribution.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSplitDistribution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSplitDistribution(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'scorefract')       
('l_int32', '*psplitindex')       
('l_float32', '*pave1')       
('l_float32', '*pave2')       
('l_float32', '*pnum1')       
('l_float32', '*pnum2')       
('NUMA', '**pnascore')       
  numaSplitDistribution()

      Input:  na (histogram)
              scorefract (fraction of the max score, used to determine
                          the range over which the histogram min is searched)
              &splitindex (<optional return> index for splitting)
              &ave1 (<optional return> average of lower distribution)
              &ave2 (<optional return> average of upper distribution)
              &num1 (<optional return> population of lower distribution)
              &num2 (<optional return> population of upper distribution)
              &nascore (<optional return> for debugging; otherwise use null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function is intended to be used on a distribution of
          values that represent two sets, such as a histogram of
          pixel values for an image with a fg and bg, and the goal
          is to determine the averages of the two sets and the
          best splitting point.
      (2) The Otsu method finds a split point that divides the distribution
          into two parts by maximizing a score function that is the
          product of two terms:
            (a) the square of the difference of centroids, (ave1 - ave2)^2
            (b) fract1 * (1 - fract1)
          where fract1 is the fraction in the lower distribution.
      (3) This works well for images where the fg and bg are
          each relatively homogeneous and well-separated in color.
          However, if the actual fg and bg sets are very different
          in size, and the bg is highly varied, as can occur in some
          scanned document images, this will bias the split point
          into the larger "bump" (i.e., toward the point where the
          (b) term reaches its maximum of 0.25 at fract1 = 0.5.
          To avoid this, we define a range of values near the
          maximum of the score function, and choose the value within
          this range such that the histogram itself has a minimum value.
          The range is determined by scorefract: we include all abscissa
          values to the left and right of the value that maximizes the
          score, such that the score stays above (1 - scorefract) * maxscore.
          The intuition behind this modification is to try to find
          a split point that both has a high variance score and is
          at or near a minimum in the histogram, so that the histogram
          slope is small at the split point.
      (4) We normalize the score so that if the two distributions
          were of equal size and at opposite ends of the numa, the
          score would be 1.0.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSplitDistribution(*args)
    
    

    try:
        leptonica.numaEvalHaarSum.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaEvalHaarSum.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaEvalHaarSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEvalHaarSum(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'width')       
('l_float32', 'shift')       
('l_float32', 'relweight')       
('l_float32', '*pscore')       
  numaEvalHaarSum()

      Input:  nas (numa of non-negative signal values)
              width (distance between +1 and -1 in convolution comb)
              shift (phase of the comb: location of first +1)
              relweight (relative weight of (-1 comb) / (+1 comb)
                         contributions to the 'convolution'.  In effect,
                         the convolution kernel is a comb consisting of
                         alternating +1 and -weight.)
              &score (<return> convolution with "Haar"-like comb)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a convolution with a comb of alternating values
          +1 and -relweight, separated by the width and phased by the shift.
          This is similar to a Haar transform, except that for Haar,
            (1) the convolution kernel is symmetric about 0, so the
                relweight is 1.0, and
            (2) the convolution is performed with a square wave.
      (2) The score is normalized to the size of nas divided by
          twice the "width".  For image applications, the input is
          typically an array of pixel projections, so one should
          normalize by dividing the score by the image width in the
          pixel projection direction.
      (3) To get a Haar-like result, use relweight = 1.0.  For detecting
          signals where you expect every other sample to be close to
          zero, as with barcodes or filtered text lines, you can
          use relweight > 1.0.


        """
        args = _convert_params(*args)
        
        return leptonica.numaEvalHaarSum(*args)
    
    

    try:
        leptonica.numaHistogramGetValFromRank.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaHistogramGetValFromRank.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaHistogramGetValFromRank not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHistogramGetValFromRank(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'rank')       
('l_float32', '*prval')       
  numaHistogramGetValFromRank()

      Input:  na (histogram)
              rank (fraction of total samples)
              &rval (<return> approx. to the bin value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If we think of the histogram as a function y(x), this returns
          the value x such that the integral of y(x) from the start
          value to x gives the fraction 'rank' of the integral
          of y(x) over all bins.
      (2) This function only makes sense when applied to a Numa that
          is a histogram.  The values in the histogram can be ints and
          floats, and are computed as floats.  The val is returned
          as a float, even though the buckets are of integer width.
      (3) The numa parameters startx and binsize are used to
          compute x from the Numa index i.


        """
        args = _convert_params(*args)
        
        return leptonica.numaHistogramGetValFromRank(*args)
    
    

    try:
        leptonica.numaFindPeaks.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.numaFindPeaks.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaFindPeaks not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFindPeaks(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'nmax')       
('l_float32', 'fract1')       
('l_float32', 'fract2')       
  numaFindPeaks()

      Input:  source na
              max number of peaks to be found
              fract1  (min fraction of peak value)
              fract2  (min slope)
      Return: peak na, or null on error.

 Notes:
     (1) The returned na consists of sets of four numbers representing
         the peak, in the following order:
            left edge; peak center; right edge; normalized peak area


        """
        args = _convert_params(*args)
        
        return leptonica.numaFindPeaks(*args)
    
    

    try:
        leptonica.numaTransform.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaTransform.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaTransform(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'shift')       
('l_float32', 'scale')       
  numaTransform()

      Input:  nas
              shift (add this to each number)
              scale (multiply each number by this)
      Return: nad (with all values shifted and scaled, or null on error)

  Notes:
      (1) Each number is shifted before scaling.
      (2) The operation sequence is opposite to that for Box and Pta:
          scale first, then shift.


        """
        args = _convert_params(*args)
        
        return leptonica.numaTransform(*args)
    
    

    try:
        leptonica.numaWindowedMean.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaWindowedMean.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaWindowedMean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedMean(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'wc')       
  numaWindowedMean()

      Input:  nas
              wc (half width of the convolution window)
      Return: nad (after low-pass filtering), or null on error

  Notes:
      (1) This is a convolution.  The window has width = 2 * @wc + 1.
      (2) We add a mirrored border of size @wc to each end of the array.


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedMean(*args)
    
    

    try:
        leptonica.numaFindExtrema.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.numaFindExtrema.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaFindExtrema not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFindExtrema(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'delta')       
  numaFindExtrema()

      Input:  nas (input values)
              delta (relative amount to resolve peaks and valleys)
      Return: nad (locations of extrema), or null on error

  Notes:
      (1) This returns a sequence of extrema (peaks and valleys).
      (2) The algorithm is analogous to that for determining
          mountain peaks.  Suppose we have a local peak, with
          bumps on the side.  Under what conditions can we consider
          those 'bumps' to be actual peaks?  The answer: if the
          bump is separated from the peak by a saddle that is at
          least 500 feet below the bump.
      (3) Operationally, suppose we are looking for a peak.
          We are keeping the largest value we've seen since the
          last valley, and are looking for a value that is delta
          BELOW our current peak.  When we find such a value,
          we label the peak, use the current value to label the
          valley, and then do the same operation in reverse (looking
          for a valley).


        """
        args = _convert_params(*args)
        
        return leptonica.numaFindExtrema(*args)
    
    

    try:
        leptonica.numaSelectCrossingThreshold.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaSelectCrossingThreshold.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaSelectCrossingThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSelectCrossingThreshold(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'estthresh')       
('l_float32', '*pbestthresh')       
  numaSelectCrossingThreshold()

      Input:  nax (<optional> numa of abscissa values; can be NULL)
              nay (signal)
              estthresh (estimated pixel threshold for crossing: e.g., for
                         images, white <--> black; typ. ~120)
              &bestthresh (<return> robust estimate of threshold to use)
      Return: 0 if OK, 1 on error

  Note:
     (1) When a valid threshold is used, the number of crossings is
         a maximum, because none are missed.  If no threshold intersects
         all the crossings, the crossings must be determined with
         numaCrossingsByPeaks().
     (2) @estthresh is an input estimate of the threshold that should
         be used.  We compute the crossings with 41 thresholds
         (20 below and 20 above).  There is a range in which the
         number of crossings is a maximum.  Return a threshold
         in the center of this stable plateau of crossings.
         This can then be used with numaCrossingsByThreshold()
         to get a good estimate of crossing locations.


        """
        args = _convert_params(*args)
        
        return leptonica.numaSelectCrossingThreshold(*args)
    
    

    try:
        leptonica.numaMakeHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaMakeHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaMakeHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeHistogram(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxbins')       
('l_int32', '*pbinsize')       
('l_int32', '*pbinstart')       
  numaMakeHistogram()

      Input:  na
              maxbins (max number of histogram bins)
              &binsize  (<return> size of histogram bins)
              &binstart (<optional return> start val of minimum bin;
                         input NULL to force start at 0)
      Return: na consisiting of histogram of integerized values,
              or null on error.

  Note:
      (1) This simple interface is designed for integer data.
          The bins are of integer width and start on integer boundaries,
          so the results on float data will not have high precision.
      (2) Specify the max number of input bins.   Then @binsize,
          the size of bins necessary to accommodate the input data,
          is returned.  It is one of the sequence:
                {1, 2, 5, 10, 20, 50, ...}.
      (3) If &binstart is given, all values are accommodated,
          and the min value of the starting bin is returned.
          Otherwise, all negative values are discarded and
          the histogram bins start at 0.


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeHistogram(*args)
    
    

    try:
        leptonica.numaMakeRankFromHistogram.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaMakeRankFromHistogram.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaMakeRankFromHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeRankFromHistogram(*args):
        """
        ('l_float32', 'startx')       
('l_float32', 'deltax')       
('NUMA', '*nasy')       
('l_int32', 'npts')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       
  numaMakeRankFromHistogram()

      Input:  startx (xval corresponding to first element in nay)
              deltax (x increment between array elements in nay)
              nasy (input histogram, assumed equally spaced)
              npts (number of points to evaluate rank function)
              &nax (<optional return> array of x values in range)
              &nay (<return> rank array of specified npts)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeRankFromHistogram(*args)
    




class gplot(object):
    """  gplot.c

     Basic plotting functions
          GPLOT      *gplotCreate()
          void        gplotDestroy()
          l_int32     gplotAddPlot()
          l_int32     gplotSetScaling()
          l_int32     gplotMakeOutput()
          l_int32     gplotGenCommandFile()
          l_int32     gplotGenDataFiles()

     Quick and dirty plots
          l_int32     gplotSimple1()
          l_int32     gplotSimple2()
          l_int32     gplotSimpleN()
          l_int32     gplotSimpleXY1()
          l_int32     gplotSimpleXY2()
          l_int32     gplotSimpleXYN()

     Serialize for I/O
          GPLOT      *gplotRead()
          l_int32     gplotWrite()


     Utility for programmatic plotting using gnuplot 7.3.2 or later
     Enabled:
         - output to png (color), ps (mono), x11 (color), latex (mono)
         - optional title for graph
         - optional x and y axis labels
         - multiple plots on one frame
         - optional title for each plot on the frame
         - optional log scaling on either or both axes
         - choice of 5 plot styles for each plot
         - choice of 2 plot modes, either using one input array
           (Y vs index) or two input arrays (Y vs X).  This
           choice is made implicitly depending on the number of
           input arrays.

     Usage:
         gplotCreate() initializes for plotting
         gplotAddPlot() for each plot on the frame
         gplotMakeOutput() to generate all output files and run gnuplot
         gplotDestroy() to clean up

     Example of use:
         gplot = gplotCreate("tempskew", GPLOT_PNG, "Skew score vs angle",
                    "angle (deg)", "score");
         gplotAddPlot(gplot, natheta, nascore1, GPLOT_LINES, "plot 1");
         gplotAddPlot(gplot, natheta, nascore2, GPLOT_POINTS, "plot 2");
         gplotSetScaling(gplot, GPLOT_LOG_SCALE_Y);
         gplotMakeOutput(gplot);
         gplotDestroy(&gplot);

     Note for output to GPLOT_LATEX:
         This creates latex output of the plot, named <rootname>.tex.
         It needs to be placed in a latex file <latexname>.tex
         that precedes the plot output with, at a minimum:
           \documentclass{article}
           \begin{document}
         and ends with
           \end{document}
         You can then generate a dvi file <latexname>.dvi using
           latex <latexname>.tex
         and a PostScript file <psname>.ps from that using
           dvips -o <psname>.ps <latexname>.dvi

     N.B. To generate plots, it is necessary to have gnuplot installed on
          your Unix system, or wgnuplot on Windows.

"""
    
    try:
        leptonica.gplotSimpleN.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotSimpleN.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSimpleN not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleN(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       
  gplotSimpleN()

      Input:  naa (numaa; we plotted with Y_VS_I for each numa)
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              outroot (root of output files)
              title (<optional>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives a line plot of all numas in a numaa (array of numa),
          where the array values are each plotted vs the array index.
          The plot is generated in the specified output format;
          the title  is optional.
      (2) When calling these simple plot functions more than once, use
          different @outroot to avoid overwriting the output files.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleN(*args)
    
    

    try:
        leptonica.gplotAddPlot.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.gplotAddPlot.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotAddPlot not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotAddPlot(*args):
        """
        ('GPLOT', '*gplot')       
('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'plotstyle')       
('const char', '*plottitle')       
  gplotAddPlot()

      Input:  gplot
              nax (<optional> numa: set to null for Y_VS_I;
                   required for Y_VS_X)
              nay (numa: required for both Y_VS_I and Y_VS_X)
              plotstyle (GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
                         GPLOT_LINESPOINTS, GPLOT_DOTS)
              plottitle  (<optional> title for individual plot)
      Return: 0 if OK, 1 on error

  Notes:
      (1) There are 2 options for (x,y) values:
            o  To plot an array vs a linear function of the
               index, set nax = NULL.
            o  To plot one array vs another, use both nax and nay.
      (2) If nax is NULL, the x value corresponding to the i-th
          value of nay is found from the startx and delx fields
          in nay:
               x = startx + i * delx
          These are set with numaSetParameters().  Their default
          values are startx = 0.0, delx = 1.0.
      (3) If nax is defined, it must be the same size as nay.
      (4) The 'plottitle' string can have spaces, double
          quotes and backquotes, but not single quotes.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotAddPlot(*args)
    
    

    try:
        leptonica.gplotGenCommandFile.argtypes = [ctypes.c_void_p]
        leptonica.gplotGenCommandFile.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotGenCommandFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGenCommandFile(*args):
        """
        ('GPLOT', '*gplot')       
  gplotGenCommandFile()

      Input:  gplot
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGenCommandFile(*args)
    
    

    try:
        leptonica.gplotRead.argtypes = [ctypes.c_void_p]
        leptonica.gplotRead.restype = lambda address: GPLOT(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function gplotRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotRead(*args):
        """
        ('const char', '*filename')       
  gplotRead()

      Input:  filename
      Return: gplot, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotRead(*args)
    
    

    try:
        leptonica.gplotMakeOutput.argtypes = [ctypes.c_void_p]
        leptonica.gplotMakeOutput.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotMakeOutput not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotMakeOutput(*args):
        """
        ('GPLOT', '*gplot')       
  gplotMakeOutput()

      Input:  gplot
      Return: 0 if OK; 1 on error

  Notes:
      (1) This uses gplot and the new arrays to add a plot
          to the output, by writing a new data file and appending
          the appropriate plot commands to the command file.
      (2) This is the only function in this file that requires the
          gnuplot executable, to actually generate the plot.
      (3) The gnuplot program for windows is wgnuplot.exe.  The
          standard gp426win32 distribution does not have a X11 terminal.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotMakeOutput(*args)
    
    

    try:
        leptonica.gplotCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotCreate.restype = lambda address: GPLOT(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function gplotCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotCreate(*args):
        """
        ('const char', '*rootname')       
('l_int32', 'outformat')       
('const char', '*title')       
('const char', '*xlabel')       
('const char', '*ylabel')       
  gplotCreate()

      Input:  rootname (root for all output files)
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              title  (<optional> overall title)
              xlabel (<optional> x axis label)
              ylabel (<optional> y axis label)
      Return: gplot, or null on error

  Notes:
      (1) This initializes the plot.
      (2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
          double quotes and backquotes, but not single quotes.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotCreate(*args)
    
    

    try:
        leptonica.gplotSimpleXY1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotSimpleXY1.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSimpleXY1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleXY1(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       
  gplotSimpleXY1()

      Input:  nax (<optional>)
              nay
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              outroot (root of output files)
              title  (<optional>, can be NULL)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives a line plot of a @nay vs @nax, generated in
          the specified output format.  The title is optional.
      (2) @nax is optional.  If NULL, @nay is plotted against
          the array index.
      (3) When calling these simple plot functions more than once, use
          different @outroot to avoid overwriting the output files.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleXY1(*args)
    
    

    try:
        leptonica.gplotSetScaling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.gplotSetScaling.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSetScaling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSetScaling(*args):
        """
        ('GPLOT', '*gplot')       
('l_int32', 'scaling')       
  gplotSetScaling()

      Input:  gplot
              scaling (GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X,
                       GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y)
      Return: 0 if OK; 1 on error

  Notes:
      (1) By default, the x and y axis scaling is linear.
      (2) Call this function to set semi-log or log-log scaling.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSetScaling(*args)
    
    

    try:
        leptonica.gplotSimpleXY2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotSimpleXY2.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSimpleXY2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleXY2(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay1')       
('NUMA', '*nay2')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       
  gplotSimpleXY2()

      Input:  nax (<optional; can be NULL)
              nay1
              nay2
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              outroot (root of output files)
              title  (<optional>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives line plots of @nay1 and @nay2 against nax, generated
          in the specified output format.  The title is optional.
      (2) @nax is optional.  If NULL, @nay1 and @nay2 are plotted
          against the array index.
      (3) When calling these simple plot functions more than once, use
          different @outroot to avoid overwriting the output files.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleXY2(*args)
    
    

    try:
        leptonica.gplotSimpleXYN.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotSimpleXYN.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSimpleXYN not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleXYN(*args):
        """
        ('NUMA', '*nax')       
('NUMAA', '*naay')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       
  gplotSimpleXYN()

      Input:  nax (<optional>; can be NULL)
              naay (numaa of arrays to plot against @nax)
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              outroot (root of output files)
              title (<optional>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives line plots of each Numa in @naa against nax,
          generated in the specified output format.  The title is optional.
      (2) @nax is optional.  If NULL, each Numa array is plotted against
          the array index.
      (3) When calling these simple plot functions more than once, use
          different @outroot to avoid overwriting the output files.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleXYN(*args)
    
    

    try:
        leptonica.gplotDestroy.argtypes = [ctypes.c_void_p]
        leptonica.gplotDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function gplotDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotDestroy(*args):
        """
        ('GPLOT', '**pgplot')       
   gplotDestroy()

        Input: &gplot (<to be nulled>)
        Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.gplotDestroy(*args)
    
    

    try:
        leptonica.gplotGenDataFiles.argtypes = [ctypes.c_void_p]
        leptonica.gplotGenDataFiles.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotGenDataFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGenDataFiles(*args):
        """
        ('GPLOT', '*gplot')       
  gplotGenDataFiles()

      Input:  gplot
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGenDataFiles(*args)
    
    

    try:
        leptonica.gplotSimple1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotSimple1.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSimple1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimple1(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       
  gplotSimple1()

      Input:  na (numa; plot Y_VS_I)
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              outroot (root of output files)
              title  (<optional>, can be NULL)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives a line plot of a numa, where the array value
          is plotted vs the array index.  The plot is generated
          in the specified output format; the title  is optional.
      (2) When calling these simple plot functions more than once, use
          different @outroot to avoid overwriting the output files.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimple1(*args)
    
    

    try:
        leptonica.gplotSimple2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotSimple2.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotSimple2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimple2(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       
  gplotSimple2()

      Input:  na1 (numa; plotted with Y_VS_I)
              na2 (ditto)
              outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                         GPLOT_LATEX)
              outroot (root of output files)
              title  (<optional>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives a line plot of two numa, where the array values
          are each plotted vs the array index.  The plot is generated
          in the specified output format; the title  is optional.
      (2) When calling these simple plot functions more than once, use
          different @outroot to avoid overwriting the output files.


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimple2(*args)
    
    

    try:
        leptonica.gplotWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.gplotWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gplotWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotWrite(*args):
        """
        ('const char', '*filename')       
('GPLOT', '*gplot')       
  gplotWrite()

      Input:  filename
              gplot
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotWrite(*args)
    




class colorseg(object):
    """  colorseg.c

    Unsupervised color segmentation

               PIX     *pixColorSegment()
               PIX     *pixColorSegmentCluster()
       static  l_int32  pixColorSegmentTryCluster()
               l_int32  pixAssignToNearestColor()
               l_int32  pixColorSegmentClean()
               l_int32  pixColorSegmentRemoveColors()

"""
    
    try:
        leptonica.pixColorSegment.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorSegment.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorSegment not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegment(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxdist')       
('l_int32', 'maxcolors')       
('l_int32', 'selsize')       
('l_int32', 'finalcolors')       
  pixColorSegment()

      Input:  pixs  (32 bpp; 24-bit color)
              maxdist (max euclidean dist to existing cluster)
              maxcolors (max number of colors allowed in first pass)
              selsize (linear size of sel for closing to remove noise)
              finalcolors (max number of final colors allowed after 4th pass)
      Return: pixd (8 bit with colormap), or null on error

  Color segmentation proceeds in four phases:

  Phase 1:  pixColorSegmentCluster()
  The image is traversed in raster order.  Each pixel either
  becomes the representative for a new cluster or is assigned to an
  existing cluster.  Assignment is greedy.  The data is stored in
  a colormapped image.  Three auxiliary arrays are used to hold
  the colors of the representative pixels, for fast lookup.
  The average color in each cluster is computed.

  Phase 2.  pixAssignToNearestColor()
  A second (non-greedy) clustering pass is performed, where each pixel
  is assigned to the nearest cluster (average).  We also keep track
  of how many pixels are assigned to each cluster.

  Phase 3.  pixColorSegmentClean()
  For each cluster, starting with the largest, do a morphological
  closing to eliminate small components within larger ones.

  Phase 4.  pixColorSegmentRemoveColors()
  Eliminate all colors except the most populated 'finalcolors'.
  Then remove unused colors from the colormap, and reassign those
  pixels to the nearest remaining cluster, using the original pixel values.

  Notes:
      (1) The goal is to generate a small number of colors.
          Typically this would be specified by 'finalcolors',
          a number that would be somewhere between 3 and 6.
          The parameter 'maxcolors' specifies the maximum number of
          colors generated in the first phase.  This should be
          larger than finalcolors, perhaps twice as large.
          If more than 'maxcolors' are generated in the first phase
          using the input 'maxdist', the distance is repeatedly
          increased by a multiplicative factor until the condition
          is satisfied.  The implicit relation between 'maxdist'
          and 'maxcolors' is thus adjusted programmatically.
      (2) As a very rough guideline, given a target value of 'finalcolors',
          here are approximate values of 'maxdist' and 'maxcolors'
          to start with:

               finalcolors    maxcolors    maxdist
               -----------    ---------    -------
                   3             6          100
                   4             8           90
                   5            10           75
                   6            12           60

          For a given number of finalcolors, if you use too many
          maxcolors, the result will be noisy.  If you use too few,
          the result will be a relatively poor assignment of colors.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegment(*args)
    
    

    try:
        leptonica.pixColorSegmentCluster.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorSegmentCluster.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorSegmentCluster not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegmentCluster(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxdist')       
('l_int32', 'maxcolors')       
  pixColorSegmentCluster()

      Input:  pixs  (32 bpp; 24-bit color)
              maxdist (max euclidean dist to existing cluster)
              maxcolors (max number of colors allowed in first pass)
      Return: pixd (8 bit with colormap), or null on error

  Notes:
      (1) This is phase 1.  See description in pixColorSegment().
      (2) Greedy unsupervised classification.  If the limit 'maxcolors'
          is exceeded, the computation is repeated with a larger
          allowed cluster size.
      (3) On each successive iteration, 'maxdist' is increased by a
          constant factor.  See comments in pixColorSegment() for
          a guideline on parameter selection.
          Note that the diagonal of the 8-bit rgb color cube is about
          440, so for 'maxdist' = 440, you are guaranteed to get 1 color!


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegmentCluster(*args)
    
    

    try:
        leptonica.pixColorSegmentRemoveColors.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixColorSegmentRemoveColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorSegmentRemoveColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegmentRemoveColors(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'finalcolors')       
  pixColorSegmentRemoveColors()

      Input:  pixd  (8 bpp, colormapped)
              pixs  (32 bpp rgb, with initial pixel values)
              finalcolors (max number of colors to retain)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This operation is in-place.
      (2) This is phase 4 of color segmentation, and the second part
          of the 2-step noise removal.  Only 'finalcolors' different
          colors are retained, with colors with smaller populations
          being replaced by the nearest color of the remaining colors.
          For highest accuracy, for pixels that are being replaced,
          we find the nearest colormap color  to the original rgb color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegmentRemoveColors(*args)
    
    

    try:
        leptonica.pixColorSegmentClean.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixColorSegmentClean.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorSegmentClean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegmentClean(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'selsize')       
('l_int32', '*countarray')       
  pixColorSegmentClean()

      Input:  pixs  (8 bpp, colormapped)
              selsize (for closing)
              countarray (ptr to array containing the number of pixels
                          found in each color in the colormap)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This operation is in-place.
      (2) This is phase 3 of color segmentation.  It is the first
          part of a two-step noise removal process.  Colors with a
          large population are closed first; this operation absorbs
          small sets of intercolated pixels of a different color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegmentClean(*args)
    
    

    try:
        leptonica.pixAssignToNearestColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAssignToNearestColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAssignToNearestColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAssignToNearestColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'level')       
('l_int32', '*countarray')       
  pixAssignToNearestColor()

      Input:  pixd  (8 bpp, colormapped)
              pixs  (32 bpp; 24-bit color)
              pixm  (<optional> 1 bpp)
              level (of octcube used for finding nearest color in cmap)
              countarray (<optional> ptr to array, in which we can store
                          the number of pixels found in each color in
                          the colormap in pixd)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is used in phase 2 of color segmentation, where pixs
          is the original input image to pixColorSegment(), and
          pixd is the colormapped image returned from
          pixColorSegmentCluster().  It is also used, with a mask,
          in phase 4.
      (2) This is an in-place operation.
      (3) The colormap in pixd is unchanged.
      (4) pixs and pixd must be the same size (w, h).
      (5) The selection mask pixm can be null.  If it exists, it must
          be the same size as pixs and pixd, and only pixels
          corresponding to fg in pixm are assigned.  Set to
          NULL if all pixels in pixd are to be assigned.
      (6) The countarray can be null.  If it exists, it is pre-allocated
          and of a size at least equal to the size of the colormap in pixd.
      (7) This does a best-fit (non-greedy) assignment of pixels to
          existing clusters.  Specifically, it assigns each pixel
          in pixd to the color index in the pixd colormap that has a
          color closest to the corresponding rgb pixel in pixs.
      (8) 'level' is the octcube level used to quickly find the nearest
          color in the colormap for each pixel.  For color segmentation,
          this parameter is set to LEVEL_IN_OCTCUBE.
      (9) We build a mapping table from octcube to colormap index so
          that this function can run in a time (otherwise) independent
          of the number of colors in the colormap.  This avoids a
          brute-force search for the closest colormap color to each
          pixel in the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAssignToNearestColor(*args)
    




class webpio(object):
    """  webpio.c

    Reading WebP
          PIX             *pixReadStreamWebP()
          PIX             *pixReadMemWebP()

    Reading WebP header
          l_int32          readHeaderWebP()
          l_int32          readHeaderMemWebP()

    Writing WebP
          l_int32          pixWriteWebP()  [ special top level ]
          l_int32          pixWriteStreamWebP()
          l_int32          pixWriteMemWebP()

"""
    
    try:
        leptonica.pixWriteMemWebP.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteMemWebP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemWebP(*args):
        """
        ('l_uint8', '**pencdata')       
('size_t', '*pencsize')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'lossless')       
  pixWriteMemWebP()

      Input:  &encdata (<return> webp encoded data of pixs)
              &encsize (<return> size of webp encoded data)
              pixs (any depth, cmapped OK)
              quality (0 - 100; default ~80)
              lossless (use 1 for lossless; 0 for lossy)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Lossless and lossy encoding are entirely different in webp.
          @quality applies to lossy, and is ignored for lossless.
      (2) The input image is converted to RGB if necessary.  If spp == 3,
          we set the alpha channel to fully opaque (255), and
          WebPEncodeRGBA() then removes the alpha chunk when encoding,
          setting the internal header field has_alpha to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemWebP(*args)
    
    

    try:
        leptonica.pixWriteStreamWebP.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteStreamWebP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamWebP(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'lossless')       
  pixWriteStreampWebP()

      Input:  stream
              pixs  (all depths)
              quality (0 - 100; default ~80)
              lossless (use 1 for lossless; 0 for lossy)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixWriteMemWebP() for details.
      (2) Use 'free', and not leptonica's 'FREE', for all heap data
          that is returned from the WebP library.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamWebP(*args)
    
    

    try:
        leptonica.readHeaderWebP.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderWebP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderWebP(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
  readHeaderWebP()

      Input:  filename
              &w (<return> width)
              &h (<return> height)
              &spp (<return> spp (3 or 4))
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderWebP(*args)
    
    

    try:
        leptonica.readHeaderMemWebP.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemWebP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderMemWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemWebP(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
  readHeaderMemWebP()

      Input:  data
              size (100 bytes is sufficient)
              &w (<return> width)
              &h (<return> height)
              &spp (<return> spp (3 or 4))
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemWebP(*args)
    
    

    try:
        leptonica.pixReadStreamWebP.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamWebP.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamWebP(*args):
        """
        ('FILE', '*fp')       
  pixReadStreamWebP()

      Input:  stream corresponding to WebP image
      Return: pix (32 bpp), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamWebP(*args)
    
    

    try:
        leptonica.pixReadMemWebP.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemWebP.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemWebP(*args):
        """
        ('const l_uint8', '*filedata')       
('size_t', 'filesize')       
  pixReadMemWebP()

      Input:  filedata (webp compressed data in memory)
              filesize (number of bytes in data)
      Return: pix (32 bpp), or null on error

  Notes:
      (1) When the encoded data only has 3 channels (no alpha),
          WebPDecodeRGBAInto() generates a raster of 32-bit pixels, with
          the alpha channel set to opaque (255).
      (2) We don't need to use the gnu runtime functions like fmemopen()
          for redirecting data from a stream to memory, because
          the webp library has been written with memory-to-memory
          functions at the lowest level (which is good!).  And, in
          any event, fmemopen() doesn't work with l_binaryReadStream().


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemWebP(*args)
    
    

    try:
        leptonica.pixWriteWebP.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteWebP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteWebP(*args):
        """
        ('const char', '*filename')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'lossless')       
  pixWriteWebP()

      Input:  filename
              pixs
              quality (0 - 100; default ~80)
              lossless (use 1 for lossless; 0 for lossy)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Special top-level function allowing specification of quality.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteWebP(*args)
    




class affine(object):
    """  affine.c

      Affine (3 pt) image transformation using a sampled
      (to nearest integer) transform on each dest point
           PIX        *pixAffineSampledPta()
           PIX        *pixAffineSampled()

      Affine (3 pt) image transformation using interpolation
      (or area mapping) for anti-aliasing images that are
      2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
           PIX        *pixAffinePta()
           PIX        *pixAffine()
           PIX        *pixAffinePtaColor()
           PIX        *pixAffineColor()
           PIX        *pixAffinePtaGray()
           PIX        *pixAffineGray()

      Affine transform including alpha (blend) component
           PIX        *pixAffinePtaWithAlpha()

      Affine coordinate transformation
           l_int32     getAffineXformCoeffs()
           l_int32     affineInvertXform()
           l_int32     affineXformSampledPt()
           l_int32     affineXformPt()

      Interpolation helper functions
           l_int32     linearInterpolatePixelGray()
           l_int32     linearInterpolatePixelColor()

      Gauss-jordan linear equation solver
           l_int32     gaussjordan()

      Affine image transformation using a sequence of
      shear/scale/translation operations
           PIX        *pixAffineSequential()

      One can define a coordinate space by the location of the origin,
      the orientation of x and y axes, and the unit scaling along
      each axis.  An affine transform is a general linear
      transformation from one coordinate space to another.

      For the general case, we can define the affine transform using
      two sets of three (noncollinear) points in a plane.  One set
      corresponds to the input (src) coordinate space; the other to the
      transformed (dest) coordinate space.  Each point in the
      src corresponds to one of the points in the dest.  With two
      sets of three points, we get a set of 6 equations in 6 unknowns
      that specifies the mapping between the coordinate spaces.
      The interface here allows you to specify either the corresponding
      sets of 3 points, or the transform itself (as a vector of 6
      coefficients).

      Given the transform as a vector of 6 coefficients, we can compute
      both a a pointwise affine coordinate transformation and an
      affine image transformation.

      To compute the coordinate transform, we need the coordinate
      value (x',y') in the transformed space for any point (x,y)
      in the original space.  To derive this transform from the
      three corresponding points, it is convenient to express the affine
      coordinate transformation using an LU decomposition of
      a set of six linear equations that express the six coordinates
      of the three points in the transformed space as a function of
      the six coordinates in the original space.  Once we have
      this transform matrix , we can transform an image by
      finding, for each destination pixel, the pixel (or pixels)
      in the source that give rise to it.

      This 'pointwise' transformation can be done either by sampling
      and picking a single pixel in the src to replicate into the dest,
      or by interpolating (or averaging) over four src pixels to
      determine the value of the dest pixel.  The first method is
      implemented by pixAffineSampled() and the second method by
      pixAffine().  The interpolated method can only be used for
      images with more than 1 bpp, but for these, the image quality
      is significantly better than the sampled method, due to
      the 'antialiasing' effect of weighting the src pixels.

      Interpolation works well when there is relatively little scaling,
      or if there is image expansion in general.  However, if there
      is significant image reduction, one should apply a low-pass
      filter before subsampling to avoid aliasing the high frequencies.

      A typical application might be to align two images, which
      may be scaled, rotated and translated versions of each other.
      Through some pre-processing, three corresponding points are
      located in each of the two images.  One of the images is
      then to be (affine) transformed to align with the other.
      As mentioned, the standard way to do this is to use three
      sets of points, compute the 6 transformation coefficients
      from these points that describe the linear transformation,

          x' = ax + by + c
          y' = dx + ey + f

      and use this in a pointwise manner to transform the image.

      N.B.  Be sure to see the comment in getAffineXformCoeffs(),
      regarding using the inverse of the affine transform for points
      to transform images.

      There is another way to do this transformation; namely,
      by doing a sequence of simple affine transforms, without
      computing directly the affine coordinate transformation.
      We have at our disposal (1) translations (using rasterop),
      (2) horizontal and vertical shear about any horizontal and vertical
      line, respectively, and (3) non-isotropic scaling by two
      arbitrary x and y scaling factors.  We also have rotation
      about an arbitrary point, but this is equivalent to a set
      of three shears so we do not need to use it.

      Why might we do this?  For binary images, it is usually
      more efficient to do such transformations by a sequence
      of word parallel operations.  Shear and translation can be
      done in-place and word parallel; arbitrary scaling is
      mostly pixel-wise.

      Suppose that we are tranforming image 1 to correspond to image 2.
      We have a set of three points, describing the coordinate space
      embedded in image 1, and we need to transform image 1 until
      those three points exactly correspond to the new coordinate space
      defined by the second set of three points.  In our image
      matching application, the latter set of three points was
      found to be the corresponding points in image 2.

      The most elegant way I can think of to do such a sequential
      implementation is to imagine that we're going to transform
      BOTH images until they're aligned.  (We don't really want
      to transform both, because in fact we may only have one image
      that is undergoing a general affine transformation.)

      Choose the 3 corresponding points as follows:
         - The 1st point is an origin
         - The 2nd point gives the orientation and scaling of the
           "x" axis with respect to the origin
         - The 3rd point does likewise for the "y" axis.
      These "axes" must not be collinear; otherwise they are
      arbitrary (although some strange things will happen if
      the handedness sweeping through the minimum angle between
      the axes is opposite).

      An important constraint is that we have shear operations
      about an arbitrary horizontal or vertical line, but always
      parallel to the x or y axis.  If we continue to pretend that
      we have an unprimed coordinate space embedded in image 1 and
      a primed coordinate space embedded in image 2, we imagine
      (a) transforming image 1 by horizontal and vertical shears about
      point 1 to align points 3 and 2 along the y and x axes,
      respectively, and (b) transforming image 2 by horizontal and
      vertical shears about point 1' to align points 3' and 2' along
      the y and x axes.  Then we scale image 1 so that the distances
      from 1 to 2 and from 1 to 3 are equal to the distances in
      image 2 from 1' to 2' and from 1' to 3'.  This scaling operation
      leaves the true image origin, at (0,0) invariant, and will in
      general translate point 1.  The original points 1 and 1' will
      typically not coincide in any event, so we must translate
      the origin of image 1, at its current point 1, to the origin
      of image 2 at 1'.  The images should now be aligned.  But
      because we never really transformed image 2 (and image 2 may
      not even exist), we now perform  on image 1 the reverse of
      the shear transforms that we imagined doing on image 2;
      namely, the negative vertical shear followed by the negative
      horizontal shear.  Image 1 should now have its transformed
      unprimed coordinates aligned with the original primed
      coordinates.  In all this, it is only necessary to keep track
      of the shear angles and translations of points during the shears.
      What has been accomplished is a general affine transformation
      on image 1.

      Having described all this, if you are going to use an
      affine transformation in an application, this is what you
      need to know:

          (1) You should NEVER use the sequential method, because
              the image quality for 1 bpp text is much poorer
              (even though it is about 2x faster than the pointwise sampled
              method), and for images with depth greater than 1, it is
              nearly 20x slower than the pointwise sampled method
              and over 10x slower than the pointwise interpolated method!
              The sequential method is given here for purely
              pedagogical reasons.

          (2) For 1 bpp images, use the pointwise sampled function
              pixAffineSampled().  For all other images, the best
              quality results result from using the pointwise
              interpolated function pixAffinePta() or pixAffine();
              the cost is less than a doubling of the computation time
              with respect to the sampled function.  If you use
              interpolation on colormapped images, the colormap will
              be removed, resulting in either a grayscale or color
              image, depending on the values in the colormap.
              If you want to retain the colormap, use pixAffineSampled().

      Typical relative timing of pointwise transforms (sampled = 1.0):
      8 bpp:   sampled        1.0
               interpolated   1.6
      32 bpp:  sampled        1.0
               interpolated   1.8
      Additionally, the computation time/pixel is nearly the same
      for 8 bpp and 32 bpp, for both sampled and interpolated.

"""
    
    try:
        leptonica.pixAffineSequential.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAffineSequential.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffineSequential not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineSequential(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'bw')       
('l_int32', 'bh')       
  pixAffineSequential()

      Input:  pixs
              ptad  (3 pts of final coordinate space)
              ptas  (3 pts of initial coordinate space)
              bw    (pixels of additional border width during computation)
              bh    (pixels of additional border height during computation)
      Return: pixd, or null on error

  Notes:
      (1) The 3 pts must not be collinear.
      (2) The 3 pts must be given in this order:
           - origin
           - a location along the x-axis
           - a location along the y-axis.
      (3) You must guess how much border must be added so that no
          pixels are lost in the transformations from src to
          dest coordinate space.  (This can be calculated but it
          is a lot of work!)  For coordinate spaces that are nearly
          at right angles, on a 300 ppi scanned page, the addition
          of 1000 pixels on each side is usually sufficient.
      (4) This is here for pedagogical reasons.  It is about 3x faster
          on 1 bpp images than pixAffineSampled(), but the results
          on text are much inferior.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineSequential(*args)
    
    

    try:
        leptonica.pixAffinePtaColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixAffinePtaColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffinePtaColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePtaColor(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint32', 'colorval')       
  pixAffinePtaColor()

      Input:  pixs (32 bpp)
              ptad  (3 pts of final coordinate space)
              ptas  (3 pts of initial coordinate space)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePtaColor(*args)
    
    

    try:
        leptonica.pixAffineSampledPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffineSampledPta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffineSampledPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineSampledPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       
  pixAffineSampledPta()

      Input:  pixs (all depths)
              ptad  (3 pts of final coordinate space)
              ptas  (3 pts of initial coordinate space)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary.
      (2) Retains colormap, which you can do for a sampled transform..
      (3) The 3 points must not be collinear.
      (4) The order of the 3 points is arbitrary; however, to compare
          with the sequential transform they must be in these locations
          and in this order: origin, x-axis, y-axis.
      (5) For 1 bpp images, this has much better quality results
          than pixAffineSequential(), particularly for text.
          It is about 3x slower, but does not require additional
          border pixels.  The poor quality of pixAffineSequential()
          is due to repeated quantized transforms.  It is strongly
          recommended that pixAffineSampled() be used for 1 bpp images.
      (6) For 8 or 32 bpp, much better quality is obtained by the
          somewhat slower pixAffinePta().  See that function
          for relative timings between sampled and interpolated.
      (7) To repeat, use of the sequential transform,
          pixAffineSequential(), for any images, is discouraged.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineSampledPta(*args)
    
    

    try:
        leptonica.pixAffineSampled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffineSampled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffineSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineSampled(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       
  pixAffineSampled()

      Input:  pixs (all depths)
              vc  (vector of 6 coefficients for affine transformation)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary.
      (2) Retains colormap, which you can do for a sampled transform..
      (3) For 8 or 32 bpp, much better quality is obtained by the
          somewhat slower pixAffine().  See that function
          for relative timings between sampled and interpolated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineSampled(*args)
    
    

    try:
        leptonica.affineXformSampledPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.affineXformSampledPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function affineXformSampledPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def affineXformSampledPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       
  affineXformSampledPt()

      Input:  vc (vector of 6 coefficients)
              (x, y)  (initial point)
              (&xp, &yp)   (<return> transformed point)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds the nearest pixel coordinates of the transformed point.
      (2) It does not check ptrs for returned data!


        """
        args = _convert_params(*args)
        
        return leptonica.affineXformSampledPt(*args)
    
    

    try:
        leptonica.gaussjordan.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.gaussjordan.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function gaussjordan not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gaussjordan(*args):
        """
        ('l_float32', '**a')       
('l_float32', '*b')       
('l_int32', 'n')       
  gaussjordan()

      Input:  a  (n x n matrix)
              b  (n x 1 right-hand side column vector)
              n  (dimension)
      Return: 0 if ok, 1 on error

  Notes:
      (1) There are two side-effects:
          * The matrix a is transformed to its inverse A
          * The rhs vector b is transformed to the solution x
            of the linear equation ax = b
      (2) The inverse A can then be used to solve the same equation with
          different rhs vectors c by multiplication: x = Ac
      (3) Adapted from "Numerical Recipes in C, Second Edition", 1992,
          pp. 36-41 (gauss-jordan elimination)


        """
        args = _convert_params(*args)
        
        return leptonica.gaussjordan(*args)
    
    

    try:
        leptonica.pixAffineColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixAffineColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffineColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint32', 'colorval')       
  pixAffineColor()

      Input:  pixs (32 bpp)
              vc  (vector of 6 coefficients for affine transformation)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineColor(*args)
    
    

    try:
        leptonica.linearInterpolatePixelColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_uint32, ctypes.c_void_p]
        leptonica.linearInterpolatePixelColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function linearInterpolatePixelColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearInterpolatePixelColor(*args):
        """
        ('l_uint32', '*datas')       
('l_int32', 'wpls')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_uint32', 'colorval')       
('l_uint32', '*pval')       
  linearInterpolatePixelColor()

      Input:  datas (ptr to beginning of image data)
              wpls (32-bit word/line for this data array)
              w, h (of image)
              x, y (floating pt location for evaluation)
              colorval (color brought in from the outside when the
                        input x,y location is outside the image;
                        in 0xrrggbb00 format))
              &val (<return> interpolated color value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a standard linear interpolation function.  It is
          equivalent to area weighting on each component, and
          avoids "jaggies" when rendering sharp edges.


        """
        args = _convert_params(*args)
        
        return leptonica.linearInterpolatePixelColor(*args)
    
    

    try:
        leptonica.pixAffinePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffinePta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffinePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       
  pixAffinePta()

      Input:  pixs (all depths; colormap ok)
              ptad  (3 pts of final coordinate space)
              ptas  (3 pts of initial coordinate space)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary
      (2) Removes any existing colormap, if necessary, before transforming


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePta(*args)
    
    

    try:
        leptonica.affineXformPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.affineXformPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function affineXformPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def affineXformPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pxp')       
('l_float32', '*pyp')       
  affineXformPt()

      Input:  vc (vector of 6 coefficients)
              (x, y)  (initial point)
              (&xp, &yp)   (<return> transformed point)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This computes the floating point location of the transformed point.
      (2) It does not check ptrs for returned data!


        """
        args = _convert_params(*args)
        
        return leptonica.affineXformPt(*args)
    
    

    try:
        leptonica.linearInterpolatePixelGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.linearInterpolatePixelGray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function linearInterpolatePixelGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearInterpolatePixelGray(*args):
        """
        ('l_uint32', '*datas')       
('l_int32', 'wpls')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', 'grayval')       
('l_int32', '*pval')       
  linearInterpolatePixelGray()

      Input:  datas (ptr to beginning of image data)
              wpls (32-bit word/line for this data array)
              w, h (of image)
              x, y (floating pt location for evaluation)
              grayval (color brought in from the outside when the
                       input x,y location is outside the image)
              &val (<return> interpolated gray value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a standard linear interpolation function.  It is
          equivalent to area weighting on each component, and
          avoids "jaggies" when rendering sharp edges.


        """
        args = _convert_params(*args)
        
        return leptonica.linearInterpolatePixelGray(*args)
    
    

    try:
        leptonica.pixAffinePtaGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixAffinePtaGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffinePtaGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePtaGray(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint8', 'grayval')       
  pixAffinePtaGray()

      Input:  pixs (8 bpp)
              ptad  (3 pts of final coordinate space)
              ptas  (3 pts of initial coordinate space)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePtaGray(*args)
    
    

    try:
        leptonica.pixAffine.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffine.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffine(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       
  pixAffine()

      Input:  pixs (all depths; colormap ok)
              vc  (vector of 6 coefficients for affine transformation)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary
      (2) Removes any existing colormap, if necessary, before transforming


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffine(*args)
    
    

    try:
        leptonica.pixAffinePtaWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixAffinePtaWithAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffinePtaWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePtaWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('PIX', '*pixg')       
('l_float32', 'fract')       
('l_int32', 'border')       
  pixAffinePtaWithAlpha()

      Input:  pixs (32 bpp rgb)
              ptad  (3 pts of final coordinate space)
              ptas  (3 pts of initial coordinate space)
              pixg (<optional> 8 bpp, can be null)
              fract (between 0.0 and 1.0, with 0.0 fully transparent
                     and 1.0 fully opaque)
              border (of pixels added to capture transformed source pixels)
      Return: pixd, or null on error

  Notes:
      (1) The alpha channel is transformed separately from pixs,
          and aligns with it, being fully transparent outside the
          boundary of the transformed pixs.  For pixels that are fully
          transparent, a blending function like pixBlendWithGrayMask()
          will give zero weight to corresponding pixels in pixs.
      (2) If pixg is NULL, it is generated as an alpha layer that is
          partially opaque, using @fract.  Otherwise, it is cropped
          to pixs if required and @fract is ignored.  The alpha channel
          in pixs is never used.
      (3) Colormaps are removed.
      (4) When pixs is transformed, it doesn't matter what color is brought
          in because the alpha channel will be transparent (0) there.
      (5) To avoid losing source pixels in the destination, it may be
          necessary to add a border to the source pix before doing
          the affine transformation.  This can be any non-negative number.
      (6) The input @ptad and @ptas are in a coordinate space before
          the border is added.  Internally, we compensate for this
          before doing the affine transform on the image after the border
          is added.
      (7) The default setting for the border values in the alpha channel
          is 0 (transparent) for the outermost ring of pixels and
          (0.5 * fract * 255) for the second ring.  When blended over
          a second image, this
          (a) shrinks the visible image to make a clean overlap edge
              with an image below, and
          (b) softens the edges by weakening the aliasing there.
          Use l_setAlphaMaskBorder() to change these values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePtaWithAlpha(*args)
    
    

    try:
        leptonica.affineInvertXform.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.affineInvertXform.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function affineInvertXform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def affineInvertXform(*args):
        """
        ('l_float32', '*vc')       
('l_float32', '**pvci')       
  affineInvertXform()

      Input:  vc (vector of 6 coefficients)
              *vci (<return> inverted transform)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The 6 affine transform coefficients are the first
          two rows of a 3x3 matrix where the last row has
          only a 1 in the third column.  We invert this
          using gaussjordan(), and select the first 2 rows
          as the coefficients of the inverse affine transform.
      (2) Alternatively, we can find the inverse transform
          coefficients by inverting the 2x2 submatrix,
          and treating the top 2 coefficients in the 3rd column as
          a RHS vector for that 2x2 submatrix.  Then the
          6 inverted transform coefficients are composed of
          the inverted 2x2 submatrix and the negative of the
          transformed RHS vector.  Why is this so?  We have
             Y = AX + R  (2 equations in 6 unknowns)
          Then
             X = A'Y - A'R
          Gauss-jordan solves
             AF = R
          and puts the solution for F, which is A'R,
          into the input R vector.



        """
        args = _convert_params(*args)
        
        return leptonica.affineInvertXform(*args)
    
    

    try:
        leptonica.getAffineXformCoeffs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getAffineXformCoeffs.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getAffineXformCoeffs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getAffineXformCoeffs(*args):
        """
        ('PTA', '*ptas')       
('PTA', '*ptad')       
('l_float32', '**pvc')       
  getAffineXformCoeffs()

      Input:  ptas  (source 3 points; unprimed)
              ptad  (transformed 3 points; primed)
              &vc   (<return> vector of coefficients of transform)
      Return: 0 if OK; 1 on error

  We have a set of six equations, describing the affine
  transformation that takes 3 points (ptas) into 3 other
  points (ptad).  These equations are:

          x1' = c[0]*x1 + c[1]*y1 + c[2]
          y1' = c[3]*x1 + c[4]*y1 + c[5]
          x2' = c[0]*x2 + c[1]*y2 + c[2]
          y2' = c[3]*x2 + c[4]*y2 + c[5]
          x3' = c[0]*x3 + c[1]*y3 + c[2]
          y3' = c[3]*x3 + c[4]*y3 + c[5]

  This can be represented as

          AC = B

  where B and C are column vectors

          B = [ x1' y1' x2' y2' x3' y3' ]
          C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]

  and A is the 6x6 matrix

          x1   y1   1   0    0    0
           0    0   0   x1   y1   1
          x2   y2   1   0    0    0
           0    0   0   x2   y2   1
          x3   y3   1   0    0    0
           0    0   0   x3   y3   1

  These six equations are solved here for the coefficients C.

  These six coefficients can then be used to find the dest
  point (x',y') corresponding to any src point (x,y), according
  to the equations

           x' = c[0]x + c[1]y + c[2]
           y' = c[3]x + c[4]y + c[5]

  that are implemented in affineXformPt().

  !!!!!!!!!!!!!!!!!!   Very important   !!!!!!!!!!!!!!!!!!!!!!

  When the affine transform is composed from a set of simple
  operations such as translation, scaling and rotation,
  it is built in a form to convert from the un-transformed src
  point to the transformed dest point.  However, when an
  affine transform is used on images, it is used in an inverted
  way: it converts from the transformed dest point to the
  un-transformed src point.  So, for example, if you transform
  a boxa using transform A, to transform an image in the same
  way you must use the inverse of A.

  For example, if you transform a boxa with a 3x3 affine matrix
  'mat', the analogous image transformation must use 'matinv':

     boxad = boxaAffineTransform(boxas, mat);
     affineInvertXform(mat, &matinv);
     pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        """
        args = _convert_params(*args)
        
        return leptonica.getAffineXformCoeffs(*args)
    
    

    try:
        leptonica.pixAffineGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixAffineGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAffineGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint8', 'grayval')       
  pixAffineGray()

      Input:  pixs (8 bpp)
              vc  (vector of 6 coefficients for affine transformation)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineGray(*args)
    




class fliphmtgen(object):
    """    fliphmtgen.c

       DWA implementation of hit-miss transforms with auto-generated sels
       for pixOrientDetectDwa() and pixUpDownDetectDwa() in flipdetect.c

            PIX             *pixFlipFHMTGen()
              static l_int32   flipfhmtgen_low()  -- dispatcher
                static void      fhmt_1_0()
                static void      fhmt_1_1()
                static void      fhmt_1_2()
                static void      fhmt_1_3()

       The code (rearranged) was generated by prog/flipselgen.c

"""
    



class viewfiles(object):
    """   viewfiles.c

     Generate smaller images for viewing and write html
        l_int32    pixHtmlViewer()

"""
    
    try:
        leptonica.pixHtmlViewer.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHtmlViewer.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixHtmlViewer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHtmlViewer(*args):
        """
        ('const char', '*dirin')       
('const char', '*dirout')       
('const char', '*rootname')       
('l_int32', 'thumbwidth')       
('l_int32', 'viewwidth')       
('l_int32', 'copyorig')       
  pixHtmlViewer()

      Input:  dirin:  directory of input image files
              dirout: directory for output files
              rootname: root name for output files
              thumbwidth:  width of thumb images
                           (in pixels; use 0 for default)
              viewwidth:  maximum width of view images (no up-scaling)
                           (in pixels; use 0 for default)
              copyorig:  1 to copy originals to dirout; 0 otherwise
      Return: 0 if OK; 1 on error

  Notes:
      (1) The thumb and view reduced images are generated,
          along with two html files:
             <rootname>.html and <rootname>-links.html
      (2) The thumb and view files are named
             <rootname>_thumb_xxx.jpg
             <rootname>_view_xxx.jpg
          With this naming scheme, any number of input directories
          of images can be processed into views and thumbs
          and placed in the same output directory.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHtmlViewer(*args)
    




class pixafunc2(object):
    """   pixafunc2.c

      Pixa Display (render into a pix)
           PIX      *pixaDisplay()
           PIX      *pixaDisplayOnColor()
           PIX      *pixaDisplayRandomCmap()
           PIX      *pixaDisplayLinearly()
           PIX      *pixaDisplayOnLattice()
           PIX      *pixaDisplayUnsplit()
           PIX      *pixaDisplayTiled()
           PIX      *pixaDisplayTiledInRows()
           PIX      *pixaDisplayTiledAndScaled()

      Pixaa Display (render into a pix)
           PIX      *pixaaDisplay()
           PIX      *pixaaDisplayByPixa()
           PIXA     *pixaaDisplayTiledAndScaled()

      Conversion of all pix to specified type (e.g., depth)
           PIXA     *pixaConvertTo1()
           PIXA     *pixaConvertTo8()
           PIXA     *pixaConvertTo8Color()
           PIXA     *pixaConvertTo32()

      Tile N-Up
           l_int32   convertToNUpFiles()
           PIXA     *convertToNUpPixa()

  We give seven methods for displaying a pixa in a pix.
  Some work for 1 bpp input; others for any input depth.
  Some give an output depth that depends on the input depth;
  others give a different output depth or allow you to choose it.
  Some use a boxes to determine where each pix goes; others tile
  onto a regular lattice; yet others tile onto an irregular lattice.

  Here is a brief description of what the pixa display functions do.

    pixaDisplay()
        This uses the boxes to lay out each pix.  It is typically
        used to reconstruct a pix that has been broken into components.
    pixaDisplayOnColor()
        pixaDisplay() with choice of background color
    pixaDisplayRandomCmap()
        This also uses the boxes to lay out each pix.  However, it creates
        a colormapped dest, where each 1 bpp pix is given a randomly
        generated color (up to 256 are used).
    pixaDisplayLinearly()
        This puts each pix, sequentially, in a line, either horizontally
        or vertically.
    pixaDisplayOnLattice()
        This puts each pix, sequentially, onto a regular lattice,
        omitting any pix that are too big for the lattice size.
        This is useful, for example, to store bitmapped fonts,
        where all the characters are stored in a single image.
    pixaDisplayUnsplit()
        This lays out a mosaic of tiles (the pix in the pixa) that
        are all of equal size.  (Don't use this for unequal sized pix!)
        For example, it can be used to invert the action of
        pixaSplitPix().
    pixaDisplayTiled()
        Like pixaDisplayOnLattice(), this places each pix on a regular
        lattice, but here the lattice size is determined by the
        largest component, and no components are omitted.  This is
        dangerous if there are thousands of small components and
        one or more very large one, because the size of the resulting
        pix can be huge!
    pixaDisplayTiledInRows()
        This puts each pix down in a series of rows, where the upper
        edges of each pix in a row are aligned and there is a uniform
        spacing between the pix.  The height of each row is determined
        by the tallest pix that was put in the row.  This function
        is a reasonably efficient way to pack the subimages.
        A boxa of the locations of each input pix is stored in the output.
    pixaDisplayTiledAndScaled()
        This scales each pix to a given width and output depth,
        and then tiles them in rows with a given number placed in
        each row.  This is very useful for presenting a sequence
        of images that can be at different resolutions, but which
        are derived from the same initial image.

"""
    
    try:
        leptonica.convertToNUpPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.convertToNUpPixa.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function convertToNUpPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToNUpPixa(*args):
        """
        ('const char', '*dir')       
('const char', '*substr')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'tw')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('const char', '*fontdir')       
  convertToNUpPixa()

      Input:  dir (full path to directory of images)
              substr (<optional> can be null)
              nx, ny (in [1, ... 50], tiling factors in each direction)
              tw (target width, in pixels; must be >= 20)
              spacing  (between images, and on outside)
              border (width of additional black border on each image;
                      use 0 for no border)
              fontdir (<optional> prints tail of filename with image)
      Return: pixad, or null on error

  Notes:
      (1) See notes for convertToNUpFiles()


        """
        args = _convert_params(*args)
        
        return leptonica.convertToNUpPixa(*args)
    
    

    try:
        leptonica.pixaDisplayLinearly.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaDisplayLinearly.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayLinearly not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayLinearly(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'direction')       
('l_float32', 'scalefactor')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('BOXA', '**pboxa')       
  pixaDisplayLinearly()

      Input:  pixa
              direction (L_HORIZ or L_VERT)
              scalefactor (applied to every pix; use 1.0 for no scaling)
              background (0 for white, 1 for black; this is the color
                 of the spacing between the images)
              spacing  (between images, and on outside)
              border (width of black border added to each image;
                      use 0 for no border)
              &boxa (<optional return> location of images in output pix
      Return: pix of composite images, or null on error

  Notes:
      (1) This puts each pix, sequentially, in a line, either horizontally
          or vertically.
      (2) If any pix has a colormap, all pix are rendered in rgb.
      (3) The boxa gives the location of each image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayLinearly(*args)
    
    

    try:
        leptonica.pixaDisplayTiledInRows.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiledInRows.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayTiledInRows not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledInRows(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'outdepth')       
('l_int32', 'maxwidth')       
('l_float32', 'scalefactor')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       
  pixaDisplayTiledInRows()

      Input:  pixa
              outdepth (output depth: 1, 8 or 32 bpp)
              maxwidth (of output image)
              scalefactor (applied to every pix; use 1.0 for no scaling)
              background (0 for white, 1 for black; this is the color
                 of the spacing between the images)
              spacing  (between images, and on outside)
              border (width of black border added to each image;
                      use 0 for no border)
      Return: pixd (of tiled images), or null on error

  Notes:
      (1) This renders a pixa to a single image file of width not to
          exceed maxwidth, with background color either white or black,
          and with each row tiled such that the top of each pix is
          aligned and separated by 'spacing' from the next one.
          A black border can be added to each pix.
      (2) All pix are converted to outdepth; existing colormaps are removed.
      (3) This does a reasonably spacewise-efficient job of laying
          out the individual pix images into a tiled composite.
      (4) A serialized boxa giving the location in pixd of each input
          pix (without added border) is stored in the text string of pixd.
          This allows, e.g., regeneration of a pixa from pixd, using
          pixaCreateFromBoxa().  If there is no scaling and the depth of
          each input pix in the pixa is the same, this tiling operation
          can be inverted using the boxa (except for loss of text in
          each of the input pix):
            pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0);
            char *boxatxt = pixGetText(pix1);
            boxa1 = boxaReadMem((l_uint8 *)boxatxt, strlen(boxatxt));
            pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledInRows(*args)
    
    

    try:
        leptonica.pixaDisplayTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiled(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'maxwidth')       
('l_int32', 'background')       
('l_int32', 'spacing')       
  pixaDisplayTiled()

      Input:  pixa
              maxwidth (of output image)
              background (0 for white, 1 for black)
              spacing
      Return: pix of tiled images, or null on error

  Notes:
      (1) This renders a pixa to a single image file of width not to
          exceed maxwidth, with background color either white or black,
          and with each subimage spaced on a regular lattice.
      (2) The lattice size is determined from the largest width and height,
          separately, of all pix in the pixa.
      (3) All pix in the pixa must be of equal depth.
      (4) If any pix has a colormap, all pix are rendered in rgb.
      (5) Careful: because no components are omitted, this is
          dangerous if there are thousands of small components and
          one or more very large one, because the size of the
          resulting pix can be huge!


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiled(*args)
    
    

    try:
        leptonica.pixaaDisplayByPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaDisplayByPixa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaDisplayByPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDisplayByPixa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'xspace')       
('l_int32', 'yspace')       
('l_int32', 'maxw')       
  pixaaDisplayByPixa()

      Input:  paa (with pix that may have different depths)
              xspace between pix in pixa
              yspace between pixa
              max width of output pix
      Return: pixd, or null on error

  Notes:
      (1) Displays each pixa on a line (or set of lines),
          in order from top to bottom.  Within each pixa,
          the pix are displayed in order from left to right.
      (2) The sizes and depths of each pix can differ.  The output pix
          has a depth equal to the max depth of all the pix.
      (3) This ignores the boxa of the paa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDisplayByPixa(*args)
    
    

    try:
        leptonica.pixaDisplayOnLattice.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaDisplayOnLattice.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayOnLattice not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayOnLattice(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'cellw')       
('l_int32', 'cellh')       
('l_int32', '*pncols')       
('BOXA', '**pboxa')       
  pixaDisplayOnLattice()

      Input:  pixa
              cellw (lattice cell width)
              cellh (lattice cell height)
              &ncols (<optional return> number of columns in output lattice)
              &boxa (<optional return> location of images in lattice)
      Return: pix of composite images, or null on error

  Notes:
      (1) This places each pix on sequentially on a regular lattice
          in the rendered composite.  If a pix is too large to fit in the
          allocated lattice space, it is not rendered.
      (2) If any pix has a colormap, all pix are rendered in rgb.
      (3) This is useful when putting bitmaps of components,
          such as characters, into a single image.
      (4) The boxa gives the location of each image.  The UL corner
          of each image is on a lattice cell corner.  Omitted images
          (due to size) are assigned an invalid width and height of 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayOnLattice(*args)
    
    

    try:
        leptonica.pixaaDisplayTiledAndScaled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaDisplayTiledAndScaled.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaDisplayTiledAndScaled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDisplayTiledAndScaled(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'outdepth')       
('l_int32', 'tilewidth')       
('l_int32', 'ncols')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       
  pixaaDisplayTiledAndScaled()

      Input:  paa
              outdepth (output depth: 1, 8 or 32 bpp)
              tilewidth (each pix is scaled to this width)
              ncols (number of tiles in each row)
              background (0 for white, 1 for black; this is the color
                 of the spacing between the images)
              spacing  (between images, and on outside)
              border (width of additional black border on each image;
                      use 0 for no border)
      Return: pixa (of tiled images, one image for each pixa in
                    the paa), or null on error

  Notes:
      (1) For each pixa, this generates from all the pix a
          tiled/scaled output pix, and puts it in the output pixa.
      (2) See comments in pixaDisplayTiledAndScaled().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDisplayTiledAndScaled(*args)
    
    

    try:
        leptonica.convertToNUpFiles.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertToNUpFiles.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertToNUpFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToNUpFiles(*args):
        """
        ('const char', '*dir')       
('const char', '*substr')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'tw')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('const char', '*fontdir')       
('const char', '*outdir')       
  convertToNUpFiles()

      Input:  indir (full path to directory of images)
              substr (<optional> can be null)
              nx, ny (in [1, ... 50], tiling factors in each direction)
              tw (target width, in pixels; must be >= 20)
              spacing  (between images, and on outside)
              border (width of additional black border on each image;
                      use 0 for no border)
              fontdir (<optional> prints tail of filename with image)
              outdir (subdirectory of /tmp to put N-up tiled images)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Each set of nx*ny images is scaled and tiled into a single
          image, that is written out to @outdir.
      (2) All images in each nx*ny set are scaled to the same width.
          This is typically used when all images are roughly the same
          size.
      (3) Typical values for nx and ny are in [2 ... 5].
      (4) All images are scaled to a width @tw.  They are not rescaled
          when placed in the (nx,ny) mosaic.


        """
        args = _convert_params(*args)
        
        return leptonica.convertToNUpFiles(*args)
    
    

    try:
        leptonica.pixaConvertTo8Color.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaConvertTo8Color.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaConvertTo8Color not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo8Color(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'dither')       
  pixaConvertTo8Color()

      Input:  pixas
              ditherflag (1 to dither if necessary; 0 otherwise)
      Return: pixad (each pix is 8 bpp), or null on error

  Notes:
      (1) See notes for pixConvertTo8Color(), applied to each pix in pixas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo8Color(*args)
    
    

    try:
        leptonica.pixaDisplayUnsplit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaDisplayUnsplit.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayUnsplit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayUnsplit(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'borderwidth')       
('l_uint32', 'bordercolor')       
  pixaDisplayUnsplit()

      Input:  pixa
              nx   (number of mosaic cells horizontally)
              ny   (number of mosaic cells vertically)
              borderwidth  (of added border on all sides)
              bordercolor  (in our RGBA format: 0xrrggbbaa)
      Return: pix of tiled images, or null on error

  Notes:
      (1) This is a logical inverse of pixaSplitPix().  It
          constructs a pix from a mosaic of tiles, all of equal size.
      (2) For added generality, a border of arbitrary color can
          be added to each of the tiles.
      (3) In use, pixa will typically have either been generated
          from pixaSplitPix() or will derived from a pixa that
          was so generated.
      (4) All pix in the pixa must be of equal depth, and, if
          colormapped, have the same colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayUnsplit(*args)
    
    

    try:
        leptonica.pixaConvertTo8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaConvertTo8.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaConvertTo8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo8(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'cmapflag')       
  pixaConvertTo8()

      Input:  pixas
              cmapflag (1 to give pixd a colormap; 0 otherwise)
      Return: pixad (each pix is 8 bpp), or null on error

  Notes:
      (1) See notes for pixConvertTo8(), applied to each pix in pixas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo8(*args)
    
    

    try:
        leptonica.pixaDisplayRandomCmap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayRandomCmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayRandomCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayRandomCmap(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixaDisplayRandomCmap()

      Input:  pixa (of 1 bpp components, with boxa)
              w, h (if set to 0, determines the size from the
                    b.b. of the components in pixa)
      Return: pix (8 bpp, cmapped, with random colors on the components),
              or null on error

  Notes:
      (1) This uses the boxes to place each pix in the rendered composite.
      (2) By default, the background color is: black, cmap index 0.
          This can be changed by pixcmapResetColor()


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayRandomCmap(*args)
    
    

    try:
        leptonica.pixaDisplayTiledAndScaled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiledAndScaled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayTiledAndScaled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledAndScaled(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'outdepth')       
('l_int32', 'tilewidth')       
('l_int32', 'ncols')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       
  pixaDisplayTiledAndScaled()

      Input:  pixa
              outdepth (output depth: 1, 8 or 32 bpp)
              tilewidth (each pix is scaled to this width)
              ncols (number of tiles in each row)
              background (0 for white, 1 for black; this is the color
                 of the spacing between the images)
              spacing  (between images, and on outside)
              border (width of additional black border on each image;
                      use 0 for no border)
      Return: pix of tiled images, or null on error

  Notes:
      (1) This can be used to tile a number of renderings of
          an image that are at different scales and depths.
      (2) Each image, after scaling and optionally adding the
          black border, has width 'tilewidth'.  Thus, the border does
          not affect the spacing between the image tiles.  The
          maximum allowed border width is tilewidth / 5.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledAndScaled(*args)
    
    

    try:
        leptonica.pixaDisplayOnColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaDisplayOnColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplayOnColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayOnColor(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_uint32', 'bgcolor')       
  pixaDisplayOnColor()

      Input:  pixa
              w, h (if set to 0, determines the size from the
                    b.b. of the components in pixa)
              color (background color to use)
      Return: pix, or null on error

  Notes:
      (1) This uses the boxes to place each pix in the rendered composite.
      (2) Set w = h = 0 to use the b.b. of the components to determine
          the size of the returned pix.
      (3) If any pix in @pixa are colormapped, or if the pix have
          different depths, it returns a 32 bpp pix.  Otherwise,
          the depth of the returned pixa equals that of the pix in @pixa.
      (4) If the pixa is empty, return null.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayOnColor(*args)
    
    

    try:
        leptonica.pixaDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplay.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplay(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixaDisplay()

      Input:  pixa
              w, h (if set to 0, determines the size from the
                    b.b. of the components in pixa)
      Return: pix, or null on error

  Notes:
      (1) This uses the boxes to place each pix in the rendered composite.
      (2) Set w = h = 0 to use the b.b. of the components to determine
          the size of the returned pix.
      (3) Uses the first pix in pixa to determine the depth.
      (4) The background is written "white".  On 1 bpp, each successive
          pix is "painted" (adding foreground), whereas for grayscale
          or color each successive pix is blitted with just the src.
      (5) If the pixa is empty, returns an empty 1 bpp pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplay(*args)
    
    

    try:
        leptonica.pixaConvertTo32.argtypes = [ctypes.c_void_p]
        leptonica.pixaConvertTo32.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaConvertTo32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo32(*args):
        """
        ('PIXA', '*pixas')       
  pixaConvertTo32()

      Input:  pixas
      Return: pixad (32 bpp rgb), or null on error

  Notes:
      (1) See notes for pixConvertTo32(), applied to each pix in pixas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo32(*args)
    
    

    try:
        leptonica.pixaConvertTo1.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaConvertTo1.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaConvertTo1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo1(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'thresh')       
  pixaConvertTo1()

      Input:  pixas
              thresh (threshold for final binarization from 8 bpp gray)
      Return: pixad, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo1(*args)
    
    

    try:
        leptonica.pixaaDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaDisplay.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDisplay(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixaaDisplay()

      Input:  paa
              w, h (if set to 0, determines the size from the
                    b.b. of the components in paa)
      Return: pix, or null on error

  Notes:
      (1) Each pix of the paa is displayed at the location given by
          its box, translated by the box of the containing pixa
          if it exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDisplay(*args)
    




class pixafunc1(object):
    """   pixafunc1.c

      Filters
           PIX      *pixSelectBySize()
           PIXA     *pixaSelectBySize()
           NUMA     *pixaMakeSizeIndicator()

           PIX      *pixSelectByPerimToAreaRatio()
           PIXA     *pixaSelectByPerimToAreaRatio()
           PIX      *pixSelectByPerimSizeRatio()
           PIXA     *pixaSelectByPerimSizeRatio()
           PIX      *pixSelectByAreaFraction()
           PIXA     *pixaSelectByAreaFraction()
           PIX      *pixSelectByWidthHeightRatio()
           PIXA     *pixaSelectByWidthHeightRatio()

           PIXA     *pixaSelectWithIndicator()
           l_int32   pixRemoveWithIndicator()
           l_int32   pixAddWithIndicator()
           PIX      *pixaRenderComponent()

      Sort functions
           PIXA     *pixaSort()
           PIXA     *pixaBinSort()
           PIXA     *pixaSortByIndex()
           PIXAA    *pixaSort2dByIndex()

      Pixa and Pixaa range selection
           PIXA     *pixaSelectRange()
           PIXAA    *pixaaSelectRange()

      Pixa and Pixaa scaling
           PIXAA    *pixaaScaleToSize()
           PIXAA    *pixaaScaleToSizeVar()
           PIXA     *pixaScaleToSize()

      Miscellaneous
           PIXA     *pixaAddBorderGeneral()
           PIXA     *pixaaFlattenToPixa()
           l_int32   pixaaSizeRange()
           l_int32   pixaSizeRange()
           PIXA     *pixaClipToPix()
           l_int32   pixaGetRenderingDepth()
           l_int32   pixaHasColor()
           l_int32   pixaAnyColormaps()
           l_int32   pixaGetDepthInfo()
           PIXA     *pixaConvertToSameDepth()
           l_int32   pixaEqual()

"""
    
    try:
        leptonica.pixaMakeSizeIndicator.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMakeSizeIndicator.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaMakeSizeIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMakeSizeIndicator(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'type')       
('l_int32', 'relation')       
  pixaMakeSizeIndicator()

      Input:  pixa
              width, height (threshold dimensions)
              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,
                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)
              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,
                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)
      Return: na (indicator array), or null on error

  Notes:
      (1) The args specify constraints on the size of the
          components that are kept.
      (2) If the selection type is L_SELECT_WIDTH, the input
          height is ignored, and v.v.
      (3) To keep small components, use relation = L_SELECT_IF_LT or
          L_SELECT_IF_LTE.
          To keep large components, use relation = L_SELECT_IF_GT or
          L_SELECT_IF_GTE.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMakeSizeIndicator(*args)
    
    

    try:
        leptonica.pixSelectByPerimToAreaRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByPerimToAreaRatio.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSelectByPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByPerimToAreaRatio(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixSelectByPerimToAreaRatio()

      Input:  pixs (1 bpp)
              thresh (threshold ratio of fg boundary to fg pixels)
              connectivity (4 or 8)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixd, or null on error

  Notes:
      (1) The args specify constraints on the size of the
          components that are kept.
      (2) If unchanged, returns a copy of pixs.  Otherwise,
          returns a new pix with the filtered components.
      (3) This filters "thick" components, where a thick component
          is defined to have a ratio of boundary to interior pixels
          that is smaller than a given threshold value.
      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker
          components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixaSelectBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectBySize.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectBySize(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'type')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       
  pixaSelectBySize()

      Input:  pixas
              width, height (threshold dimensions)
              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,
                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)
              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,
                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 otherwise)
      Return: pixad, or null on error

  Notes:
      (1) The args specify constraints on the size of the
          components that are kept.
      (2) Uses pix and box clones in the new pixa.
      (3) If the selection type is L_SELECT_WIDTH, the input
          height is ignored, and v.v.
      (4) To keep small components, use relation = L_SELECT_IF_LT or
          L_SELECT_IF_LTE.
          To keep large components, use relation = L_SELECT_IF_GT or
          L_SELECT_IF_GTE.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectBySize(*args)
    
    

    try:
        leptonica.pixaSizeRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaSizeRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaSizeRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSizeRange(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pminw')       
('l_int32', '*pminh')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       
  pixaSizeRange()

      Input:  pixa
              &minw, &minh, &maxw, &maxh (<optional return> range of
                                          dimensions of pix in the array)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSizeRange(*args)
    
    

    try:
        leptonica.pixaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSortByIndex.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSortByIndex(*args):
        """
        ('PIXA', '*pixas')       
('NUMA', '*naindex')       
('l_int32', 'copyflag')       
  pixaSortByIndex()

      Input:  pixas
              naindex (na that maps from the new pixa to the input pixa)
              copyflag (L_COPY, L_CLONE)
      Return: pixad (sorted), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSortByIndex(*args)
    
    

    try:
        leptonica.pixaSelectWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaSelectWithIndicator.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectWithIndicator(*args):
        """
        ('PIXA', '*pixas')       
('NUMA', '*na')       
('l_int32', '*pchanged')       
  pixaSelectWithIndicator()

      Input:  pixas
              na (indicator numa)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixad, or null on error

  Notes:
      (1) Returns a pixa clone if no components are removed.
      (2) Uses pix and box clones in the new pixa.
      (3) The indicator numa has values 0 (ignore) and 1 (accept).
      (4) If the source boxa is not fully populated, it is left
          empty in the dest pixa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectWithIndicator(*args)
    
    

    try:
        leptonica.pixaRenderComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaRenderComponent.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaRenderComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRenderComponent(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_int32', 'index')       
  pixaRenderComponent()

      Input:  pixs (<optional> 1 bpp pix)
              pixa (of 1 bpp connected components, one of which will
                    be rendered in pixs, with its origin determined
                    by the associated box.)
              index (of component to be rendered)
      Return: pixd, or null on error

  Notes:
      (1) If pixs is null, this generates an empty pix of a size determined
          by union of the component bounding boxes, and including the origin.
      (2) The selected component is blitted into pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRenderComponent(*args)
    
    

    try:
        leptonica.pixaaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaSelectRange.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaSelectRange(*args):
        """
        ('PIXAA', '*paas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'copyflag')       
  pixaaSelectRange()

      Input:  paas
              first (use 0 to select from the beginning)
              last (use 0 to select to the end)
              copyflag (L_COPY, L_CLONE)
      Return: paad, or null on error

  Notes:
      (1) The copyflag specifies what we do with each pixa from paas.
          Specifically, L_CLONE inserts a clone into paad of each
          selected pixa from paas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaSelectRange(*args)
    
    

    try:
        leptonica.pixRemoveWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRemoveWithIndicator.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveWithIndicator(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('NUMA', '*na')       
  pixRemoveWithIndicator()

      Input:  pixs (1 bpp pix from which components are removed; in-place)
              pixa (of connected components in pixs)
              na (numa indicator: remove components corresponding to 1s)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This complements pixAddWithIndicator().   Here, the selected
          components are set subtracted from pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveWithIndicator(*args)
    
    

    try:
        leptonica.pixaGetDepthInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetDepthInfo.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaGetDepthInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetDepthInfo(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pmaxdepth')       
('l_int32', '*psame')       
  pixaGetDepthInfo()

      Input:  pixa
              &maxdepth (<optional return> max pixel depth of pix in pixa)
              &same (<optional return> true if all depths are equal)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetDepthInfo(*args)
    
    

    try:
        leptonica.pixaConvertToSameDepth.argtypes = [ctypes.c_void_p]
        leptonica.pixaConvertToSameDepth.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaConvertToSameDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertToSameDepth(*args):
        """
        ('PIXA', '*pixas')       
  pixaConvertToSameDepth()

      Input:  pixas
      Return: pixad, or null on error

  Notes:
      (1) If any pix has a colormap, they are all converted to rgb.
          Otherwise, they are all converted to the maximum depth of
          all the pix.
      (2) This can be used to allow lossless rendering onto a single pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertToSameDepth(*args)
    
    

    try:
        leptonica.pixSelectByPerimSizeRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByPerimSizeRatio.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSelectByPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByPerimSizeRatio(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixSelectByPerimSizeRatio()

      Input:  pixs (1 bpp)
              thresh (threshold ratio of fg boundary to fg pixels)
              connectivity (4 or 8)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixd, or null on error

  Notes:
      (1) The args specify constraints on the size of the
          components that are kept.
      (2) If unchanged, returns a copy of pixs.  Otherwise,
          returns a new pix with the filtered components.
      (3) This filters components with smooth vs. dendritic shape, using
          the ratio of the fg boundary pixels to the circumference of
          the bounding box, and comparing it to a threshold value.
      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth
          boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE
          to remove them.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixaaScaleToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaScaleToSize.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaScaleToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaScaleToSize(*args):
        """
        ('PIXAA', '*paas')       
('l_int32', 'wd')       
('l_int32', 'hd')       
  pixaaScaleToSize()

      Input:  paas
              wd  (target width; use 0 if using height as target)
              hd  (target height; use 0 if using width as target)
      Return: paad, or null on error

  Notes:
      (1) This guarantees that each output scaled image has the
          dimension(s) you specify.
           - To specify the width with isotropic scaling, set @hd = 0.
           - To specify the height with isotropic scaling, set @wd = 0.
           - If both @wd and @hd are specified, the image is scaled
             (in general, anisotropically) to that size.
           - It is an error to set both @wd and @hd to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaScaleToSize(*args)
    
    

    try:
        leptonica.pixaaFlattenToPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaFlattenToPixa.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaFlattenToPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaFlattenToPixa(*args):
        """
        ('PIXAA', '*paa')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       
  pixaaFlattenToPixa()

      Input:  paa
              &naindex  (<optional return> the pixa index in the pixaa)
              copyflag  (L_COPY or L_CLONE)
      Return: pixa, or null on error

  Notes:
      (1) This 'flattens' the pixaa to a pixa, taking the pix in
          order in the first pixa, then the second, etc.
      (2) If &naindex is defined, we generate a Numa that gives, for
          each pix in the pixaa, the index of the pixa to which it belongs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaFlattenToPixa(*args)
    
    

    try:
        leptonica.pixaSort2dByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSort2dByIndex.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSort2dByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSort2dByIndex(*args):
        """
        ('PIXA', '*pixas')       
('NUMAA', '*naa')       
('l_int32', 'copyflag')       
  pixaSort2dByIndex()

      Input:  pixas
              naa (numaa that maps from the new pixaa to the input pixas)
              copyflag (L_CLONE or L_COPY)
      Return: paa (sorted), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSort2dByIndex(*args)
    
    

    try:
        leptonica.pixaaScaleToSizeVar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaScaleToSizeVar.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaScaleToSizeVar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaScaleToSizeVar(*args):
        """
        ('PIXAA', '*paas')       
('NUMA', '*nawd')       
('NUMA', '*nahd')       
  pixaaScaleToSizeVar()

      Input:  paas
              nawd  (<optional> target widths; use NULL if using height)
              nahd  (<optional> target height; use NULL if using width)
      Return: paad, or null on error

  Notes:
      (1) This guarantees that the scaled images in each pixa have the
          dimension(s) you specify in the numas.
           - To specify the width with isotropic scaling, set @nahd = NULL.
           - To specify the height with isotropic scaling, set @nawd = NULL.
           - If both @nawd and @nahd are specified, the image is scaled
             (in general, anisotropically) to that size.
           - It is an error to set both @nawd and @nahd to NULL.
      (2) If either nawd and/or nahd is defined, it must have the same
          count as the number of pixa in paas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaScaleToSizeVar(*args)
    
    

    try:
        leptonica.pixAddWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddWithIndicator.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAddWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddWithIndicator(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('NUMA', '*na')       
  pixAddWithIndicator()

      Input:  pixs (1 bpp pix from which components are added; in-place)
              pixa (of connected components, some of which will be put
                    into pixs)
              na (numa indicator: add components corresponding to 1s)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This complements pixRemoveWithIndicator().   Here, the selected
          components are added to pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddWithIndicator(*args)
    
    

    try:
        leptonica.pixaSelectByPerimToAreaRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByPerimToAreaRatio.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectByPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByPerimToAreaRatio(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixaSelectByPerimToAreaRatio()

      Input:  pixas
              thresh (threshold ratio of fg boundary to fg pixels)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixad, or null on error

  Notes:
      (1) Returns a pixa clone if no components are removed.
      (2) Uses pix and box clones in the new pixa.
      (3) See pixSelectByPerimToAreaRatio().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixSelectBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectBySize.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSelectBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectBySize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       
  pixSelectBySize()

      Input:  pixs (1 bpp)
              width, height (threshold dimensions)
              connectivity (4 or 8)
              type (L_SELECT_WIDTH, L_SELECT_HEIGHT,
                    L_SELECT_IF_EITHER, L_SELECT_IF_BOTH)
              relation (L_SELECT_IF_LT, L_SELECT_IF_GT,
                        L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 otherwise)
      Return: filtered pixd, or null on error

  Notes:
      (1) The args specify constraints on the size of the
          components that are kept.
      (2) If unchanged, returns a copy of pixs.  Otherwise,
          returns a new pix with the filtered components.
      (3) If the selection type is L_SELECT_WIDTH, the input
          height is ignored, and v.v.
      (4) To keep small components, use relation = L_SELECT_IF_LT or
          L_SELECT_IF_LTE.
          To keep large components, use relation = L_SELECT_IF_GT or
          L_SELECT_IF_GTE.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectBySize(*args)
    
    

    try:
        leptonica.pixaSelectByWidthHeightRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByWidthHeightRatio.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectByWidthHeightRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByWidthHeightRatio(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixaSelectByWidthHeightRatio()

      Input:  pixas
              thresh (threshold ratio of width/height)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixad, or null on error

  Notes:
      (1) Returns a pixa clone if no components are removed.
      (2) Uses pix and box clones in the new pixa.
      (3) This filters components based on the width-to-height ratio
          of each pix.
      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
          with less than the threshold ratio, and
          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByWidthHeightRatio(*args)
    
    

    try:
        leptonica.pixaGetRenderingDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetRenderingDepth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaGetRenderingDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetRenderingDepth(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pdepth')       
  pixaGetRenderingDepth()

      Input:  pixa
              &depth (<return> depth required to render if all
                      colormaps are removed)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetRenderingDepth(*args)
    
    

    try:
        leptonica.pixSelectByAreaFraction.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByAreaFraction.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSelectByAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByAreaFraction(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixSelectByAreaFraction()

      Input:  pixs (1 bpp)
              thresh (threshold ratio of fg pixels to (w * h))
              connectivity (4 or 8)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixd, or null on error

  Notes:
      (1) The args specify constraints on the amount of foreground
          coverage of the components that are kept.
      (2) If unchanged, returns a copy of pixs.  Otherwise,
          returns a new pix with the filtered components.
      (3) This filters components based on the fraction of fg pixels
          of the component in its bounding box.
      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
          with less than the threshold fraction of foreground, and
          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByAreaFraction(*args)
    
    

    try:
        leptonica.pixaSelectByPerimSizeRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByPerimSizeRatio.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectByPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByPerimSizeRatio(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixaSelectByPerimSizeRatio()

      Input:  pixas
              thresh (threshold ratio of fg boundary to b.b. circumference)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixad, or null on error

  Notes:
      (1) Returns a pixa clone if no components are removed.
      (2) Uses pix and box clones in the new pixa.
      (3) See pixSelectByPerimSizeRatio().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixSelectByWidthHeightRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByWidthHeightRatio.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSelectByWidthHeightRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByWidthHeightRatio(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixSelectByWidthHeightRatio()

      Input:  pixs (1 bpp)
              thresh (threshold ratio of width/height)
              connectivity (4 or 8)
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixd, or null on error

  Notes:
      (1) The args specify constraints on the width-to-height ratio
          for components that are kept.
      (2) If unchanged, returns a copy of pixs.  Otherwise,
          returns a new pix with the filtered components.
      (3) This filters components based on the width-to-height ratios.
      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
          with less than the threshold ratio, and
          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByWidthHeightRatio(*args)
    
    

    try:
        leptonica.pixaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaSelectRange.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectRange(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'copyflag')       
  pixaSelectRange()

      Input:  pixas
              first (use 0 to select from the beginning)
              last (use 0 to select to the end)
              copyflag (L_COPY, L_CLONE)
      Return: pixad, or null on error

  Notes:
      (1) The copyflag specifies what we do with each pix from pixas.
          Specifically, L_CLONE inserts a clone into pixad of each
          selected pix from pixas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectRange(*args)
    
    

    try:
        leptonica.pixaSelectByAreaFraction.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByAreaFraction.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSelectByAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByAreaFraction(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       
  pixaSelectByAreaFraction()

      Input:  pixas
              thresh (threshold ratio of fg pixels to (w * h))
              type (L_SELECT_IF_LT, L_SELECT_IF_GT,
                    L_SELECT_IF_LTE, L_SELECT_IF_GTE)
              &changed (<optional return> 1 if changed; 0 if clone returned)
      Return: pixad, or null on error

  Notes:
      (1) Returns a pixa clone if no components are removed.
      (2) Uses pix and box clones in the new pixa.
      (3) This filters components based on the fraction of fg pixels
          of the component in its bounding box.
      (4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
          with less than the threshold fraction of foreground, and
          L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByAreaFraction(*args)
    
    

    try:
        leptonica.pixaClipToPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaClipToPix.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaClipToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaClipToPix(*args):
        """
        ('PIXA', '*pixas')       
('PIX', '*pixs')       
  pixaClipToPix()

      Input:  pixas
              pixs
      Return: pixad, or null on error

  Notes:
      (1) This is intended for use in situations where pixas
          was originally generated from the input pixs.
      (2) Returns a pixad where each pix in pixas is ANDed
          with its associated region of the input pixs.  This
          region is specified by the the box that is associated
          with the pix.
      (3) In a typical application of this function, pixas has
          a set of region masks, so this generates a pixa of
          the parts of pixs that correspond to each region
          mask component, along with the bounding box for
          the region.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaClipToPix(*args)
    
    

    try:
        leptonica.pixaAnyColormaps.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaAnyColormaps.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaAnyColormaps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAnyColormaps(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*phascmap')       
  pixaAnyColormaps()

      Input:  pixa
              &hascmap (<return> 1 if any pix has a colormap; 0 otherwise)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAnyColormaps(*args)
    
    

    try:
        leptonica.pixaSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSort.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSort(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       
  pixaSort()

      Input:  pixas
              sorttype (L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,
                        L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION,
                        L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER,
                        L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO)
              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)
              &naindex (<optional return> index of sorted order into
                        original array)
              copyflag (L_COPY, L_CLONE)
      Return: pixad (sorted version of pixas), or null on error

  Notes:
      (1) This sorts based on the data in the boxa.  If the boxa
          count is not the same as the pixa count, this returns an error.
      (2) The copyflag refers to the pix and box copies that are
          inserted into the sorted pixa.  These are either L_COPY
          or L_CLONE.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSort(*args)
    
    

    try:
        leptonica.pixaAddBorderGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaAddBorderGeneral.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaAddBorderGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddBorderGeneral(*args):
        """
        ('PIXA', '*pixad')       
('PIXA', '*pixas')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_uint32', 'val')       
  pixaAddBorderGeneral()

      Input:  pixad (can be null or equal to pixas)
              pixas (containing pix of all depths; colormap ok)
              left, right, top, bot  (number of pixels added)
              val   (value of added border pixels)
      Return: pixad (with border added to each pix), including on error

  Notes:
      (1) For binary images:
             white:  val = 0
             black:  val = 1
          For grayscale images:
             white:  val = 2 ** d - 1
             black:  val = 0
          For rgb color images:
             white:  val = 0xffffff00
             black:  val = 0
          For colormapped images, use 'index' found this way:
             white: pixcmapGetRankIntensity(cmap, 1.0, &index);
             black: pixcmapGetRankIntensity(cmap, 0.0, &index);
      (2) For in-place replacement of each pix with a bordered version,
          use @pixad = @pixas.  To make a new pixa, use @pixad = NULL.
      (3) In both cases, the boxa has sides adjusted as if it were
          expanded by the border.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddBorderGeneral(*args)
    
    

    try:
        leptonica.pixaEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaEqual.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaEqual(*args):
        """
        ('PIXA', '*pixa1')       
('PIXA', '*pixa2')       
('l_int32', 'maxdist')       
('NUMA', '**pnaindex')       
('l_int32', '*psame')       
  pixaEqual()

      Input:  pixa1
              pixa2
              maxdist
              &naindex (<optional return> index array of correspondences
              &same (<return> 1 if equal; 0 otherwise)
      Return  0 if OK, 1 on error

  Notes:
      (1) The two pixa are the "same" if they contain the same
          boxa and the same ordered set of pix.  However, if they
          have boxa, the pix in each pixa can differ in ordering
          by an amount given by the parameter @maxdist.  If they
          don't have a boxa, the @maxdist parameter is ignored,
          and the ordering must be identical.
      (2) This applies only to boxa geometry, pixels and ordering;
          other fields in the pix are ignored.
      (3) naindex[i] gives the position of the box in pixa2 that
          corresponds to box i in pixa1.  It is only returned if the
          pixa have boxa and the boxa are equal.
      (4) In situations where the ordering is very different, so that
          a large @maxdist is required for "equality", this should be
          implemented with a hash function for efficiency.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaEqual(*args)
    
    

    try:
        leptonica.pixaScaleToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaScaleToSize.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaScaleToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaScaleToSize(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'wd')       
('l_int32', 'hd')       
  pixaScaleToSize()

      Input:  pixas
              wd  (target width; use 0 if using height as target)
              hd  (target height; use 0 if using width as target)
      Return: pixad, or null on error

  Notes:
      (1) See pixaaScaleToSize()


        """
        args = _convert_params(*args)
        
        return leptonica.pixaScaleToSize(*args)
    
    

    try:
        leptonica.pixaHasColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaHasColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaHasColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaHasColor(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*phascolor')       
  pixaHasColor()

      Input:  pixa
              &hascolor (<return> 1 if any pix is rgb or has
                         a colormap with color; 0 otherwise)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaHasColor(*args)
    
    

    try:
        leptonica.pixaaSizeRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaSizeRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaSizeRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaSizeRange(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*pminw')       
('l_int32', '*pminh')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       
  pixaaSizeRange()

      Input:  paa
              &minw, &minh, &maxw, &maxh (<optional return> range of
                                          dimensions of all boxes)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaSizeRange(*args)
    
    

    try:
        leptonica.pixaBinSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaBinSort.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaBinSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaBinSort(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       
  pixaBinSort()

      Input:  pixas
              sorttype (L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,
                        L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER)
              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)
              &naindex (<optional return> index of sorted order into
                        original array)
              copyflag (L_COPY, L_CLONE)
      Return: pixad (sorted version of pixas), or null on error

  Notes:
      (1) This sorts based on the data in the boxa.  If the boxa
          count is not the same as the pixa count, this returns an error.
      (2) The copyflag refers to the pix and box copies that are
          inserted into the sorted pixa.  These are either L_COPY
          or L_CLONE.
      (3) For a large number of boxes (say, greater than 1000), this
          O(n) binsort is much faster than the O(nlogn) shellsort.
          For 5000 components, this is over 20x faster than boxaSort().
      (4) Consequently, pixaSort() calls this function if it will
          likely go much faster.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaBinSort(*args)
    




class correlscore(object):
    """ correlscore.c

     These are functions for computing correlation between
     pairs of 1 bpp images.

     Optimized 2 pix correlators (for jbig2 clustering)
         l_int32     pixCorrelationScore()
         l_int32     pixCorrelationScoreThresholded()

     Simple 2 pix correlators
         l_int32     pixCorrelationScoreSimple()
         l_int32     pixCorrelationScoreShifted()

     There are other, more application-oriented functions, that
     compute the correlation between two binary images, taking into
     account small translational shifts, between two binary images.
     These are:
         compare.c:     pixBestCorrelation()
                        Uses coarse-to-fine translations of full image
         recogident.c:  pixCorrelationBestShift()
                        Uses small shifts between c.c. centroids.

"""
    
    try:
        leptonica.pixCorrelationScoreShifted.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationScoreShifted.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCorrelationScoreShifted not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScoreShifted(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_int32', 'delx')       
('l_int32', 'dely')       
('l_int32', '*tab')       
('l_float32', '*pscore')       
  pixCorrelationScoreShifted()

      Input:  pix1   (1 bpp)
              pix2   (1 bpp)
              area1  (number of on pixels in pix1)
              area2  (number of on pixels in pix2)
              delx (x translation of pix2 relative to pix1)
              dely (y translation of pix2 relative to pix1)
              tab    (sum tab for byte)
              &score (<return> correlation score)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This finds the correlation between two 1 bpp images,
          when pix2 is shifted by (delx, dely) with respect
          to each other.
      (2) This is implemented by starting with a copy of pix1 and
          ANDing its pixels with those of a shifted pix2.
      (3) Get the pixel counts for area1 and area2 using piCountPixels().
      (4) A good estimate for a shift that would maximize the correlation
          is to align the centroids (cx1, cy1; cx2, cy2), giving the
          relative translations etransx and etransy:
             etransx = cx1 - cx2
             etransy = cy1 - cy2
          Typically delx is chosen to be near etransx; ditto for dely.
          This function is used in pixBestCorrelation(), where the
          translations delx and dely are varied to find the best alignment.
      (5) We do not check the sizes of pix1 and pix2, because they should
          be comparable.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScoreShifted(*args)
    
    

    try:
        leptonica.pixCorrelationScoreSimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationScoreSimple.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCorrelationScoreSimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScoreSimple(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', '*tab')       
('l_float32', '*pscore')       
  pixCorrelationScoreSimple()

      Input:  pix1   (test pix, 1 bpp)
              pix2   (exemplar pix, 1 bpp)
              area1  (number of on pixels in pix1)
              area2  (number of on pixels in pix2)
              delx   (x comp of centroid difference)
              dely   (y comp of centroid difference)
              maxdiffw (max width difference of pix1 and pix2)
              maxdiffh (max height difference of pix1 and pix2)
              tab    (sum tab for byte)
              &score (<return> correlation score, in range [0.0 ... 1.0])
      Return: 0 if OK, 1 on error

  Notes:
      (1) This calculates exactly the same value as pixCorrelationScore().
          It is 2-3x slower, but much simpler to understand.
      (2) The returned correlation score is 0.0 if the width or height
          exceed @maxdiffw or @maxdiffh.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScoreSimple(*args)
    
    

    try:
        leptonica.pixCorrelationScore.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationScore.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCorrelationScore not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScore(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', '*tab')       
('l_float32', '*pscore')       
  pixCorrelationScore()

      Input:  pix1   (test pix, 1 bpp)
              pix2   (exemplar pix, 1 bpp)
              area1  (number of on pixels in pix1)
              area2  (number of on pixels in pix2)
              delx   (x comp of centroid difference)
              dely   (y comp of centroid difference)
              maxdiffw (max width difference of pix1 and pix2)
              maxdiffh (max height difference of pix1 and pix2)
              tab    (sum tab for byte)
              &score (<return> correlation score)
      Return: 0 if OK, 1 on error

  Note: we check first that the two pix are roughly the same size.
  For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and
  maxdiffh should be at least 2.

  Only if they meet that criterion do we compare the bitmaps.
  The centroid difference is used to align the two images to the
  nearest integer for the correlation.

  The correlation score is the ratio of the square of the number of
  pixels in the AND of the two bitmaps to the product of the number
  of ON pixels in each.  Denote the number of ON pixels in pix1
  by |1|, the number in pix2 by |2|, and the number in the AND
  of pix1 and pix2 by |1 & 2|.  The correlation score is then
  (|1 & 2|)**2 / (|1|*|2|).

  This score is compared with an input threshold, which can
  be modified depending on the weight of the template.
  The modified threshold is
     thresh + (1.0 - thresh) * weight * R
  where
     weight is a fixed input factor between 0.0 and 1.0
     R = |2| / area(2)
  and area(2) is the total number of pixels in 2 (i.e., width x height).

  To understand why a weight factor is useful, consider what happens
  with thick, sans-serif characters that look similar and have a value
  of R near 1.  Different characters can have a high correlation value,
  and the classifier will make incorrect substitutions.  The weight
  factor raises the threshold for these characters.

  Yet another approach to reduce such substitutions is to run the classifier
  in a non-greedy way, matching to the template with the highest
  score, not the first template with a score satisfying the matching
  constraint.  However, this is not particularly effective.

  The implementation here gives the same result as in
  pixCorrelationScoreSimple(), where a temporary Pix is made to hold
  the AND and implementation uses rasterop:
      pixt = pixCreateTemplate(pix1);
      pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0);
      pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC & PIX_DST, pix1, 0, 0);
      pixCountPixels(pixt, &count, tab);
      pixDestroy(&pixt);
  However, here it is done in a streaming fashion, counting as it goes,
  and touching memory exactly once, giving a 3-4x speedup over the
  simple implementation.  This very fast correlation matcher was
  contributed by William Rucklidge.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScore(*args)
    
    

    try:
        leptonica.pixCorrelationScoreThresholded.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixCorrelationScoreThresholded.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCorrelationScoreThresholded not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScoreThresholded(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', '*tab')       
('l_int32', '*downcount')       
('l_float32', 'score_threshold')       
  pixCorrelationScoreThresholded()

      Input:  pix1   (test pix, 1 bpp)
              pix2   (exemplar pix, 1 bpp)
              area1  (number of on pixels in pix1)
              area2  (number of on pixels in pix2)
              delx   (x comp of centroid difference)
              dely   (y comp of centroid difference)
              maxdiffw (max width difference of pix1 and pix2)
              maxdiffh (max height difference of pix1 and pix2)
              tab    (sum tab for byte)
              downcount (count of 1 pixels below each row of pix1)
              score_threshold
      Return: whether the correlation score is >= score_threshold


  Note: we check first that the two pix are roughly the same size.
  Only if they meet that criterion do we compare the bitmaps.
  The centroid difference is used to align the two images to the
  nearest integer for the correlation.

  The correlation score is the ratio of the square of the number of
  pixels in the AND of the two bitmaps to the product of the number
  of ON pixels in each.  Denote the number of ON pixels in pix1
  by |1|, the number in pix2 by |2|, and the number in the AND
  of pix1 and pix2 by |1 & 2|.  The correlation score is then
  (|1 & 2|)**2 / (|1|*|2|).

  This score is compared with an input threshold, which can
  be modified depending on the weight of the template.
  The modified threshold is
     thresh + (1.0 - thresh) * weight * R
  where
     weight is a fixed input factor between 0.0 and 1.0
     R = |2| / area(2)
  and area(2) is the total number of pixels in 2 (i.e., width x height).

  To understand why a weight factor is useful, consider what happens
  with thick, sans-serif characters that look similar and have a value
  of R near 1.  Different characters can have a high correlation value,
  and the classifier will make incorrect substitutions.  The weight
  factor raises the threshold for these characters.

  Yet another approach to reduce such substitutions is to run the classifier
  in a non-greedy way, matching to the template with the highest
  score, not the first template with a score satisfying the matching
  constraint.  However, this is not particularly effective.

  This very fast correlation matcher was contributed by William Rucklidge.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScoreThresholded(*args)
    




class shear(object):
    """  shear.c

    About arbitrary lines
           PIX      *pixHShear()
           PIX      *pixVShear()

    About special 'points': UL corner and center
           PIX      *pixHShearCorner()
           PIX      *pixVShearCorner()
           PIX      *pixHShearCenter()
           PIX      *pixVShearCenter()

    In place about arbitrary lines
           l_int32   pixHShearIP()
           l_int32   pixVShearIP()

    Linear interpolated shear about arbitrary lines
           PIX      *pixHShearLI()
           PIX      *pixVShearLI()

    Static helper
      static l_float32  normalizeAngleForShear()

"""
    
    try:
        leptonica.pixHShearCorner.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearCorner.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHShearCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearCorner(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixHShearCorner()

      Input:  pixd (<optional>, if not null, must be equal to pixs)
              pixs
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) See pixHShear() for usage.
      (2) This does a horizontal shear about the UL corner, with (+) shear
          pushing increasingly leftward (-x) with increasing y.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearCorner(*args)
    
    

    try:
        leptonica.pixVShearCorner.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearCorner.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVShearCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearCorner(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixVShearCorner()

      Input:  pixd (<optional>, if not null, must be equal to pixs)
              pixs
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) See pixVShear() for usage.
      (2) This does a vertical shear about the UL corner, with (+) shear
          pushing increasingly downward (+y) with increasing x.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearCorner(*args)
    
    

    try:
        leptonica.pixVShearLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVShearLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixVShearLI()

      Input:  pixs (8 bpp or 32 bpp, or colormapped)
              xloc  (location of vertical line, measured from origin)
              angle (in radians, in range (-pi/2 ... pi/2))
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd (sheared), or null on error

  Notes:
      (1) This does vertical shear with linear interpolation for
          accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
          It is relatively slow compared to the sampled version
          implemented by rasterop, but the result is much smoother.
      (2) This shear leaves the vertical line of pixels at x = xloc
          invariant.  For a positive shear angle, pixels to the right
          of this line are shoved downward, and pixels to the left
          of the line move upward.
      (3) Any colormap is removed.
      (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
          where del == MIN_DIFF_FROM_HALF_PI.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearLI(*args)
    
    

    try:
        leptonica.pixVShearIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearIP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixVShearIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearIP(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixVShearIP()

      Input:  pixs (all depths; not colormapped)
              xloc  (location of vertical line, measured from origin)
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place version of pixVShear(); see comments there.
      (2) This brings in 'incolor' pixels from outside the image.
      (3) pixs cannot be colormapped, because the in-place operation
          only blits in 0 or 1 bits, not an arbitrary colormap index.
      (4) Does a vertical full-band shear about the line with (+) shear
          pushing increasingly downward (+y) with increasing x.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearIP(*args)
    
    

    try:
        leptonica.pixHShearIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearIP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixHShearIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearIP(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'yloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixHShearIP()

      Input:  pixs
              yloc (location of horizontal line, measured from origin)
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place version of pixHShear(); see comments there.
      (2) This brings in 'incolor' pixels from outside the image.
      (3) pixs cannot be colormapped, because the in-place operation
          only blits in 0 or 1 bits, not an arbitrary colormap index.
      (4) Does a horizontal full-band shear about the line with (+) shear
          pushing increasingly leftward (-x) with increasing y.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearIP(*args)
    
    

    try:
        leptonica.pixVShear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShear(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'xloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixVShear()

      Input:  pixd (<optional>, this can be null, equal to pixs,
                    or different from pixs)
              pixs (no restrictions on depth)
              xloc (location of vertical line, measured from origin)
              angle (in radians; not too close to +-(pi / 2))
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error

  Notes:
      (1) There are 3 cases:
            (a) pixd == null (make a new pixd)
            (b) pixd == pixs (in-place)
            (c) pixd != pixs
      (2) For these three cases, use these patterns, respectively:
              pixd = pixVShear(NULL, pixs, ...);
              pixVShear(pixs, pixs, ...);
              pixVShear(pixd, pixs, ...);
      (3) This shear leaves the vertical line of pixels at x = xloc
          invariant.  For a positive shear angle, pixels to the right
          of this line are shoved downward, and pixels to the left
          of the line move upward.
      (4) With positive shear angle, this can be used, along with
          pixHShear(), to perform a cw rotation, either with 2 shears
          (for small angles) or in the general case with 3 shears.
      (5) Changing the value of xloc is equivalent to translating
          the result vertically.
      (6) This brings in 'incolor' pixels from outside the image.
      (7) For in-place operation, pixs cannot be colormapped,
          because the in-place operation only blits in 0 or 1 bits,
          not an arbitrary colormap index.
      (8) The angle is brought into the range [-pi, -pi].  It is
          not permitted to be within MIN_DIFF_FROM_HALF_PI radians
          from either -pi/2 or pi/2.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShear(*args)
    
    

    try:
        leptonica.pixHShearLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHShearLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'yloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixHShearLI()

      Input:  pixs (8 bpp or 32 bpp, or colormapped)
              yloc (location of horizontal line, measured from origin)
              angle (in radians, in range (-pi/2 ... pi/2))
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd (sheared), or null on error

  Notes:
      (1) This does horizontal shear with linear interpolation for
          accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
          It is relatively slow compared to the sampled version
          implemented by rasterop, but the result is much smoother.
      (2) This shear leaves the horizontal line of pixels at y = yloc
          invariant.  For a positive shear angle, pixels above this
          line are shoved to the right, and pixels below this line
          move to the left.
      (3) Any colormap is removed.
      (4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
          where del == MIN_DIFF_FROM_HALF_PI.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearLI(*args)
    
    

    try:
        leptonica.pixHShear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShear(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'yloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixHShear()

      Input:  pixd (<optional>, this can be null, equal to pixs,
                    or different from pixs)
              pixs (no restrictions on depth)
              yloc (location of horizontal line, measured from origin)
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, always

  Notes:
      (1) There are 3 cases:
            (a) pixd == null (make a new pixd)
            (b) pixd == pixs (in-place)
            (c) pixd != pixs
      (2) For these three cases, use these patterns, respectively:
              pixd = pixHShear(NULL, pixs, ...);
              pixHShear(pixs, pixs, ...);
              pixHShear(pixd, pixs, ...);
      (3) This shear leaves the horizontal line of pixels at y = yloc
          invariant.  For a positive shear angle, pixels above this
          line are shoved to the right, and pixels below this line
          move to the left.
      (4) With positive shear angle, this can be used, along with
          pixVShear(), to perform a cw rotation, either with 2 shears
          (for small angles) or in the general case with 3 shears.
      (5) Changing the value of yloc is equivalent to translating
          the result horizontally.
      (6) This brings in 'incolor' pixels from outside the image.
      (7) For in-place operation, pixs cannot be colormapped,
          because the in-place operation only blits in 0 or 1 bits,
          not an arbitrary colormap index.
      (8) The angle is brought into the range [-pi, -pi].  It is
          not permitted to be within MIN_DIFF_FROM_HALF_PI radians
          from either -pi/2 or pi/2.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShear(*args)
    
    

    try:
        leptonica.pixHShearCenter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearCenter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHShearCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearCenter(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixHShearCenter()

      Input:  pixd (<optional>, if not null, must be equal to pixs)
              pixs
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) See pixHShear() for usage.
      (2) This does a horizontal shear about the center, with (+) shear
          pushing increasingly leftward (-x) with increasing y.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearCenter(*args)
    
    

    try:
        leptonica.pixVShearCenter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearCenter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVShearCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearCenter(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       
  pixVShearCenter()

      Input:  pixd (<optional>, if not null, must be equal to pixs)
              pixs
              angle (in radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) See pixVShear() for usage.
      (2) This does a vertical shear about the center, with (+) shear
          pushing increasingly downward (+y) with increasing x.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearCenter(*args)
    




class freetype(object):
    """ freetype.c
      static l_int32       ftUtfToUniChar()
      static PIX          *ftDrawBitmap()
             FT_LIBRARY   *ftInitLibrary()
             void          ftShutdownLibrary()
             PIX          *pixWriteTTFText()

"""
    



class boxfunc3(object):
    """   boxfunc3.c

      Boxa/Boxaa painting into pix
           PIX             *pixMaskConnComp()
           PIX             *pixMaskBoxa()
           PIX             *pixPaintBoxa()
           PIX             *pixSetBlackOrWhiteBoxa()
           PIX             *pixPaintBoxaRandom()
           PIX             *pixBlendBoxaRandom()
           PIX             *pixDrawBoxa()
           PIX             *pixDrawBoxaRandom()
           PIX             *boxaaDisplay()

      Split mask components into Boxa
           BOXA            *pixSplitIntoBoxa()
           BOXA            *pixSplitComponentIntoBoxa()
           static l_int32   pixSearchForRectangle()

      Represent horizontal or vertical mosaic strips
           BOXA            *makeMosaicStrips()

      Comparison between boxa
           l_int32          boxaCompareRegions()

  See summary in pixPaintBoxa() of various ways to paint and draw
  boxes on images.

"""
    
    try:
        leptonica.pixBlendBoxaRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixBlendBoxaRandom.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendBoxaRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendBoxaRandom(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_float32', 'fract')       
  pixBlendBoxaRandom()

      Input:  pixs (any depth; can be cmapped)
              boxa (of boxes, to blend/paint)
              fract (of box color to use)
      Return: pixd (32 bpp, with blend/painted boxes), or null on error

  Notes:
      (1) pixs is converted to 32 bpp.
      (2) This differs from pixPaintBoxaRandom(), in that the
          colors here are blended with the color of pixs.
      (3) We use up to 254 different colors for painting the regions.
      (4) If boxes overlap, the final color depends only on the last
          rect that is used.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendBoxaRandom(*args)
    
    

    try:
        leptonica.pixDrawBoxaRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDrawBoxaRandom.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDrawBoxaRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDrawBoxaRandom(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'width')       
  pixDrawBoxaRandom()

      Input:  pixs (any depth, can be cmapped)
              boxa (of boxes, to draw)
              width (thickness of line)
      Return: pixd (with box outlines drawn), or null on error

  Notes:
      (1) If pixs is 1 bpp, we draw the boxa using a colormap;
          otherwise, we convert to 32 bpp.
      (2) We use up to 254 different colors for drawing the boxes.
      (3) If boxes overlap, the later ones draw over earlier ones.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDrawBoxaRandom(*args)
    
    

    try:
        leptonica.pixSetBlackOrWhiteBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetBlackOrWhiteBoxa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSetBlackOrWhiteBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBlackOrWhiteBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'op')       
  pixSetBlackOrWhiteBoxa()

      Input:  pixs (any depth, can be cmapped)
              boxa (<optional> of boxes, to clear or set)
              op (L_SET_BLACK, L_SET_WHITE)
      Return: pixd (with boxes filled with white or black), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBlackOrWhiteBoxa(*args)
    
    

    try:
        leptonica.pixMaskConnComp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMaskConnComp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMaskConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskConnComp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('BOXA', '**pboxa')       
  pixMaskConnComp()

      Input:  pixs (1 bpp)
              connectivity (4 or 8)
              &boxa (<optional return> bounding boxes of c.c.)
      Return: pixd (1 bpp mask over the c.c.), or null on error

  Notes:
      (1) This generates a mask image with ON pixels over the
          b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,
          pixd will also have no ON pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskConnComp(*args)
    
    

    try:
        leptonica.pixPaintBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixPaintBoxa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixPaintBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_uint32', 'val')       
  pixPaintBoxa()

      Input:  pixs (any depth, can be cmapped)
              boxa (of boxes, to paint)
              val (rgba color to paint)
      Return: pixd (with painted boxes), or null on error

  Notes:
      (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
          and the boxa is painted using a colormap; otherwise,
          it is converted to 32 bpp rgb.
      (2) There are several ways to display a box on an image:
            * Paint it as a solid color
            * Draw the outline
            * Blend the outline or region with the existing image
          We provide painting and drawing here; blending is in blend.c.
          When painting or drawing, the result can be either a
          cmapped image or an rgb image.  The dest will be cmapped
          if the src is either 1 bpp or has a cmap that is not full.
          To force RGB output, use pixConvertTo8(pixs, FALSE)
          before calling any of these paint and draw functions.


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintBoxa(*args)
    
    

    try:
        leptonica.pixDrawBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixDrawBoxa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDrawBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDrawBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_uint32', 'val')       
  pixDrawBoxa()

      Input:  pixs (any depth; can be cmapped)
              boxa (of boxes, to draw)
              width (of lines)
              val (rgba color to draw)
      Return: pixd (with outlines of boxes added), or null on error

  Notes:
      (1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
          and the boxa is drawn using a colormap; otherwise,
          it is converted to 32 bpp rgb.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDrawBoxa(*args)
    
    

    try:
        leptonica.makeMosaicStrips.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makeMosaicStrips.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function makeMosaicStrips not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeMosaicStrips(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'direction')       
('l_int32', 'size')       
  makeMosaicStrips()

      Input:  w, h
              direction (L_SCAN_HORIZONTAL or L_SCAN_VERTICAL)
              size (of strips in the scan direction)
      Return: boxa, or null on error

  Notes:
      (1) For example, this can be used to generate a pixa of
          vertical strips of width 10 from an image, using:
             pixGetDimensions(pix, &w, &h, NULL);
             boxa = makeMosaicStrips(w, h, L_SCAN_HORIZONTAL, 10);
             pixa = pixClipRectangles(pix, boxa);
          All strips except the last will be the same width.  The
          last strip will have width w % 10.


        """
        args = _convert_params(*args)
        
        return leptonica.makeMosaicStrips(*args)
    
    

    try:
        leptonica.boxaaDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaDisplay.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaDisplay(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'linewba')       
('l_int32', 'linewb')       
('l_uint32', 'colorba')       
('l_uint32', 'colorb')       
('l_int32', 'w')       
('l_int32', 'h')       
  boxaaDisplay()

      Input:  baa
              linewba (line width to display boxa)
              linewb (line width to display box)
              colorba (color to display boxa)
              colorb (color to display box)
              w (of pix; use 0 if determined by baa)
              h (of pix; use 0 if determined by baa)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaDisplay(*args)
    
    

    try:
        leptonica.boxaCompareRegions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaCompareRegions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaCompareRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCompareRegions(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', 'areathresh')       
('l_int32', '*pnsame')       
('l_float32', '*pdiffarea')       
('l_float32', '*pdiffxor')       
('PIX', '**ppixdb')       
  boxaCompareRegions()

      Input:  boxa1, boxa2
              areathresh (minimum area of boxes to be considered)
              &pnsame  (<return> true if same number of boxes)
              &pdiffarea (<return> fractional difference in total area)
              &pdiffxor (<optional return> fractional difference
                         in xor of regions)
              &pixdb (<optional return> debug pix showing two boxa)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This takes 2 boxa, removes all boxes smaller than a given area,
          and compares the remaining boxes between the boxa.
      (2) The area threshold is introduced to help remove noise from
          small components.  Any box with a smaller value of w * h
          will be removed from consideration.
      (3) The xor difference is the most stringent test, requiring alignment
          of the corresponding boxes.  It is also more computationally
          intensive and is optionally returned.  Alignment is to the
          UL corner of each region containing all boxes, as given by
          boxaGetExtent().
      (4) Both fractional differences are with respect to the total
          area in the two boxa.  They range from 0.0 to 1.0.
          A perfect match has value 0.0.  If both boxa are empty,
          we return 0.0; if one is empty we return 1.0.
      (5) An example input might be the rectangular regions of a
          segmentation mask for text or images from two pages.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCompareRegions(*args)
    
    

    try:
        leptonica.pixMaskBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMaskBoxa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMaskBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskBoxa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'op')       
  pixMaskBoxa()

      Input:  pixd (<optional> may be null)
              pixs (any depth; not cmapped)
              boxa (of boxes, to paint)
              op (L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS)
      Return: pixd (with masking op over the boxes), or null on error

  Notes:
      (1) This can be used with:
              pixd = NULL  (makes a new pixd)
              pixd = pixs  (in-place)
      (2) If pixd == NULL, this first makes a copy of pixs, and then
          bit-twiddles over the boxes.  Otherwise, it operates directly
          on pixs.
      (3) This simple function is typically used with 1 bpp images.
          It uses the 1-image rasterop function, rasteropUniLow(),
          to set, clear or flip the pixels in pixd.
      (4) If you want to generate a 1 bpp mask of ON pixels from the boxes
          in a Boxa, in a pix of size (w,h):
              pix = pixCreate(w, h, 1);
              pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS);


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskBoxa(*args)
    
    

    try:
        leptonica.pixSplitIntoBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSplitIntoBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSplitIntoBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitIntoBoxa(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minsum')       
('l_int32', 'skipdist')       
('l_int32', 'delta')       
('l_int32', 'maxbg')       
('l_int32', 'maxcomps')       
('l_int32', 'remainder')       
  pixSplitIntoBoxa()

      Input:  pixs (1 bpp)
              minsum  (minimum pixels to trigger propagation)
              skipdist (distance before computing sum for propagation)
              delta (difference required to stop propagation)
              maxbg (maximum number of allowed bg pixels in ref scan)
              maxcomps (use 0 for unlimited number of subdivided components)
              remainder (set to 1 to get b.b. of remaining stuff)
      Return: boxa (of rectangles covering the fg of pixs), or null on error

  Notes:
      (1) This generates a boxa of rectangles that covers
          the fg of a mask.  For each 8-connected component in pixs,
          it does a greedy partitioning, choosing the largest
          rectangle found from each of the four directions at each iter.
          See pixSplitComponentIntoBoxa() for details.
      (2) The input parameters give some flexibility for boundary
          noise.  The resulting set of rectangles may cover some
          bg pixels.
      (3) This should be used when there are a small number of
          mask components, each of which has sides that are close
          to horizontal and vertical.  The input parameters @delta
          and @maxbg determine whether or not holes in the mask are covered.
      (4) The parameter @maxcomps gives the maximum number of allowed
          rectangles extracted from any single connected component.
          Use 0 if no limit is to be applied.
      (5) The flag @remainder specifies whether we take a final bounding
          box for anything left after the maximum number of allowed
          rectangle is extracted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitIntoBoxa(*args)
    
    

    try:
        leptonica.pixPaintBoxaRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixPaintBoxaRandom.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixPaintBoxaRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintBoxaRandom(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
  pixPaintBoxaRandom()

      Input:  pixs (any depth, can be cmapped)
              boxa (of boxes, to paint)
      Return: pixd (with painted boxes), or null on error

  Notes:
      (1) If pixs is 1 bpp, we paint the boxa using a colormap;
          otherwise, we convert to 32 bpp.
      (2) We use up to 254 different colors for painting the regions.
      (3) If boxes overlap, the later ones paint over earlier ones.


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintBoxaRandom(*args)
    
    

    try:
        leptonica.pixSplitComponentIntoBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSplitComponentIntoBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSplitComponentIntoBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitComponentIntoBoxa(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'minsum')       
('l_int32', 'skipdist')       
('l_int32', 'delta')       
('l_int32', 'maxbg')       
('l_int32', 'maxcomps')       
('l_int32', 'remainder')       
  pixSplitComponentIntoBoxa()

      Input:  pixs (1 bpp)
              box (<optional> location of pixs w/rt an origin)
              minsum  (minimum pixels to trigger propagation)
              skipdist (distance before computing sum for propagation)
              delta (difference required to stop propagation)
              maxbg (maximum number of allowed bg pixels in ref scan)
              maxcomps (use 0 for unlimited number of subdivided components)
              remainder (set to 1 to get b.b. of remaining stuff)
      Return: boxa (of rectangles covering the fg of pixs), or null on error

  Notes:
      (1) This generates a boxa of rectangles that covers
          the fg of a mask.  It does so by a greedy partitioning of
          the mask, choosing the largest rectangle found from
          each of the four directions at each step.
      (2) The input parameters give some flexibility for boundary
          noise.  The resulting set of rectangles must cover all
          the fg pixels and, in addition, may cover some bg pixels.
          Using small input parameters on a noiseless mask (i.e., one
          that has only large vertical and horizontal edges) will
          result in a proper covering of only the fg pixels of the mask.
      (3) The input is assumed to be a single connected component, that
          may have holes.  From each side, sweep inward, counting
          the pixels.  If the count becomes greater than @minsum,
          and we have moved forward a further amount @skipdist,
          record that count ('countref'), but don't accept if the scan
          contains more than @maxbg bg pixels.  Continue the scan
          until we reach a count that differs from countref by at
          least @delta, at which point the propagation stops.  The box
          swept out gets a score, which is the sum of fg pixels
          minus a penalty.  The penalty is the number of bg pixels
          in the box.  This is done from all four sides, and the
          side with the largest score is saved as a rectangle.
          The process repeats until there is either no rectangle
          left, or there is one that can't be captured from any
          direction.  For the latter case, we simply accept the
          last rectangle.
      (4) The input box is only used to specify the location of
          the UL corner of pixs, with respect to an origin that
          typically represents the UL corner of an underlying image,
          of which pixs is one component.  If @box is null,
          the UL corner is taken to be (0, 0).
      (5) The parameter @maxcomps gives the maximum number of allowed
          rectangles extracted from any single connected component.
          Use 0 if no limit is to be applied.
      (6) The flag @remainder specifies whether we take a final bounding
          box for anything left after the maximum number of allowed
          rectangle is extracted.
      (7) So if @maxcomps > 0, it specifies that we want no more than
          the first @maxcomps rectangles that satisfy the input
          criteria.  After this, we can get a final rectangle that
          bounds everything left over by setting @remainder == 1.
          If @remainder == 0, we only get rectangles that satisfy
          the input criteria.
      (8) It should be noted that the removal of rectangles can
          break the original c.c. into several c.c.
      (9) Summing up:
            * If @maxcomp == 0, the splitting proceeds as far as possible.
            * If @maxcomp > 0, the splitting stops when @maxcomps are
                found, or earlier if no more components can be selected.
            * If @remainder == 1 and components remain that cannot be
                selected, they are returned as a single final rectangle;
                otherwise, they are ignored.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitComponentIntoBoxa(*args)
    




class boxfunc2(object):
    """   boxfunc2.c

      Boxa/Box transform (shift, scale) and orthogonal rotation
           BOXA            *boxaTransform()
           BOX             *boxTransform()
           BOXA            *boxaTransformOrdered()
           BOX             *boxTransformOrdered()
           BOXA            *boxaRotateOrth()
           BOX             *boxRotateOrth()

      Boxa sort
           BOXA            *boxaSort()
           BOXA            *boxaBinSort()
           BOXA            *boxaSortByIndex()
           BOXAA           *boxaSort2d()
           BOXAA           *boxaSort2dByIndex()

      Boxa statistics
           BOX             *boxaGetRankSize()
           BOX             *boxaGetMedian()
           l_int32          boxaGetAverageSize()

      Boxa array extraction
           l_int32          boxaExtractAsNuma()
           l_int32          boxaExtractAsPta()

      Other Boxaa functions
           l_int32          boxaaGetExtent()
           BOXA            *boxaaFlattenToBoxa()
           BOXA            *boxaaFlattenAligned()
           BOXAA           *boxaEncapsulateAligned()
           l_int32          boxaaAlignBox()

"""
    
    try:
        leptonica.boxaTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.boxaTransform.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaTransform(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  boxaTransform()

      Input:  boxa
              shiftx, shifty
              scalex, scaley
      Return: boxad, or null on error

  Notes:
      (1) This is a very simple function that first shifts, then scales.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaTransform(*args)
    
    

    try:
        leptonica.boxaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSortByIndex.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSortByIndex(*args):
        """
        ('BOXA', '*boxas')       
('NUMA', '*naindex')       
  boxaSortByIndex()

      Input:  boxas
              naindex (na that maps from the new boxa to the input boxa)
      Return: boxad (sorted), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSortByIndex(*args)
    
    

    try:
        leptonica.boxTransformOrdered.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxTransformOrdered.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxTransformOrdered not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxTransformOrdered(*args):
        """
        ('BOX', '*boxs')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'order')       
  boxTransformOrdered()

      Input:  boxs
              shiftx, shifty
              scalex, scaley
              xcen, ycen (center of rotation)
              angle (in radians; clockwise is positive)
              order (one of 6 combinations: L_TR_SC_RO, ...)
      Return: boxd, or null on error

  Notes:
      (1) This allows a sequence of linear transforms, composed of
          shift, scaling and rotation, where the order of the
          transforms is specified.
      (2) The rotation is taken about a point specified by (xcen, ycen).
          Let the components of the vector from the center of rotation
          to the box center be (xdif, ydif):
            xdif = (bx + 0.5 * bw) - xcen
            ydif = (by + 0.5 * bh) - ycen
          Then the box center after rotation has new components:
            bxcen = xcen + xdif * cosa + ydif * sina
            bycen = ycen + ydif * cosa - xdif * sina
          where cosa and sina are the cos and sin of the angle,
          and the enclosing box for the rotated box has size:
            rw = |bw * cosa| + |bh * sina|
            rh = |bh * cosa| + |bw * sina|
          where bw and bh are the unrotated width and height.
          Then the box UL corner (rx, ry) is
            rx = bxcen - 0.5 * rw
            ry = bycen - 0.5 * rh
      (3) The center of rotation specified by args @xcen and @ycen
          is the point BEFORE any translation or scaling.  If the
          rotation is not the first operation, this function finds
          the actual center at the time of rotation.  It does this
          by making the following assumptions:
             (1) Any scaling is with respect to the UL corner, so
                 that the center location scales accordingly.
             (2) A translation does not affect the center of
                 the image; it just moves the boxes.
          We always use assumption (1).  However, assumption (2)
          will be incorrect if the apparent translation is due
          to a clipping operation that, in effect, moves the
          origin of the image.  In that case, you should NOT use
          these simple functions.  Instead, use the functions
          in affinecompose.c, where the rotation center can be
          computed from the actual clipping due to translation
          of the image origin.


        """
        args = _convert_params(*args)
        
        return leptonica.boxTransformOrdered(*args)
    
    

    try:
        leptonica.boxaBinSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaBinSort.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaBinSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaBinSort(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
  boxaBinSort()

      Input:  boxa
              sorttype (L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,
                        L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER)
              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)
              &naindex (<optional return> index of sorted order into
                        original array)
      Return: boxad (sorted version of boxas), or null on error

  Notes:
      (1) For a large number of boxes (say, greater than 1000), this
          O(n) binsort is much faster than the O(nlogn) shellsort.
          For 5000 components, this is over 20x faster than boxaSort().
      (2) Consequently, boxaSort() calls this function if it will
          likely go much faster.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaBinSort(*args)
    
    

    try:
        leptonica.boxaGetAverageSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetAverageSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaGetAverageSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetAverageSize(*args):
        """
        ('BOXA', '*boxa')       
('l_float32', '*pw')       
('l_float32', '*ph')       
  boxaGetAverageSize()

      Input:  boxa
              &w  (<optional return> average width)
              &h  (<optional return> average height)
      Return: 0 if OK, 1 on error or if the boxa is empty


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetAverageSize(*args)
    
    

    try:
        leptonica.boxaRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaRotateOrth.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRotateOrth(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'rotation')       
  boxaRotateOrth()

      Input:  boxa
              w, h (of image in which the boxa is embedded)
              rotation (0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;
                        all rotations are clockwise)
      Return: boxad, or null on error

  Notes:
      (1) See boxRotateOrth() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRotateOrth(*args)
    
    

    try:
        leptonica.boxaaFlattenToBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaFlattenToBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaFlattenToBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaFlattenToBoxa(*args):
        """
        ('BOXAA', '*baa')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       
  boxaaFlattenToBoxa()

      Input:  baa
              &naindex  (<optional return> the boxa index in the baa)
              copyflag  (L_COPY or L_CLONE)
      Return: boxa, or null on error

  Notes:
      (1) This 'flattens' the baa to a boxa, taking the boxes in
          order in the first boxa, then the second, etc.
      (2) If a boxa is empty, we generate an invalid, placeholder box
          of zero size.  This is useful when converting from a baa
          where each boxa has either 0 or 1 boxes, and it is necessary
          to maintain a 1:1 correspondence between the initial
          boxa array and the resulting box array.
      (3) If &naindex is defined, we generate a Numa that gives, for
          each box in the baa, the index of the boxa to which it belongs.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaFlattenToBoxa(*args)
    
    

    try:
        leptonica.boxaTransformOrdered.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaTransformOrdered.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaTransformOrdered not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaTransformOrdered(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'order')       
  boxaTransformOrdered()

      Input:  boxa
              shiftx, shifty
              scalex, scaley
              xcen, ycen (center of rotation)
              angle (in radians; clockwise is positive)
              order (one of 6 combinations: L_TR_SC_RO, ...)
      Return: boxd, or null on error

  Notes:
      (1) This allows a sequence of linear transforms on each box.
          the transforms are from the affine set, composed of
          shift, scaling and rotation, and the order of the
          transforms is specified.
      (2) Although these operations appear to be on an infinite
          2D plane, in practice the region of interest is clipped
          to a finite image.  The center of rotation is usually taken
          with respect to the image (either the UL corner or the
          center).  A translation can have two very different effects:
            (a) Moves the boxes across the fixed image region.
            (b) Moves the image origin, causing a change in the image
                region and an opposite effective translation of the boxes.
          This function should only be used for (a), where the image
          region is fixed on translation.  If the image region is
          changed by the translation, use instead the functions
          in affinecompose.c, where the image region and rotation
          center can be computed from the actual clipping due to
          translation of the image origin.
      (3) See boxTransformOrdered() for usage and implementation details.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaTransformOrdered(*args)
    
    

    try:
        leptonica.boxaaGetExtent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaGetExtent.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaGetExtent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetExtent(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('BOX', '**pbox')       
('BOXA', '**pboxa')       
  boxaaGetExtent()

      Input:  baa
              &w  (<optional return> width)
              &h  (<optional return> height)
              &box (<optional return>, minimum box containing all boxa
                    in boxaa)
              &boxa (<optional return>, boxa containing all boxes in each
                     boxa in the boxaa)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The returned w and h are the minimum size image
          that would contain all boxes untranslated.
      (2) Each box in the returned boxa is the minimum box required to
          hold all the boxes in the respective boxa of baa.
      (3) If there are no valid boxes in a boxa, the box corresponding
          to its extent has all fields set to 0 (an invalid box).


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetExtent(*args)
    
    

    try:
        leptonica.boxaaAlignBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaAlignBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaAlignBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaAlignBox(*args):
        """
        ('BOXAA', '*baa')       
('BOX', '*box')       
('l_int32', 'delta')       
('l_int32', '*pindex')       
  boxaaAlignBox()

      Input:  baa
              box (to be aligned with the bext boxa in the baa, if possible)
              delta (amount by which consecutive components can miss
                     in overlap and still be included in the array)
              &index (of boxa with best overlap, or if none match,
                      this is the index of the next boxa to be generated)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is not greedy.  It finds the boxa whose vertical
          extent has the closest overlap with the input box.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaAlignBox(*args)
    
    

    try:
        leptonica.boxRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxRotateOrth.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxRotateOrth(*args):
        """
        ('BOX', '*box')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'rotation')       
  boxRotateOrth()

      Input:  box
              w, h (of image in which the box is embedded)
              rotation (0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;
                        all rotations are clockwise)
      Return: boxd, or null on error

  Notes:
      (1) Rotate the image with the embedded box by the specified amount.
      (2) After rotation, the rotated box is always measured with
          respect to the UL corner of the image.


        """
        args = _convert_params(*args)
        
        return leptonica.boxRotateOrth(*args)
    
    

    try:
        leptonica.boxaSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaSort.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSort(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
  boxaSort()

      Input:  boxa
              sorttype (L_SORT_BY_X, L_SORT_BY_Y,
                        L_SORT_BY_RIGHT, L_SORT_BY_BOT,
                        L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,
                        L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,
                        L_SORT_BY_PERIMETER, L_SORT_BY_AREA,
                        L_SORT_BY_ASPECT_RATIO)
              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)
              &naindex (<optional return> index of sorted order into
                        original array)
      Return: boxad (sorted version of boxas), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSort(*args)
    
    

    try:
        leptonica.boxaEncapsulateAligned.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaEncapsulateAligned.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaEncapsulateAligned not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaEncapsulateAligned(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'num')       
('l_int32', 'copyflag')       
  boxaEncapsulateAligned()

      Input:  boxa
              num (number put into each boxa in the baa)
              copyflag  (L_COPY or L_CLONE)
      Return: baa, or null on error

  Notes:
      (1) This puts @num boxes from the input @boxa into each of a
          set of boxa within an output baa.
      (2) This assumes that the boxes in @boxa are in sets of @num each.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaEncapsulateAligned(*args)
    
    

    try:
        leptonica.boxaExtractAsPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaExtractAsPta.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaExtractAsPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractAsPta(*args):
        """
        ('BOXA', '*boxa')       
('PTA', '**pptal')       
('PTA', '**pptat')       
('PTA', '**pptar')       
('PTA', '**pptab')       
('l_int32', 'keepinvalid')       
  boxaExtractAsPta()

      Input:  boxa
              &ptal (<optional return> array of left locations vs. index)
              &ptat (<optional return> array of top locations vs. index)
              &ptar (<optional return> array of right locations vs. index)
              &ptab (<optional return> array of bottom locations vs. index)
              keepinvalid (1 to keep invalid boxes; 0 to remove them)
      Return: 0 if OK, 1 on error

      Notes:
          (1) For invalid boxes, this stores the values
              (left, top, right, bot) = (0, 0, -1, -1)
              If you plan to do a least square fit, you must use
              @keepinvalid = 0.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractAsPta(*args)
    
    

    try:
        leptonica.boxaaFlattenAligned.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaFlattenAligned.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaFlattenAligned not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaFlattenAligned(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'num')       
('BOX', '*fillerbox')       
('l_int32', 'copyflag')       
  boxaaFlattenAligned()

      Input:  baa
              num (number extracted from each)
              fillerbox (<optional> that fills if necessary)
              copyflag  (L_COPY or L_CLONE)
      Return: boxa, or null on error

  Notes:
      (1) This 'flattens' the baa to a boxa, taking the first @num
          boxes from each boxa.
      (2) In each boxa, if there are less than @num boxes, we preserve
          the alignment between the input baa and the output boxa
          by inserting one or more fillerbox(es) or, if @fillerbox == NULL,
          one or more invalid placeholder boxes.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaFlattenAligned(*args)
    
    

    try:
        leptonica.boxTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.boxTransform.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxTransform(*args):
        """
        ('BOX', '*box')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  boxTransform()

      Input:  box
              shiftx, shifty
              scalex, scaley
      Return: boxd, or null on error

  Notes:
      (1) This is a very simple function that first shifts, then scales.
      (2) If the box is invalid, a new invalid box is returned.


        """
        args = _convert_params(*args)
        
        return leptonica.boxTransform(*args)
    
    

    try:
        leptonica.boxaSort2dByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSort2dByIndex.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaSort2dByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSort2dByIndex(*args):
        """
        ('BOXA', '*boxas')       
('NUMAA', '*naa')       
  boxaSort2dByIndex()

      Input:  boxas
              naa (numaa that maps from the new baa to the input boxa)
      Return: baa (sorted boxaa), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSort2dByIndex(*args)
    
    

    try:
        leptonica.boxaGetMedian.argtypes = [ctypes.c_void_p]
        leptonica.boxaGetMedian.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaGetMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetMedian(*args):
        """
        ('BOXA', '*boxa')       
  boxaGetMedian()

      Input:  boxa
      Return: box (with median values for x, y, w, h), or null on error
              or if the boxa is empty.

  Notes:
      (1) See boxaGetRankSize()


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetMedian(*args)
    
    

    try:
        leptonica.boxaSort2d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSort2d.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaSort2d not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSort2d(*args):
        """
        ('BOXA', '*boxas')       
('NUMAA', '**pnaad')       
('l_int32', 'delta1')       
('l_int32', 'delta2')       
('l_int32', 'minh1')       
  boxaSort2d()

      Input:  boxas
              &naa (<optional return> numaa with sorted indices
                    whose values are the indices of the input array)
              delta1 (min overlap that permits aggregation of a box
                      onto a boxa of horizontally-aligned boxes; pass 1)
              delta2 (min overlap that permits aggregation of a box
                      onto a boxa of horizontally-aligned boxes; pass 2)
              minh1 (components less than this height either join an
                     existing boxa or are set aside for pass 2)
      Return: baa (2d sorted version of boxa), or null on error

  Notes:
      (1) The final result is a sort where the 'fast scan' direction is
          left to right, and the 'slow scan' direction is from top
          to bottom.  Each boxa in the baa represents a sorted set
          of boxes from left to right.
      (2) Three passes are used to aggregate the boxas, which can correspond
          to characters or words in a line of text.  In pass 1, only
          taller components, which correspond to xheight or larger,
          are permitted to start a new boxa.  In pass 2, the remaining
          vertically-challenged components are allowed to join an
          existing boxa or start a new one.  In pass 3, boxa whose extent
          is overlapping are joined.  After that, the boxes in each
          boxa are sorted horizontally, and finally the boxa are
          sorted vertically.
      (3) If delta1 < 0, the first pass allows aggregation when
          boxes in the same boxa do not overlap vertically.
          The distance by which they can miss and still be aggregated
          is the absolute value |delta1|.   Similar for delta2 on
          the second pass.
      (4) On the first pass, any component of height less than minh1
          cannot start a new boxa; it's put aside for later insertion.
      (5) On the second pass, any small component that doesn't align
          with an existing boxa can start a new one.
      (6) This can be used to identify lines of text from
          character or word bounding boxes.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSort2d(*args)
    
    

    try:
        leptonica.boxaGetRankSize.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.boxaGetRankSize.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaGetRankSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetRankSize(*args):
        """
        ('BOXA', '*boxa')       
('l_float32', 'fract')       
  boxaGetRankSize()

      Input:  boxa
              fract (use 0.0 for smallest, 1.0 for largest)
      Return: box (with rank values for x, y, w, h), or null on error
              or if the boxa is empty (has no valid boxes)

  Notes:
      (1) This function does not assume that all boxes in the boxa are valid
      (2) The four box parameters are sorted independently.
          For rank order, the width and height are sorted in increasing
          order.  But what does it mean to sort x and y in "rank order"?
          If the boxes are of comparable size and somewhat
          aligned (e.g., from multiple images), it makes some sense
          to give a "rank order" for x and y by sorting them in
          decreasing order.  But in general, the interpretation of a rank
          order on x and y is highly application dependent.  In summary:
             - x and y are sorted in decreasing order
             - w and h are sorted in increasing order


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetRankSize(*args)
    
    

    try:
        leptonica.boxaExtractAsNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaExtractAsNuma.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaExtractAsNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractAsNuma(*args):
        """
        ('BOXA', '*boxa')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       
('NUMA', '**pnaw')       
('NUMA', '**pnah')       
('l_int32', 'keepinvalid')       
  boxaExtractAsNuma()

      Input:  boxa
              &nax (<optional return> array of x locations)
              &nay (<optional return> array of y locations)
              &naw (<optional return> array of w locations)
              &nah (<optional return> array of h locations)
              keepinvalid (1 to keep invalid boxes; 0 to remove them)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractAsNuma(*args)
    




class boxfunc1(object):
    """   boxfunc1.c

      Box geometry
           l_int32   boxContains()
           l_int32   boxIntersects()
           BOXA     *boxaContainedInBox()
           BOXA     *boxaIntersectsBox()
           BOXA     *boxaClipToBox()
           BOXA     *boxaCombineOverlaps()
           BOX      *boxOverlapRegion()
           BOX      *boxBoundingRegion()
           l_int32   boxOverlapFraction()
           l_int32   boxOverlapArea()
           BOXA     *boxaHandleOverlaps()
           l_int32   boxSeparationDistance()
           l_int32   boxContainsPt()
           BOX      *boxaGetNearestToPt()
           l_int32   boxIntersectByLine()
           l_int32   boxGetCenter()
           BOX      *boxClipToRectangle()
           l_int32   boxClipToRectangleParams()
           BOX      *boxRelocateOneSide()
           BOX      *boxAdjustSides()
           BOXA     *boxaSetSide()
           BOXA     *boxaAdjustWidthToTarget()
           BOXA     *boxaAdjustHeightToTarget()
           l_int32   boxEqual()
           l_int32   boxaEqual()
           l_int32   boxSimilar()
           l_int32   boxaSimilar()

      Boxa combine and split
           l_int32   boxaJoin()
           l_int32   boxaaJoin()
           l_int32   boxaSplitEvenOdd()
           BOXA     *boxaMergeEvenOdd()

"""
    
    try:
        leptonica.boxaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaJoin(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  boxaJoin()

      Input:  boxad  (dest boxa; add to this one)
              boxas  (source boxa; add from this one)
              istart  (starting index in boxas)
              iend  (ending index in boxas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This appends a clone of each indicated box in boxas to boxad
      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (3) iend < 0 means 'read to the end'
      (4) if boxas == NULL or has no boxes, this is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaJoin(*args)
    
    

    try:
        leptonica.boxaSplitEvenOdd.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSplitEvenOdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaSplitEvenOdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSplitEvenOdd(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'fillflag')       
('BOXA', '**pboxae')       
('BOXA', '**pboxao')       
  boxaSplitEvenOdd()

      Input:  boxa
              fillflag (1 to put invalid boxes in place; 0 to omit)
              &boxae, &boxao (<return> save even and odd boxes in their
                 separate boxa, setting the other type to invalid boxes.)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If @fillflag == 1, boxae has copies of the even boxes
          in their original location, and nvalid boxes are placed
          in the odd array locations.  And v.v.
      (2) If @fillflag == 0, boxae has only copies of the even boxes.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSplitEvenOdd(*args)
    
    

    try:
        leptonica.boxaAdjustHeightToTarget.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaAdjustHeightToTarget.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaAdjustHeightToTarget not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAdjustHeightToTarget(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'sides')       
('l_int32', 'target')       
('l_int32', 'thresh')       
  boxaAdjustHeightToTarget()

      Input:  boxad (use null to get a new one)
              boxas
              sides (L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT)
              target (target height if differs by more than thresh)
              thresh (min abs difference in height to cause adjustment)
      Return: boxad, or null on error

  Notes:
      (1) Conditionally adjusts the height of each box, by moving
          the indicated edges (top and/or bot) if the height differs
          by @thresh or more from @target.
      (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
          Use one of these:
               boxad = boxaAdjustHeightToTarget(NULL, boxas, ...);   // new
               boxaAdjustHeightToTarget(boxas, boxas, ...);  // in-place


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAdjustHeightToTarget(*args)
    
    

    try:
        leptonica.boxOverlapArea.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapArea.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxOverlapArea not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapArea(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*parea')       
  boxOverlapArea()

      Input:  box1, box2 (two boxes)
              &area (<return> the number of pixels in the overlap)
      Return: 0 if OK, 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapArea(*args)
    
    

    try:
        leptonica.boxaGetNearestToPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetNearestToPt.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaGetNearestToPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetNearestToPt(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'x')       
('l_int32', 'y')       
  boxaGetNearestToPt()

      Input:  boxa
              x, y  (point)
      Return  box (box with centroid closest to the given point [x,y]),
              or NULL if no boxes in boxa)

  Notes:
      (1) Uses euclidean distance between centroid and point.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetNearestToPt(*args)
    
    

    try:
        leptonica.boxClipToRectangle.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxClipToRectangle.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxClipToRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxClipToRectangle(*args):
        """
        ('BOX', '*box')       
('l_int32', 'wi')       
('l_int32', 'hi')       
  boxClipToRectangle()

      Input:  box
              wi, hi (rectangle representing image)
      Return: part of box within given rectangle, or NULL on error
              or if box is entirely outside the rectangle

  Notes:
      (1) This can be used to clip a rectangle to an image.
          The clipping rectangle is assumed to have a UL corner at (0, 0),
          and a LR corner at (wi - 1, hi - 1).


        """
        args = _convert_params(*args)
        
        return leptonica.boxClipToRectangle(*args)
    
    

    try:
        leptonica.boxGetCenter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxGetCenter.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxGetCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetCenter(*args):
        """
        ('BOX', '*box')       
('l_float32', '*pcx')       
('l_float32', '*pcy')       
  boxGetCenter()

      Input:  box
              &cx, &cy (<return> location of center of box)
      Return  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetCenter(*args)
    
    

    try:
        leptonica.boxaSimilar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaSimilar.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaSimilar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSimilar(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', 'leftdiff')       
('l_int32', 'rightdiff')       
('l_int32', 'topdiff')       
('l_int32', 'botdiff')       
('l_int32', 'debugflag')       
('l_int32', '*psimilar')       
  boxaSimilar()

      Input:  boxa1
              boxa2
              leftdiff, rightdiff, topdiff, botdiff
              debugflag (output details of non-similar boxes)
              &similar (<return> 1 if similar; 0 otherwise)
      Return  0 if OK, 1 on error

  Notes:
      (1) See boxSimilar() for parameter usage.
      (2) Corresponding boxes are taken in order in the two boxa.
      (3) With debugflag == 1, boxes continue to be tested after failure.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSimilar(*args)
    
    

    try:
        leptonica.boxaIntersectsBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaIntersectsBox.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaIntersectsBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaIntersectsBox(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       
  boxaIntersectsBox()

      Input:  boxas
              box (for intersecting)
      Return  boxad (boxa with all boxes in boxas that intersect box),
                     or null on error

  Notes:
      (1) All boxes in boxa that intersect with box (i.e., are completely
          or partially contained in box) are retained.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaIntersectsBox(*args)
    
    

    try:
        leptonica.boxaSetSide.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSetSide.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaSetSide not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSetSide(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'side')       
('l_int32', 'val')       
('l_int32', 'thresh')       
  boxaSetSide()

      Input:  boxad (use null to get a new one; same as boxas for in-place)
              boxas
              side (L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT)
              val (location to set for given side, for each box)
              thresh (min abs difference to cause resetting to @val)
      Return: boxad, or null on error

  Notes:
      (1) Sets the given side of each box.  Use boxad == NULL for a new
          boxa, and boxad == boxas for in-place.
      (2) Use one of these:
               boxad = boxaSetSide(NULL, boxas, ...);   // new
               boxaSetSide(boxas, boxas, ...);  // in-place


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSetSide(*args)
    
    

    try:
        leptonica.boxClipToRectangleParams.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxClipToRectangleParams.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxClipToRectangleParams not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxClipToRectangleParams(*args):
        """
        ('BOX', '*box')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', '*pxstart')       
('l_int32', '*pystart')       
('l_int32', '*pxend')       
('l_int32', '*pyend')       
('l_int32', '*pbw')       
('l_int32', '*pbh')       
  boxClipToRectangleParams()

      Input:  box (<optional> requested box; can be null)
              w, h (clipping box size; typ. the size of an image)
              &xstart (<return>)
              &ystart (<return>)
              &xend (<return> one pixel beyond clipping box)
              &yend (<return> one pixel beyond clipping box)
              &bw (<optional return> clipped width)
              &bh (<optional return> clipped height)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The return value should be checked.  If it is 1, the
          returned parameter values are bogus.
      (2) This simplifies the selection of pixel locations within
          a given rectangle:
             for (i = ystart; i < yend; i++ {
                 ...
                 for (j = xstart; j < xend; j++ {
                     ....


        """
        args = _convert_params(*args)
        
        return leptonica.boxClipToRectangleParams(*args)
    
    

    try:
        leptonica.boxContainsPt.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.boxContainsPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxContainsPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxContainsPt(*args):
        """
        ('BOX', '*box')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', '*pcontains')       
  boxContainsPt()

      Input:  box
              x, y (a point)
              &contains (<return> 1 if box contains point; 0 otherwise)
      Return: 0 if OK, 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.boxContainsPt(*args)
    
    

    try:
        leptonica.boxBoundingRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxBoundingRegion.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxBoundingRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxBoundingRegion(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
  boxBoundingRegion()

      Input:  box1, box2 (two boxes)
      Return: box (of bounding region containing the input boxes),
              or null on error

  Notes:
      (1) This is the geometric union of the two rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.boxBoundingRegion(*args)
    
    

    try:
        leptonica.boxIntersects.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxIntersects.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxIntersects not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxIntersects(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*presult')       
  boxIntersects()

      Input:  box1, box2
              &result (<return> 1 if any part of box2 is contained
                      in box1, and 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxIntersects(*args)
    
    

    try:
        leptonica.boxOverlapFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapFraction.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxOverlapFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapFraction(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_float32', '*pfract')       
  boxOverlapFraction()

      Input:  box1, box2 (two boxes)
              &fract (<return> the fraction of box2 overlapped by box1)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) The result depends on the order of the input boxes,
          because the overlap is taken as a fraction of box2.


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapFraction(*args)
    
    

    try:
        leptonica.boxEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxEqual.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxEqual(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*psame')       
  boxEqual()

      Input:  box1
              box2
              &same (<return> 1 if equal; 0 otherwise)
      Return  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxEqual(*args)
    
    

    try:
        leptonica.boxaCombineOverlaps.argtypes = [ctypes.c_void_p]
        leptonica.boxaCombineOverlaps.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaCombineOverlaps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCombineOverlaps(*args):
        """
        ('BOXA', '*boxas')       
  boxaCombineOverlaps()

      Input:  boxas
      Return: boxad (where each set of boxes in boxas that overlap are
                     combined into a single bounding box in boxad), or
                     null on error.

  Notes:
      (1) If there are no overlapping boxes, it simply returns a copy
          of @boxas.
      (2) The alternative method of painting each rectanle and finding
          the 4-connected components gives the wrong result, because
          two non-overlapping rectangles, when rendered, can still
          be 4-connected, and hence they will be joined.
      (3) A bad case is to have n boxes, none of which overlap.
          Then you have one iteration with O(n^2) compares.  This
          is still faster than painting each rectangle and finding
          the connected components, even for thousands of rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCombineOverlaps(*args)
    
    

    try:
        leptonica.boxaMergeEvenOdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaMergeEvenOdd.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaMergeEvenOdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaMergeEvenOdd(*args):
        """
        ('BOXA', '*boxae')       
('BOXA', '*boxao')       
('l_int32', 'fillflag')       
  boxaMergeEvenOdd()

      Input:  boxae (boxes to go in even positions in merged boxa)
              boxao (boxes to go in odd positions in merged boxa)
              fillflag (1 if there are invalid boxes in placeholders)
      Return: boxad (merged), or null on error

  Notes:
      (1) This is essentially the inverse of boxaSplitEvenOdd().
          Typically, boxae and boxao were generated by boxaSplitEvenOdd(),
          and the value of @fillflag needs to be the same in both calls.
      (2) If @fillflag == 1, both boxae and boxao are of the same size;
          otherwise boxae may have one more box than boxao.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaMergeEvenOdd(*args)
    
    

    try:
        leptonica.boxaHandleOverlaps.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.boxaHandleOverlaps.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaHandleOverlaps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaHandleOverlaps(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'op')       
('l_int32', 'range')       
('l_float32', 'min_overlap')       
('l_float32', 'max_ratio')       
('NUMA', '**pnamap')       
  boxaHandleOverlaps()

      Input:  boxas
              op (L_COMBINE, L_REMOVE_SMALL)
              range (> 0, forward distance over which overlaps are checked)
              min_overlap (minimum fraction of smaller box required for
                           overlap to count; 0.0 to ignore)
              max_ratio (maximum fraction of small/large areas for
                         overlap to count; 1.0 to ignore)
              &namap (<optional return> combining map)
      Return: boxad, or null on error.

  Notes:
      (1) For all n(n-1)/2 box pairings, if two boxes overlap, either:
          (a) op == L_COMBINE: get the bounding region for the two,
              replace the larger with the bounding region, and remove
              the smaller of the two, or
          (b) op == L_REMOVE_SMALL: just remove the smaller.
      (2) If boxas is 2D sorted, range can be small, but if it is
          not spatially sorted, range should be large to allow all
          pairwise comparisons to be made.
      (3) The @min_overlap parameter allows ignoring small overlaps.
          If @min_overlap == 1.0, only boxes fully contained in larger
          boxes can be considered for removal; if @min_overlap == 0.0,
          this constraint is ignored.
      (4) The @max_ratio parameter allows ignoring overlaps between
          boxes that are not too different in size.  If @max_ratio == 0.0,
          no boxes can be removed; if @max_ratio == 1.0, this constraint
          is ignored.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaHandleOverlaps(*args)
    
    

    try:
        leptonica.boxaClipToBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaClipToBox.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaClipToBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaClipToBox(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       
  boxaClipToBox()

      Input:  boxas
              box (for clipping)
      Return  boxad (boxa with boxes in boxas clipped to box),
                     or null on error

  Notes:
      (1) All boxes in boxa not intersecting with box are removed, and
          the remaining boxes are clipped to box.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaClipToBox(*args)
    
    

    try:
        leptonica.boxaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaJoin(*args):
        """
        ('BOXAA', '*baad')       
('BOXAA', '*baas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  boxaaJoin()

      Input:  baad  (dest boxaa; add to this one)
              baas  (source boxaa; add from this one)
              istart  (starting index in baas)
              iend  (ending index in baas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This appends a clone of each indicated boxa in baas to baad
      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (3) iend < 0 means 'read to the end'
      (4) if baas == NULL, this is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaJoin(*args)
    
    

    try:
        leptonica.boxSeparationDistance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxSeparationDistance.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxSeparationDistance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSeparationDistance(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*ph_sep')       
('l_int32', '*pv_sep')       
  boxSeparationDistance()

      Input:  box1, box2 (two boxes, in any order)
              &h_sep (<optional return> horizontal separation)
              &v_sep (<optional return> vertical separation)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This measures horizontal and vertical separation of the
          two boxes.  If the boxes are touching but have no pixels
          in common, the separation is 0.  If the boxes overlap by
          a distance d, the returned separation is -d.


        """
        args = _convert_params(*args)
        
        return leptonica.boxSeparationDistance(*args)
    
    

    try:
        leptonica.boxaAdjustWidthToTarget.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaAdjustWidthToTarget.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaAdjustWidthToTarget not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAdjustWidthToTarget(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'sides')       
('l_int32', 'target')       
('l_int32', 'thresh')       
  boxaAdjustWidthToTarget()

      Input:  boxad (use null to get a new one; same as boxas for in-place)
              boxas
              sides (L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFTL_AND_RIGHT)
              target (target width if differs by more than thresh)
              thresh (min abs difference in width to cause adjustment)
      Return: boxad, or null on error

  Notes:
      (1) Conditionally adjusts the width of each box, by moving
          the indicated edges (left and/or right) if the width differs
          by @thresh or more from @target.
      (2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
          Use one of these:
               boxad = boxaAdjustWidthToTarget(NULL, boxas, ...);   // new
               boxaAdjustWidthToTarget(boxas, boxas, ...);  // in-place


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAdjustWidthToTarget(*args)
    
    

    try:
        leptonica.boxContains.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxContains.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxContains not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxContains(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*presult')       
  boxContains()

      Input:  box1, box2
              &result (<return> 1 if box2 is entirely contained within
                       box1, and 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxContains(*args)
    
    

    try:
        leptonica.boxOverlapRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapRegion.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxOverlapRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapRegion(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
  boxOverlapRegion()

      Input:  box1, box2 (two boxes)
      Return: box (of overlap region between input boxes),
              or null if no overlap or on error

  Notes:
      (1) This is the geometric intersection of the two rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapRegion(*args)
    
    

    try:
        leptonica.boxAdjustSides.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxAdjustSides.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxAdjustSides not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxAdjustSides(*args):
        """
        ('BOX', '*boxd')       
('BOX', '*boxs')       
('l_int32', 'delleft')       
('l_int32', 'delright')       
('l_int32', 'deltop')       
('l_int32', 'delbot')       
  boxAdjustSides()

      Input:  boxd  (<optional>; this can be null, equal to boxs,
                     or different from boxs)
              boxs  (starting box; to have sides adjusted)
              delleft, delright, deltop, delbot (changes in location of
                                                 each side)
      Return: boxd, or null on error or if the computed boxd has
              width or height <= 0.

  Notes:
      (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
          or otherwise to resize existing boxd.
      (2) For usage, suggest one of these:
               boxd = boxAdjustSides(NULL, boxs, ...);   // new
               boxAdjustSides(boxs, boxs, ...);          // in-place
               boxAdjustSides(boxd, boxs, ...);          // other
      (1) New box dimensions are cropped at left and top to x >= 0 and y >= 0.
      (2) For example, to expand in-place by 20 pixels on each side, use
             boxAdjustSides(box, box, -20, 20, -20, 20);


        """
        args = _convert_params(*args)
        
        return leptonica.boxAdjustSides(*args)
    
    

    try:
        leptonica.boxaContainedInBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaContainedInBox.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaContainedInBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaContainedInBox(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       
  boxaContainedInBox()

      Input:  boxas
              box (for containment)
      Return: boxad (boxa with all boxes in boxas that are
                     entirely contained in box), or null on error

  Notes:
      (1) All boxes in boxa that are entirely outside box are removed.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaContainedInBox(*args)
    
    

    try:
        leptonica.boxIntersectByLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxIntersectByLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxIntersectByLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxIntersectByLine(*args):
        """
        ('BOX', '*box')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'slope')       
('l_int32', '*px1')       
('l_int32', '*py1')       
('l_int32', '*px2')       
('l_int32', '*py2')       
('l_int32', '*pn')       
  boxIntersectByLine()

      Input:  box
              x, y (point that line goes through)
              slope (of line)
              (&x1, &y1) (<return> 1st point of intersection with box)
              (&x2, &y2) (<return> 2nd point of intersection with box)
              &n (<return> number of points of intersection)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If the intersection is at only one point (a corner), the
          coordinates are returned in (x1, y1).
      (2) Represent a vertical line by one with a large but finite slope.


        """
        args = _convert_params(*args)
        
        return leptonica.boxIntersectByLine(*args)
    
    

    try:
        leptonica.boxRelocateOneSide.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxRelocateOneSide.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxRelocateOneSide not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxRelocateOneSide(*args):
        """
        ('BOX', '*boxd')       
('BOX', '*boxs')       
('l_int32', 'loc')       
('l_int32', 'sideflag')       
  boxRelocateOneSide()

      Input:  boxd (<optional>; this can be null, equal to boxs,
                    or different from boxs);
              boxs (starting box; to have one side relocated)
              loc (new location of the side that is changing)
              sideflag (L_FROM_LEFT, etc., indicating the side that moves)
      Return: boxd, or null on error or if the computed boxd has
              width or height <= 0.

  Notes:
      (1) Set boxd == NULL to get new box; boxd == boxs for in-place;
          or otherwise to resize existing boxd.
      (2) For usage, suggest one of these:
               boxd = boxRelocateOneSide(NULL, boxs, ...);   // new
               boxRelocateOneSide(boxs, boxs, ...);          // in-place
               boxRelocateOneSide(boxd, boxs, ...);          // other


        """
        args = _convert_params(*args)
        
        return leptonica.boxRelocateOneSide(*args)
    
    

    try:
        leptonica.boxaEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaEqual.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaEqual(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', 'maxdist')       
('NUMA', '**pnaindex')       
('l_int32', '*psame')       
  boxaEqual()

      Input:  boxa1
              boxa2
              maxdist
              &naindex (<optional return> index array of correspondences
              &same (<return> 1 if equal; 0 otherwise)
      Return  0 if OK, 1 on error

  Notes:
      (1) The two boxa are the "same" if they contain the same
          boxes and each box is within @maxdist of its counterpart
          in their positions within the boxa.  This allows for
          small rearrangements.  Use 0 for maxdist if the boxa
          must be identical.
      (2) This applies only to geometry and ordering; refcounts
          are not considered.
      (3) @maxdist allows some latitude in the ordering of the boxes.
          For the boxa to be the "same", corresponding boxes must
          be within @maxdist of each other.  Note that for large
          @maxdist, we should use a hash function for efficiency.
      (4) naindex[i] gives the position of the box in boxa2 that
          corresponds to box i in boxa1.  It is only returned if the
          boxa are equal.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaEqual(*args)
    
    

    try:
        leptonica.boxSimilar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxSimilar.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxSimilar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSimilar(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', 'leftdiff')       
('l_int32', 'rightdiff')       
('l_int32', 'topdiff')       
('l_int32', 'botdiff')       
('l_int32', '*psimilar')       
  boxSimilar()

      Input:  box1
              box2
              leftdiff, rightdiff, topdiff, botdiff
              &similar (<return> 1 if similar; 0 otherwise)
      Return  0 if OK, 1 on error

  Notes:
      (1) The values of leftdiff (etc) are the maximum allowed deviations
          between the locations of the left (etc) sides.  If any side
          pairs differ by more than this amount, the boxes are not similar.


        """
        args = _convert_params(*args)
        
        return leptonica.boxSimilar(*args)
    




class textops(object):
    """  textops.c

    Font layout
       PIX             *pixAddSingleTextblock()
       PIX             *pixAddSingleTextline()
       l_int32          pixSetTextblock()
       l_int32          pixSetTextline()
       PIXA            *pixaAddTextNumber()
       PIXA            *pixaAddTextline()

    Text size estimation and partitioning
       SARRAY          *bmfGetLineStrings()
       NUMA            *bmfGetWordWidths()
       l_int32          bmfGetStringWidth()

    Text splitting
       SARRAY          *splitStringToParagraphs()
       static l_int32   stringAllWhitespace()
       static l_int32   stringLeadingWhitespace()

    This is a simple utility to put text on images.  One font and style
    is provided, with a variety of pt sizes.  For example, to put a
    line of green 10 pt text on an image, with the beginning baseline
    at (50, 50):
        L_Bmf  *bmf = bmfCreate("./fonts", 10);
        const char *textstr = "This is a funny cat";
        pixSetTextline(pixs, bmf, textstr, 0x00ff0000, 50, 50, NULL, NULL);

    The simplest interfaces for adding text to an image are
    pixAddSingleTextline() and pixAddSingleTextblock().

"""
    
    try:
        leptonica.bmfGetWordWidths.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bmfGetWordWidths.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function bmfGetWordWidths not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetWordWidths(*args):
        """
        ('L_BMF', '*bmf')       
('const char', '*textstr')       
('SARRAY', '*sa')       
  bmfGetWordWidths()

      Input:  bmf
              textstr
              sa (of individual words)
      Return: numa (of word lengths in pixels for the font represented
                    by the bmf), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetWordWidths(*args)
    
    

    try:
        leptonica.splitStringToParagraphs.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.splitStringToParagraphs.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function splitStringToParagraphs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def splitStringToParagraphs(*args):
        """
        ('char', '*textstr')       
('l_int32', 'splitflag')       
  splitStringToParagraphs()

      Input:  textstring
              splitting flag (see enum in bmf.h; valid values in {1,2,3})
      Return: sarray (where each string is a paragraph of the input),
                      or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.splitStringToParagraphs(*args)
    
    

    try:
        leptonica.pixSetTextline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetTextline.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetTextline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetTextline(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_int32', '*pwidth')       
('l_int32', '*poverflow')       
  pixSetTextline()

      Input:  pixs (input image)
              bmf (bitmap font data)
              textstr (text string to be set on the line)
              val (color to set the text)
              x0 (left edge for first char)
              y0 (baseline location for all text on line)
              &width (<optional return> width of generated text)
              &overflow (<optional return> 0 if text is contained in
                         input pix; 1 if it is clipped)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function paints a line of text over an image.
      (2) @val is the pixel value to be painted through the font mask.
          It should be chosen to agree with the depth of pixs.
          If it is out of bounds, an intermediate value is chosen.
          For RGB, use hex notation: 0xRRGGBB00, where RR is the
          hex representation of the red intensity, etc.
          The last two hex digits are 00 (byte value 0), assigned to
          the A component.  Note that, as usual, RGBA proceeds from
          left to right in the order from MSB to LSB (see pix.h
          for details).
      (3) If there is a colormap, this does the best it can to use
          the requested color, or something similar to it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetTextline(*args)
    
    

    try:
        leptonica.pixAddSingleTextblock.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAddSingleTextblock.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddSingleTextblock not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddSingleTextblock(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       
('l_int32', '*poverflow')       
  pixAddSingleTextblock()

      Input:  pixs (input pix; colormap ok)
              bmf (bitmap font data)
              textstr (<optional> text string to be added)
              val (color to set the text)
              location (L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW)
              &overflow (<optional return> 1 if text overflows
                         allocated region and is clipped; 0 otherwise)
      Return: pixd (new pix with rendered text), or either a copy
                    or null on error

  Notes:
      (1) This function paints a set of lines of text over an image.
          If @location is L_ADD_ABOVE or L_ADD_BELOW, the pix size
          is expanded with a border and rendered over the border.
      (2) @val is the pixel value to be painted through the font mask.
          It should be chosen to agree with the depth of pixs.
          If it is out of bounds, an intermediate value is chosen.
          For RGB, use hex notation: 0xRRGGBB00, where RR is the
          hex representation of the red intensity, etc.
      (3) If textstr == NULL, use the text field in the pix.
      (4) If there is a colormap, this does the best it can to use
          the requested color, or something similar to it.
      (5) Typical usage is for labelling a pix with some text data.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddSingleTextblock(*args)
    
    

    try:
        leptonica.bmfGetLineStrings.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.bmfGetLineStrings.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function bmfGetLineStrings not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetLineStrings(*args):
        """
        ('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_int32', 'maxw')       
('l_int32', 'firstindent')       
('l_int32', '*ph')       
  bmfGetLineStrings()

      Input:  bmf
              textstr
              maxw (max width of a text line in pixels)
              firstindent (indentation of first line, in x-widths)
              &h (<return> height required to hold text bitmap)
      Return: sarray of text strings for each line, or null on error

  Notes:
      (1) Divides the input text string into an array of text strings,
          each of which will fit within maxw bits of width.


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetLineStrings(*args)
    
    

    try:
        leptonica.pixaAddTextline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixaAddTextline.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaAddTextline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddTextline(*args):
        """
        ('PIXA', '*pixas')       
('L_BMF', '*bmf')       
('SARRAY', '*sa')       
('l_uint32', 'val')       
('l_int32', 'location')       
  pixaAddTextline()

      Input:  pixas (input pixa; colormap ok)
              bmf (bitmap font data)
              sa (<optional> sarray; use text embedded in each pix if null)
              val (color to set the text)
              location (L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT)
      Return: pixad (new pixa with rendered text), or null on error

  Notes:
      (1) This function paints a line of text external to each pix,
          in a position given by @location.  In all cases, the pix is
          expanded as necessary to accommodate the text.
      (2) @val is the pixel value to be painted through the font mask.
          It should be chosen to agree with the depth of pixs.
          If it is out of bounds, an intermediate value is chosen.
          For RGB, use hex notation: 0xRRGGBB00, where RR is the
          hex representation of the red intensity, etc.
      (3) If sa == NULL, use the text embedded in each pix.
      (4) If sa has a smaller count than pixa, issue a warning
          but do not use any embedded text.
      (5) If there is a colormap, this does the best it can to use
          the requested color, or something similar to it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddTextline(*args)
    
    

    try:
        leptonica.bmfGetStringWidth.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bmfGetStringWidth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bmfGetStringWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetStringWidth(*args):
        """
        ('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_int32', '*pw')       
  bmfGetStringWidth()

      Input:  bmf
              textstr
              &w (<return> width of text string, in pixels for the
                 font represented by the bmf)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetStringWidth(*args)
    
    

    try:
        leptonica.pixSetTextblock.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSetTextblock.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetTextblock not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetTextblock(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_int32', 'wtext')       
('l_int32', 'firstindent')       
('l_int32', '*poverflow')       
  pixSetTextblock()

      Input:  pixs (input image)
              bmf (bitmap font data)
              textstr (block text string to be set)
              val (color to set the text)
              x0 (left edge for each line of text)
              y0 (baseline location for the first text line)
              wtext (max width of each line of generated text)
              firstindent (indentation of first line, in x-widths)
              &overflow (<optional return> 0 if text is contained in
                         input pix; 1 if it is clipped)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function paints a set of lines of text over an image.
      (2) @val is the pixel value to be painted through the font mask.
          It should be chosen to agree with the depth of pixs.
          If it is out of bounds, an intermediate value is chosen.
          For RGB, use hex notation: 0xRRGGBB00, where RR is the
          hex representation of the red intensity, etc.
          The last two hex digits are 00 (byte value 0), assigned to
          the A component.  Note that, as usual, RGBA proceeds from
          left to right in the order from MSB to LSB (see pix.h
          for details).
      (3) If there is a colormap, this does the best it can to use
          the requested color, or something similar to it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetTextblock(*args)
    
    

    try:
        leptonica.pixaAddTextNumber.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixaAddTextNumber.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaAddTextNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddTextNumber(*args):
        """
        ('PIXA', '*pixas')       
('L_BMF', '*bmf')       
('NUMA', '*na')       
('l_uint32', 'val')       
('l_int32', 'location')       
  pixaAddTextNumber()

      Input:  pixas (input pixa; colormap ok)
              bmf (bitmap font data)
              numa (<optional> number array; use 1 ... n if null)
              val (color to set the text)
              location (L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT)
      Return: pixad (new pixa with rendered numbers), or null on error

  Notes:
      (1) Typical usage is for labelling each pix in a pixa with a number.
      (2) This function paints numbers external to each pix, in a position
          given by @location.  In all cases, the pix is expanded on
          on side and the number is painted over white in the added region.
      (3) @val is the pixel value to be painted through the font mask.
          It should be chosen to agree with the depth of pixs.
          If it is out of bounds, an intermediate value is chosen.
          For RGB, use hex notation: 0xRRGGBB00, where RR is the
          hex representation of the red intensity, etc.
      (4) If na == NULL, number each pix sequentially, starting with 1.
      (5) If there is a colormap, this does the best it can to use
          the requested color, or something similar to it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddTextNumber(*args)
    
    

    try:
        leptonica.pixAddSingleTextline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixAddSingleTextline.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddSingleTextline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddSingleTextline(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       
  pixAddSingleTextline()

      Input:  pixs (input pix; colormap ok)
              bmf (bitmap font data)
              textstr (<optional> text string to be added)
              val (color to set the text)
              location (L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT)
      Return: pixd (new pix with rendered text), or either a copy
                    or null on error

  Notes:
      (1) This function expands an image as required to paint a single
          line of text adjacent to the image.  If @bmf == NULL, this
          returns a copy.
      (2) @val is the pixel value to be painted through the font mask.
          It should be chosen to agree with the depth of pixs.
          If it is out of bounds, an intermediate value is chosen.
          For RGB, use hex notation: 0xRRGGBB00, where RR is the
          hex representation of the red intensity, etc.
      (3) If textstr == NULL, use the text field in the pix.
      (4) If there is a colormap, this does the best it can to use
          the requested color, or something similar to it.
      (5) Typical usage is for labelling a pix with some text data.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddSingleTextline(*args)
    




class colorquant2(object):
    """  colorquant2.c

  Modified median cut color quantization

      High level
          PIX              *pixMedianCutQuant()
          PIX              *pixMedianCutQuantGeneral()
          PIX              *pixMedianCutQuantMixed()
          PIX              *pixFewColorsMedianCutQuantMixed()

      Median cut indexed histogram
          l_int32          *pixMedianCutHisto()

      Static helpers
          static PIXCMAP   *pixcmapGenerateFromHisto()
          static PIX       *pixQuantizeWithColormap()
          static void       getColorIndexMedianCut()
          static L_BOX3D   *pixGetColorRegion()
          static l_int32    medianCutApply()
          static PIXCMAP   *pixcmapGenerateFromMedianCuts()
          static l_int32    vboxGetAverageColor()
          static l_int32    vboxGetCount()
          static l_int32    vboxGetVolume()
          static L_BOX3D   *box3dCreate();
          static L_BOX3D   *box3dCopy();

   Paul Heckbert published the median cut algorithm, "Color Image
   Quantization for Frame Buffer Display," in Proc. SIGGRAPH '82,
   Boston, July 1982, pp. 297-307.  A copy of the paper without
   figures can be found on the web.

   Median cut starts with either the full color space or the occupied
   region of color space.  If you're not dithering, the occupied region
   can be used, but with dithering, pixels can end up in any place
   in the color space, so you must represent the entire color space in
   the final colormap.

   Color components are quantized to typically 5 or 6 significant
   bits (for each of r, g and b).   Call a 3D region of color
   space a 'vbox'.  Any color in this quantized space is represented
   by an element of a linear histogram array, indexed by rgb value.
   The initial region is then divided into two regions that have roughly
   equal pixel occupancy (hence the name "median cut").  Subdivision
   continues until the requisite number of vboxes has been generated.

   But the devil is in the details of the subdivision process.
   Here are some choices that you must make:
     (1) Along which axis to subdivide?
     (2) Which box to put the bin with the median pixel?
     (3) How to order the boxes for subdivision?
     (4) How to adequately handle boxes with very small numbers of pixels?
     (5) How to prevent a little-represented but highly visible color
         from being masked out by other colors in its vbox.

   Taking these in order:
     (1) Heckbert suggests using either the largest vbox side, or the vbox
         side with the largest variance in pixel occupancy.  We choose
         to divide based on the largest vbox side.
     (2) Suppose you've chosen a side.  Then you have a histogram
         of pixel occupancy in 2D slices of the vbox.  One of those
         slices includes the median pixel.  Suppose there are L bins
         to the left (smaller index) and R bins to the right.  Then
         this slice (or bin) should be assigned to the box containing
         the smaller of L and R.  This both shortens the larger
         of the subdivided dimensions and helps a low-count color
         far from the subdivision boundary to better express itself.
     (2a) One can also ask if the boundary should be moved even
         farther into the longer side.  This is feasable if we have
         a method for doing extra subdivisions on the high count
         vboxes.  And we do (see (3)).
     (3) To make sure that the boxes are subdivided toward equal
         occupancy, use an occupancy-sorted priority queue, rather
         than a simple queue.
     (4) With a priority queue, boxes with small number of pixels
         won't be repeatedly subdivided.  This is good.
     (5) Use of a priority queue allows tricks such as in (2a) to let
         small occupancy clusters be better expressed.  In addition,
         rather than splitting near the median, small occupancy colors
         are best reproduced by cutting half-way into the longer side.

   However, serious problems can arise with dithering if a priority
   queue is used based on population alone.  If the picture has
   large regions of nearly constant color, some vboxes can be very
   large and have a sizeable population (but not big enough to get to
   the head of the queue).  If one of these large, occupied vboxes
   is near in color to a nearly constant color region of the
   image, dithering can inject pixels from the large vbox into
   the nearly uniform region.  These pixels can be very far away
   in color, and the oscillations are highly visible.  To prevent
   this, we can take either or both of these actions:

     (1) Subdivide a fraction (< 1.0) based on population, and
         do the rest of the subdivision based on the product of
         the vbox volume and its population.  By using the product,
         we avoid further subdivision of nearly empty vboxes, and
         directly target large vboxes with significant population.

     (2) Threshold the excess color transferred in dithering to
         neighboring pixels.

   Doing either of these will stop the most annoying oscillations
   in dithering.  Furthermore, by doing (1), we also improve the
   rendering of regions of nearly constant color, both with and
   without dithering.  It turns out that the image quality is
   not sensitive to the value of the parameter in (1); values
   between 0.3 and 0.9 give very good results.

   Here's the lesson: subdivide the color space into vboxes such
   that (1) the most populated vboxes that can be further
   subdivided (i.e., that occupy more than one quantum volume
   in color space) all have approximately the same population,
   and (2) all large vboxes have no significant population.
   If these conditions are met, the quantization will be excellent.

   Once the subdivision has been made, the colormap is generated,
   with one color for each vbox and using the average color in the vbox.
   At the same time, the histogram array is converted to an inverse
   colormap table, storing the colormap index in every cell in the
   vbox.  Finally, using both the colormap and the inverse colormap,
   a colormapped pix is quickly generated from the original rgb pix.

   In the present implementation, subdivided regions of colorspace
   that are not occupied are retained, but not further subdivided.
   This is required for our inverse colormap lookup table for
   dithering, because dithered pixels may fall into these unoccupied
   regions.  For such empty regions, we use the center as the rgb
   colormap value.

   This variation on median cut can be referred to as "Modified Median
   Cut" quantization, or MMCQ.  Overall, the undithered MMCQ gives
   comparable results to the two-pass Octcube Quantizer (OQ).
   Comparing the two methods on the test24.jpg painting, we see:

     (1) For rendering spot color (the various reds and pinks in
         the image), MMCQ is not as good as OQ.

     (2) For rendering majority color regions, MMCQ does a better
         job of avoiding posterization.  That is, it does better
         dividing the color space up in the most heavily populated regions.

"""
    
    try:
        leptonica.pixMedianCutQuantGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianCutQuantGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMedianCutQuantGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutQuantGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       
('l_int32', 'outdepth')       
('l_int32', 'maxcolors')       
('l_int32', 'sigbits')       
('l_int32', 'maxsub')       
('l_int32', 'checkbw')       
  pixMedianCutQuantGeneral()

      Input:  pixs  (32 bpp; rgb color)
              ditherflag (1 for dither; 0 for no dither)
              outdepth (output depth; valid: 0, 1, 2, 4, 8)
              maxcolors (between 2 and 256)
              sigbits (valid: 5 or 6; use 0 for default)
              maxsub (max subsampling, integer; use 0 for default;
                      1 for no subsampling)
              checkbw (1 to check if color content is very small,
                       0 to assume there is sufficient color)
      Return: pixd (8 bit with colormap), or null on error

  Notes:
      (1) @maxcolors must be in the range [2 ... 256].
      (2) Use @outdepth = 0 to have the output depth computed as the
          minimum required to hold the actual colors found, given
          the @maxcolors constraint.
      (3) Use @outdepth = 1, 2, 4 or 8 to specify the output depth.
          In that case, @maxcolors must not exceed 2^(outdepth).
      (4) If there are fewer quantized colors in the image than @maxcolors,
          the colormap is simply generated from those colors.
      (5) @maxsub is the maximum allowed subsampling to be used in the
          computation of the color histogram and region of occupied
          color space.  The subsampling is chosen internally for
          efficiency, based on the image size, but this parameter
          limits it.  Use @maxsub = 0 for the internal default, which is the
          maximum allowed subsampling.  Use @maxsub = 1 to prevent
          subsampling.  In general use @maxsub >= 1 to specify the
          maximum subsampling to be allowed, where the actual subsampling
          will be the minimum of this value and the internally
          determined default value.
      (6) If the image appears gray because either most of the pixels
          are gray or most of the pixels are essentially black or white,
          the image is trivially quantized with a grayscale colormap.  The
          reason is that median cut divides the color space into rectangular
          regions, and it does a very poor job if all the pixels are
          near the diagonal of the color space cube.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutQuantGeneral(*args)
    
    

    try:
        leptonica.pixMedianCutQuant.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMedianCutQuant.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMedianCutQuant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutQuant(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       
  pixMedianCutQuant()

      Input:  pixs  (32 bpp; rgb color)
              ditherflag (1 for dither; 0 for no dither)
      Return: pixd (8 bit with colormap), or null on error

  Notes:
      (1) Simple interface.  See pixMedianCutQuantGeneral() for
          use of defaulted parameters.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutQuant(*args)
    
    

    try:
        leptonica.pixFewColorsMedianCutQuantMixed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFewColorsMedianCutQuantMixed.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFewColorsMedianCutQuantMixed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsMedianCutQuantMixed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncolor')       
('l_int32', 'ngray')       
('l_int32', 'maxncolors')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       
  pixFewColorsMedianCutQuantMixed()

      Input:  pixs (32 bpp rgb)
              ncolor (number of colors to be assigned to pixels with
                       significant color)
              ngray (number of gray colors to be used; must be >= 2)
              maxncolors (maximum number of colors to be returned
                         from pixColorsForQuantization(); use 0 for default)
              darkthresh (threshold near black; if the lightest component
                          is below this, the pixel is not considered to
                          be gray or color; use 0 for default)
              lightthresh (threshold near white; if the darkest component
                           is above this, the pixel is not considered to
                           be gray or color; use 0 for default)
              diffthresh (thresh for the max difference between component
                          values; for differences below this, the pixel
                          is considered to be gray; use 0 for default)
                          considered gray; use 0 for default)
      Return: pixd (8 bpp, median cut quantized for pixels that are
                    not gray; gray pixels are quantized separately
                    over the full gray range); null if too many colors
                    or on error

  Notes:
      (1) This is the "few colors" version of pixMedianCutQuantMixed().
          It fails (returns NULL) if it finds more than maxncolors, but
          otherwise it gives the same result.
      (2) Recommended input parameters are:
              @maxncolors:  20
              @darkthresh:  20
              @lightthresh: 244
              @diffthresh:  15  (any higher can miss colors differing
                                 slightly from gray)
      (3) Both ncolor and ngray should be at least equal to maxncolors.
          If they're not, they are automatically increased, and a
          warning is given.
      (4) If very little color content is found, the input is
          converted to gray and quantized in equal intervals.
      (5) This can be useful for quantizing orthographically generated
          images such as color maps, where there may be more than 256 colors
          because of aliasing or jpeg artifacts on text or lines, but
          there are a relatively small number of solid colors.
      (6) Example of usage:
             // Try to quantize, using default values for mixed med cut
             Pix *pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,
                             0, 0, 0, 0);
             if (!pixq)  // too many colors; don't quantize
                 pixq = pixClone(pixs);


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsMedianCutQuantMixed(*args)
    
    

    try:
        leptonica.pixMedianCutQuantMixed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianCutQuantMixed.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMedianCutQuantMixed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutQuantMixed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncolor')       
('l_int32', 'ngray')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       
  pixMedianCutQuantMixed()

      Input:  pixs  (32 bpp; rgb color)
              ncolor (maximum number of colors assigned to pixels with
                      significant color)
              ngray (number of gray colors to be used; must be >= 2)
              darkthresh (threshold near black; if the lightest component
                          is below this, the pixel is not considered to
                          be gray or color; uses 0 for default)
              lightthresh (threshold near white; if the darkest component
                           is above this, the pixel is not considered to
                           be gray or color; use 0 for default)
              diffthresh (thresh for the max difference between component
                          values; for differences below this, the pixel
                          is considered to be gray; use 0 for default)
      Return: pixd (8 bpp cmapped), or null on error

  Notes:
      (1) ncolor + ngray must not exceed 255.
      (2) The method makes use of pixMedianCutQuantGeneral() with
          minimal addition.
          (a) Preprocess the image, setting all pixels with little color
              to black, and populating an auxiliary 8 bpp image with the
              expected colormap values corresponding to the set of
              quantized gray values.
          (b) Color quantize the altered input image to n + 1 colors.
          (c) Augment the colormap with the gray indices, and
              substitute the gray quantized values from the auxiliary
              image for those in the color quantized output that had
              been quantized as black.
      (3) Median cut color quantization is relatively poor for grayscale
          images with many colors, when compared to octcube quantization.
          Thus, for images with both gray and color, it is important
          to quantize the gray pixels by another method.  Here, we
          are conservative in detecting color, preferring to use
          a few extra bits to encode colorful pixels that push them
          to gray.  This is particularly reasonable with this function,
          because it handles the gray and color pixels separately,
          using median cut color quantization for the color pixels
          and equal-bin grayscale quantization for the non-color pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutQuantMixed(*args)
    
    

    try:
        leptonica.pixMedianCutHisto.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianCutHisto.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function pixMedianCutHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutHisto(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'subsample')       
  pixMedianCutHisto()

      Input:  pixs  (32 bpp; rgb color)
              sigbits (valid: 5 or 6)
              subsample (integer > 0)
      Return: histo (1-d array, giving the number of pixels in
                     each quantized region of color space), or null on error

  Notes:
      (1) Array is indexed by (3 * sigbits) bits.  The array size
          is 2^(3 * sigbits).
      (2) Indexing into the array from rgb uses red sigbits as
          most significant and blue as least.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutHisto(*args)
    




class colorquant1(object):
    """  colorquant1.c

  Octcube color quantization

  There are several different octcube/octree based quantizations.
  These can be classified, in the order in which they appear in this
  file, as follows:

  -----------------------------------------------------------------
  (1) General adaptive octree
  (2) Adaptive octree by population at fixed level
  (3) Adaptive octree using population and with specified number
      of output colors
  (4) Octcube with colormap representation of mixed color/gray
  (5) 256 fixed octcubes covering color space
  (6) Octcubes at fixed level for ncolors <= 256
  (7) Octcubes at fixed level with RGB output
  (8) Quantizing an rgb image using a specified colormap
  -----------------------------------------------------------------

  (1) Two-pass adaptive octree color quantization
          PIX              *pixOctreeColorQuant()
          PIX              *pixOctreeColorQuantGeneral()

        which calls
          static CQCELL  ***octreeGenerateAndPrune()
          static PIX       *pixOctreeQuantizePixels()

        which calls
          static l_int32    octreeFindColorCell()

      Helper cqcell functions
          static CQCELL  ***cqcellTreeCreate()
          static void       cqcellTreeDestroy()

      Helper index functions
          l_int32           makeRGBToIndexTables()
          void              getOctcubeIndexFromRGB()
          static void       getRGBFromOctcube()
          static l_int32    getOctcubeIndices()
          static l_int32    octcubeGetCount()

  (2) Adaptive octree quantization based on population at a fixed level
          PIX              *pixOctreeQuantByPopulation()
          static l_int32    pixDitherOctindexWithCmap()

  (3) Adaptive octree quantization to 4 and 8 bpp with specified
      number of output colors in colormap
          PIX              *pixOctreeQuantNumColors()

  (4) Mixed color/gray quantization with specified number of colors
          PIX              *pixOctcubeQuantMixedWithGray()

  (5) Fixed partition octcube quantization with 256 cells
          PIX              *pixFixedOctcubeQuant256()

  (6) Fixed partition quantization for images with few colors
          PIX              *pixFewColorsOctcubeQuant1()
          PIX              *pixFewColorsOctcubeQuant2()
          PIX              *pixFewColorsOctcubeQuantMixed()

  (7) Fixed partition octcube quantization at specified level
      with quantized output to RGB
          PIX              *pixFixedOctcubeQuantGenRGB()

  (8) Color quantize RGB image using existing colormap
          PIX              *pixQuantFromCmap()  [high-level wrapper]
          PIX              *pixOctcubeQuantFromCmap()
          PIX              *pixOctcubeQuantFromCmapLUT()

      Generation of octcube histogram
          NUMA             *pixOctcubeHistogram()

      Get filled octcube table from colormap
          l_int32          *pixcmapToOctcubeLUT()

      Strip out unused elements in colormap
          l_int32           pixRemoveUnusedColors()

      Find number of occupied octcubes at the specified level
          l_int32           pixNumberOccupiedOctcubes()

  Note: leptonica also provides color quantization using a modified
        form of median cut.  See colorquant2.c for details.

"""
    
    try:
        leptonica.pixRemoveUnusedColors.argtypes = [ctypes.c_void_p]
        leptonica.pixRemoveUnusedColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveUnusedColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveUnusedColors(*args):
        """
        ('PIX', '*pixs')       
  pixRemoveUnusedColors()

      Input:  pixs  (colormapped)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) If the image doesn't have a colormap, returns without error.
      (3) Unusued colors are removed from the colormap, and the
          image pixels are re-numbered.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveUnusedColors(*args)
    
    

    try:
        leptonica.pixFewColorsOctcubeQuant1.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFewColorsOctcubeQuant1.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFewColorsOctcubeQuant1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsOctcubeQuant1(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
  pixFewColorsOctcubeQuant1()

      Input:  pixs (32 bpp rgb)
              level (significant bits for each of RGB; valid in [1...6])
      Return: pixd (quantized to octcube) or null on error

  Notes:
      (1) Generates a colormapped image, where the colormap table values
          are the averages of all pixels that are found in the octcube.
      (2) This fails if there are more than 256 colors (i.e., more
          than 256 occupied octcubes).
      (3) Often level 3 (512 octcubes) will succeed because not more
          than half of them are occupied with 1 or more pixels.
      (4) The depth of the result, which is either 2, 4 or 8 bpp,
          is the minimum required to hold the number of colors that
          are found.
      (5) This can be useful for quantizing orthographically generated
          images such as color maps, where there may be more than 256 colors
          because of aliasing or jpeg artifacts on text or lines, but
          there are a relatively small number of solid colors.  Then,
          use with level = 3 can often generate a compact and accurate
          representation of the original RGB image.  For this purpose,
          it is better than pixFewColorsOctcubeQuant2(), because it
          uses the average value of pixels in the octcube rather
          than the first found pixel.  It is also simpler to use,
          because it generates the histogram internally.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsOctcubeQuant1(*args)
    
    

    try:
        leptonica.getOctcubeIndexFromRGB.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getOctcubeIndexFromRGB.restype = None
    except AttributeError:
        os.stderr.write("Warning - function getOctcubeIndexFromRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getOctcubeIndexFromRGB(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_uint32', '*rtab')       
('l_uint32', '*gtab')       
('l_uint32', '*btab')       
('l_uint32', '*pindex')       
  getOctcubeIndexFromRGB()

      Input:  rval, gval, bval
              rtab, gtab, btab  (generated with makeRGBToIndexTables())
              &index (<return>)
      Return: void

  Note: no error checking!


        """
        args = _convert_params(*args)
        
        return leptonica.getOctcubeIndexFromRGB(*args)
    
    

    try:
        leptonica.pixOctreeColorQuantGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixOctreeColorQuantGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctreeColorQuantGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeColorQuantGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'colors')       
('l_int32', 'ditherflag')       
('l_float32', 'validthresh')       
('l_float32', 'colorthresh')       
  pixOctreeColorQuantGeneral()

      Input:  pixs  (32 bpp; 24-bit color)
              colors  (in colormap; some number in range [128 ... 240];
                      the actual number of colors used will be smaller)
              ditherflag  (1 to dither, 0 otherwise)
              validthresh (minimum fraction of pixels neither near white
                           nor black, required for color quantization;
                           typically ~0.01, but smaller for images that have
                           color but are nearly all white)
              colorthresh (minimum fraction of pixels with color that are
                           not near white or black, that are required
                           for color quantization; typ. ~0.01, but smaller
                           for images that have color along with a
                           significant fraction of gray)
      Return: pixd (8 bit with colormap), or null on error

  Notes:
      (1) The parameters @validthresh and @colorthresh are used to
          determine if color quantization should be used on an image,
          or whether, instead, it should be quantized in grayscale.
          If the image has very few non-white and non-black pixels, or
          if those pixels that are non-white and non-black are all
          very close to either white or black, it is usually better
          to treat the color as accidental and to quantize the image
          to gray only.  These parameters are useful if you know
          something a priori about the image.  Perhaps you know that
          there is only a very small fraction of color pixels, but they're
          important to preserve; then you want to use a smaller value for
          these parameters.  To disable conversion to gray and force
          color quantization, use @validthresh = 0.0 and @colorthresh = 0.0.
      (2) See pixOctreeColorQuant() for algorithmic and implementation
          details.  This function has a more general interface.
      (3) See pixColorFraction() for computing the fraction of pixels
          that are neither white nor black, and the fraction of those
          pixels that have little color.  From the documentation there:
             If pixfract is very small, there are few pixels that are
             neither black nor white.  If colorfract is very small,
             the pixels that are neither black nor white have very
             little color content.  The product 'pixfract * colorfract'
             gives the fraction of pixels with significant color content.
          We test against the product @validthresh * @colorthresh
          to find color in images that have either very few
          intermediate gray pixels or that have many such gray pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeColorQuantGeneral(*args)
    
    

    try:
        leptonica.pixFewColorsOctcubeQuant2.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFewColorsOctcubeQuant2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFewColorsOctcubeQuant2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsOctcubeQuant2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('NUMA', '*na')       
('l_int32', 'ncolors')       
('l_int32', '*pnerrors')       
  pixFewColorsOctcubeQuant2()

      Input:  pixs (32 bpp rgb)
              level (of octcube indexing, for histogram: 3, 4, 5, 6)
              na (histogram of pixel occupation in octree leaves at
                  given level)
              ncolors (number of occupied octree leaves at given level)
              &nerrors (<optional return> num of pixels not exactly
                        represented in the colormap)
      Return: pixd (2, 4 or 8 bpp with colormap), or null on error

  Notes:
      (1) Generates a colormapped image, where the colormap table values
          are the averages of all pixels that are found in the octcube.
      (2) This fails if there are more than 256 colors (i.e., more
          than 256 occupied octcubes).
      (3) Often level 3 (512 octcubes) will succeed because not more
          than half of them are occupied with 1 or more pixels.
      (4) For an image with not more than 256 colors, it is unlikely
          that two pixels of different color will fall in the same
          octcube at level = 4.   However it is possible, and this
          function optionally returns @nerrors, the number of pixels
          where, because more than one color is in the same octcube,
          the pixel color is not exactly reproduced in the colormap.
          The colormap for an occupied leaf of the octree contains
          the color of the first pixel encountered in that octcube.
      (5) This differs from pixFewColorsOctcubeQuant1(), which also
          requires not more than 256 occupied leaves, but represents
          the color of each leaf by an average over the pixels in
          that leaf.  This also requires precomputing the histogram
          of occupied octree leaves, which is generated using
          pixOctcubeHistogram().
      (6) This is used in pixConvertRGBToColormap() for images that
          are determined, by their histogram, to have relatively few
          colors.  This typically happens with orthographically
          produced images (as oppopsed to natural images), where
          it is expected that most of the pixels within a leaf
          octcube have exactly the same color, and quantization to
          that color is lossless.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsOctcubeQuant2(*args)
    
    

    try:
        leptonica.pixcmapToOctcubeLUT.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapToOctcubeLUT.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapToOctcubeLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapToOctcubeLUT(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'level')       
('l_int32', 'metric')       
  pixcmapToOctcubeLUT()

      Input:  cmap
              level (significant bits for each of RGB; valid in [1...6])
              metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)
      Return: tab[2**(3 * level)]

  Notes:
      (1) This function is used to quickly find the colormap color
          that is closest to any rgb color.  It is used to assign
          rgb colors to an existing colormap.  It can be very expensive
          to search through the entire colormap for the closest color
          to each pixel.  Instead, we first set up this table, which is
          populated by the colormap index nearest to each octcube
          color.  Then we go through the image; for each pixel,
          do two table lookups: first to generate the octcube index
          from rgb and second to use this table to read out the
          colormap index.
      (2) Do a slight modification for white and black.  For level = 4,
          each octcube size is 16.  The center of the whitest octcube
          is at (248, 248, 248), which is closer to 242 than 255.
          Consequently, any gray color between 242 and 254 will
          be selected, even if white (255, 255, 255) exists.  This is
          typically not optimal, because the original color was
          likely white.  Therefore, if white exists in the colormap,
          use it for any rgb color that falls into the most white octcube.
          Do the similar thing for black.
      (3) Here are the actual function calls for quantizing to a
          specified colormap:
            - first make the tables that map from rgb --> octcube index
                     makeRGBToIndexTables()
            - then for each pixel:
                * use the tables to get the octcube index
                     getOctcubeIndexFromRGB()
                * use this table to get the nearest color in the colormap
                     cmap_index = tab[index]
      (4) Distance can be either manhattan or euclidean.
      (5) In typical use, level = 4 gives reasonable results, and
          level = 5 is slightly better.  When this function is used
          for color segmentation, there are typically a small number
          of colors and the number of levels can be small (e.g., level = 3).


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapToOctcubeLUT(*args)
    
    

    try:
        leptonica.makeRGBToIndexTables.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.makeRGBToIndexTables.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeRGBToIndexTables not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeRGBToIndexTables(*args):
        """
        ('l_uint32', '**prtab')       
('l_uint32', '**pgtab')       
('l_uint32', '**pbtab')       
('l_int32', 'cqlevels')       
  makeRGBToIndexTables()

      Input:  &rtab, &gtab, &btab  (<return> tables)
              cqlevels (can be 1, 2, 3, 4, 5 or 6)
      Return: 0 if OK; 1 on error

  Set up tables.  e.g., for cqlevels = 5, we need an integer 0 < i < 2^15:
      rtab = (0  i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0   0)
      gtab = (0  0   i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0)
      btab = (0  0   0   i7  0  0   i6  0  0   i5  0   0   i4  0   0   i3)

  The tables are then used to map from rbg --> index as follows:
      index = (0  r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4  r3  g3  b3)

    e.g., for cqlevels = 4, we map to
      index = (0  0   0   0   r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4)

  This may look a bit strange.  The notation 'r7' means the MSBit of
  the r value (which has 8 bits, going down from r7 to r0).
  Keep in mind that r7 is actually the r component bit for level 1 of
  the octtree.  Level 1 is composed of 8 octcubes, represented by
  the bits (r7 g7 b7), which divide the entire color space into
  8 cubes.  At level 2, each of these 8 octcubes is further divided into
  8 cubes, each labeled by the second most significant bits (r6 g6 b6)
  of the rgb color.


        """
        args = _convert_params(*args)
        
        return leptonica.makeRGBToIndexTables(*args)
    
    

    try:
        leptonica.pixFixedOctcubeQuantGenRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFixedOctcubeQuantGenRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFixedOctcubeQuantGenRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFixedOctcubeQuantGenRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
  pixFixedOctcubeQuantGenRGB()

      Input:  pixs (32 bpp rgb)
              level (significant bits for each of r,g,b)
      Return: pixd (rgb; quantized to octcube centers), or null on error

  Notes:
      (1) Unlike the other color quantization functions, this one
          generates an rgb image.
      (2) The pixel values are quantized to the center of each octcube
          (at the specified level) containing the pixel.  They are
          not quantized to the average of the pixels in that octcube.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFixedOctcubeQuantGenRGB(*args)
    
    

    try:
        leptonica.pixNumberOccupiedOctcubes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixNumberOccupiedOctcubes.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixNumberOccupiedOctcubes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixNumberOccupiedOctcubes(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'level')       
('l_int32', 'mincount')       
('l_float32', 'minfract')       
('l_int32', '*pncolors')       
  pixNumberOccupiedOctcubes()

      Input:  pix (32 bpp)
              level (of octcube)
              mincount (minimum num pixels in an octcube to be counted;
                        -1 to not use)
              minfract (minimum fract of pixels in an octcube to be
                        counted; -1 to not use)
              &ncolors (<return> number of occupied octcubes)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Exactly one of (@mincount, @minfract) must be -1, so, e.g.,
          if @mincount == -1, then we use @minfract.
      (2) If all occupied octcubes are to count, set @mincount == 1.
          Setting @minfract == 0.0 is taken to mean the same thing.


        """
        args = _convert_params(*args)
        
        return leptonica.pixNumberOccupiedOctcubes(*args)
    
    

    try:
        leptonica.pixOctreeQuantByPopulation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctreeQuantByPopulation.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctreeQuantByPopulation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeQuantByPopulation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_int32', 'ditherflag')       
  pixOctreeQuantByPopulation()

      Input:  pixs (32 bpp rgb)
              level (significant bits for each of RGB; valid for {3,4},
                     Use 0 for default (level 4; recommended)
              ditherflag  (1 to dither, 0 otherwise)
      Return: pixd (quantized to octcubes) or null on error

  Notes:
      (1) This color quantization method works very well without
          dithering, using octcubes at two different levels:
            (a) the input @level, which is either 3 or 4
            (b) level 2 (64 octcubes to cover the entire color space)
      (2) For best results, using @level = 4 is recommended.
          Why do we provide an option for using level 3?  Because
          there are 512 octcubes at level 3, and for many images
          not more than 256 are filled.  As a result, on some images
          a very accurate quantized representation is possible using
          @level = 3.
      (3) This first breaks up the color space into octcubes at the
          input @level, and computes, for each octcube, the average
          value of the pixels that are in it.
      (4) Then there are two possible situations:
            (a) If there are not more than 256 populated octcubes,
                it returns a cmapped pix with those values assigned.
            (b) Otherwise, it selects 192 octcubes containing the largest
                number of pixels and quantizes pixels within those octcubes
                to their average.  Then, to handle the residual pixels
                that are not in those 192 octcubes, it generates a
                level 2 octree consisting of 64 octcubes, and within
                each octcube it quantizes the residual pixels to their
                average within each of those level 2 octcubes.
      (5) Unpopulated level 2 octcubes are represented in the colormap
          by their centers.  This, of course, has no effect unless
          dithering is used for the output image.
      (6) The depth of pixd is the minumum required to suppport the
          number of colors found at @level; namely, 2, 4 or 8.
      (7) This function works particularly well on images such as maps,
          where there are a relatively small number of well-populated
          colors, but due to antialiasing and compression artifacts
          there may be a large number of different colors.  This will
          pull out and represent accurately the highly populated colors,
          while still making a reasonable approximation for the others.
      (8) The highest level of octcubes allowed is 4.  Use of higher
          levels typically results in having a small fraction of
          pixels in the most populated 192 octcubes.  As a result,
          most of the pixels are represented at level 2, which is
          not sufficiently accurate.
      (9) Dithering shows artifacts on some images.  If you plan to
          dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()
          usually give better results.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeQuantByPopulation(*args)
    
    

    try:
        leptonica.pixOctcubeQuantFromCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctcubeQuantFromCmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctcubeQuantFromCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeQuantFromCmap(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       
('l_int32', 'level')       
('l_int32', 'metric')       
  pixOctcubeQuantFromCmap()

      Input:  pixs  (32 bpp rgb)
              cmap  (to quantize to; insert copy into dest pix)
              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)
              level (of octcube used for finding nearest color in cmap)
              metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)
      Return: pixd  (2, 4 or 8 bpp, colormapped), or null on error

  Notes:
      (1) In typical use, we are doing an operation, such as
          interpolative scaling, on a colormapped pix, where it is
          necessary to remove the colormap before the operation.
          We then want to re-quantize the RGB result using the same
          colormap.
      (2) The level is used to divide the color space into octcubes.
          Each input pixel is, in effect, placed at the center of an
          octcube at the given level, and it is mapped into the
          exact color (given in the colormap) that is the closest
          to that location.  We need to know that distance, for each color
          in the colormap.  The higher the level of the octtree, the smaller
          the octcubes in the color space, and hence the more accurately
          we can determine the closest color in the colormap; however,
          the size of the LUT, which is the total number of octcubes,
          increases by a factor of 8 for each increase of 1 level.
          The time required to acquire a level 4 mapping table, which has
          about 4K entries, is less than 1 msec, so that is the
          recommended minimum size to be used.  At that size, the
          octcubes have their centers 16 units apart in each (r,g,b)
          direction.  If two colors are in the same octcube, the one
          closest to the center will always be chosen.  The maximum
          error for any component occurs when the correct color is
          at a cube corner and there is an incorrect color just inside
          the cube next to the opposite corner, giving an error of
          14 units (out of 256) for each component.   Using a level 5
          mapping table reduces the maximum error to 6 units.
      (3) Typically you should use the Euclidean metric, because the
          resulting voronoi cells (which are generated using the actual
          colormap values as seeds) are convex for Euclidean distance
          but not for Manhattan distance.  In terms of the octcubes,
          convexity of the voronoi cells means that if the 8 corners
          of any cube (of which the octcubes are special cases)
          are all within a cell, then every point in the cube will
          lie within the cell.
      (4) The depth of the output pixd is equal to the maximum of
          (a) @mindepth and (b) the minimum (2, 4 or 8 bpp) necessary
          to hold the indices in the colormap.
      (5) We build a mapping table from octcube to colormap index so
          that this function can run in a time (otherwise) independent
          of the number of colors in the colormap.  This avoids a
          brute-force search for the closest colormap color to each
          pixel in the image.
      (6) This is similar to the function pixAssignToNearestColor()
          used for color segmentation.
      (7) Except for very small images or when using level > 4,
          it takes very little time to generate the tables,
          compared to the generation of the colormapped dest pix,
          so one would not typically use the low-level version.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeQuantFromCmap(*args)
    
    

    try:
        leptonica.pixOctcubeHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixOctcubeHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctcubeHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_int32', '*pncolors')       
  pixOctcubeHistogram()

      Input:  pixs (32 bpp rgb)
              level (significant bits for each of RGB; valid in [1...6])
              &ncolors (<optional return> number of occupied cubes)
      Return: numa (histogram of color pixels, or null on error)

  Notes:
      (1) Input NULL for &ncolors to prevent computation and return value.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeHistogram(*args)
    
    

    try:
        leptonica.pixQuantFromCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuantFromCmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixQuantFromCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuantFromCmap(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       
('l_int32', 'level')       
('l_int32', 'metric')       
  pixQuantFromCmap()

      Input:  pixs  (8 bpp grayscale without cmap, or 32 bpp rgb)
              cmap  (to quantize to; insert copy into dest pix)
              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)
              level (of octcube used for finding nearest color in cmap)
              metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)
      Return: pixd  (2, 4 or 8 bpp, colormapped), or null on error

  Notes:
      (1) This is a top-level wrapper for quantizing either grayscale
          or rgb images to a specified colormap.
      (2) The actual output depth is constrained by @mindepth and
          by the number of colors in @cmap.
      (3) For grayscale, @level and @metric are ignored.
      (4) If the cmap has color and pixs is grayscale, the color is
          removed from the cmap before quantizing pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuantFromCmap(*args)
    
    

    try:
        leptonica.pixFixedOctcubeQuant256.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFixedOctcubeQuant256.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFixedOctcubeQuant256 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFixedOctcubeQuant256(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       
  pixFixedOctcubeQuant256()

      Input:  pixs  (32 bpp; 24-bit color)
              ditherflag  (1 for dithering; 0 for no dithering)
      Return: pixd (8 bit with colormap), or null on error

  This simple 1-pass color quantization works by breaking the
  color space into 256 pieces, with 3 bits quantized for each of
  red and green, and 2 bits quantized for blue.  We shortchange
  blue because the eye is least sensitive to blue.  This
  division of the color space is into two levels of octrees,
  followed by a further division by 4 (not 8), where both
  blue octrees have been combined in the third level.

  The color map is generated from the 256 color centers by
  taking the representative color to be the center of the
  cell volume.  This gives a maximum error in the red and
  green values of 16 levels, and a maximum error in the
  blue sample of 32 levels.

  Each pixel in the 24-bit color image is placed in its containing
  cell, given by the relevant MSbits of the red, green and blue
  samples.  An error-diffusion dithering is performed on each
  color sample to give the appearance of good average local color.
  Dithering is required; without it, the contouring and visible
  color errors are very bad.

  I originally implemented this algorithm in two passes,
  where the first pass was used to compute the weighted average
  of each sample in each pre-allocated region of color space.
  The idea was to use these centroids in the dithering algorithm
  of the second pass, to reduce the average error that was
  being dithered.  However, with dithering, there is
  virtually no difference, so there is no reason to make the
  first pass.  Consequently, this 1-pass version just assigns
  the pixels to the centers of the pre-allocated cells.
  We use dithering to spread the difference between the sample
  value and the location of the center of the cell.  For speed
  and simplicity, we use integer dithering and propagate only
  to the right, down, and diagonally down-right, with ratios
  3/8, 3/8 and 1/4, respectively.  The results should be nearly
  as good, and a bit faster, with propagation only to the right
  and down.

  The algorithm is very fast, because there is no search,
  only fast generation of the cell index for each pixel.
  We use a simple mapping from the three 8 bit rgb samples
  to the 8 bit cell index; namely, (r7 r6 r5 g7 g6 g5 b7 b6).
  This is not in an octcube format, but it doesn't matter.
  There are no storage requirements.  We could keep a
  running average of the center of each sample in each
  cluster, rather than using the center of the cell, but
  this is just extra work, esp. with dithering.

  This method gives surprisingly good results with dithering.
  However, without dithering, the loss of color accuracy is
  evident in regions that are very light or that have subtle
  blending of colors.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFixedOctcubeQuant256(*args)
    
    

    try:
        leptonica.pixOctreeColorQuant.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctreeColorQuant.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctreeColorQuant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeColorQuant(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'colors')       
('l_int32', 'ditherflag')       
  pixOctreeColorQuant()

      Input:  pixs  (32 bpp; 24-bit color)
              colors  (in colormap; some number in range [128 ... 256];
                      the actual number of colors used will be smaller)
              ditherflag  (1 to dither, 0 otherwise)
      Return: pixd (8 bpp with colormap), or null on error

  I found one description in the literature of octree color
  quantization, using progressive truncation of the octree,
  by M. Gervautz and W. Purgathofer in Graphics Gems, pp.
  287-293, ed. A. Glassner, Academic Press, 1990.
  Rather than setting up a fixed partitioning of the color
  space ab initio, as we do here, they allow the octree to be
  progressively truncated as new pixels are added.  They
  need to set up some data structures that are traversed
  with the addition of each 24 bit pixel, in order to decide
  either (1) in which cluster (sub-branch of the octree) to put
  the pixel, or (2) whether to truncate the octree further
  to place the pixel in an existing cluster, or (3) which
  two existing clusters should be merged so that the pixel
  can be left to start a truncated leaf of the octree.  Such dynamic
  truncation is considerably more complicated, and Gervautz et
  al. did not explain how they did it in anywhere near the
  detail required to check their implementation.

  The simple method in pixFixedOctcubeQuant256() is very
  fast, and with dithering the results are good, but you
  can do better if the color clusters are selected adaptively
  from the image.  We want a method that makes much better
  use of color samples in regions of color space with high
  pixel density, while also fairly representing small numbers
  of color pixels in low density regions.  Such adaptation
  requires two passes through the image: the first for generating
  the pruned tree of color cubes and the second for computing the index
  into the color table for each pixel.

  A relatively simple adaptive method is pixOctreeQuantByPopulation().
  That function first determines if the image has very few colors,
  and, if so, quantizes to those colors.  If there are more than
  256 colors, it generates a histogram of octcube leaf occupancy
  at level 4, chooses the 192 most populated such leaves as
  the first 192 colors, and sets the remaining 64 colors to the
  residual average pixel values in each of the 64 level 2 octcubes.
  This is a bit faster than pixOctreeColorQuant(), and does very
  well without dithering, but for most images with dithering it
  is clearly inferior.

  We now describe pixOctreeColorQuant().  The first pass is done
  on a subsampled image, because we do not need to use all the
  pixels in the image to generate the tree.  Subsampling
  down to 0.25 (1/16 of the pixels) makes the program run
  about 1.3 times faster.

  Instead of dividing the color space into 256 equal-sized
  regions, we initially divide it into 2^12 or 2^15 or 2^18
  equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.
  This gives us 6 octree levels.  We then prune back,
  starting from level 6.  For every cube at level 6, there
  are 8 cubes at level 5.  Call the operation of putting a
  cube aside as a color table entry (CTE) a "saving."
  We use a (in general) level-dependent threshold, and save
  those level 6 cubes that are above threshold.
  The rest are combined into the containing level 5 cube.
  If between 1 and 7 level 6 cubes within a level 5
  cube have been saved by thresholding, then the remaining
  level 6 cubes in that level 5 cube are automatically
  saved as well, without applying a threshold.  This greatly
  simplifies both the description of the CTEs and the later
  classification of each pixel as belonging to a CTE.
  This procedure is iterated through every cube, starting at
  level 5, and then 4, 3, and 2, successively.  The result is that
  each CTE contains the entirety of a set of from 1 to 7 cubes
  from a given level that all belong to a single cube at the
  level above.   We classify the CTEs in terms of the
  condition in which they are made as either being "threshold"
  or "residual."  They are "threshold" CTEs if no subcubes
  are CTEs (that is, they contain every pixel within the cube)
  and the number of pixels exceeds the threshold for making
  a CTE.  They are "residual" CTEs if at least one but not more
  than 7 of the subcubes have already been determined to be CTEs;
  this happens automatically -- no threshold is applied.
  If all 8 subcubes are determined to be CTEs, the cube is
  marked as having all pixels accounted for ('bleaf' = 1) but
  is not saved as a CTE.

  We stop the pruning at level 2, at which there are 64
  sub-cubes.  Any pixels not already claimed in a CTE are
  put in these cubes.

  As the cubes are saved as color samples in the color table,
  the number of remaining pixels P and the number of
  remaining colors in the color table N are recomputed,
  along with the average number of pixels P/N (ppc) to go in
  each of the remaining colors.  This running average number is
  used to set the threshold at the current level.

  Because we are going to very small cubes at levels 6 or 5,
  and will dither the colors for errors, it is not necessary
  to compute the color center of each cluster; we can simply
  use the center of the cube.  This gives us a minimax error
  condition: the maximum error is half the width of the
  level 2 cubes -- 32 color values out of 256 -- for each color
  sample.  In practice, most of the pixels will be very much
  closer to the center of their cells.  And with dithering,
  the average pixel color in a small region will be closer still.
  Thus with the octree quantizer, we are able to capture
  regions of high color pdf (probability density function) in small
  but accurate CTEs, and to have only a small number of pixels
  that end up a significant distance (with a guaranteed maximum)
  from their true color.

  How should the threshold factor vary?  Threshold factors
  are required for levels 2, 3, 4 and 5 in the pruning stage.
  The threshold for level 5 is actually applied to cubes at
  level 6, etc.  From various experiments, it appears that
  the results do not vary appreciably for threshold values near 1.0.
  If you want more colors in smaller cubes, the threshold
  factors can be set lower than 1.0 for cubes at levels 4 and 5.
  However, if the factor is set much lower than 1.0 for
  levels 2 and 3, we can easily run out of colors.
  We put aside 64 colors in the calculation of the threshold
  values, because we must have 64 color centers at level 2,
  that will have very few pixels in most of them.
  If we reduce the factor for level 5 to 0.4, this will
  generate many level 6 CTEs, and consequently
  many residual cells will be formed up from those leaves,
  resulting in the possibility of running out of colors.
  Remember, the residual CTEs are mandatory, and are formed
  without using the threshold, regardless of the number of
  pixels that are absorbed.

  The implementation logically has four parts:

       (1) accumulation into small, fixed cells
       (2) pruning back into selected CTE cubes
       (3) organizing the CTEs for fast search to find
           the CTE to which any image pixel belongs
       (4) doing a second scan to code the image pixels by CTE

  Step (1) is straightforward; we use 2^15 cells.

  We've already discussed how the pruning step (2) will be performed.

  Steps (3) and (4) are related, in that the organization
  used by step (3) determines how the search actually
  takes place for each pixel in step (4).

  There are many ways to do step (3).  Let's explore a few.

  (a) The simplest is to order the cubes from highest occupancy
      to lowest, and traverse the list looking for the deepest
      match.  To make this more efficient, so that we know when
      to stop looking, any cube that has separate CTE subcubes
      would be marked as such, so that we know when we hit a
      true leaf.

  (b) Alternatively, we can order the cubes by highest
      occupancy separately each level, and work upward,
      starting at level 5, so that when we find a match we
      know that it will be correct.

  (c) Another approach would be to order the cubes by
      "address" and use a hash table to find the cube
      corresponding to a pixel color.  I don't know how to
      do this with a variable length address, as each CTE
      will have 3*n bits, where n is the level.

  (d) Another approach entirely is to put the CTE cubes into
      a tree, in such a way that starting from the root, and
      using 3 bits of address at a time, the correct branch of
      each octree can be taken until a leaf is found.  Because
      a given cube can be both a leaf and also have branches
      going to sub-cubes, the search stops only when no
      marked subcubes have addresses that match the given pixel.

      In the tree method, we can start with a dense infrastructure,
      and place the leaves corresponding to the N colors
      in the tree, or we can grow from the root only those
      branches that end directly on leaves.

  What we do here is to take approach (d), and implement the tree
  "virtually", as a set of arrays, one array for each level
  of the tree.   Initially we start at level 5, an array with
  2^15 cubes, each with 8 subcubes.  We then build nodes at
  levels closer to the root; at level 4 there are 2^12 nodes
  each with 8 subcubes; etc.  Using these arrays has
  several advantages:

     -  We don't need to keep track of links between cubes
        and subcubes, because we can use the canonical
        addressing on the cell arrays directly to determine
        which nodes are parent cubes and which are sub-cubes.

     -  We can prune directly on this tree

     -  We can navigate the pruned tree quickly to classify
        each pixel in the image.

  Canonical addressing guarantees that the i-th node at level k
  has 8 subnodes given by the 8*i ... 8*i+7 nodes at level k+1.

  The pruning step works as follows.  We go from the lowest
  level up.  At each level, the threshold is found from the
  product of a factor near 1.0 and the ratio of unmarked pixels
  to remaining colors (minus the 64).  We march through
  the space, sequentially considering a cube and its 8 subcubes.
  We first check those subcubes that are not already
  marked as CTE to see if any are above threshold, and if so,
  generate a CTE and mark them as such.
  We then determine if any of the subcubes have been marked.
  If so, and there are subcubes that are not marked,
  we generate a CTE for the cube from the remaining unmarked
  subcubes; this is mandatory and does not depend on how many
  pixels are in the set of subcubes.  If none of the subcubes
  are marked, we aggregate their pixels into the cube
  containing them, but do not mark it as a CTE; that
  will be determined when iterating through the next level up.

  When all the pixels in a cube are accounted for in one or more
  colors, we set the boolean 'bleaf' to true.  This is the
  flag used to mark the cubes in the pruning step.  If a cube
  is marked, and all 8 subcubes are marked, then it is not
  itself given a CTE because all pixels have already been
  accounted for.

  Note that the pruning of the tree and labelling of the CTEs
  (step 2) accomplishes step 3 implicitly, because the marked
  and pruned tree is ready for use in labelling each pixel
  in step 4.  We now, for every pixel in the image, traverse
  the tree from the root, looking for the lowest cube that is a leaf.
  At each level we have a cube and subcube.  If we reach a subcube
  leaf that is marked 0, we know that the color is stored in the
  cube above, and we've found the CTE.  Otherwise, the subcube
  leaf is marked 1.  If we're at the last level, we've reached
  the final leaf and must use it.  Otherwise, continue the
  process at the next level down.

  For robustness, efficiency and high quality output, we do the following:

  (1) Measure the color content of the image.  If there is very little
      color, quantize in grayscale.
  (2) For efficiency, build the octree with a subsampled image if the
      image is larger than some threshold size.
  (3) Reserve an extra set of colors to prevent running out of colors
      when pruning the octree; specifically, during the assignment
      of those level 2 cells (out of the 64) that have unassigned
      pixels.  The problem of running out is more likely to happen
      with small images, because the estimation we use for the
      number of pixels available is not accurate.
  (4) In the unlikely event that we run out of colors, the dithered
      image can be very poor.  As this would only happen with very
      small images, and dithering is not particularly noticeable with
      such images, turn it off.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeColorQuant(*args)
    
    

    try:
        leptonica.pixFewColorsOctcubeQuantMixed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixFewColorsOctcubeQuantMixed.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFewColorsOctcubeQuantMixed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsOctcubeQuantMixed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       
('l_float32', 'minfract')       
('l_int32', 'maxspan')       
  pixFewColorsOctcubeQuantMixed()

      Input:  pixs (32 bpp rgb)
              level (significant octcube bits for each of RGB;
                     valid in [1...6]; use 0 for default)
              darkthresh (threshold near black; if the lightest component
                          is below this, the pixel is not considered to
                          be gray or color; uses 0 for default)
              lightthresh (threshold near white; if the darkest component
                           is above this, the pixel is not considered to
                           be gray or color; use 0 for default)
              diffthresh (thresh for the max difference between component
                          values; for differences below this, the pixel
                          is considered to be gray; use 0 for default)
                          considered gray; use 0 for default)
              minfract (min fraction of pixels for gray histo bin;
                        use 0.0 for default)
              maxspan (max size of gray histo bin; use 0 for default)
      Return: pixd (8 bpp, quantized to octcube for pixels that are
                    not gray; gray pixels are quantized separately
                    over the full gray range), or null on error

  Notes:
      (1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,
          it separates the color from gray(ish) entries in the cmap,
          and re-quantizes the gray pixels.  The result has some pixels
          in color and others in gray.
      (2) This fails if there are more than 256 colors (i.e., more
          than 256 occupied octcubes in the color quantization).
      (3) Level 3 (512 octcubes) will usually succeed because not more
          than half of them are occupied with 1 or more pixels.
      (4) This uses the criterion from pixColorFraction() for deciding
          if a colormap entry is color; namely, if the color components
          are not too close to either black or white, and the maximum
          difference between component values equals or exceeds a threshold.
      (5) For quantizing the gray pixels, it uses a histogram-based
          method where input parameters determining the buckets are
          the minimum population fraction and the maximum allowed size.
      (6) Recommended input parameters are:
              @level:  3 or 4  (3 is default)
              @darkthresh:  20
              @lightthresh: 244
              @diffthresh: 20
              @minfract: 0.05
              @maxspan: 15
          These numbers are intended to be conservative (somewhat over-
          sensitive) in color detection,  It's usually better to pay
          extra with octcube quantization of a grayscale image than
          to use grayscale quantization on an image that has some
          actual color.  Input 0 on any of these to get the default.
      (7) This can be useful for quantizing orthographically generated
          images such as color maps, where there may be more than 256 colors
          because of aliasing or jpeg artifacts on text or lines, but
          there are a relatively small number of solid colors.  It usually
          gives results that are better than pixOctcubeQuantMixedWithGray(),
          both in size and appearance.  But it is a bit slower.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsOctcubeQuantMixed(*args)
    
    

    try:
        leptonica.pixOctcubeQuantMixedWithGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctcubeQuantMixedWithGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctcubeQuantMixedWithGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeQuantMixedWithGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'depth')       
('l_int32', 'graylevels')       
('l_int32', 'delta')       
  pixOctcubeQuantMixedWithGray()

      Input:  pixs (32 bpp rgb)
              depth (of output pix)
              graylevels (grayscale)
              delta (threshold for deciding if a pix is color or grayscale)
      Return: pixd (quantized to octcube and gray levels) or null on error

  Notes:
      (1) Generates a colormapped image, where the colormap table values
          have two components: octcube values representing pixels with
          color content, and grayscale values for the rest.
      (2) The threshold (delta) is the maximum allowable difference of
          the max abs value of | r - g |, | r - b | and | g - b |.
      (3) The octcube values are the averages of all pixels that are
          found in the octcube, and that are far enough from gray to
          be considered color.  This can roughly be visualized as all
          the points in the rgb color cube that are not within a "cylinder"
          of diameter approximately 'delta' along the main diagonal.
      (4) We want to guarantee full coverage of the rgb color space; thus,
          if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)
          and if the output depth is 8, the octlevel is 2 (4 x 4 x 4
          = 64 cubes).
      (5) Consequently, we have the following constraint on the number
          of allowed gray levels: for 4 bpp, 8; for 8 bpp, 192.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeQuantMixedWithGray(*args)
    
    

    try:
        leptonica.pixOctreeQuantNumColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctreeQuantNumColors.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctreeQuantNumColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeQuantNumColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxcolors')       
('l_int32', 'subsample')       
  pixOctreeQuantNumColors()

      Input:  pixs (32 bpp rgb)
              maxcolors (8 to 256; the actual number of colors used
                         may be less than this)
              subsample (factor for computing color distribution;
                         use 0 for default)
      Return: pixd (4 or 8 bpp, colormapped), or null on error

  pixOctreeColorQuant() is very flexible in terms of the relative
  depth of different cubes of the octree.   By contrast, this function,
  pixOctreeQuantNumColors() is also adaptive, but it supports octcube
  leaves at only two depths: a smaller depth that guarantees
  full coverage of the color space and octcubes at one level
  deeper for more accurate colors.  Its main virutes are simplicity
  and speed, which are both derived from the natural indexing of
  the octcubes from the RGB values.

  Before describing pixOctreeQuantNumColors(), consider an even simpler
  approach for 4 bpp with either 8 or 16 colors.  With 8 colors,
  you simply go to level 1 octcubes and use the average color
  found in each cube.  For 16 colors, you find which of the three
  colors has the largest variance at the second level, and use two
  indices for that color.  The result is quite poor, because (1) some
  of the cubes are nearly empty and (2) you don't get much color
  differentiation for the extra 8 colors.  Trust me, this method may
  be simple, but it isn't worth anything.

  In pixOctreeQuantNumColors(), we generate colormapped images at
  either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors
  for the level 1 octcubes, plus up to 8 additional colors that
  are determined from the level 2 popularity.  If the number of colors
  is between 8 and 16, the output is a 4 bpp image.  If the number of
  colors is greater than 16, the output is a 8 bpp image.

  We use a priority queue, implemented with a heap, to select the
  requisite number of most populated octcubes at the deepest level
  (level 2 for 64 or fewer colors; level 3 for more than 64 colors).
  These are combined with one color for each octcube one level above,
  which is used to span the color space of octcubes that were not
  included at the deeper level.

  If the deepest level is 2, we combine the popular level 2 octcubes
  (out of a total of 64) with the 8 level 1 octcubes.  If the deepest
  level is 3, we combine the popular level 3 octcubes (out of a
  total 512) with the 64 level 2 octcubes that span the color space.
  In the latter case, we require a minimum of 64 colors for the level 2
  octcubes, plus up to 192 additional colors determined from level 3
  popularity.

  The parameter 'maxlevel' is the deepest octcube level that is used.
  The implementation also uses two LUTs, which are employed in
  two successive traversals of the dest image.  The first maps
  from the src octindex at 'maxlevel' to the color table index,
  which is the value that is stored in the 4 or 8 bpp dest pixel.
  The second LUT maps from that colormap value in the dest to a
  new colormap value for a minimum sized colormap, stored back in
  the dest.  It is used to remove any color map entries that
  correspond to color space regions that have no pixels in the
  source image.  These regions can be either from the higher level
  (e.g., level 1 for 4 bpp), or from octcubes at 'maxlevel' that
  are unoccupied.  This remapping results in the minimum number
  of colors used according to the constraints induced by the
  input 'maxcolors'.  We also compute the average R, G and B color
  values in each region of the color space represented by a
  colormap entry, and store them in the colormap.

  The maximum number of colors is input, which determines the
  following properties of the dest image and octcube regions used:

     Number of colors      dest image depth      maxlevel
     ----------------      ----------------      --------
       8 to 16                  4 bpp               2
       17 to 64                 8 bpp               2
       65 to 256                8 bpp               3

  It may turn out that the number of extra colors, beyond the
  minimum (8 and 64 for maxlevel 2 and 3, respectively), is larger
  than the actual number of occupied cubes at these levels
  In that case, all the pixels are contained in this
  subset of cubes at maxlevel, and no colormap colors are needed
  to represent the remainder pixels one level above.  Thus, for
  example, in use one often finds that the pixels in an image
  occupy less than 192 octcubes at level 3, so they can be represented
  by a colormap for octcubes at level 3 only.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeQuantNumColors(*args)
    
    

    try:
        leptonica.pixOctcubeQuantFromCmapLUT.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOctcubeQuantFromCmapLUT.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOctcubeQuantFromCmapLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeQuantFromCmapLUT(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       
('l_int32', '*cmaptab')       
('l_uint32', '*rtab')       
('l_uint32', '*gtab')       
('l_uint32', '*btab')       
  pixOctcubeQuantFromCmapLUT()

      Input:  pixs  (32 bpp rgb)
              cmap  (to quantize to; insert copy into dest pix)
              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)
              cmaptab  (table mapping from octindex to colormap index)
              rtab, gtab, btab (tables mapping from RGB to octindex)
      Return: pixd  (2, 4 or 8 bpp, colormapped), or null on error

  Notes:
      (1) See the notes in the higher-level function
          pixOctcubeQuantFromCmap().  The octcube level for
          the generated octree is specified there, along with
          the distance metric for determining the closest
          color in the colormap to each octcube.
      (2) If the colormap, level and metric information have already
          been used to construct the set of mapping tables,
          this low-level function can be used directly (i.e.,
          independently of pixOctcubeQuantFromCmap()) to build
          a colormapped pix that uses the specified colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeQuantFromCmapLUT(*args)
    




class rank(object):
    """  rank.c

      Rank filter (gray and rgb)
          PIX      *pixRankFilter()
          PIX      *pixRankFilterRGB()
          PIX      *pixRankFilterGray()

      Median filter
          PIX      *pixMedianFilter()

      Rank filter (accelerated with downscaling)
          PIX      *pixRankFilterWithScaling()

  What is a brick rank filter?

    A brick rank order filter evaluates, for every pixel in the image,
    a rectangular set of n = wf x hf pixels in its neighborhood (where the
    pixel in question is at the "center" of the rectangle and is
    included in the evaluation).  It determines the value of the
    neighboring pixel that is the r-th smallest in the set,
    where r is some integer between 1 and n.  The input rank parameter
    is a fraction between 0.0 and 1.0, where 0.0 represents the
    smallest value (r = 1) and 1.0 represents the largest value (r = n).
    A median filter is a rank filter where rank = 0.5.

    It is important to note that grayscale erosion is equivalent
    to rank = 0.0, and grayscale dilation is equivalent to rank = 1.0.
    These are much easier to calculate than the general rank value,
    thanks to the van Herk/Gil-Werman algorithm:
       http://www.leptonica.com/grayscale-morphology.html
    so you should use pixErodeGray() and pixDilateGray() for
    rank 0.0 and 1.0, rsp.  See notes below in the function header.

  How is a rank filter implemented efficiently on an image?

    Sorting will not work.

      * The best sort algorithms are O(n*logn), where n is the number
        of values to be sorted (the area of the filter).  For large
        filters this is an impractically large number.

      * Selection of the rank value is O(n).  (To understand why it's not
        O(n*logn), see Numerical Recipes in C, 2nd edition, 1992,  p. 355ff).
        This also still far too much computation for large filters.

      * Suppose we get clever.  We really only need to do an incremental
        selection or sorting, because, for example, moving the filter
        down by one pixel causes one filter width of pixels to be added
        and another to be removed.  Can we do this incrementally in
        an efficient way?  Unfortunately, no.  The sorted values will be
        in an array.  Even if the filter width is 1, we can expect to
        have to move O(n) pixels, because insertion and deletion can happen
        anywhere in the array.  By comparison, heapsort is excellent for
        incremental sorting, where the cost for insertion or deletion
        is O(logn), because the array itself doesn't need to
        be sorted into strictly increasing order.  However, heapsort
        only gives the max (or min) value, not the general rank value.

    This leaves histograms.

      * Represented as an array.  The problem with an array of 256
        bins is that, in general, a significant fraction of the
        entire histogram must be summed to find the rank value bin.
        Suppose the filter size is 5x5.  You spend most of your time
        adding zeroes.  Ouch!

      * Represented as a linked list.  This would overcome the
        summing-over-empty-bin problem, but you lose random access
        for insertions and deletions.  No way.

      * Two histogram solution.  Maintain two histograms with
        bin sizes of 1 and 16.  Proceed from coarse to fine.
        First locate the coarse bin for the given rank, of which
        there are only 16.  Then, in the 256 entry (fine) histogram,
        you need look at a maximum of 16 bins.  For each output
        pixel, the average number of bins summed over, both in the
        coarse and fine histograms, is thus 16.

  If someone has a better method, please let me know!

  The rank filtering operation is relatively expensive, compared to most
  of the other imaging operations.  The speed is only weakly dependent
  on the size of the rank filter.  On standard hardware, it runs at
  about 10 Mpix/sec for a 50 x 50 filter, and 25 Mpix/sec for
  a 5 x 5 filter.   For applications where the rank filter can be
  performed on a downscaled image, significant speedup can be
  achieved because the time goes as the square of the scaling factor.
  We provide an interface that handles the details, and only
  requires the amount of downscaling to be input.

"""
    
    try:
        leptonica.pixMedianFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianFilter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMedianFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
  pixMedianFilter()

      Input:  pixs (8 or 32 bpp; no colormap)
              wf, hf  (width and height of filter; each is >= 1)
      Return: pixd (of median values), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianFilter(*args)
    
    

    try:
        leptonica.pixRankFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRankFilter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       
  pixRankFilter()

      Input:  pixs (8 or 32 bpp; no colormap)
              wf, hf  (width and height of filter; each is >= 1)
              rank (in [0.0 ... 1.0])
      Return: pixd (of rank values), or null on error

  Notes:
      (1) This defines, for each pixel in pixs, a neighborhood of
          pixels given by a rectangle "centered" on the pixel.
          This set of wf*hf pixels has a distribution of values.
          For each component, if the values are sorted in increasing
          order, we choose the component such that rank*(wf*hf-1)
          pixels have a lower or equal value and
          (1-rank)*(wf*hf-1) pixels have an equal or greater value.
      (2) See notes in pixRankFilterGray() for further details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilter(*args)
    
    

    try:
        leptonica.pixRankFilterRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRankFilterRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankFilterRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilterRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       
  pixRankFilterRGB()

      Input:  pixs (32 bpp)
              wf, hf  (width and height of filter; each is >= 1)
              rank (in [0.0 ... 1.0])
      Return: pixd (of rank values), or null on error

  Notes:
      (1) This defines, for each pixel in pixs, a neighborhood of
          pixels given by a rectangle "centered" on the pixel.
          This set of wf*hf pixels has a distribution of values.
          For each component, if the values are sorted in increasing
          order, we choose the component such that rank*(wf*hf-1)
          pixels have a lower or equal value and
          (1-rank)*(wf*hf-1) pixels have an equal or greater value.
      (2) Apply gray rank filtering to each component independently.
      (3) See notes in pixRankFilterGray() for further details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilterRGB(*args)
    
    

    try:
        leptonica.pixRankFilterWithScaling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixRankFilterWithScaling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankFilterWithScaling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilterWithScaling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       
('l_float32', 'scalefactor')       
  pixRankFilterWithScaling()

      Input:  pixs (8 or 32 bpp; no colormap)
              wf, hf  (width and height of filter; each is >= 1)
              rank (in [0.0 ... 1.0])
              scalefactor (scale factor; must be >= 0.2 and <= 0.7)
      Return: pixd (of rank values), or null on error

  Notes:
      (1) This is a convenience function that downscales, does
          the rank filtering, and upscales.  Because the down-
          and up-scaling functions are very fast compared to
          rank filtering, the time it takes is reduced from that
          for the simple rank filtering operation by approximately
          the square of the scaling factor.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilterWithScaling(*args)
    
    

    try:
        leptonica.pixRankFilterGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRankFilterGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankFilterGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilterGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       
  pixRankFilterGray()

      Input:  pixs (8 bpp; no colormap)
              wf, hf  (width and height of filter; each is >= 1)
              rank (in [0.0 ... 1.0])
      Return: pixd (of rank values), or null on error

  Notes:
      (1) This defines, for each pixel in pixs, a neighborhood of
          pixels given by a rectangle "centered" on the pixel.
          This set of wf*hf pixels has a distribution of values,
          and if they are sorted in increasing order, we choose
          the pixel such that rank*(wf*hf-1) pixels have a lower
          or equal value and (1-rank)*(wf*hf-1) pixels have an equal
          or greater value.
      (2) By this definition, the rank = 0.0 pixel has the lowest
          value, and the rank = 1.0 pixel has the highest value.
      (3) We add mirrored boundary pixels to avoid boundary effects,
          and put the filter center at (0, 0).
      (4) This dispatches to grayscale erosion or dilation if the
          filter dimensions are odd and the rank is 0.0 or 1.0, rsp.
      (5) Returns a copy if both wf and hf are 1.
      (6) Uses row-major or column-major incremental updates to the
          histograms depending on whether hf > wf or hv <= wf, rsp.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilterGray(*args)
    




class fmorphauto(object):
    """  fmorphauto.c

    Main function calls:
       l_int32             fmorphautogen()
       l_int32             fmorphautogen1()
       l_int32             fmorphautogen2()

    Static helpers:
       static SARRAY      *sarrayMakeWplsCode()
       static SARRAY      *sarrayMakeInnerLoopDWACode()
       static char        *makeBarrelshiftString()


    This automatically generates dwa code for erosion and dilation.
    Here's a road map for how it all works.

    (1) You generate an array (a SELA) of structuring elements (SELs).
        This can be done in several ways, including
           (a) calling the function selaAddBasic() for
               pre-compiled SELs
           (b) generating the SELA in code in line
           (c) reading in a SELA from file, using selaRead() or
               various other formats.

    (2) You call fmorphautogen1() and fmorphautogen2() on this SELA.
        These use the text files morphtemplate1.txt and
        morphtemplate2.txt for building up the source code.  See the file
        prog/fmorphautogen.c for an example of how this is done.
        The output is written to files named fmorphgen.*.c
        and fmorphgenlow.*.c, where "*" is an integer that you
        input to this function.  That integer labels both
        the output files, as well as all the functions that
        are generated.  That way, using different integers,
        you can invoke fmorphautogen() any number of times
        to get functions that all have different names so that
        they can be linked into one program.

    (3) You copy the generated source files back to your src
        directory for compilation.  Put their names in the
        Makefile, regenerate the prototypes, and recompile
        the library.  Look at the Makefile to see how I've
        included morphgen.1.c and fmorphgenlow.1.c.  These files
        provide the high-level interfaces for erosion, dilation,
        opening and closing, and the low-level interfaces to
        do the actual work, for all 58 SELs in the SEL array.

    (4) In an application, you now use this interface.  Again
        for the example files in the library, using integer "1":

            PIX   *pixMorphDwa_1(PIX *pixd, PIX, *pixs,
                                 l_int32 operation, char *selname);

                 or

            PIX   *pixFMorphopGen_1(PIX *pixd, PIX *pixs,
                                    l_int32 operation, char *selname);

        where the operation is one of {L_MORPH_DILATE, L_MORPH_ERODE.
        L_MORPH_OPEN, L_MORPH_CLOSE}, and the selname is one
        of the set that were defined as the name field of sels.
        This set is listed at the beginning of the file fmorphgen.1.c.
        For examples of use, see the file prog/binmorph_reg1.c, which
        verifies the consistency of the various implementations by
        comparing the dwa result with that of full-image rasterops.

"""
    
    try:
        leptonica.fmorphautogen.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fmorphautogen.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fmorphautogen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fmorphautogen(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       
  fmorphautogen()

      Input:  sela
              fileindex
              filename (<optional>; can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This function generates all the code for implementing
          dwa morphological operations using all the sels in the sela.
      (2) See fmorphautogen1() and fmorphautogen2() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.fmorphautogen(*args)
    
    

    try:
        leptonica.fmorphautogen1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fmorphautogen1.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fmorphautogen1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fmorphautogen1(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       
  fmorphautogen1()

      Input:  sela
              fileindex
              filename (<optional>; can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This function uses morphtemplate1.txt to create a
          top-level file that contains two functions.  These
          functions will carry out dilation, erosion,
          opening or closing for any of the sels in the input sela.
      (2) The fileindex parameter is inserted into the output
          filename, as described below.
      (3) If filename == NULL, the output file is fmorphgen.<n>.c,
          where <n> is equal to the 'fileindex' parameter.
      (4) If filename != NULL, the output file is <filename>.<n>.c.


        """
        args = _convert_params(*args)
        
        return leptonica.fmorphautogen1(*args)
    




class rotate(object):
    """  rotate.c

     General rotation about image center
              PIX     *pixRotate()
              PIX     *pixEmbedForRotation()

     General rotation by sampling
              PIX     *pixRotateBySampling()

     Nice (slow) rotation of 1 bpp image
              PIX     *pixRotateBinaryNice()

     Rotation including alpha (blend) component
              PIX     *pixRotateWithAlpha()

     Rotations are measured in radians; clockwise is positive.

     The general rotation pixRotate() does the best job for
     rotating about the image center.  For 1 bpp, it uses shear;
     for others, it uses either shear or area mapping.
     If requested, it expands the output image so that no pixels are lost
     in the rotation, and this can be done on multiple successive shears
     without expanding beyond the maximum necessary size.

"""
    
    try:
        leptonica.pixRotateBySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateBySampling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateBySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateBySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateBySampling()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp rgb; can be cmapped)
              xcen (x value of center of rotation)
              ycen (y value of center of rotation)
              angle (radians; clockwise is positive)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) For very small rotations, just return a clone.
      (2) Rotation brings either white or black pixels in
          from outside the image.
      (3) Colormaps are retained.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateBySampling(*args)
    
    

    try:
        leptonica.pixEmbedForRotation.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixEmbedForRotation.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixEmbedForRotation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEmbedForRotation(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
('l_int32', 'width')       
('l_int32', 'height')       
  pixEmbedForRotation()

      Input:  pixs (1, 2, 4, 8, 32 bpp rgb)
              angle (radians; clockwise is positive)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
              width (original width; use 0 to avoid embedding)
              height (original height; use 0 to avoid embedding)
      Return: pixd, or null on error

  Notes:
      (1) For very small rotations, just return a clone.
      (2) Generate larger image to embed pixs if necessary, and
          place the center of the input image in the center.
      (3) Rotation brings either white or black pixels in
          from outside the image.  For colormapped images where
          there is no white or black, a new color is added if
          possible for these pixels; otherwise, either the
          lightest or darkest color is used.  In most cases,
          the colormap will be removed prior to rotation.
      (4) The dest is to be expanded so that no image pixels
          are lost after rotation.  Input of the original width
          and height allows the expansion to stop at the maximum
          required size, which is a square with side equal to
          sqrt(w*w + h*h).
      (5) For an arbitrary angle, the expansion can be found by
          considering the UL and UR corners.  As the image is
          rotated, these move in an arc centered at the center of
          the image.  Normalize to a unit circle by dividing by half
          the image diagonal.  After a rotation of T radians, the UL
          and UR corners are at points T radians along the unit
          circle.  Compute the x and y coordinates of both these
          points and take the max of absolute values; these represent
          the half width and half height of the containing rectangle.
          The arithmetic is done using formulas for sin(a+b) and cos(a+b),
          where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.
          For the UL corner, replace a by (pi - a), and you have
          sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations
          given below follow directly.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEmbedForRotation(*args)
    
    

    try:
        leptonica.pixRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRotate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'type')       
('l_int32', 'incolor')       
('l_int32', 'width')       
('l_int32', 'height')       
  pixRotate()

      Input:  pixs (1, 2, 4, 8, 32 bpp rgb)
              angle (radians; clockwise is positive)
              type (L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
              width (original width; use 0 to avoid embedding)
              height (original height; use 0 to avoid embedding)
      Return: pixd, or null on error

  Notes:
      (1) This is a high-level, simple interface for rotating images
          about their center.
      (2) For very small rotations, just return a clone.
      (3) Rotation brings either white or black pixels in
          from outside the image.
      (4) The rotation type is adjusted if necessary for the image
          depth and size of rotation angle.  For 1 bpp images, we
          rotate either by shear or sampling.
      (5) Colormaps are removed for rotation by area mapping.
      (6) The dest can be expanded so that no image pixels
          are lost.  To invoke expansion, input the original
          width and height.  For repeated rotation, use of the
          original width and height allows the expansion to
          stop at the maximum required size, which is a square
          with side = sqrt(w*w + h*h).

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate(*args)
    
    

    try:
        leptonica.pixRotateWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixRotateWithAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('PIX', '*pixg')       
('l_float32', 'fract')       
  pixRotateWithAlpha()

      Input:  pixs (32 bpp rgb or cmapped)
              angle (radians; clockwise is positive)
              pixg (<optional> 8 bpp, can be null)
              fract (between 0.0 and 1.0, with 0.0 fully transparent
                     and 1.0 fully opaque)
      Return: pixd (32 bpp rgba), or null on error

  Notes:
      (1) The alpha channel is transformed separately from pixs,
          and aligns with it, being fully transparent outside the
          boundary of the transformed pixs.  For pixels that are fully
          transparent, a blending function like pixBlendWithGrayMask()
          will give zero weight to corresponding pixels in pixs.
      (2) Rotation is about the center of the image; for very small
          rotations, just return a clone.  The dest is automatically
          expanded so that no image pixels are lost.
      (3) Rotation is by area mapping.  It doesn't matter what
          color is brought in because the alpha channel will
          be transparent (black) there.
      (4) If pixg is NULL, it is generated as an alpha layer that is
          partially opaque, using @fract.  Otherwise, it is cropped
          to pixs if required and @fract is ignored.  The alpha
          channel in pixs is never used.
      (4) Colormaps are removed to 32 bpp.
      (5) The default setting for the border values in the alpha channel
          is 0 (transparent) for the outermost ring of pixels and
          (0.5 * fract * 255) for the second ring.  When blended over
          a second image, this
          (a) shrinks the visible image to make a clean overlap edge
              with an image below, and
          (b) softens the edges by weakening the aliasing there.
          Use l_setAlphaMaskBorder() to change these values.
      (6) A subtle use of gamma correction is to remove gamma correction
          before rotation and restore it afterwards.  This is done
          by sandwiching this function between a gamma/inverse-gamma
          photometric transform:
              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
              pixd = pixRotateWithAlpha(pixt, angle, NULL, fract);
              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
              pixDestroy(&pixt);
          This has the side-effect of producing artifacts in the very
          dark regions.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateWithAlpha(*args)
    
    

    try:
        leptonica.pixRotateBinaryNice.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateBinaryNice.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateBinaryNice not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateBinaryNice(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateBinaryNice()

      Input:  pixs (1 bpp)
              angle (radians; clockwise is positive; about the center)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) For very small rotations, just return a clone.
      (2) This does a computationally expensive rotation of 1 bpp images.
          The fastest rotators (using shears or subsampling) leave
          visible horizontal and vertical shear lines across which
          the image shear changes by one pixel.  To ameliorate the
          visual effect one can introduce random dithering.  One
          way to do this in a not-too-random fashion is given here.
          We convert to 8 bpp, do a very small blur, rotate using
          linear interpolation (same as area mapping), do a
          small amount of sharpening to compensate for the initial
          blur, and threshold back to binary.  The shear lines
          are magically removed.
      (3) This operation is about 5x slower than rotation by sampling.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateBinaryNice(*args)
    




class regutils(object):
    """  regutils.c

       Regression test utilities
           l_int32    regTestSetup()
           l_int32    regTestCleanup()
           l_int32    regTestCompareValues()
           l_int32    regTestCompareStrings()
           l_int32    regTestComparePix()
           l_int32    regTestCompareSimilarPix()
           l_int32    regTestCheckFile()
           l_int32    regTestCompareFiles()
           l_int32    regTestWritePixAndCheck()

       Static function
           char      *getRootNameFromArgv0()

  See regutils.h for how to use this.  Here is a minimal setup:

  main(int argc, char **argv) {
  ...
  L_REGPARAMS  *rp;

      if (regTestSetup(argc, argv, &rp))
          return 1;
      ...
      regTestWritePixAndCheck(rp, pix, IFF_PNG);  // 0
      ...
      return regTestCleanup(rp);
  }

"""
    
    try:
        leptonica.regTestCompareSimilarPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.regTestCompareSimilarPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestCompareSimilarPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareSimilarPix(*args):
        """
        ('L_REGPARAMS', '*rp')       
('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'mindiff')       
('l_float32', 'maxfract')       
('l_int32', 'printstats')       
  regTestCompareSimilarPix()

      Input:  rp (regtest parameters)
              pix1, pix2 (to be tested for near equality)
              mindiff (minimum pixel difference to be counted; > 0)
              maxfract (maximum fraction of pixels allowed to have
                        diff greater than or equal to mindiff)
              printstats (use 1 to print normalized histogram to stderr)
      Return: 0 if OK, 1 on error (a failure in similarity comparison
              is not an error)

  Notes:
      (1) This function compares two pix for near equality.  On failure,
          this writes to stderr.
      (2) The pix are similar if the fraction of non-conforming pixels
          does not exceed @maxfract.  Pixels are non-conforming if
          the difference in pixel values equals or exceeds @mindiff.
          Typical values might be @mindiff = 15 and @maxfract = 0.01.
      (3) The input images must have the same size and depth.  The
          pixels for comparison are typically subsampled from the images.
      (4) Normally, use @printstats = 0.  In debugging mode, to see
          the relation between @mindiff and the minimum value of
          @maxfract for success, set this to 1.


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareSimilarPix(*args)
    
    

    try:
        leptonica.regTestCleanup.argtypes = [ctypes.c_void_p]
        leptonica.regTestCleanup.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestCleanup not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCleanup(*args):
        """
        ('L_REGPARAMS', '*rp')       
  regTestCleanup()

      Input:  rp (regression test parameters)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This copies anything written to the temporary file to the
          output file /tmp/reg_results.txt.


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCleanup(*args)
    
    

    try:
        leptonica.regTestCompareStrings.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.regTestCompareStrings.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestCompareStrings not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareStrings(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_uint8', '*string1')       
('size_t', 'bytes1')       
('l_uint8', '*string2')       
('size_t', 'bytes2')       
  regTestCompareStrings()

      Input:  rp (regtest parameters)
              string1 (typ. the expected string)
              bytes1 (size of string1)
              string2 (typ. the computed string)
              bytes2 (size of string2)
      Return: 0 if OK, 1 on error (a failure in comparison is not an error)


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareStrings(*args)
    
    

    try:
        leptonica.regTestCompareFiles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.regTestCompareFiles.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestCompareFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareFiles(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_int32', 'index1')       
('l_int32', 'index2')       
  regTestCompareFiles()

      Input:  rp (regtest parameters)
              index1 (of one output file from reg test)
              index2 (of another output file from reg test)
      Return: 0 if OK, 1 on error (a failure in comparison is not an error)

  Notes:
      (1) This only does something in "compare" mode.
      (2) The canonical format of the golden filenames is:
            /tmp/golden/<root of main name>_golden.<index>.<ext of localname>
          e.g.,
            /tmp/golden/maze_golden.0.png


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareFiles(*args)
    
    

    try:
        leptonica.regTestSetup.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.regTestSetup.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestSetup not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestSetup(*args):
        """
        ('l_int32', 'argc')       
('char', '**argv')       
('L_REGPARAMS', '**prp')       
  regTestSetup()

      Input:  argc (from invocation; can be either 1 or 2)
              argv (to regtest: @argv[1] is one of these:
                    "generate", "compare", "display")
              &rp (<return> all regression params)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Call this function with the args to the reg test.
          There are three cases:
          Case 1:
              There is either only one arg, or the second arg is "compare".
              This is the mode in which you run a regression test
              (or a set of them), looking for failures and logging
              the results to a file.  The output, which includes
              logging of all reg test failures plus a SUCCESS or
              FAILURE summary for each test, is appended to the file
              "/tmp/reg_results.txt.  For this case, as in Case 2,
              the display field in rp is set to FALSE, preventing
              image display.
          Case 2:
              The second arg is "generate".  This will cause
              generation of new golden files for the reg test.
              The results of the reg test are not recorded, and
              the display field in rp is set to FALSE.
          Case 3:
              The second arg is "display".  The test will run and
              files will be written.  Comparisons with golden files
              will not be carried out, so the only notion of success
              or failure is with tests that do not involve golden files.
              The display field in rp is TRUE, and this is used by
              pixDisplayWithTitle().
      (2) See regutils.h for examples of usage.


        """
        args = _convert_params(*args)
        
        return leptonica.regTestSetup(*args)
    
    

    try:
        leptonica.regTestCheckFile.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.regTestCheckFile.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestCheckFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCheckFile(*args):
        """
        ('L_REGPARAMS', '*rp')       
('const char', '*localname')       
  regTestCheckFile()

      Input:  rp (regtest parameters)
              localname (name of output file from reg test)
      Return: 0 if OK, 1 on error (a failure in comparison is not an error)

  Notes:
      (1) This function does one of three things, depending on the mode:
           * "generate": makes a "golden" file as a copy @localname.
           * "compare": compares @localname contents with the golden file
           * "display": makes the @localname file but does no comparison
      (2) The canonical format of the golden filenames is:
            /tmp/golden/<root of main name>_golden.<index>.<ext of localname>
          e.g.,
             /tmp/golden/maze_golden.0.png
          It is important to add an extension to the local name, because
          the extension is added to the name of the golden file.


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCheckFile(*args)
    
    

    try:
        leptonica.regTestComparePix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.regTestComparePix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestComparePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestComparePix(*args):
        """
        ('L_REGPARAMS', '*rp')       
('PIX', '*pix1')       
('PIX', '*pix2')       
  regTestComparePix()

      Input:  rp (regtest parameters)
              pix1, pix2 (to be tested for equality)
      Return: 0 if OK, 1 on error (a failure in comparison is not an error)

  Notes:
      (1) This function compares two pix for equality.  On failure,
          this writes to stderr.


        """
        args = _convert_params(*args)
        
        return leptonica.regTestComparePix(*args)
    
    

    try:
        leptonica.regTestCompareValues.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.regTestCompareValues.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestCompareValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareValues(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_float32', 'val1')       
('l_float32', 'val2')       
('l_float32', 'delta')       
  regTestCompareValues()

      Input:  rp (regtest parameters)
              val1 (typ. the golden value)
              val2 (typ. the value computed)
              delta (allowed max absolute difference)
      Return: 0 if OK, 1 on error (a failure in comparison is not an error)


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareValues(*args)
    
    

    try:
        leptonica.regTestWritePixAndCheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.regTestWritePixAndCheck.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function regTestWritePixAndCheck not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestWritePixAndCheck(*args):
        """
        ('L_REGPARAMS', '*rp')       
('PIX', '*pix')       
('l_int32', 'format')       
  regTestWritePixAndCheck()

      Input:  rp (regtest parameters)
              pix (to be written)
              format (of output pix)
      Return: 0 if OK, 1 on error (a failure in comparison is not an error)

  Notes:
      (1) This function makes it easy to write the pix in a numbered
          sequence of files, and either to:
             (a) write the golden file ("generate" arg to regression test)
             (b) make a local file and "compare" with the golden file
             (c) make a local file and "display" the results
      (3) The canonical format of the local filename is:
            /tmp/regout/<root of main name>.<count>.<format extension string>
          e.g., for scale_reg,
            /tmp/regout/scale.0.png


        """
        args = _convert_params(*args)
        
        return leptonica.regTestWritePixAndCheck(*args)
    




class pageseg(object):
    """   pageseg.c

      Top level page segmentation
          l_int32   pixGetRegionsBinary()

      Halftone region extraction
          PIX      *pixGenHalftoneMask()

      Textline extraction
          PIX      *pixGenTextlineMask()

      Textblock extraction
          PIX      *pixGenTextblockMask()

      Location of page foreground
          PIX      *pixFindPageForeground()

      Extraction of characters from image with only text
          l_int32   pixSplitIntoCharacters()
          BOXA     *pixSplitComponentWithProfile()

"""
    
    try:
        leptonica.pixGenHalftoneMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGenHalftoneMask.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenHalftoneMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenHalftoneMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixtext')       
('l_int32', '*phtfound')       
('l_int32', 'debug')       
  pixGenHalftoneMask()

      Input:  pixs (1 bpp, assumed to be 150 to 200 ppi)
              &pixtext (<optional return> text part of pixs)
              &htfound (<optional return> 1 if the mask is not empty)
              debug (flag: 1 for debug output)
      Return: pixd (halftone mask), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenHalftoneMask(*args)
    
    

    try:
        leptonica.pixSplitComponentWithProfile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSplitComponentWithProfile.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSplitComponentWithProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitComponentWithProfile(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'delta')       
('l_int32', 'mindel')       
('PIX', '**ppixdebug')       
  pixSplitComponentWithProfile()

      Input:  pixs (1 bpp, exactly one connected component)
              delta (distance used in extrema finding in a numa; typ. 10)
              mindel (minimum required difference between profile minimum
                      and profile values +2 and -2 away; typ. 7)
              &pixdebug (<optional return> debug image of splitting)
      Return: boxa (of c.c. after splitting), or null on error

  Notes:
      (1) This will split the most obvious cases of touching characters.
          The split points it is searching for are narrow and deep
          minimima in the vertical pixel projection profile, after a
          large vertical closing has been applied to the component.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitComponentWithProfile(*args)
    
    

    try:
        leptonica.pixGenTextblockMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGenTextblockMask.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenTextblockMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenTextblockMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixvws')       
('l_int32', 'debug')       
  pixGenTextblockMask()

      Input:  pixs (1 bpp, textline mask, assumed to be 150 to 200 ppi)
              pixvws (vertical white space mask)
              debug (flag: 1 for debug output)
      Return: pixd (textblock mask), or null on error

  Notes:
      (1) Both the input masks (textline and vertical white space) and
          the returned textblock mask are at the same resolution.
      (2) The result is somewhat noisy, in that small "blocks" of
          text may be included.  These can be removed by post-processing,
          using, e.g.,
             pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,
                             L_SELECT_IF_GTE, NULL);


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenTextblockMask(*args)
    
    

    try:
        leptonica.pixFindPageForeground.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFindPageForeground.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindPageForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindPageForeground(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'threshold')       
('l_int32', 'mindist')       
('l_int32', 'erasedist')       
('l_int32', 'pagenum')       
('l_int32', 'showmorph')       
('l_int32', 'display')       
('const char', '*pdfdir')       
  pixFindPageForeground()

      Input:  pixs (full resolution (any type or depth)
              threshold (for binarization; typically about 128)
              mindist (min distance of text from border to allow
                       cleaning near border; at 2x reduction, this
                       should be larger than 50; typically about 70)
              erasedist (when conditions are satisfied, erase anything
                         within this distance of the edge;
                         typically 30 at 2x reduction)
              pagenum (use for debugging when called repeatedly; labels
                       debug images that are assembled into pdfdir)
              showmorph (set to a negative integer to show steps in
                         generating masks; this is typically used
                         for debugging region extraction)
              display (set to 1  to display mask and selected region
                       for debugging a single page)
              pdfdir (subdirectory of /tmp where images showing the
                      result are placed when called repeatedly; use
                      null if no output requested)
      Return: box (region including foreground, with some pixel noise
                   removed), or null if not found

  Notes:
      (1) This doesn't simply crop to the fg.  It attempts to remove
          pixel noise and junk at the edge of the image before cropping.
          The input @threshold is used if pixs is not 1 bpp.
      (2) There are several debugging options, determined by the
          last 4 arguments.
      (3) If you want pdf output of results when called repeatedly,
          the pagenum arg labels the images written, which go into
          /tmp/<pdfdir>/<pagenum>.png.  In that case,
          you would clean out the /tmp directory before calling this
          function on each page:
              lept_rmdir(pdfdir);
              lept_mkdir(pdfdir);


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindPageForeground(*args)
    
    

    try:
        leptonica.pixGenTextlineMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGenTextlineMask.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenTextlineMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenTextlineMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixvws')       
('l_int32', '*ptlfound')       
('l_int32', 'debug')       
  pixGenTextlineMask()

      Input:  pixs (1 bpp, assumed to be 150 to 200 ppi)
              &pixvws (<return> vertical whitespace mask)
              &tlfound (<optional return> 1 if the mask is not empty)
              debug (flag: 1 for debug output)
      Return: pixd (textline mask), or null on error

  Notes:
      (1) The input pixs should be deskewed.
      (2) pixs should have no halftone pixels.
      (3) Both the input image and the returned textline mask
          are at the same resolution.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenTextlineMask(*args)
    
    

    try:
        leptonica.pixGetRegionsBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetRegionsBinary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRegionsBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRegionsBinary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixhm')       
('PIX', '**ppixtm')       
('PIX', '**ppixtb')       
('l_int32', 'debug')       
  pixGetRegionsBinary()

      Input:  pixs (1 bpp, assumed to be 300 to 400 ppi)
              &pixhm (<optional return> halftone mask)
              &pixtm (<optional return> textline mask)
              &pixtb (<optional return> textblock mask)
              debug (flag: set to 1 for debug output)
      Return: 0 if OK, 1 on error

  Notes:
      (1) It is best to deskew the image before segmenting.
      (2) The debug flag enables a number of outputs.  These
          are included to show how to generate and save/display
          these results.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRegionsBinary(*args)
    
    

    try:
        leptonica.pixSplitIntoCharacters.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSplitIntoCharacters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSplitIntoCharacters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitIntoCharacters(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('BOXA', '**pboxa')       
('PIXA', '**ppixa')       
('PIX', '**ppixdebug')       
  pixSplitIntoCharacters()

      Input:  pixs (1 bpp, contains only deskewed text)
              minw (minimum component width for initial filtering; typ. 4)
              minh (minimum component height for initial filtering; typ. 4)
              &boxa (<optional return> character bounding boxes)
              &pixa (<optional return> character images)
              &pixdebug (<optional return> showing splittings)

      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a simple function that attempts to find split points
          based on vertical pixel profiles.
      (2) It should be given an image that has an arbitrary number
          of text characters.
      (3) The returned pixa includes the boxes from which the
          (possibly split) components are extracted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitIntoCharacters(*args)
    




class list(object):
    """   list.c

      Inserting and removing elements

           void      listDestroy()
           DLLIST   *listAddToHead()
           l_int32   listAddToTail()
           l_int32   listInsertBefore()
           l_int32   listInsertAfter()
           void     *listRemoveElement()
           void     *listRemoveFromHead()
           void     *listRemoveFromTail()

      Other list operations

           DLLIST   *listFindElement()
           DLLIST   *listFindTail()
           l_int32   listGetCount()
           l_int32   listReverse()
           DLLIST   *listJoin()

      Lists are much harder to handle than arrays.  There is
      more overhead for the programmer, both cognitive and
      codewise, and more likelihood that an error can be made.
      For that reason, lists should only be used when it is
      inefficient to use arrays, such as when elements are
      routinely inserted or deleted from inside arrays whose
      average size is greater than about 10.

      A list of data structures can be implemented in a number
      of ways.  The two most popular are:

         (1) The list can be composed of a linked list of
             pointer cells ("cons cells"), where the data structures
             are hung off the cells.  This is more difficult
             to use because you have to keep track of both
             your hanging data and the cell structures.
             It requires 3 pointers for every data structure
             that is put in a list.  There is no problem
             cloning (using reference counts) for structures that
             are put in such a list.  We implement lists by this
             method here.

         (2) The list pointers can be inserted directly into
             the data structures.  This is easy to implement
             and easier to use, but it adds 2 ptrs of overhead
             to every data structure in which the ptrs are embedded.
             It also requires special care not to put the ptrs
             in any data that is cloned with a reference count;
             else your lists will break.

      Writing C code that uses list pointers explicitly to make
      and alter lists is difficult and prone to error.
      Consequently, a generic list utility that handles lists
      of arbitrary objects and doesn't force the programmer to
      touch the "next" and "prev" pointers, is quite useful.
      Such functions are provided here.   However, the usual
      situation requires traversing a list and applying some
      function to one or more of the list elements.  Macros
      for traversing the list are, in general, necessary, to
      achieve the goal of invisibly handling all "next" and "prev"
      pointers in generic lists.  We provide macros for
      traversing a list in both forward and reverse directions.

      Because of the typing in C, implementation of a general
      list utility requires casting.  If macros are used, the
      casting can be done implicitly; otherwise, using functions,
      some of the casts must be explicit.  Fortunately, this
      can be implemented with void* so the programmer using
      the library will not have to make any casts!  (Unless you
      compile with g++, in which case the rules on implicit
      conversion are more strict.)

      For example, to add an arbitrary data structure foo to the
      tail of a list, use
             listAddToTail(&head, &tail, pfoo);
      where head and tail are list cell ptrs and pfoo is
      a pointer to the foo object.
      And to remove an arbitrary data structure foo from a
      list, when you know the list cell element it is hanging from,
      use
             pfoo = listRemoveElement(&head, elem)
      where head and elem are list cell ptrs and pfoo is a pointer
      to the foo object.  No casts are required for foo in
      either direction in ANSI C.  (However, casts are
      required for ANSI C++).

      We use lists that are composed of doubly-linked
      cells with data structures hanging off the cells.
      We use doubly-linked cells to simplify insertion
      and deletion, and to allow operations to proceed in either
      direction along the list.  With doubly-linked lists,
      it is tempting to make them circular, by setting head->prev
      to the tail of the list and tail->next to the head.
      The circular list costs nothing extra in storage, and
      allows operations to proceed from either end of the list
      with equal speed.  However, the circular link adds
      cognitive overhead for the application programmer in
      general, and it greatly complicates list traversal when
      arbitrary list elements can be added or removed as you
      move through.  It can be done, but in the spirit of
      simplicity, we avoid the temptation.  The price to be paid
      is the extra cost to find the tail of a list -- a full
      traversal -- before the tail can be used.  This is a
      cheap price to pay to avoid major headaches and buggy code.

      When you are only applying some function to each element
      in a list, you can go either forwards or backwards.
      To run through a list forwards, use:

          for (elem = head; elem; elem = nextelem) {
              nextelem = elem->next;   (in case we destroy elem)
              <do something with elem->data>
          }

      To run through a list backwards, find the tail and use:

          for (elem = tail; elem; elem = prevelem) {
              prevelem = elem->prev;  (in case we destroy elem)
              <do something with elem->data>
          }

      Even though these patterns are very simple, they are so common
      that we've provided macros for them in list.h.  Using the
      macros, this becomes:

          L_BEGIN_LIST_FORWARD(head, elem)
              <do something with elem->data>
          L_END_LIST

          L_BEGIN_LIST_REVERSE(tail, elem)
              <do something with elem->data>
          L_END_LIST

      Note again that with macros, the application programmer does
      not need to refer explicitly to next and prev fields.  Also,
      in the reverse case, note that we do not explicitly
      show the head of the list.  However, the head of the list
      is always in scope, and functions can be called within the
      iterator that change the head.

      Some special cases are simpler.  For example, when
      removing all items from the head of the list, you can use

          while (head) {
              obj = listRemoveFromHead(&head);
              <do something with obj>
          }

      Removing successive elements from the tail is equally simple:

          while (tail) {
              obj = listRemoveFromTail(&head, &tail);
              <do something with obj>
          }

      When removing an arbitrary element from a list, use

              obj = listRemoveElement(&head, elem);

      All the listRemove*() functions hand you the object,
      destroy the list cell to which it was attached, and
      reset the list pointers if necessary.

      Several other list operations, that do not involve
      inserting or removing objects, are also provided.
      The function listFindElement() locates a list pointer
      by matching the object hanging on it to a given
      object.  The function listFindTail() gets a handle
      to the tail list ptr, allowing backwards traversals of
      the list.  listGetCount() gives the number of elements
      in a list.  Functions that reverse a list and concatenate
      two lists are also provided.

      These functions can be modified for efficiency in the
      situation where there is a large amount of creation and
      destruction of list cells.  If millions of cells are
      made and destroyed, but a relatively small number are
      around at any time, the list cells can be stored for
      later re-use in a stack (see the generic stack functions
      in stack.c).

"""
    
    try:
        leptonica.listJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listJoin(*args):
        """
        ('DLLIST', '**phead1')       
('DLLIST', '**phead2')       
  listJoin()

      Input:  &head1  (<may be changed> head of first list)
              &head2  (<to be nulled> head of second list)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The concatenated list is returned with head1 as the new head.
      (2) Both input ptrs must exist, though either can have the value NULL.


        """
        args = _convert_params(*args)
        
        return leptonica.listJoin(*args)
    
    

    try:
        leptonica.listInsertAfter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listInsertAfter.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listInsertAfter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listInsertAfter(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '*elem')       
('void', '*data')       
  listInsertAfter()

      Input:  &head  (<optional> input head)
               elem  (list element to be inserted after;
                      must be null if head is null)
               data  (void*  ptr, to be added)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This can be called on a null list, in which case both
          head and elem must be null.  The head is included
          in the call to allow "consing" up from NULL.
      (2) If you are searching through a list, looking for a condition
          to add an element, you can do something like this:
            L_BEGIN_LIST_FORWARD(head, elem)
                <identify an elem to insert after>
                listInsertAfter(&head, elem, data);
            L_END_LIST


        """
        args = _convert_params(*args)
        
        return leptonica.listInsertAfter(*args)
    
    

    try:
        leptonica.listAddToTail.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listAddToTail.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listAddToTail not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listAddToTail(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '**ptail')       
('void', '*data')       
  listAddToTail()

      Input:  &head  (<may be updated>, head can be null)
              &tail  (<updated>, tail can be null)
              data  (void* ptr, to be hung on tail cons cell)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This makes a new cell, attaches the data, and adds the
          cell to the tail of the list.
      (2) &head is input to allow the list to be "cons'd" up from NULL.
      (3) &tail is input to allow the tail to be updated
          for efficient sequential operation with this function.
      (4) We assume that if *phead and/or *ptail are not NULL,
          then they are valid addresses.  Therefore:
           (a) when consing from NULL, be sure to initialize both
               head and tail to NULL.
           (b) when tail == NULL for an existing list, the tail
               will be found and updated.


        """
        args = _convert_params(*args)
        
        return leptonica.listAddToTail(*args)
    
    

    try:
        leptonica.listFindElement.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listFindElement.restype = lambda address: DLLIST(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function listFindElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listFindElement(*args):
        """
        ('DLLIST', '*head')       
('void', '*data')       
  listFindElement()

      Input:  head  (list head)
              data  (void*  address, to be searched for)
      Return: cell  (the containing cell, or null if not found or on error)

  Notes:
      (1) This returns a ptr to the cell, which is still embedded in
          the list.
      (2) This handle and the attached data have not been copied or
          reference counted, so they must not be destroyed.  This
          violates our basic rule that every handle returned from a
          function is owned by that function and must be destroyed,
          but if rules aren't there to be broken, why have them?


        """
        args = _convert_params(*args)
        
        return leptonica.listFindElement(*args)
    
    

    try:
        leptonica.listRemoveElement.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listRemoveElement.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function listRemoveElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listRemoveElement(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '*elem')       
  listRemoveElement()

      Input:  &head (<can be changed> input head)
              elem (list element to be removed)
      Return: data  (void* struct on cell)

  Notes:
      (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
             pix = listRemoveElement(&head, elem);
          but in ANSI C++, it is necessary to do the cast:
             pix = (Pix *)listRemoveElement(&head, elem);


        """
        args = _convert_params(*args)
        
        return leptonica.listRemoveElement(*args)
    
    

    try:
        leptonica.listAddToHead.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listAddToHead.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listAddToHead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listAddToHead(*args):
        """
        ('DLLIST', '**phead')       
('void', '*data')       
  listAddToHead()

      Input:  &head  (<optional> input head)
              data  (void* ptr, to be added)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This makes a new cell, attaches the data, and adds the
          cell to the head of the list.
      (2) When consing from NULL, be sure to initialize head to NULL
          before calling this function.


        """
        args = _convert_params(*args)
        
        return leptonica.listAddToHead(*args)
    
    

    try:
        leptonica.listFindTail.argtypes = [ctypes.c_void_p]
        leptonica.listFindTail.restype = lambda address: DLLIST(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function listFindTail not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listFindTail(*args):
        """
        ('DLLIST', '*head')       
  listFindTail()

      Input:  head
      Return: tail, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.listFindTail(*args)
    
    

    try:
        leptonica.listReverse.argtypes = [ctypes.c_void_p]
        leptonica.listReverse.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listReverse(*args):
        """
        ('DLLIST', '**phead')       
  listReverse()

      Input:  &head  (<may be changed> list head)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This reverses the list in-place.


        """
        args = _convert_params(*args)
        
        return leptonica.listReverse(*args)
    
    

    try:
        leptonica.listInsertBefore.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listInsertBefore.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listInsertBefore not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listInsertBefore(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '*elem')       
('void', '*data')       
  listInsertBefore()

      Input:  &head  (<optional> input head)
               elem  (list element to be inserted in front of;
                      must be null if head is null)
               data  (void*  address, to be added)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This can be called on a null list, in which case both
          head and elem must be null.
      (2) If you are searching through a list, looking for a condition
          to add an element, you can do something like this:
            L_BEGIN_LIST_FORWARD(head, elem)
                <identify an elem to insert before>
                listInsertBefore(&head, elem, data);
            L_END_LIST



        """
        args = _convert_params(*args)
        
        return leptonica.listInsertBefore(*args)
    
    

    try:
        leptonica.listRemoveFromTail.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listRemoveFromTail.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function listRemoveFromTail not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listRemoveFromTail(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '**ptail')       
  listRemoveFromTail()

      Input:  &head (<may be changed>, head must NOT be null)
              &tail (<always updated>, tail may be null)
      Return: data  (void* struct on cell) or null on error

  Notes:
      (1) We include &head so that it can be set to NULL if
          if the only element in the list is removed.
      (2) The function is relying on the fact that if tail is
          not NULL, then is is a valid address.  You can use
          this function with tail == NULL for an existing list, in
          which case  the tail is found and updated, and the
          removed element is returned.
      (3) In ANSI C, it is not necessary to cast return to actual type; e.g.,
            pix = listRemoveFromTail(&head, &tail);
          but in ANSI C++, it is necessary to do the cast; e.g.,
            pix = (Pix *)listRemoveFromTail(&head, &tail);


        """
        args = _convert_params(*args)
        
        return leptonica.listRemoveFromTail(*args)
    
    

    try:
        leptonica.listGetCount.argtypes = [ctypes.c_void_p]
        leptonica.listGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function listGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listGetCount(*args):
        """
        ('DLLIST', '*head')       
  listGetCount()

      Input:  head  (of list)
      Return: number of elements; 0 if no list or on error


        """
        args = _convert_params(*args)
        
        return leptonica.listGetCount(*args)
    
    

    try:
        leptonica.listRemoveFromHead.argtypes = [ctypes.c_void_p]
        leptonica.listRemoveFromHead.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function listRemoveFromHead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listRemoveFromHead(*args):
        """
        ('DLLIST', '**phead')       
  listRemoveFromHead()

      Input:  &head (<to be updated> head of list)
      Return: data  (void* struct on cell), or null on error

  Notes:
      (1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
            pix = listRemoveFromHead(&head);
          but in ANSI C++, it is necessary to do the cast; e.g.,
            pix = (Pix *)listRemoveFromHead(&head);


        """
        args = _convert_params(*args)
        
        return leptonica.listRemoveFromHead(*args)
    
    

    try:
        leptonica.listDestroy.argtypes = [ctypes.c_void_p]
        leptonica.listDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function listDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listDestroy(*args):
        """
        ('DLLIST', '**phead')       
  listDestroy()

      Input:  &head   (<to be nulled> head of list)
      Return: void

  Notes:
      (1) This only destroys the cons cells.  Before destroying
          the list, it is necessary to remove all data and set the
          data pointers in each cons cell to NULL.
      (2) listDestroy() will give a warning message for each data
          ptr that is not NULL.


        """
        args = _convert_params(*args)
        
        return leptonica.listDestroy(*args)
    




class flipdetect(object):
    """  flipdetect.c

      Page orientation detection (pure rotation by 90 degree increments):
          l_int32      pixOrientDetect()
          l_int32      makeOrientDecision()
          l_int32      pixUpDownDetect()
          l_int32      pixUpDownDetectGeneral()
          l_int32      pixOrientDetectDwa()
          l_int32      pixUpDownDetectDwa()
          l_int32      pixUpDownDetectGeneralDwa()

      Page mirror detection (flip 180 degrees about line in plane of image):
          l_int32      pixMirrorDetect()
          l_int32      pixMirrorDetectDwa()

      Static debug helper
          void         pixDebugFlipDetect()

  ===================================================================

  Page transformation detection:

  Once a page is deskewed, there are 8 possible states that it
  can be in, shown symbolically below.  Suppose state 0 is correct.

      0: correct     1          2          3
      +------+   +------+   +------+   +------+
      | **** |   | *    |   | **** |   |    * |
      | *    |   | *    |   |    * |   |    * |
      | *    |   | **** |   |    * |   | **** |
      +------+   +------+   +------+   +------+

         4          5          6          7
      +-----+    +-----+    +-----+    +-----+
      | *** |    |   * |    | *** |    | *   |
      |   * |    |   * |    | *   |    | *   |
      |   * |    |   * |    | *   |    | *   |
      |   * |    | *** |    | *   |    | *** |
      +-----+    +-----+    +-----+    +-----+

  Each of the other seven can be derived from state 0 by applying some
  combination of a 90 degree clockwise rotation, a flip about
  a horizontal line, and a flip about a vertical line,
  all abbreviated as:
      R = Rotation (about a line perpendicular to the image)
      H = Horizontal flip (about a vertical line in the plane of the image)
      V = Vertical flip (about a horizontal line in the plane of the image)

  We get these transformations:
      RHV
      000  -> 0
      001  -> 1
      010  -> 2
      011  -> 3
      100  -> 4
      101  -> 5
      110  -> 6
      111  -> 7

  Note that in four of these, the sum of H and V is 1 (odd).
  For these four, we have a change in parity (handedness) of
  the image, and the transformation cannot be performed by
  rotation about a vertical line out of the page.   Under
  rotation R, the set of 8 transformations decomposes into
  two subgroups linking {0, 3, 4, 7} and {1, 2, 5, 6} independently.

  pixOrientDetect*() tests for a pure rotation (0, 90, 180, 270 degrees).
  It doesn't change parity.

  pixMirrorDetect*() tests for a horizontal flip about the vertical axis.
  It changes parity.

  The landscape/portrait rotation can be detected in two ways:

    (1) Compute the deskew confidence for an image segment,
        both as is and rotated 90 degrees  (see skew.c).

    (2) Compute the ascender/descender signal for the image,
        both as is and rotated 90 degrees  (implemented here).

  The ascender/descender signal is useful for determining text
  orientation in Roman alphabets because the incidence of letters
  with straight-line ascenders (b, d, h, k, l, <t>) outnumber
  those with descenders (<g>, p, q).  The letters <t> and <g>
  will respond variably to the filter, depending on the type face.

  What about the mirror image situations?  These aren't common
  unless you're dealing with film, for example.
  But you can reliably test if the image has undergone a
  parity-changing flip once about some axis in the plane
  of the image, using pixMirrorDetect*().  This works ostensibly by
  counting the number of characters with ascenders that
  stick out to the left and right of the ascender.  Characters
  that are not mirror flipped are more likely to extend to the
  right (b, h, k) than to the left (d).  Of course, that is for
  text that is rightside-up.  So before you apply the mirror
  test, it is necessary to insure that the text has the ascenders
  going up, and not down or to the left or right.  But here's
  what *really* happens.  It turns out that the pre-filtering before
  the hit-miss transform (HMT) is crucial, and surprisingly, when
  the pre-filtering is chosen to generate a large signal, the majority
  of the signal comes from open regions of common lower-case
  letters such as 'e', 'c' and 'f'.

  All operations are given in two implementations whose results are
  identical: rasterop morphology and dwa morphology.  The dwa
  implementations are between 2x and 3x faster.

  The set of operations you actually use depends on your prior knowledge:

  (1) If the page is known to be either rightside-up or upside-down, use
      either pixOrientDetect*() with pleftconf = NULL, or
      pixUpDownDetect*().   [The '*' refers to either the rasterop
      or dwa versions.]

  (2) If any of the four orientations are possible, use pixOrientDetect*().

  (3) If the text is horizontal and rightside-up, the only remaining
      degree of freedom is a left-right mirror flip: use
      pixMirrorDetect*().

  (4) If you have a relatively large amount of numbers on the page,
      us the slower pixUpDownDetectGeneral().

  We summarize the full orientation and mirror flip detection process:

  (1) First determine which of the four 90 degree rotations
      causes the text to be rightside-up.  This can be done
      with either skew confidence or the pixOrientDetect*()
      signals.  For the latter, see the table for pixOrientDetect().

  (2) Then, with ascenders pointing up, apply pixMirrorDetect*().
      In the normal situation the confidence confidence will be
      large and positive.  However, if mirror flipped, the
      confidence will be large and negative.

"""
    
    try:
        leptonica.pixUpDownDetect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixUpDownDetect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       
  pixUpDownDetect()

      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)
              &conf (<return> confidence that text is rightside-up)
              mincount (min number of up + down; use 0 for default)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Special (typical, slightly faster) case, where the pixels
          identified through the HMT (hit-miss transform) are not
          clipped by a truncated word mask pixm.  See pixOrientDetect()
          and pixUpDownDetectGeneral() for details.
      (2) The returned confidence is the normalized difference
          between the number of detected up and down ascenders,
          assuming that the text is either rightside-up or upside-down
          and not rotated at a 90 degree angle.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetect(*args)
    
    

    try:
        leptonica.pixMirrorDetect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMirrorDetect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMirrorDetect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMirrorDetect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       
  pixMirrorDetect()

      Input:  pixs (1 bpp, deskewed, English text)
              &conf (<return> confidence that text is not LR mirror reversed)
              mincount (min number of left + right; use 0 for default)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) For this test, it is necessary that the text is horizontally
          oriented, with ascenders going up.
      (2) conf is the normalized difference between the number of
          right and left facing characters with ascenders.
          Left-facing are {d}; right-facing are {b, h, k}.
          At least that was the expectation.  In practice, we can
          really just say that it is the normalized difference in
          hits using two specific hit-miss filters, textsel1 and textsel2,
          after the image has been suitably pre-filtered so that
          these filters are effective.  See (4) for what's really happening.
      (3) A large positive conf value indicates normal text, whereas
          a large negative conf value means the page is mirror reversed.
      (4) The implementation is a bit tricky.  The general idea is
          to fill the x-height part of characters, but not the space
          between them, before doing the HMT.  This is done by
          finding pixels added using two different operations -- a
          horizontal close and a vertical dilation -- and adding
          the intersection of these sets to the original.  It turns
          out that the original intuition about the signal was largely
          in error: much of the signal for right-facing characters
          comes from the lower part of common x-height characters, like
          the e and c, that remain open after these operations.
          So it's important that the operations to close the x-height
          parts of the characters are purposely weakened sufficiently
          to allow these characters to remain open.  The wonders
          of morphology!


        """
        args = _convert_params(*args)
        
        return leptonica.pixMirrorDetect(*args)
    
    

    try:
        leptonica.pixUpDownDetectDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetectDwa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixUpDownDetectDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetectDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       
  pixUpDownDetectDwa()

      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)
              &conf (<return> confidence that text is rightside-up)
              mincount (min number of up + down; use 0 for default)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Faster (DWA) version of pixUpDownDetect().
      (2) This is a special case (but typical and slightly faster) of
          pixUpDownDetectGeneralDwa(), where the pixels identified
          through the HMT (hit-miss transform) are not clipped by
          a truncated word mask pixm.  See pixUpDownDetectGeneral()
          for usage and other details.
      (3) The returned confidence is the normalized difference
          between the number of detected up and down ascenders,
          assuming that the text is either rightside-up or upside-down
          and not rotated at a 90 degree angle.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetectDwa(*args)
    
    

    try:
        leptonica.makeOrientDecision.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32]
        leptonica.makeOrientDecision.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeOrientDecision not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeOrientDecision(*args):
        """
        ('l_float32', 'upconf')       
('l_float32', 'leftconf')       
('l_float32', 'minupconf')       
('l_float32', 'minratio')       
('l_int32', '*porient')       
('l_int32', 'debug')       
  makeOrientDecision()

      Input:  upconf (nonzero)
              leftconf (nonzero)
              minupconf (minimum value for which a decision can be made)
              minratio (minimum conf ratio required for a decision)
              &orient (<return> text orientation enum {0,1,2,3,4})
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This can be run after pixOrientDetect()
      (2) Both upconf and leftconf must be nonzero; otherwise the
          orientation cannot be determined.
      (3) The abs values of the input confidences are compared to
          minupconf.
      (4) The abs value of the largest of (upconf/leftconf) and
          (leftconf/upconf) is compared with minratio.
      (5) Input 0.0 for the default values for minupconf and minratio.
      (6) The return value of orient is interpreted thus:
            L_TEXT_ORIENT_UNKNOWN:  not enough evidence to determine
            L_TEXT_ORIENT_UP:       text rightside-up
            L_TEXT_ORIENT_LEFT:     landscape, text up facing left
            L_TEXT_ORIENT_DOWN:     text upside-down
            L_TEXT_ORIENT_RIGHT:    landscape, text up facing right


        """
        args = _convert_params(*args)
        
        return leptonica.makeOrientDecision(*args)
    
    

    try:
        leptonica.pixOrientDetect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOrientDetect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixOrientDetect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOrientDetect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pupconf')       
('l_float32', '*pleftconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       
  pixOrientDetect()

      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)
              &upconf (<optional return> ; may be null)
              &leftconf (<optional return> ; may be null)
              mincount (min number of up + down; use 0 for default)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See "Measuring document image skew and orientation"
          Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari
          IS&T/SPIE EI'95, Conference 2422: Document Recognition II
          pp 302-316, Feb 6-7, 1995, San Jose, CA
      (2) upconf is the normalized difference between up ascenders
          and down ascenders.  The image is analyzed without rotation
          for being rightside-up or upside-down.  Set &upconf to null
          to skip this operation.
      (3) leftconf is the normalized difference between up ascenders
          and down ascenders in the image after it has been
          rotated 90 degrees clockwise.  With that rotation, ascenders
          projecting to the left in the source image will project up
          in the rotated image.  We compute this by rotating 90 degrees
          clockwise and testing for up and down ascenders.  Set
          &leftconf to null to skip this operation.
      (4) Note that upconf and leftconf are not linear measures of
          confidence, e.g., in a range between 0 and 100.  They
          measure how far you are out on the tail of a (presumably)
          normal distribution.  For example, a confidence of 10 means
          that it is nearly certain that the difference did not
          happen at random.  However, these values must be interpreted
          cautiously, taking into consideration the estimated prior
          for a particular orientation or mirror flip.   The up-down
          signal is very strong if applied to text with ascenders
          up and down, and relatively weak for text at 90 degrees,
          but even at 90 degrees, the difference can look significant.
          For example, suppose the ascenders are oriented horizontally,
          but the test is done vertically.  Then upconf can
          be < -MIN_CONF_FOR_UP_DOWN, suggesting the text may be
          upside-down.  However, if instead the test were done
          horizontally, leftconf will be very much larger
          (in absolute value), giving the correct orientation.
      (5) If you compute both upconf and leftconf, and there is
          sufficient signal, the following table determines the
          cw angle necessary to rotate pixs so that the text is
          rightside-up:
             0 deg :           upconf >> 1,    abs(upconf) >> abs(leftconf)
             90 deg :          leftconf >> 1,  abs(leftconf) >> abs(upconf)
             180 deg :         upconf << -1,   abs(upconf) >> abs(leftconf)
             270 deg :         leftconf << -1, abs(leftconf) >> abs(upconf)
      (6) One should probably not interpret the direction unless
          there are a sufficient number of counts for both orientations,
          in which case neither upconf nor leftconf will be 0.0.
      (7) Uses rasterop implementation of HMT.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOrientDetect(*args)
    
    

    try:
        leptonica.pixOrientDetectDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOrientDetectDwa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixOrientDetectDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOrientDetectDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pupconf')       
('l_float32', '*pleftconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       
  pixOrientDetectDwa()

      Input:  pixs (1 bpp, deskewed, English text)
              &upconf (<optional return> ; may be null)
              &leftconf (<optional return> ; may be null)
              mincount (min number of up + down; use 0 for default)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Same interface as for pixOrientDetect().  See notes
          there for usage.
      (2) Uses auto-gen'd code for the Sels defined at the
          top of this file, with some renaming of functions.
          The auto-gen'd code is in fliphmtgen.c, and can
          be generated by a simple executable; see prog/flipselgen.c.
      (3) This runs about 2.5 times faster than the pixOrientDetect().


        """
        args = _convert_params(*args)
        
        return leptonica.pixOrientDetectDwa(*args)
    
    

    try:
        leptonica.pixUpDownDetectGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetectGeneral.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixUpDownDetectGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetectGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'npixels')       
('l_int32', 'debug')       
  pixUpDownDetectGeneral()

      Input:  pixs (1 bpp, deskewed, English text, 150 - 300 ppi)
              &conf (<return> confidence that text is rightside-up)
              mincount (min number of up + down; use 0 for default)
              npixels (number of pixels removed from each side of word box)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixOrientDetect() for other details.
      (2) @conf is the normalized difference between the number of
          detected up and down ascenders, assuming that the text
          is either rightside-up or upside-down and not rotated
          at a 90 degree angle.
      (3) The typical mode of operation is @npixels == 0.
          If @npixels > 0, this removes HMT matches at the
          beginning and ending of "words."  This is useful for
          pages that may have mostly digits, because if npixels == 0,
          leading "1" and "3" digits can register as having
          ascenders or descenders, and "7" digits can match descenders.
          Consequently, a page image of only digits may register
          as being upside-down.
      (4) We want to count the number of instances found using the HMT.
          An expensive way to do this would be to count the
          number of connected components.  A cheap way is to do a rank
          reduction cascade that reduces each component to a single
          pixel, and results (after two or three 2x reductions)
          in one pixel for each of the original components.
          After the reduction, you have a much smaller pix over
          which to count pixels.  We do only 2 reductions, because
          this function is designed to work for input pix between
          150 and 300 ppi, and an 8x reduction on a 150 ppi image
          is going too far -- components will get merged.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetectGeneral(*args)
    
    

    try:
        leptonica.pixMirrorDetectDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMirrorDetectDwa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMirrorDetectDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMirrorDetectDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       
  pixMirrorDetectDwa()

      Input:  pixs (1 bpp, deskewed, English text)
              &conf (<return> confidence that text is not LR mirror reversed)
              mincount (min number of left + right; use 0 for default)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) We assume the text is horizontally oriented, with
          ascenders going up.
      (2) See notes in pixMirrorDetect().


        """
        args = _convert_params(*args)
        
        return leptonica.pixMirrorDetectDwa(*args)
    
    

    try:
        leptonica.pixUpDownDetectGeneralDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetectGeneralDwa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixUpDownDetectGeneralDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetectGeneralDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'npixels')       
('l_int32', 'debug')       
  pixUpDownDetectGeneralDwa()

      Input:  pixs (1 bpp, deskewed, English text)
              &conf (<return> confidence that text is rightside-up)
              mincount (min number of up + down; use 0 for default)
              npixels (number of pixels removed from each side of word box)
              debug (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See the notes in pixUpDownDetectGeneral() for usage.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetectGeneralDwa(*args)
    




class fhmtauto(object):
    """  fhmtauto.c

    Main function calls:
       l_int32             fhmtautogen()
       l_int32             fhmtautogen1()
       l_int32             fhmtautogen2()

    Static helpers:
       static SARRAY      *sarrayMakeWplsCode()
       static SARRAY      *sarrayMakeInnerLoopDWACode()
       static char        *makeBarrelshiftString()

    This automatically generates dwa code for the hit-miss transform.
    Here's a road map for how it all works.

    (1) You generate an array (a SELA) of hit-miss transform SELs.
        This can be done in several ways, including
           (a) calling the function selaAddHitMiss() for
               pre-compiled SELs
           (b) generating the SELA in code in line
           (c) reading in a SELA from file, using selaRead()
               or various other formats.

    (2) You call fhmtautogen1() and fhmtautogen2() on this SELA.
        This uses the text files hmttemplate1.txt and
        hmttemplate2.txt for building up the source code.  See the file
        prog/fhmtautogen.c for an example of how this is done.
        The output is written to files named fhmtgen.*.c
        and fhmtgenlow.*.c, where "*" is an integer that you
        input to this function.  That integer labels both
        the output files, as well as all the functions that
        are generated.  That way, using different integers,
        you can invoke fhmtautogen() any number of times
        to get functions that all have different names so that
        they can be linked into one program.

    (3) You copy the generated source code back to your src
        directory for compilation.  Put their names in the
        Makefile, regnerate the prototypes, and recompile
        the libraries.  Look at the Makefile to see how I've
        included fhmtgen.1.c and fhmtgenlow.1.c.  These files
        provide the high-level interfaces for the hmt, and
        the low-level interfaces to do the actual work.

    (4) In an application, you now use this interface.  Again
        for the example files generated, using integer "1":

           PIX   *pixHMTDwa_1(PIX *pixd, PIX *pixs, char *selname);

              or

           PIX   *pixFHMTGen_1(PIX *pixd, PIX *pixs, char *selname);

        where the selname is one of the set that were defined
        as the name field of sels.  This set is listed at the
        beginning of the file fhmtgen.1.c.
        As an example, see the file prog/fmtauto_reg.c, which
        verifies the correctness of the implementation by
        comparing the dwa result with that of full-image
        rasterops.

"""
    
    try:
        leptonica.fhmtautogen2.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fhmtautogen2.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fhmtautogen2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fhmtautogen2(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       
  fhmtautogen2()

      Input:  sel array
              fileindex
              filename (<optional>; can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This function uses hmttemplate2.txt to create a
          low-level file that contains the low-level functions for
          implementing the hit-miss transform for every sel
          in the input sela.
      (2) The fileindex parameter is inserted into the output
          filename, as described below.
      (3) If filename == NULL, the output file is fhmtgenlow.<n>.c,
          where <n> is equal to the 'fileindex' parameter.
      (4) If filename != NULL, the output file is <filename>low.<n>.c.


        """
        args = _convert_params(*args)
        
        return leptonica.fhmtautogen2(*args)
    
    

    try:
        leptonica.fhmtautogen.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fhmtautogen.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fhmtautogen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fhmtautogen(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       
  fhmtautogen()

      Input:  sela
              fileindex
              filename (<optional>; can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This function generates all the code for implementing
          dwa morphological operations using all the sels in the sela.
      (2) See fhmtautogen1() and fhmtautogen2() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.fhmtautogen(*args)
    
    

    try:
        leptonica.fhmtautogen1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fhmtautogen1.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fhmtautogen1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fhmtautogen1(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       
  fhmtautogen1()

      Input:  sel array
              fileindex
              filename (<optional>; can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This function uses hmttemplate1.txt to create a
          top-level file that contains two functions that carry
          out the hit-miss transform for any of the sels in
          the input sela.
      (2) The fileindex parameter is inserted into the output
          filename, as described below.
      (3) If filename == NULL, the output file is fhmtgen.<n>.c,
          where <n> is equal to the 'fileindex' parameter.
      (4) If filename != NULL, the output file is <filename>.<n>.c.
      (5) Each sel must have at least one hit.  A sel with only misses
          generates code that will abort the operation if it is called.


        """
        args = _convert_params(*args)
        
        return leptonica.fhmtautogen1(*args)
    




class morphseq(object):
    """  morphseq.c

      Run a sequence of binary rasterop morphological operations
            PIX     *pixMorphSequence()

      Run a sequence of binary composite rasterop morphological operations
            PIX     *pixMorphCompSequence()

      Run a sequence of binary dwa morphological operations
            PIX     *pixMorphSequenceDwa()

      Run a sequence of binary composite dwa morphological operations
            PIX     *pixMorphCompSequenceDwa()

      Parser verifier for binary morphological operations
            l_int32  morphSequenceVerify()

      Run a sequence of grayscale morphological operations
            PIX     *pixGrayMorphSequence()

      Run a sequence of color morphological operations
            PIX     *pixColorMorphSequence()

"""
    
    try:
        leptonica.pixColorMorphSequence.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorMorphSequence.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorMorphSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorMorphSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
('l_int32', 'dispy')       
  pixColorMorphSequence()

      Input:  pixs
              sequence (string specifying sequence)
              dispsep (controls debug display of each result in the sequence:
                       0: no output
                       > 0: gives horizontal separation in pixels between
                            successive displays
                       < 0: pdf output; abs(dispsep) is used for naming)
              dispy (if dispsep > 0, this gives the y-value of the
                     UL corner for display; otherwise it is ignored)
      Return: pixd, or null on error

  Notes:
      (1) This works on 32 bpp rgb images.
      (2) Each component is processed separately.
      (3) This runs a pipeline of operations; no branching is allowed.
      (4) This only uses brick SELs.
      (5) A new image is always produced; the input image is not changed.
      (6) This contains an interpreter, allowing sequences to be
          generated and run.
      (7) Sel sizes (width, height) must each be odd numbers.
      (8) The format of the sequence string is defined below.
      (9) Intermediate results can optionally be displayed.
      (10) The sequence string is formatted as follows:
            - An arbitrary number of operations,  each separated
              by a '+' character.  White space is ignored.
            - Each operation begins with a case-independent character
              specifying the operation:
                 d or D  (dilation)
                 e or E  (erosion)
                 o or O  (opening)
                 c or C  (closing)
            - The args to the morphological operations are bricks of hits,
              and are formatted as a.b, where a and b are horizontal and
              vertical dimensions, rsp. (each must be an odd number)
           Example valid sequences are:
             "c5.3 + o7.5"
             "D9.1"


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorMorphSequence(*args)
    
    

    try:
        leptonica.pixMorphCompSequence.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMorphCompSequence.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphCompSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphCompSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
  pixMorphCompSequence()

      Input:  pixs
              sequence (string specifying sequence)
              dispsep (controls debug display of each result in the sequence:
                       0: no output
                       > 0: gives horizontal separation in pixels between
                            successive displays
                       < 0: pdf output; abs(dispsep) is used for naming)
      Return: pixd, or null on error

  Notes:
      (1) This does rasterop morphology on binary images, using composite
          operations for extra speed on large Sels.
      (2) Safe closing is used atomically.  However, if you implement a
          closing as a sequence with a dilation followed by an
          erosion, it will not be safe, and to ensure that you have
          no boundary effects you must add a border in advance and
          remove it at the end.
      (3) For other usage details, see the notes for pixMorphSequence().
      (4) The sequence string is formatted as follows:
            - An arbitrary number of operations,  each separated
              by a '+' character.  White space is ignored.
            - Each operation begins with a case-independent character
              specifying the operation:
                 d or D  (dilation)
                 e or E  (erosion)
                 o or O  (opening)
                 c or C  (closing)
                 r or R  (rank binary reduction)
                 x or X  (replicative binary expansion)
                 b or B  (add a border of 0 pixels of this size)
            - The args to the morphological operations are bricks of hits,
              and are formatted as a.b, where a and b are horizontal and
              vertical dimensions, rsp.
            - The args to the reduction are a sequence of up to 4 integers,
              each from 1 to 4.
            - The arg to the expansion is a power of two, in the set
              {2, 4, 8, 16}.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphCompSequence(*args)
    
    

    try:
        leptonica.pixGrayMorphSequence.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGrayMorphSequence.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGrayMorphSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGrayMorphSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
('l_int32', 'dispy')       
  pixGrayMorphSequence()

      Input:  pixs
              sequence (string specifying sequence)
              dispsep (controls debug display of each result in the sequence:
                       0: no output
                       > 0: gives horizontal separation in pixels between
                            successive displays
                       < 0: pdf output; abs(dispsep) is used for naming)
              dispy (if dispsep > 0, this gives the y-value of the
                     UL corner for display; otherwise it is ignored)
      Return: pixd, or null on error

  Notes:
      (1) This works on 8 bpp grayscale images.
      (2) This runs a pipeline of operations; no branching is allowed.
      (3) This only uses brick SELs.
      (4) A new image is always produced; the input image is not changed.
      (5) This contains an interpreter, allowing sequences to be
          generated and run.
      (6) The format of the sequence string is defined below.
      (7) In addition to morphological operations, the composite
          morph/subtract tophat can be performed.
      (8) Sel sizes (width, height) must each be odd numbers.
      (9) Intermediate results can optionally be displayed
      (10) The sequence string is formatted as follows:
            - An arbitrary number of operations,  each separated
              by a '+' character.  White space is ignored.
            - Each operation begins with a case-independent character
              specifying the operation:
                 d or D  (dilation)
                 e or E  (erosion)
                 o or O  (opening)
                 c or C  (closing)
                 t or T  (tophat)
            - The args to the morphological operations are bricks of hits,
              and are formatted as a.b, where a and b are horizontal and
              vertical dimensions, rsp. (each must be an odd number)
            - The args to the tophat are w or W (for white tophat)
              or b or B (for black tophat), followed by a.b as for
              the dilation, erosion, opening and closing.
           Example valid sequences are:
             "c5.3 + o7.5"
             "c9.9 + tw9.9"


        """
        args = _convert_params(*args)
        
        return leptonica.pixGrayMorphSequence(*args)
    
    

    try:
        leptonica.pixMorphSequence.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMorphSequence.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
  pixMorphSequence()

      Input:  pixs
              sequence (string specifying sequence)
              dispsep (controls debug display of each result in the sequence:
                       0: no output
                       > 0: gives horizontal separation in pixels between
                            successive displays
                       < 0: pdf output; abs(dispsep) is used for naming)
      Return: pixd, or null on error

  Notes:
      (1) This does rasterop morphology on binary images.
      (2) This runs a pipeline of operations; no branching is allowed.
      (3) This only uses brick Sels, which are created on the fly.
          In the future this will be generalized to extract Sels from
          a Sela by name.
      (4) A new image is always produced; the input image is not changed.
      (5) This contains an interpreter, allowing sequences to be
          generated and run.
      (6) The format of the sequence string is defined below.
      (7) In addition to morphological operations, rank order reduction
          and replicated expansion allow operations to take place
          downscaled by a power of 2.
      (8) Intermediate results can optionally be displayed.
      (9) Thanks to Dar-Shyang Lee, who had the idea for this and
          built the first implementation.
      (10) The sequence string is formatted as follows:
            - An arbitrary number of operations,  each separated
              by a '+' character.  White space is ignored.
            - Each operation begins with a case-independent character
              specifying the operation:
                 d or D  (dilation)
                 e or E  (erosion)
                 o or O  (opening)
                 c or C  (closing)
                 r or R  (rank binary reduction)
                 x or X  (replicative binary expansion)
                 b or B  (add a border of 0 pixels of this size)
            - The args to the morphological operations are bricks of hits,
              and are formatted as a.b, where a and b are horizontal and
              vertical dimensions, rsp.
            - The args to the reduction are a sequence of up to 4 integers,
              each from 1 to 4.
            - The arg to the expansion is a power of two, in the set
              {2, 4, 8, 16}.
      (11) An example valid sequence is:
               "b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4"
           In this example, the following operation sequence is carried out:
             * b32: Add a 32 pixel border around the input image
             * o1.3: Opening with vert sel of length 3 (e.g., 1 x 3)
             * C3.1: Closing with horiz sel of length 3  (e.g., 3 x 1)
             * r23: Two successive 2x2 reductions with rank 2 in the first
                    and rank 3 in the second.  The result is a 4x reduced pix.
             * e2.2: Erosion with a 2x2 sel (origin will be at x,y: 0,0)
             * d3.2: Dilation with a 3x2 sel (origin will be at x,y: 1,0)
             * X4: 4x replicative expansion, back to original resolution
      (12) The safe closing is used.  However, if you implement a
           closing as separable dilations followed by separable erosions,
           it will not be safe.  For that situation, you need to add
           a sufficiently large border as the first operation in
           the sequence.  This will be removed automatically at the
           end.  There are two cautions:
              - When computing what is sufficient, remember that if
                reductions are carried out, the border is also reduced.
              - The border is removed at the end, so if a border is
                added at the beginning, the result must be at the
                same resolution as the input!


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequence(*args)
    
    

    try:
        leptonica.pixMorphCompSequenceDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMorphCompSequenceDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphCompSequenceDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphCompSequenceDwa(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
  pixMorphCompSequenceDwa()

      Input:  pixs
              sequence (string specifying sequence)
              dispsep (controls debug display of each result in the sequence:
                       0: no output
                       > 0: gives horizontal separation in pixels between
                            successive displays
                       < 0: pdf output; abs(dispsep) is used for naming)
      Return: pixd, or null on error

  Notes:
      (1) This does dwa morphology on binary images, using brick Sels.
      (2) This runs a pipeline of operations; no branching is allowed.
      (3) It implements all brick Sels that have dimensions up to 63
          on each side, using a composite (linear + comb) when useful.
      (4) A new image is always produced; the input image is not changed.
      (5) This contains an interpreter, allowing sequences to be
          generated and run.
      (6) See pixMorphSequence() for further information about usage.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphCompSequenceDwa(*args)
    
    

    try:
        leptonica.morphSequenceVerify.argtypes = [ctypes.c_void_p]
        leptonica.morphSequenceVerify.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function morphSequenceVerify not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def morphSequenceVerify(*args):
        """
        ('SARRAY', '*sa')       
  morphSequenceVerify()

      Input:  sarray (of operation sequence)
      Return: TRUE if valid; FALSE otherwise or on error

  Notes:
      (1) This does verification of valid binary morphological
          operation sequences.
      (2) See pixMorphSequence() for notes on valid operations
          in the sequence.


        """
        args = _convert_params(*args)
        
        return leptonica.morphSequenceVerify(*args)
    
    

    try:
        leptonica.pixMorphSequenceDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMorphSequenceDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMorphSequenceDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceDwa(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
  pixMorphSequenceDwa()

      Input:  pixs
              sequence (string specifying sequence)
              dispsep (controls debug display of each result in the sequence:
                       0: no output
                       > 0: gives horizontal separation in pixels between
                            successive displays
                       < 0: pdf output; abs(dispsep) is used for naming)
      Return: pixd, or null on error

  Notes:
      (1) This does dwa morphology on binary images.
      (2) This runs a pipeline of operations; no branching is allowed.
      (3) This only uses brick Sels that have been pre-compiled with
          dwa code.
      (4) A new image is always produced; the input image is not changed.
      (5) This contains an interpreter, allowing sequences to be
          generated and run.
      (6) See pixMorphSequence() for further information about usage.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceDwa(*args)
    




class enhance(object):
    """  enhance.c

      Gamma TRC (tone reproduction curve) mapping
           PIX     *pixGammaTRC()
           PIX     *pixGammaTRCMasked()
           PIX     *pixGammaTRCWithAlpha()
           NUMA    *numaGammaTRC()

      Contrast enhancement
           PIX     *pixContrastTRC()
           PIX     *pixContrastTRCMasked()
           NUMA    *numaContrastTRC()

      Histogram equalization
           PIX     *pixEqualizeTRC()
           NUMA    *numaEqualizeTRC()

      Generic TRC mapper
           PIX     *pixTRCMap()

      Unsharp-masking
           PIX     *pixUnsharpMasking()
           PIX     *pixUnsharpMaskingGray()
           PIX     *pixUnsharpMaskingFast()
           PIX     *pixUnsharpMaskingGrayFast()
           PIX     *pixUnsharpMaskingGray1D()
           PIX     *pixUnsharpMaskingGray2D()

      Hue and saturation modification
           PIX     *pixModifyHue()
           PIX     *pixModifySaturation()
           l_int32  pixMeasureSaturation()
           PIX     *pixModifyBrightness()

      Color shifting
           PIX     *pixColorShiftRGB()

      General multiplicative constant color transform
           PIX     *pixMultConstantColor()
           PIX     *pixMultMatrixColor()

      Edge by bandpass
           PIX     *pixHalfEdgeByBandpass()

      Gamma correction, contrast enhancement and histogram equalization
      apply a simple mapping function to each pixel (or, for color
      images, to each sample (i.e., r,g,b) of the pixel).

       - Gamma correction either lightens the image or darkens
         it, depending on whether the gamma factor is greater
         or less than 1.0, respectively.

       - Contrast enhancement darkens the pixels that are already
         darker than the middle of the dynamic range (128)
         and lightens pixels that are lighter than 128.

       - Histogram equalization remaps to have the same number
         of image pixels at each of 256 intensity values.  This is
         a quick and dirty method of adjusting contrast and brightness
         to bring out details in both light and dark regions.

      Unsharp masking is a more complicated enhancement.
      A "high frequency" image, generated by subtracting
      the smoothed ("low frequency") part of the image from
      itself, has all the energy at the edges.  This "edge image"
      has 0 average value.  A fraction of the edge image is
      then added to the original, enhancing the differences
      between pixel values at edges.  Because we represent
      images as l_uint8 arrays, we preserve dynamic range and
      handle negative values by doing all the arithmetic on
      shifted l_uint16 arrays; the l_uint8 values are recovered
      at the end.

      Hue and saturation modification work in HSV space.  Because
      this is too large for efficient table lookup, each pixel value
      is transformed to HSV, modified, and transformed back.
      It's not the fastest way to do this, but the method is
      easily understood.

      Unsharp masking is never in-place, and returns a clone if no
      operation is to be performed.

"""
    
    try:
        leptonica.pixGammaTRCMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGammaTRCMasked.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGammaTRCMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGammaTRCMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
  pixGammaTRCMasked()

      Input:  pixd (<optional> null or equal to pixs)
              pixs (8 or 32 bpp; not colormapped)
              pixm (<optional> null or 1 bpp)
              gamma (gamma correction; must be > 0.0)
              minval  (input value that gives 0 for output; can be < 0)
              maxval  (input value that gives 255 for output; can be > 255)
      Return: pixd always

  Notes:
      (1) Same as pixGammaTRC() except mapping is optionally over
          a subset of pixels described by pixm.
      (2) Masking does not work for colormapped images.
      (3) See pixGammaTRC() for details on how to use the parameters.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGammaTRCMasked(*args)
    
    

    try:
        leptonica.pixContrastTRCMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixContrastTRCMasked.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixContrastTRCMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixContrastTRCMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'factor')       
  pixContrastTRCMasked()

      Input:  pixd (<optional> null or equal to pixs)
              pixs (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)
              pixm (<optional> null or 1 bpp)
              factor  (0.0 is no enhancement)
      Return: pixd always

  Notes:
      (1) Same as pixContrastTRC() except mapping is optionally over
          a subset of pixels described by pixm.
      (2) Masking does not work for colormapped images.
      (3) See pixContrastTRC() for details on how to use the parameters.


        """
        args = _convert_params(*args)
        
        return leptonica.pixContrastTRCMasked(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixUnsharpMaskingGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnsharpMaskingGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
  pixUnsharpMaskingGray()

      Input:  pixs (8 bpp; no colormap)
              halfwidth  ("half-width" of smoothing filter)
              fract  (fraction of edge added back into image)
      Return: pixd, or null on error

  Notes:
      (1) We use symmetric smoothing filters of odd dimension,
          typically use sizes of 3, 5, 7, etc.  The @halfwidth parameter
          for these is (size - 1)/2; i.e., 1, 2, 3, etc.
      (2) The fract parameter is typically taken in the range:
          0.2 < fract < 0.7
      (3) Returns a clone if no sharpening is requested.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGray(*args)
    
    

    try:
        leptonica.pixUnsharpMasking.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixUnsharpMasking.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnsharpMasking not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMasking(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
  pixUnsharpMasking()

      Input:  pixs (all depths except 1 bpp; with or without colormaps)
              halfwidth  ("half-width" of smoothing filter)
              fract  (fraction of edge added back into image)
      Return: pixd, or null on error

  Notes:
      (1) We use symmetric smoothing filters of odd dimension,
          typically use sizes of 3, 5, 7, etc.  The @halfwidth parameter
          for these is (size - 1)/2; i.e., 1, 2, 3, etc.
      (2) The fract parameter is typically taken in the
          range:  0.2 < fract < 0.7
      (3) Returns a clone if no sharpening is requested.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMasking(*args)
    
    

    try:
        leptonica.pixTRCMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTRCMap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTRCMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTRCMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('NUMA', '*na')       
  pixTRCMap()

      Input:  pixs (8 grayscale or 32 bpp rgb; not colormapped)
              pixm (<optional> 1 bpp mask)
              na (mapping array)
      Return: pixd, or null on error

  Notes:
      (1) This operation is in-place on pixs.
      (2) For 32 bpp, this applies the same map to each of the r,g,b
          components.
      (3) The mapping array is of size 256, and it maps the input
          index into values in the range [0, 255].
      (4) If defined, the optional 1 bpp mask pixm has its origin
          aligned with pixs, and the map function is applied only
          to pixels in pixs under the fg of pixm.
      (5) For 32 bpp, this does not save the alpha channel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTRCMap(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGrayFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixUnsharpMaskingGrayFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnsharpMaskingGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGrayFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
('l_int32', 'direction')       
  pixUnsharpMaskingGrayFast()

      Input:  pixs (8 bpp; no colormap)
              halfwidth  ("half-width" of smoothing filter: 1 or 2)
              fract  (fraction of high frequency added to image)
              direction (L_HORIZ, L_VERT, L_BOTH_DIRECTIONS)
      Return: pixd, or null on error

  Notes:
      (1) For usage and explanation of the algorithm, see notes
          in pixUnsharpMaskingFast().
      (2) Returns a clone if no sharpening is requested.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGrayFast(*args)
    
    

    try:
        leptonica.numaEqualizeTRC.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.numaEqualizeTRC.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaEqualizeTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEqualizeTRC(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'fract')       
('l_int32', 'factor')       
  numaEqualizeTRC()

      Input:  pix (8 bpp, no colormap)
              fract (fraction of equalization movement of pixel values)
              factor (subsampling factor; integer >= 1)
      Return: nad, or null on error

  Notes:
      (1) If fract == 0.0, no equalization will be performed.
          If fract == 1.0, equalization is complete.
      (2) Set the subsampling factor > 1 to reduce the amount of computation.
      (3) The map is returned as a numa with 256 values, specifying
          the equalized value (array value) for every input value
          (the array index).


        """
        args = _convert_params(*args)
        
        return leptonica.numaEqualizeTRC(*args)
    
    

    try:
        leptonica.numaGammaTRC.argtypes = [ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaGammaTRC.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaGammaTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGammaTRC(*args):
        """
        ('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
  numaGammaTRC()

      Input:  gamma   (gamma factor; must be > 0.0)
              minval  (input value that gives 0 for output)
              maxval  (input value that gives 255 for output)
      Return: na, or null on error

  Notes:
      (1) The map is returned as a numa; values are clipped to [0, 255].
      (2) To force all intensities into a range within fraction delta
          of white, use: minval = -256 * (1 - delta) / delta
                         maxval = 255
      (3) To force all intensities into a range within fraction delta
          of black, use: minval = 0
                         maxval = 256 * (1 - delta) / delta


        """
        args = _convert_params(*args)
        
        return leptonica.numaGammaTRC(*args)
    
    

    try:
        leptonica.pixGammaTRCWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGammaTRCWithAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGammaTRCWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGammaTRCWithAlpha(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
  pixGammaTRCWithAlpha()

      Input:  pixd (<optional> null or equal to pixs)
              pixs (32 bpp)
              gamma (gamma correction; must be > 0.0)
              minval  (input value that gives 0 for output; can be < 0)
              maxval  (input value that gives 255 for output; can be > 255)
      Return: pixd always

  Notes:
      (1) See usage notes in pixGammaTRC().
      (2) This version saves the alpha channel.  It is only valid
          for 32 bpp (no colormap), and is a bit slower.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGammaTRCWithAlpha(*args)
    
    

    try:
        leptonica.pixModifyBrightness.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixModifyBrightness.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixModifyBrightness not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifyBrightness(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       
  pixModifyBrightness()

      Input:  pixd (<optional> can be null, existing or equal to pixs)
              pixs (32 bpp rgb)
              fract (between -1.0 and 1.0)
      Return: pixd, or null on error

  Notes:
      (1) If fract > 0.0, it gives the fraction that the v-parameter,
          which is max(r,g,b), is moved from its initial value toward 255.
          If fract < 0.0, it gives the fraction that the v-parameter
          is moved from its initial value toward 0.
          The limiting values for fract = -1.0 (1.0) thus set the
          v-parameter to 0 (255).
      (2) If fract = 0, no modification is requested; return a copy
          unless in-place, in which case this is a no-op.
      (3) See discussion of color-modification methods, in coloring.c.


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifyBrightness(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGray1D.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixUnsharpMaskingGray1D.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnsharpMaskingGray1D not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGray1D(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
('l_int32', 'direction')       
  pixUnsharpMaskingGray1D()

      Input:  pixs (8 bpp; no colormap)
              halfwidth  ("half-width" of smoothing filter: 1 or 2)
              fract  (fraction of high frequency added to image)
              direction (of filtering; use L_HORIZ or L_VERT)
      Return: pixd, or null on error

  Notes:
      (1) For usage and explanation of the algorithm, see notes
          in pixUnsharpMaskingFast().
      (2) Returns a clone if no sharpening is requested.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGray1D(*args)
    
    

    try:
        leptonica.pixHalfEdgeByBandpass.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHalfEdgeByBandpass.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHalfEdgeByBandpass not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHalfEdgeByBandpass(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sm1h')       
('l_int32', 'sm1v')       
('l_int32', 'sm2h')       
('l_int32', 'sm2v')       
  pixHalfEdgeByBandpass()

      Input:  pixs (8 bpp gray or 32 bpp rgb)
              sm1h, sm1v ("half-widths" of smoothing filter sm1)
              sm2h, sm2v ("half-widths" of smoothing filter sm2)
                      (require sm2 != sm1)
      Return: pixd, or null on error

  Notes:
      (1) We use symmetric smoothing filters of odd dimension,
          typically use 3, 5, 7, etc.  The smoothing parameters
          for these are 1, 2, 3, etc.  The filter size is related
          to the smoothing parameter by
               size = 2 * smoothing + 1
      (2) Because we take the difference of two lowpass filters,
          this is actually a bandpass filter.
      (3) We allow both filters to be anisotropic.
      (4) Consider either the h or v component of the 2 filters.
          Depending on whether sm1 > sm2 or sm2 > sm1, we get
          different halves of the smoothed gradients (or "edges").
          This difference of smoothed signals looks more like
          a second derivative of a transition, which we rectify
          by not allowing the signal to go below zero.  If sm1 < sm2,
          the sm2 transition is broader, so the difference between
          sm1 and sm2 signals is positive on the upper half of
          the transition.  Likewise, if sm1 > sm2, the sm1 - sm2
          signal difference is positive on the lower half of
          the transition.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHalfEdgeByBandpass(*args)
    
    

    try:
        leptonica.pixModifyHue.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixModifyHue.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixModifyHue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifyHue(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       
  pixModifyHue()

      Input:  pixd (<optional> can be null or equal to pixs)
              pixs (32 bpp rgb)
              fract (between -1.0 and 1.0)
      Return: pixd, or null on error

  Notes:
      (1) pixd must either be null or equal to pixs.
          For in-place operation, set pixd == pixs:
             pixEqualizeTRC(pixs, pixs, ...);
          To get a new image, set pixd == null:
             pixd = pixEqualizeTRC(NULL, pixs, ...);
      (1) Use fract > 0.0 to increase hue value; < 0.0 to decrease it.
          1.0 (or -1.0) represents a 360 degree rotation; i.e., no change.
      (2) If no modification is requested (fract = -1.0 or 0 or 1.0),
          return a copy unless in-place, in which case this is a no-op.
      (3) See discussion of color-modification methods, in coloring.c.


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifyHue(*args)
    
    

    try:
        leptonica.pixGammaTRC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGammaTRC.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGammaTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGammaTRC(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
  pixGammaTRC()

      Input:  pixd (<optional> null or equal to pixs)
              pixs (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)
              gamma (gamma correction; must be > 0.0)
              minval  (input value that gives 0 for output; can be < 0)
              maxval  (input value that gives 255 for output; can be > 255)
      Return: pixd always

  Notes:
      (1) pixd must either be null or equal to pixs.
          For in-place operation, set pixd == pixs:
             pixGammaTRC(pixs, pixs, ...);
          To get a new image, set pixd == null:
             pixd = pixGammaTRC(NULL, pixs, ...);
      (2) If pixs is colormapped, the colormap is transformed,
          either in-place or in a copy of pixs.
      (3) We use a gamma mapping between minval and maxval.
      (4) If gamma < 1.0, the image will appear darker;
          if gamma > 1.0, the image will appear lighter;
      (5) If gamma = 1.0 and minval = 0 and maxval = 255, no
          enhancement is performed; return a copy unless in-place,
          in which case this is a no-op.
      (6) For color images that are not colormapped, the mapping
          is applied to each component.
      (7) minval and maxval are not restricted to the interval [0, 255].
          If minval < 0, an input value of 0 is mapped to a
          nonzero output.  This will turn black to gray.
          If maxval > 255, an input value of 255 is mapped to
          an output value less than 255.  This will turn
          white (e.g., in the background) to gray.
      (8) Increasing minval darkens the image.
      (9) Decreasing maxval bleaches the image.
      (10) Simultaneously increasing minval and decreasing maxval
           will darken the image and make the colors more intense;
           e.g., minval = 50, maxval = 200.
      (11) See numaGammaTRC() for further examples of use.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGammaTRC(*args)
    
    

    try:
        leptonica.pixEqualizeTRC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixEqualizeTRC.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixEqualizeTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqualizeTRC(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'factor')       
  pixEqualizeTRC()

      Input:  pixd (<optional> null or equal to pixs)
              pixs (8 bpp gray, 32 bpp rgb, or colormapped)
              fract (fraction of equalization movement of pixel values)
              factor (subsampling factor; integer >= 1)
      Return: pixd, or null on error

  Notes:
      (1) pixd must either be null or equal to pixs.
          For in-place operation, set pixd == pixs:
             pixEqualizeTRC(pixs, pixs, ...);
          To get a new image, set pixd == null:
             pixd = pixEqualizeTRC(NULL, pixs, ...);
      (2) In histogram equalization, a tone reproduction curve
          mapping is used to make the number of pixels at each
          intensity equal.
      (3) If fract == 0.0, no equalization is performed; return a copy
          unless in-place, in which case this is a no-op.
          If fract == 1.0, equalization is complete.
      (4) Set the subsampling factor > 1 to reduce the amount of computation.
      (5) If pixs is colormapped, the colormap is removed and
          converted to rgb or grayscale.
      (6) If pixs has color, equalization is done in each channel
          separately.
      (7) Note that even if there is a colormap, we can get an
          in-place operation because the intermediate image pixt
          is copied back to pixs (which for in-place is the same
          as pixd).


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqualizeTRC(*args)
    
    

    try:
        leptonica.pixMeasureSaturation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMeasureSaturation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMeasureSaturation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeasureSaturation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', '*psat')       
  pixMeasureSaturation()

      Input:  pixs (32 bpp rgb)
              factor (subsampling factor; integer >= 1)
              &sat (<return> average saturation)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeasureSaturation(*args)
    
    

    try:
        leptonica.pixModifySaturation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixModifySaturation.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixModifySaturation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifySaturation(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       
  pixModifySaturation()

      Input:  pixd (<optional> can be null, existing or equal to pixs)
              pixs (32 bpp rgb)
              fract (between -1.0 and 1.0)
      Return: pixd, or null on error

  Notes:
      (1) If fract > 0.0, it gives the fraction that the pixel
          saturation is moved from its initial value toward 255.
          If fract < 0.0, it gives the fraction that the pixel
          saturation is moved from its initial value toward 0.
          The limiting values for fract = -1.0 (1.0) thus set the
          saturation to 0 (255).
      (2) If fract = 0, no modification is requested; return a copy
          unless in-place, in which case this is a no-op.
      (3) See discussion of color-modification methods, in coloring.c.


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifySaturation(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGray2D.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixUnsharpMaskingGray2D.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnsharpMaskingGray2D not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGray2D(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
  pixUnsharpMaskingGray2D()

      Input:  pixs (8 bpp; no colormap)
              halfwidth  ("half-width" of smoothing filter: 1 or 2)
              fract  (fraction of high frequency added to image)
      Return: pixd, or null on error

  Notes:
      (1) For halfwidth == 1, we implement the full sharpening filter
          directly.  For halfwidth == 2, we implement the the lowpass
          filter separably and then compute the sharpening result locally.
      (2) Returns a clone if no sharpening is requested.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGray2D(*args)
    
    

    try:
        leptonica.numaContrastTRC.argtypes = [ctypes.c_float]
        leptonica.numaContrastTRC.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaContrastTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaContrastTRC(*args):
        """
        ('l_float32', 'factor')       
  numaContrastTRC()

      Input:  factor (generally between 0.0 (no enhancement)
              and 1.0, but can be larger than 1.0)
      Return: na, or null on error

  Notes:
      (1) The mapping is monotonic increasing, where 0 is mapped
          to 0 and 255 is mapped to 255.
      (2) As 'factor' is increased from 0.0 (where the mapping is linear),
          the map gets closer to its limit as a step function that
          jumps from 0 to 255 at the center (input value = 127).


        """
        args = _convert_params(*args)
        
        return leptonica.numaContrastTRC(*args)
    
    

    try:
        leptonica.pixContrastTRC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixContrastTRC.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixContrastTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixContrastTRC(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'factor')       
  pixContrastTRC()

      Input:  pixd (<optional> null or equal to pixs)
              pixs (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)
              factor  (0.0 is no enhancement)
      Return: pixd always

  Notes:
      (1) pixd must either be null or equal to pixs.
          For in-place operation, set pixd == pixs:
             pixContrastTRC(pixs, pixs, ...);
          To get a new image, set pixd == null:
             pixd = pixContrastTRC(NULL, pixs, ...);
      (2) If pixs is colormapped, the colormap is transformed,
          either in-place or in a copy of pixs.
      (3) Contrast is enhanced by mapping each color component
          using an atan function with maximum slope at 127.
          Pixels below 127 are lowered in intensity and pixels
          above 127 are increased.
      (4) The useful range for the contrast factor is scaled to
          be in (0.0 to 1.0), but larger values can also be used.
      (5) If factor == 0.0, no enhancement is performed; return a copy
          unless in-place, in which case this is a no-op.
      (6) For color images that are not colormapped, the mapping
          is applied to each component.


        """
        args = _convert_params(*args)
        
        return leptonica.pixContrastTRC(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixUnsharpMaskingFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixUnsharpMaskingFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
('l_int32', 'direction')       
  pixUnsharpMaskingFast()

      Input:  pixs (all depths except 1 bpp; with or without colormaps)
              halfwidth  ("half-width" of smoothing filter; 1 and 2 only)
              fract  (fraction of high frequency added to image)
              direction (L_HORIZ, L_VERT, L_BOTH_DIRECTIONS)
      Return: pixd, or null on error

  Notes:
      (1) The fast version uses separable 1-D filters directly on
          the input image.  The halfwidth is either 1 (full width = 3)
          or 2 (full width = 5).
      (2) The fract parameter is typically taken in the
            range:  0.2 < fract < 0.7
      (3) To skip horizontal sharpening, use @fracth = 0.0; ditto for @fractv
      (4) For one dimensional filtering (as an example):
          For @halfwidth = 1, the low-pass filter is
              L:    1/3    1/3   1/3
          and the high-pass filter is
              H = I - L:   -1/3   2/3   -1/3
          For @halfwidth = 2, the low-pass filter is
              L:    1/5    1/5   1/5    1/5    1/5
          and the high-pass filter is
              H = I - L:   -1/5  -1/5   4/5  -1/5   -1/5
          The new sharpened pixel value is found by adding some fraction
          of the high-pass filter value (which sums to 0) to the
          initial pixel value:
              N = I + fract * H
      (5) For 2D, the sharpening filter is not separable, because the
          vertical filter depends on the horizontal location relative
          to the filter origin, and v.v.   So we either do the full
          2D filter (for @halfwidth == 1) or do the low-pass
          convolution separably and then compose with the original pix.
      (6) Returns a clone if no sharpening is requested.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingFast(*args)
    
    

    try:
        leptonica.pixColorShiftRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixColorShiftRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorShiftRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorShiftRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rfract')       
('l_float32', 'gfract')       
('l_float32', 'bfract')       
  pixColorShiftRGB()

      Input:  pixs (32 bpp rgb)
              rfract (fractional shift in red component)
              gfract (fractional shift in green component)
              bfract (fractional shift in blue component)
      Return: pixd, or null on error

  Notes:
      (1) This allows independent fractional shifts of the r,g and b
          components.  A positive shift pushes to saturation (255);
          a negative shift pushes toward 0 (black).
      (2) The effect can be imagined using a color wheel that consists
          (for our purposes) of these 6 colors, separated by 60 degrees:
             red, magenta, blue, cyan, green, yellow
      (3) So, for example, a negative shift of the blue component
          (bfract < 0) could be accompanied by positive shifts
          of red and green to make an image more yellow.
      (4) Examples of limiting cases:
            rfract = 1 ==> r = 255
            rfract = -1 ==> r = 0


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorShiftRGB(*args)
    




class adaptmap(object):
    """  adaptmap.c

  ===================================================================
  Image binarization algorithms are found in:
     grayquant.c:   standard, simple, general grayscale quantization
     adaptmap.c:    local adaptive; mostly gray-to-gray in preparation
                    for binarization
     binarize.c:    special binarization methods, locally adaptive.
  ===================================================================

      Adaptive background normalization (top-level functions)
          PIX       *pixBackgroundNormSimple()     8 and 32 bpp
          PIX       *pixBackgroundNorm()           8 and 32 bpp
          PIX       *pixBackgroundNormMorph()      8 and 32 bpp

      Arrays of inverted background values for normalization (16 bpp)
          l_int32    pixBackgroundNormGrayArray()   8 bpp input
          l_int32    pixBackgroundNormRGBArrays()   32 bpp input
          l_int32    pixBackgroundNormGrayArrayMorph()   8 bpp input
          l_int32    pixBackgroundNormRGBArraysMorph()   32 bpp input

      Measurement of local background
          l_int32    pixGetBackgroundGrayMap()        8 bpp
          l_int32    pixGetBackgroundRGBMap()         32 bpp
          l_int32    pixGetBackgroundGrayMapMorph()   8 bpp
          l_int32    pixGetBackgroundRGBMapMorph()    32 bpp
          l_int32    pixFillMapHoles()
          PIX       *pixExtendByReplication()         8 bpp
          l_int32    pixSmoothConnectedRegions()      8 bpp

      Measurement of local foreground
          l_int32    pixGetForegroundGrayMap()        8 bpp

      Generate inverted background map for each component
          PIX       *pixGetInvBackgroundMap()   16 bpp

      Apply inverse background map to image
          PIX       *pixApplyInvBackgroundGrayMap()   8 bpp
          PIX       *pixApplyInvBackgroundRGBMap()    32 bpp

      Apply variable map
          PIX       *pixApplyVariableGrayMap()        8 bpp

      Non-adaptive (global) mapping
          PIX       *pixGlobalNormRGB()               32 bpp or cmapped
          PIX       *pixGlobalNormNoSatRGB()          32 bpp

      Adaptive threshold spread normalization
          l_int32    pixThresholdSpreadNorm()         8 bpp

      Adaptive background normalization (flexible adaptaption)
          PIX       *pixBackgroundNormFlex()          8 bpp

      Adaptive contrast normalization
          PIX             *pixContrastNorm()          8 bpp
          l_int32          pixMinMaxTiles()
          l_int32          pixSetLowContrast()
          PIX             *pixLinearTRCTiled()
          static l_int32  *iaaGetLinearTRC()

  Background normalization is done by generating a reduced map (or set
  of maps) representing the estimated background value of the
  input image, and using this to shift the pixel values so that
  this background value is set to some constant value.

  Specifically, normalization has 3 steps:
    (1) Generate a background map at a reduced scale.
    (2) Make the array of inverted background values by inverting
        the map.  The result is an array of local multiplicative factors.
    (3) Apply this inverse background map to the image

  The inverse background arrays can be generated in two different ways here:
    (1) Remove the 'foreground' pixels and average over the remaining
        pixels in each tile.  Propagate values into tiles where
        values have not been assigned, either because there was not
        enough background in the tile or because the tile is covered
        by a foreground region described by an image mask.
        After the background map is made, the inverse map is generated by
        smoothing over some number of adjacent tiles
        (block convolution) and then inverting.
    (2) Remove the foreground pixels using a morphological closing
        on a subsampled version of the image.  Propagate values
        into pixels covered by an optional image mask.  Invert the
        background map without preconditioning by convolutional smoothing.

  Note: Several of these functions make an implicit assumption about RGB
        component ordering.

  Other methods for adaptively normalizing the image are also given here.

  (1) pixThresholdSpreadNorm() computes a local threshold over the image
      and normalizes the input pixel values so that this computed threshold
      is a constant across the entire image.

  (2) pixContrastNorm() computes and applies a local TRC so that the
      local dynamic range is expanded to the full 8 bits, where the
      darkest pixels are mapped to 0 and the lightest to 255.  This is
      useful for improving the appearance of pages with very light
      foreground or very dark background, and where the local TRC
      function doesn't change rapidly with position.

"""
    
    try:
        leptonica.pixBackgroundNormGrayArrayMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixBackgroundNormGrayArrayMorph.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormGrayArrayMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormGrayArrayMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('l_int32', 'bgval')       
('PIX', '**ppixd')       
  pixBackgroundNormGrayArrayMorph()

      Input:  pixs (8 bpp grayscale)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              reduction (at which morph closings are done; between 2 and 16)
              size (of square Sel for the closing; use an odd number)
              bgval (target bg val; typ. > 128)
              &pixd (<return> 16 bpp array of inverted background value)
      Return: 0 if OK, 1 on error

  Notes:
    (1) See notes in pixBackgroundNormMorph().
    (2) This returns a 16 bpp pix that can be used by
        pixApplyInvBackgroundGrayMap() to generate a normalized version
        of the input pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormGrayArrayMorph(*args)
    
    

    try:
        leptonica.pixContrastNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixContrastNorm.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixContrastNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixContrastNorm(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'mindiff')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
  pixContrastNorm()

      Input:  pixd (<optional> 8 bpp; null or equal to pixs)
              pixs (8 bpp grayscale; not colormapped)
              sx, sy (tile dimensions)
              mindiff (minimum difference to accept as valid)
              smoothx, smoothy (half-width of convolution kernel applied to
                                min and max arrays: use 0 for no smoothing)
      Return: pixd always

  Notes:
      (1) This function adaptively attempts to expand the contrast
          to the full dynamic range in each tile.  If the contrast in
          a tile is smaller than @mindiff, it uses the min and max
          pixel values from neighboring tiles.  It also can use
          convolution to smooth the min and max values from
          neighboring tiles.  After all that processing, it is
          possible that the actual pixel values in the tile are outside
          the computed [min ... max] range for local contrast
          normalization.  Such pixels are taken to be at either 0
          (if below the min) or 255 (if above the max).
      (2) pixd can be equal to pixs (in-place operation) or
          null (makes a new pixd).
      (3) sx and sy give the tile size; they are typically at least 20.
      (4) mindiff is used to eliminate results for tiles where it is
          likely that either fg or bg is missing.  A value around 50
          or more is reasonable.
      (5) The full width and height of the convolution kernel
          are (2 * smoothx + 1) and (2 * smoothy + 1).  Some smoothing
          is typically useful, and we limit the smoothing half-widths
          to the range from 0 to 8.
      (6) A linear TRC (gamma = 1.0) is applied to increase the contrast
          in each tile.  The result can subsequently be globally corrected,
          by applying pixGammaTRC() with arbitrary values of gamma
          and the 0 and 255 points of the mapping.


        """
        args = _convert_params(*args)
        
        return leptonica.pixContrastNorm(*args)
    
    

    try:
        leptonica.pixBackgroundNormRGBArrays.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBackgroundNormRGBArrays.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormRGBArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormRGBArrays(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       
  pixBackgroundNormRGBArrays()

      Input:  pixs (32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              pixg (<optional> 8 bpp grayscale version; can be null)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              bgval (target bg val; typ. > 128)
              smoothx (half-width of block convolution kernel width)
              smoothy (half-width of block convolution kernel height)
              &pixr (<return> 16 bpp array of inverted R background value)
              &pixg (<return> 16 bpp array of inverted G background value)
              &pixb (<return> 16 bpp array of inverted B background value)
      Return: 0 if OK, 1 on error

  Notes:
    (1) See notes in pixBackgroundNorm().
    (2) This returns a set of three 16 bpp pix that can be used by
        pixApplyInvBackgroundGrayMap() to generate a normalized version
        of each component of the input pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormRGBArrays(*args)
    
    

    try:
        leptonica.pixApplyInvBackgroundRGBMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixApplyInvBackgroundRGBMap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixApplyInvBackgroundRGBMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyInvBackgroundRGBMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixmr')       
('PIX', '*pixmg')       
('PIX', '*pixmb')       
('l_int32', 'sx')       
('l_int32', 'sy')       
  pixApplyInvBackgroundRGBMap()

      Input:  pixs (32 bpp rbg)
              pixmr (16 bpp, red inverse background map)
              pixmg (16 bpp, green inverse background map)
              pixmb (16 bpp, blue inverse background map)
              sx (tile width in pixels)
              sy (tile height in pixels)
      Return: pixd (32 bpp rbg), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyInvBackgroundRGBMap(*args)
    
    

    try:
        leptonica.pixThresholdSpreadNorm.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdSpreadNorm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdSpreadNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdSpreadNorm(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'filtertype')       
('l_int32', 'edgethresh')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
('l_int32', 'targetthresh')       
('PIX', '**ppixth')       
('PIX', '**ppixb')       
('PIX', '**ppixd')       
  pixThresholdSpreadNorm()

      Input:  pixs (8 bpp grayscale; not colormapped)
              filtertype (L_SOBEL_EDGE or L_TWO_SIDED_EDGE);
              edgethresh (threshold on magnitude of edge filter; typ 10-20)
              smoothx, smoothy (half-width of convolution kernel applied to
                                spread threshold: use 0 for no smoothing)
              gamma (gamma correction; typ. about 0.7)
              minval  (input value that gives 0 for output; typ. -25)
              maxval  (input value that gives 255 for output; typ. 255)
              targetthresh (target threshold for normalization)
              &pixth (<optional return> computed local threshold value)
              &pixb (<optional return> thresholded normalized image)
              &pixd (<optional return> normalized image)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The basis of this approach is the use of seed spreading
          on a (possibly) sparse set of estimates for the local threshold.
          The resulting dense estimates are smoothed by convolution
          and used to either threshold the input image or normalize it
          with a local transformation that linearly maps the pixels so
          that the local threshold estimate becomes constant over the
          resulting image.  This approach is one of several that
          have been suggested (and implemented) by Ray Smith.
      (2) You can use either the Sobel or TwoSided edge filters.
          The results appear to be similar, using typical values
          of edgethresh in the rang 10-20.
      (3) To skip the trc enhancement, use gamma = 1.0, minval = 0
          and maxval = 255.
      (4) For the normalized image pixd, each pixel is linearly mapped
          in such a way that the local threshold is equal to targetthresh.
      (5) The full width and height of the convolution kernel
          are (2 * smoothx + 1) and (2 * smoothy + 1).
      (6) This function can be used with the pixtiling utility if the
          images are too large.  See pixOtsuAdaptiveThreshold() for
          an example of this.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdSpreadNorm(*args)
    
    

    try:
        leptonica.pixGlobalNormNoSatRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixGlobalNormNoSatRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGlobalNormNoSatRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGlobalNormNoSatRGB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'factor')       
('l_float32', 'rank')       
  pixGlobalNormNoSatRGB()

      Input:  pixd (<optional> null, existing or equal to pixs)
              pixs (32 bpp rgb)
              rval, gval, bval (pixel values in pixs that are
                                linearly mapped to mapval; but see below)
              factor (subsampling factor; integer >= 1)
              rank (between 0.0 and 1.0; typ. use a value near 1.0)
      Return: pixd (32 bpp rgb), or null on error

  Notes:
    (1) This is a version of pixGlobalNormRGB(), where the output
        intensity is scaled back so that a controlled fraction of
        pixel components is allowed to saturate.  See comments in
        pixGlobalNormRGB().
    (2) The value of pixd determines if the results are written to a
        new pix (use NULL), in-place to pixs (use pixs), or to some
        other existing pix.
    (3) This does a global normalization of an image where the
        r,g,b color components are not balanced.  Thus, white in pixs is
        represented by a set of r,g,b values that are not all 255.
    (4) The input values (rval, gval, bval) can be chosen to be the
        color that, after normalization, becomes white background.
        For images that are mostly background, the closer these values
        are to the median component values, the closer the resulting
        background will be to gray, becoming white at the brightest places.
    (5) The mapval used in pixGlobalNormRGB() is computed here to
        avoid saturation of any component in the image (save for a
        fraction of the pixels given by the input rank value).


        """
        args = _convert_params(*args)
        
        return leptonica.pixGlobalNormNoSatRGB(*args)
    
    

    try:
        leptonica.pixBackgroundNormRGBArraysMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBackgroundNormRGBArraysMorph.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormRGBArraysMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormRGBArraysMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('l_int32', 'bgval')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       
  pixBackgroundNormRGBArraysMorph()

      Input:  pixs (32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              reduction (at which morph closings are done; between 2 and 16)
              size (of square Sel for the closing; use an odd number)
              bgval (target bg val; typ. > 128)
              &pixr (<return> 16 bpp array of inverted R background value)
              &pixg (<return> 16 bpp array of inverted G background value)
              &pixb (<return> 16 bpp array of inverted B background value)
      Return: 0 if OK, 1 on error

  Notes:
    (1) See notes in pixBackgroundNormMorph().
    (2) This returns a set of three 16 bpp pix that can be used by
        pixApplyInvBackgroundGrayMap() to generate a normalized version
        of each component of the input pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormRGBArraysMorph(*args)
    
    

    try:
        leptonica.pixBackgroundNormFlex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBackgroundNormFlex.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormFlex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormFlex(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_int32', 'delta')       
  pixBackgroundNormFlex()

      Input:  pixs (8 bpp grayscale; not colormapped)
              sx, sy (desired tile dimensions; actual size may vary; use
                      values between 3 and 10)
              smoothx, smoothy (half-width of convolution kernel applied to
                                threshold array: use values between 1 and 3)
              delta (difference parameter in basin filling; use 0
                     to skip)
      Return: pixd (8 bpp, background-normalized), or null on error)

  Notes:
      (1) This does adaptation flexibly to a quickly varying background.
          For that reason, all input parameters should be small.
      (2) sx and sy give the tile size; they should be in [5 - 7].
      (3) The full width and height of the convolution kernel
          are (2 * smoothx + 1) and (2 * smoothy + 1).  They
          should be in [1 - 2].
      (4) Basin filling is used to fill the large fg regions.  The
          parameter @delta measures the height that the black
          background is raised from the local minima.  By raising
          the background, it is possible to threshold the large
          fg regions to foreground.  If @delta is too large,
          bg regions will be lifted, causing thickening of
          the fg regions.  Use 0 to skip.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormFlex(*args)
    
    

    try:
        leptonica.pixMinMaxTiles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMinMaxTiles.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMinMaxTiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMinMaxTiles(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'mindiff')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('PIX', '**ppixmin')       
('PIX', '**ppixmax')       
  pixMinMaxTiles()

      Input:  pixs (8 bpp grayscale; not colormapped)
              sx, sy (tile dimensions)
              mindiff (minimum difference to accept as valid)
              smoothx, smoothy (half-width of convolution kernel applied to
                                min and max arrays: use 0 for no smoothing)
              &pixmin (<return> tiled minima)
              &pixmax (<return> tiled maxima)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes filtered and smoothed values for the min and
          max pixel values in each tile of the image.
      (2) See pixContrastNorm() for usage.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMinMaxTiles(*args)
    
    

    try:
        leptonica.pixExtendByReplication.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixExtendByReplication.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtendByReplication not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtendByReplication(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'addw')       
('l_int32', 'addh')       
  pixExtendByReplication()

      Input:  pixs (8 bpp)
              addw (number of extra pixels horizontally to add)
              addh (number of extra pixels vertically to add)
      Return: pixd (extended with replicated pixel values), or null on error

  Notes:
      (1) The pixel values are extended to the left and down, as required.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtendByReplication(*args)
    
    

    try:
        leptonica.pixSetLowContrast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetLowContrast.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetLowContrast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetLowContrast(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'mindiff')       
  pixSetLowContrast()

      Input:  pixs1 (8 bpp)
              pixs2 (8 bpp)
              mindiff (minimum difference to accept as valid)
      Return: 0 if OK; 1 if no pixel diffs are large enough, or on error

  Notes:
      (1) This compares corresponding pixels in pixs1 and pixs2.
          When they differ by less than @mindiff, set the pixel
          values to 0 in each.  Each pixel typically represents a tile
          in a larger image, and a very small difference between
          the min and max in the tile indicates that the min and max
          values are not to be trusted.
      (2) If contrast (pixel difference) detection is expected to fail,
          caller should check return value.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetLowContrast(*args)
    
    

    try:
        leptonica.pixBackgroundNormSimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBackgroundNormSimple.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormSimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormSimple(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
  pixBackgroundNormSimple()

      Input:  pixs (8 bpp grayscale or 32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              pixg (<optional> 8 bpp grayscale version; can be null)
      Return: pixd (8 bpp or 32 bpp rgb), or null on error

  Notes:
    (1) This is a simplified interface to pixBackgroundNorm(),
        where seven parameters are defaulted.
    (2) The input image is either grayscale or rgb.
    (3) See pixBackgroundNorm() for usage and function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormSimple(*args)
    
    

    try:
        leptonica.pixBackgroundNormGrayArray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixBackgroundNormGrayArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormGrayArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormGrayArray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('PIX', '**ppixd')       
  pixBackgroundNormGrayArray()

      Input:  pixs (8 bpp grayscale)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              bgval (target bg val; typ. > 128)
              smoothx (half-width of block convolution kernel width)
              smoothy (half-width of block convolution kernel height)
              &pixd (<return> 16 bpp array of inverted background value)
      Return: 0 if OK, 1 on error

  Notes:
    (1) See notes in pixBackgroundNorm().
    (2) This returns a 16 bpp pix that can be used by
        pixApplyInvBackgroundGrayMap() to generate a normalized version
        of the input pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormGrayArray(*args)
    
    

    try:
        leptonica.pixGetBackgroundRGBMapMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetBackgroundRGBMapMorph.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBackgroundRGBMapMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundRGBMapMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('PIX', '**ppixmr')       
('PIX', '**ppixmg')       
('PIX', '**ppixmb')       
  pixGetBackgroundRGBMapMorph()

      Input:  pixs (32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null; it
                     should not have all foreground pixels)
              reduction (factor at which closing is performed)
              size (of square Sel for the closing; use an odd number)
              &pixmr (<return> red component map)
              &pixmg (<return> green component map)
              &pixmb (<return> blue component map)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundRGBMapMorph(*args)
    
    

    try:
        leptonica.pixBackgroundNormMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBackgroundNormMorph.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNormMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('l_int32', 'bgval')       
  pixBackgroundNormMorph()

      Input:  pixs (8 bpp grayscale or 32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              reduction (at which morph closings are done; between 2 and 16)
              size (of square Sel for the closing; use an odd number)
              bgval (target bg val; typ. > 128)
      Return: pixd (8 bpp), or null on error

  Notes:
    (1) This is a top-level interface for normalizing the image intensity
        by mapping the image so that the background is near the input
        value 'bgval'.
    (2) The input image is either grayscale or rgb.
    (3) For each component in the input image, the background value
        is estimated using a grayscale closing; hence the 'Morph'
        in the function name.
    (4) An optional binary mask can be specified, with the foreground
        pixels typically over image regions.  The resulting background
        map values will be determined by surrounding pixels that are
        not under the mask foreground.  The origin (0,0) of this mask
        is assumed to be aligned with the origin of the input image.
        This binary mask must not fully cover pixs, because then there
        will be no pixels in the input image available to compute
        the background.
    (5) The map is computed at reduced size (given by 'reduction')
        from the input pixs and optional pixim.  At this scale,
        pixs is closed to remove the background, using a square Sel
        of odd dimension.  The product of reduction * size should be
        large enough to remove most of the text foreground.
    (6) No convolutional smoothing needs to be done on the map before
        inverting it.
    (7) A 'bgval' target background value for the normalized image.  This
        should be at least 128.  If set too close to 255, some
        clipping will occur in the result.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormMorph(*args)
    
    

    try:
        leptonica.pixLinearTRCTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixLinearTRCTiled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixLinearTRCTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLinearTRCTiled(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('PIX', '*pixmin')       
('PIX', '*pixmax')       
  pixLinearTRCTiled()

      Input:  pixd (<optional> 8 bpp)
              pixs (8 bpp, not colormapped)
              sx, sy (tile dimensions)
              pixmin (pix of min values in tiles)
              pixmax (pix of max values in tiles)
      Return: pixd always

  Notes:
      (1) pixd can be equal to pixs (in-place operation) or
          null (makes a new pixd).
      (2) sx and sy give the tile size; they are typically at least 20.
      (3) pixmin and pixmax are generated by pixMinMaxTiles()
      (4) For each tile, this does a linear expansion of the dynamic
          range so that the min value in the tile becomes 0 and the
          max value in the tile becomes 255.
      (5) The LUTs that do the mapping are generated as needed
          and stored for reuse in an integer array within the ptr array iaa[].


        """
        args = _convert_params(*args)
        
        return leptonica.pixLinearTRCTiled(*args)
    
    

    try:
        leptonica.pixSmoothConnectedRegions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSmoothConnectedRegions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSmoothConnectedRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSmoothConnectedRegions(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'factor')       
  pixSmoothConnectedRegions()

      Input:  pixs (8 bpp grayscale; no colormap)
              pixm (<optional> 1 bpp; if null, this is a no-op)
              factor (subsampling factor for getting average; >= 1)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The pixels in pixs corresponding to those in each
          8-connected region in the mask are set to the average value.
      (2) This is required for adaptive mapping to avoid the
          generation of stripes in the background map, due to
          variations in the pixel values near the edges of mask regions.
      (3) This function is optimized for background smoothing, where
          there are a relatively small number of components.  It will
          be inefficient if used where there are many small components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSmoothConnectedRegions(*args)
    
    

    try:
        leptonica.pixApplyVariableGrayMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixApplyVariableGrayMap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixApplyVariableGrayMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyVariableGrayMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       
('l_int32', 'target')       
  pixApplyVariableGrayMap()

      Input:  pixs (8 bpp)
              pixg (8 bpp, variable map)
              target (typ. 128 for threshold)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) Suppose you have an image that you want to transform based
          on some photometric measurement at each point, such as the
          threshold value for binarization.  Representing the photometric
          measurement as an image pixg, you can threshold in input image
          using pixVarThresholdToBinary().  Alternatively, you can map
          the input image pointwise so that the threshold over the
          entire image becomes a constant, such as 128.  For example,
          if a pixel in pixg is 150 and the target is 128, the
          corresponding pixel in pixs is mapped linearly to a value
          (128/150) of the input value.  If the resulting mapped image
          pixd were then thresholded at 128, you would obtain the
          same result as a direct binarization using pixg with
          pixVarThresholdToBinary().
      (2) The sizes of pixs and pixg must be equal.


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyVariableGrayMap(*args)
    
    

    try:
        leptonica.pixGetBackgroundRGBMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetBackgroundRGBMap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBackgroundRGBMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundRGBMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('PIX', '**ppixmr')       
('PIX', '**ppixmg')       
('PIX', '**ppixmb')       
  pixGetBackgroundRGBMap()

      Input:  pixs (32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null; it
                     should not have all foreground pixels)
              pixg (<optional> 8 bpp grayscale version; can be null)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              &pixmr, &pixmg, &pixmb (<return> rgb maps)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If pixg, which is a grayscale version of pixs, is provided,
          use this internally to generate the foreground mask.
          Otherwise, a grayscale version of pixs will be generated
          from the green component only, used, and destroyed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundRGBMap(*args)
    
    

    try:
        leptonica.pixGlobalNormRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGlobalNormRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGlobalNormRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGlobalNormRGB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'mapval')       
  pixGlobalNormRGB()

      Input:  pixd (<optional> null, existing or equal to pixs)
              pixs (32 bpp rgb, or colormapped)
              rval, gval, bval (pixel values in pixs that are
                                linearly mapped to mapval)
              mapval (use 255 for mapping to white)
      Return: pixd (32 bpp rgb or colormapped), or null on error

  Notes:
    (1) The value of pixd determines if the results are written to a
        new pix (use NULL), in-place to pixs (use pixs), or to some
        other existing pix.
    (2) This does a global normalization of an image where the
        r,g,b color components are not balanced.  Thus, white in pixs is
        represented by a set of r,g,b values that are not all 255.
    (3) The input values (rval, gval, bval) should be chosen to
        represent the gray color (mapval, mapval, mapval) in src.
        Thus, this function will map (rval, gval, bval) to that gray color.
    (4) Typically, mapval = 255, so that (rval, gval, bval)
        corresponds to the white point of src.  In that case, these
        parameters should be chosen so that few pixels have higher values.
    (5) In all cases, we do a linear TRC separately on each of the
        components, saturating at 255.
    (6) If the input pix is 8 bpp without a colormap, you can get
        this functionality with mapval = 255 by calling:
            pixGammaTRC(pixd, pixs, 1.0, 0, bgval);
        where bgval is the value you want to be mapped to 255.
        Or more generally, if you want bgval to be mapped to mapval:
            pixGammaTRC(pixd, pixs, 1.0, 0, 255 * bgval / mapval);


        """
        args = _convert_params(*args)
        
        return leptonica.pixGlobalNormRGB(*args)
    
    

    try:
        leptonica.pixApplyInvBackgroundGrayMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixApplyInvBackgroundGrayMap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixApplyInvBackgroundGrayMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyInvBackgroundGrayMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'sx')       
('l_int32', 'sy')       
  pixApplyInvBackgroundGrayMap()

      Input:  pixs (8 bpp grayscale; no colormap)
              pixm (16 bpp, inverse background map)
              sx (tile width in pixels)
              sy (tile height in pixels)
      Return: pixd (8 bpp), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyInvBackgroundGrayMap(*args)
    
    

    try:
        leptonica.pixGetBackgroundGrayMapMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetBackgroundGrayMapMorph.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBackgroundGrayMapMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundGrayMapMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('PIX', '**ppixm')       
  pixGetBackgroundGrayMapMorph()

      Input:  pixs (8 bpp grayscale; not cmapped)
              pixim (<optional> 1 bpp 'image' mask; can be null; it
                     should not have all foreground pixels)
              reduction (factor at which closing is performed)
              size (of square Sel for the closing; use an odd number)
              &pixm (<return> grayscale map)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundGrayMapMorph(*args)
    
    

    try:
        leptonica.pixGetBackgroundGrayMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetBackgroundGrayMap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBackgroundGrayMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundGrayMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('PIX', '**ppixd')       
  pixGetBackgroundGrayMap()

      Input:  pixs (8 bpp grayscale; not cmapped)
              pixim (<optional> 1 bpp 'image' mask; can be null; it
                     should not have all foreground pixels)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              &pixd (<return> 8 bpp grayscale map)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The background is measured in regions that don't have
          images.  It is then propagated into the image regions,
          and finally smoothed in each image region.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundGrayMap(*args)
    
    

    try:
        leptonica.pixBackgroundNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBackgroundNorm.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBackgroundNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNorm(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
  pixBackgroundNorm()

      Input:  pixs (8 bpp grayscale or 32 bpp rgb)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              pixg (<optional> 8 bpp grayscale version; can be null)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              bgval (target bg val; typ. > 128)
              smoothx (half-width of block convolution kernel width)
              smoothy (half-width of block convolution kernel height)
      Return: pixd (8 bpp or 32 bpp rgb), or null on error

  Notes:
    (1) This is a top-level interface for normalizing the image intensity
        by mapping the image so that the background is near the input
        value 'bgval'.
    (2) The input image is either grayscale or rgb.
    (3) For each component in the input image, the background value
        in each tile is estimated using the values in the tile that
        are not part of the foreground, where the foreground is
        determined by the input 'thresh' argument.
    (4) An optional binary mask can be specified, with the foreground
        pixels typically over image regions.  The resulting background
        map values will be determined by surrounding pixels that are
        not under the mask foreground.  The origin (0,0) of this mask
        is assumed to be aligned with the origin of the input image.
        This binary mask must not fully cover pixs, because then there
        will be no pixels in the input image available to compute
        the background.
    (5) An optional grayscale version of the input pixs can be supplied.
        The only reason to do this is if the input is RGB and this
        grayscale version can be used elsewhere.  If the input is RGB
        and this is not supplied, it is made internally using only
        the green component, and destroyed after use.
    (6) The dimensions of the pixel tile (sx, sy) give the amount by
        by which the map is reduced in size from the input image.
    (7) The threshold is used to binarize the input image, in order to
        locate the foreground components.  If this is set too low,
        some actual foreground may be used to determine the maps;
        if set too high, there may not be enough background
        to determine the map values accurately.  Typically, it's
        better to err by setting the threshold too high.
    (8) A 'mincount' threshold is a minimum count of pixels in a
        tile for which a background reading is made, in order for that
        pixel in the map to be valid.  This number should perhaps be
        at least 1/3 the size of the tile.
    (9) A 'bgval' target background value for the normalized image.  This
        should be at least 128.  If set too close to 255, some
        clipping will occur in the result.
    (10) Two factors, 'smoothx' and 'smoothy', are input for smoothing
        the map.  Each low-pass filter kernel dimension is
        is 2 * (smoothing factor) + 1, so a
        value of 0 means no smoothing. A value of 1 or 2 is recommended.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNorm(*args)
    
    

    try:
        leptonica.pixGetInvBackgroundMap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetInvBackgroundMap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetInvBackgroundMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetInvBackgroundMap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
  pixGetInvBackgroundMap()

      Input:  pixs (8 bpp grayscale; no colormap)
              bgval (target bg val; typ. > 128)
              smoothx (half-width of block convolution kernel width)
              smoothy (half-width of block convolution kernel height)
      Return: pixd (16 bpp), or null on error

  Note:
     - bgval should typically be > 120 and < 240
     - pixd is a normalization image; the original image is
       multiplied by pixd and the result is divided by 256.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetInvBackgroundMap(*args)
    
    

    try:
        leptonica.pixFillMapHoles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFillMapHoles.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFillMapHoles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillMapHoles(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'filltype')       
  pixFillMapHoles()

      Input:  pix (8 bpp; a map, with one pixel for each tile in
              a larger image)
              nx (number of horizontal pixel tiles that are entirely
                  covered with pixels in the original source image)
              ny (ditto for the number of vertical pixel tiles)
              filltype (L_FILL_WHITE or L_FILL_BLACK)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place operation on pix (the map).  pix is
          typically a low-resolution version of some other image
          from which it was derived, where each pixel in pix
          corresponds to a rectangular tile (say, m x n) of pixels
          in the larger image.  All we need to know about the larger
          image is whether or not the rightmost column and bottommost
          row of pixels in pix correspond to tiles that are
          only partially covered by pixels in the larger image.
      (2) Typically, some number of pixels in the input map are
          not known, and their values must be determined by near
          pixels that are known.  These unknown pixels are the 'holes'.
          They can take on only two values, 0 and 255, and the
          instruction about which to fill is given by the filltype flag.
      (3) The "holes" can come from two sources.  The first is when there
          are not enough foreground or background pixels in a tile;
          the second is when a tile is at least partially covered
          by an image mask.  If we're filling holes in a fg mask,
          the holes are initialized to black (0) and use L_FILL_BLACK.
          For filling holes in a bg mask, initialize the holes to
          white (255) and use L_FILL_WHITE.
      (4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillMapHoles(*args)
    




class kernel(object):
    """  kernel.c

      Basic operations on kernels for image convolution

         Create/destroy/copy
            L_KERNEL   *kernelCreate()
            void        kernelDestroy()
            L_KERNEL   *kernelCopy()

         Accessors:
            l_int32     kernelGetElement()
            l_int32     kernelSetElement()
            l_int32     kernelGetParameters()
            l_int32     kernelSetOrigin()
            l_int32     kernelGetSum()
            l_int32     kernelGetMinMax()

         Normalize/invert
            L_KERNEL   *kernelNormalize()
            L_KERNEL   *kernelInvert()

         Helper function
            l_float32 **create2dFloatArray()

         Serialized I/O
            L_KERNEL   *kernelRead()
            L_KERNEL   *kernelReadStream()
            l_int32     kernelWrite()
            l_int32     kernelWriteStream()

         Making a kernel from a compiled string
            L_KERNEL   *kernelCreateFromString()

         Making a kernel from a simple file format
            L_KERNEL   *kernelCreateFromFile()

         Making a kernel from a Pix
            L_KERNEL   *kernelCreateFromPix()

         Display a kernel in a pix
            PIX        *kernelDisplayInPix()

         Parse string to extract numbers
            NUMA       *parseStringForNumbers()

      Simple parametric kernels
            L_KERNEL   *makeFlatKernel()
            L_KERNEL   *makeGaussianKernel()
            L_KERNEL   *makeGaussianKernelSep()
            L_KERNEL   *makeDoGKernel()

"""
    
    try:
        leptonica.kernelGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelGetParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetParameters(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', '*psy')       
('l_int32', '*psx')       
('l_int32', '*pcy')       
('l_int32', '*pcx')       
  kernelGetParameters()

      Input:  kernel
              &sy, &sx, &cy, &cx (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetParameters(*args)
    
    

    try:
        leptonica.kernelReadStream.argtypes = [ctypes.c_void_p]
        leptonica.kernelReadStream.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelReadStream(*args):
        """
        ('FILE', '*fp')       
  kernelReadStream()

      Input:  stream
      Return: kernel, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelReadStream(*args)
    
    

    try:
        leptonica.kernelGetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.kernelGetElement.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelGetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetElement(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_float32', '*pval')       
  kernelGetElement()

      Input:  kel
              row
              col
              &val
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetElement(*args)
    
    

    try:
        leptonica.kernelCopy.argtypes = [ctypes.c_void_p]
        leptonica.kernelCopy.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCopy(*args):
        """
        ('L_KERNEL', '*kels')       
  kernelCopy()

      Input:  kels (source kernel)
      Return: keld (copy of kels), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCopy(*args)
    
    

    try:
        leptonica.kernelDestroy.argtypes = [ctypes.c_void_p]
        leptonica.kernelDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function kernelDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelDestroy(*args):
        """
        ('L_KERNEL', '**pkel')       
  kernelDestroy()

      Input:  &kel (<to be nulled>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.kernelDestroy(*args)
    
    

    try:
        leptonica.kernelNormalize.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.kernelNormalize.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelNormalize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelNormalize(*args):
        """
        ('L_KERNEL', '*kels')       
('l_float32', 'normsum')       
  kernelNormalize()

      Input:  kels (source kel, to be normalized)
              normsum (desired sum of elements in keld)
      Return: keld (normalized version of kels), or null on error
                   or if sum of elements is very close to 0)

  Notes:
      (1) If the sum of kernel elements is close to 0, do not
          try to calculate the normalized kernel.  Instead,
          return a copy of the input kernel, with a warning.


        """
        args = _convert_params(*args)
        
        return leptonica.kernelNormalize(*args)
    
    

    try:
        leptonica.makeGaussianKernelSep.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.makeGaussianKernelSep.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeGaussianKernelSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGaussianKernelSep(*args):
        """
        ('l_int32', 'halfheight')       
('l_int32', 'halfwidth')       
('l_float32', 'stdev')       
('l_float32', 'max')       
('L_KERNEL', '**pkelx')       
('L_KERNEL', '**pkely')       
  makeGaussianKernelSep()

      Input:  halfheight, halfwidth (sx = 2 * halfwidth + 1, etc)
              stdev (standard deviation)
              max (value at (cx,cy))
              &kelx (<return> x part of kernel)
              &kely (<return> y part of kernel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See makeGaussianKernel() for description of input parameters.
      (2) These kernels are constructed so that the result of both
          normalized and un-normalized convolution will be the same
          as when convolving with pixConvolve() using the full kernel.
      (3) The trick for the un-normalized convolution is to have the
          product of the two kernel elemets at (cx,cy) be equal to max,
          not max**2.  That's why the max for kely is 1.0.  If instead
          we use sqrt(max) for both, the results are slightly less
          accurate, when compared to using the full kernel in
          makeGaussianKernel().


        """
        args = _convert_params(*args)
        
        return leptonica.makeGaussianKernelSep(*args)
    
    

    try:
        leptonica.makeFlatKernel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makeFlatKernel.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function makeFlatKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeFlatKernel(*args):
        """
        ('l_int32', 'height')       
('l_int32', 'width')       
('l_int32', 'cy')       
('l_int32', 'cx')       
  makeFlatKernel()

      Input:  height, width
              cy, cx (origin of kernel)
      Return: kernel, or null on error

  Notes:
      (1) This is the same low-pass filtering kernel that is used
          in the block convolution functions.
      (2) The kernel origin (@cy, @cx) is typically placed as near
          the center of the kernel as possible.  If height and
          width are odd, then using cy = height / 2 and
          cx = width / 2 places the origin at the exact center.
      (3) This returns a normalized kernel.


        """
        args = _convert_params(*args)
        
        return leptonica.makeFlatKernel(*args)
    
    

    try:
        leptonica.makeDoGKernel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.makeDoGKernel.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function makeDoGKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeDoGKernel(*args):
        """
        ('l_int32', 'halfheight')       
('l_int32', 'halfwidth')       
('l_float32', 'stdev')       
('l_float32', 'ratio')       
  makeDoGKernel()

      Input:  halfheight, halfwidth (sx = 2 * halfwidth + 1, etc)
              stdev (standard deviation of narrower gaussian)
              ratio (of stdev for wide filter to stdev for narrow one)
      Return: kernel, or null on error

  Notes:
      (1) The DoG (difference of gaussians) is a wavelet mother
          function with null total sum.  By subtracting two blurred
          versions of the image, it acts as a bandpass filter for
          frequencies passed by the narrow gaussian but stopped
          by the wide one.See:
               http://en.wikipedia.org/wiki/Difference_of_Gaussians
      (2) The kernel size (sx, sy) = (2 * halfwidth + 1, 2 * halfheight + 1).
      (3) The kernel center (cx, cy) = (halfwidth, halfheight).
      (4) The halfwidth and halfheight are typically equal, and
          are typically several times larger than the standard deviation.
      (5) The ratio is the ratio of standard deviations of the wide
          to narrow gaussian.  It must be >= 1.0; 1.0 is a no-op.
      (6) Because the kernel is a null sum, it must be invoked without
          normalization in pixConvolve().


        """
        args = _convert_params(*args)
        
        return leptonica.makeDoGKernel(*args)
    
    

    try:
        leptonica.kernelWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelWrite(*args):
        """
        ('const char', '*fname')       
('L_KERNEL', '*kel')       
  kernelWrite()

      Input:  fname (output file)
              kernel
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelWrite(*args)
    
    

    try:
        leptonica.kernelCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelCreateFromPix.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'cy')       
('l_int32', 'cx')       
  kernelCreateFromPix()

      Input:  pix
              cy, cx (origin of kernel)
      Return: kernel, or null on error

  Notes:
      (1) The origin must be positive and within the dimensions of the pix.


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreateFromPix(*args)
    
    

    try:
        leptonica.kernelCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelCreate.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreate(*args):
        """
        ('l_int32', 'height')       
('l_int32', 'width')       
  kernelCreate()

      Input:  height, width
      Return: kernel, or null on error

  Notes:
      (1) kernelCreate() initializes all values to 0.
      (2) After this call, (cy,cx) and nonzero data values must be
          assigned.


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreate(*args)
    
    

    try:
        leptonica.makeGaussianKernel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.makeGaussianKernel.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function makeGaussianKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGaussianKernel(*args):
        """
        ('l_int32', 'halfheight')       
('l_int32', 'halfwidth')       
('l_float32', 'stdev')       
('l_float32', 'max')       
  makeGaussianKernel()

      Input:  halfheight, halfwidth (sx = 2 * halfwidth + 1, etc)
              stdev (standard deviation)
              max (value at (cx,cy))
      Return: kernel, or null on error

  Notes:
      (1) The kernel size (sx, sy) = (2 * halfwidth + 1, 2 * halfheight + 1).
      (2) The kernel center (cx, cy) = (halfwidth, halfheight).
      (3) The halfwidth and halfheight are typically equal, and
          are typically several times larger than the standard deviation.
      (4) If pixConvolve() is invoked with normalization (the sum of
          kernel elements = 1.0), use 1.0 for max (or any number that's
          not too small or too large).


        """
        args = _convert_params(*args)
        
        return leptonica.makeGaussianKernel(*args)
    
    

    try:
        leptonica.kernelWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_KERNEL', '*kel')       
  kernelWriteStream()

      Input:  stream
              kel
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelWriteStream(*args)
    
    

    try:
        leptonica.kernelCreateFromFile.argtypes = [ctypes.c_void_p]
        leptonica.kernelCreateFromFile.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreateFromFile(*args):
        """
        ('const char', '*filename')       
  kernelCreateFromFile()

      Input:  filename
      Return: kernel, or null on error

  Notes:
      (1) The file contains, in the following order:
           - Any number of comment lines starting with '#' are ignored
           - The height and width of the kernel
           - The y and x values of the kernel origin
           - The kernel data, formatted as lines of numbers (integers
             or floats) for the kernel values in row-major order,
             and with no other punctuation.
             (Note: this differs from kernelCreateFromString(),
             where each line must begin and end with a double-quote
             to tell the compiler it's part of a string.)
           - The kernel specification ends when a blank line,
             a comment line, or the end of file is reached.
      (2) All lines must be left-justified.
      (3) See kernelCreateFromString() for a description of the string
          format for the kernel data.  As an example, here are the lines
          of a valid kernel description file  In the file, all lines
          are left-justified:
                    # small 3x3 kernel
                    3 3
                    1 1
                    25.5   51    24.3
                    70.2  146.3  73.4
                    20     50.9  18.4


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreateFromFile(*args)
    
    

    try:
        leptonica.kernelCreateFromString.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.kernelCreateFromString.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreateFromString(*args):
        """
        ('l_int32', 'h')       
('l_int32', 'w')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('const char', '*kdata')       
  kernelCreateFromString()

      Input:  height, width
              cy, cx   (origin)
              kdata
      Return: kernel of the given size, or null on error

  Notes:
      (1) The data is an array of chars, in row-major order, giving
          space separated integers in the range [-255 ... 255].
      (2) The only other formatting limitation is that you must
          leave space between the last number in each row and
          the double-quote.  If possible, it's also nice to have each
          line in the string represent a line in the kernel; e.g.,
              static const char *kdata =
                  " 20   50   20 "
                  " 70  140   70 "
                  " 20   50   20 ";


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreateFromString(*args)
    
    

    try:
        leptonica.kernelGetSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelGetSum.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelGetSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetSum(*args):
        """
        ('L_KERNEL', '*kel')       
('l_float32', '*psum')       
  kernelGetSum()

      Input:  kernel
              &sum (<return> sum of all kernel values)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetSum(*args)
    
    

    try:
        leptonica.kernelSetOrigin.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelSetOrigin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelSetOrigin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelSetOrigin(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'cy')       
('l_int32', 'cx')       
  kernelSetOrigin()

      Input:  kernel
              cy, cx
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelSetOrigin(*args)
    
    

    try:
        leptonica.kernelSetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.kernelSetElement.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelSetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelSetElement(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_float32', 'val')       
  kernelSetElement()

      Input:  kernel
              row
              col
              val
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelSetElement(*args)
    
    

    try:
        leptonica.kernelInvert.argtypes = [ctypes.c_void_p]
        leptonica.kernelInvert.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelInvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelInvert(*args):
        """
        ('L_KERNEL', '*kels')       
  kernelInvert()

      Input:  kels (source kel, to be inverted)
      Return: keld (spatially inverted, about the origin), or null on error

  Notes:
      (1) For convolution, the kernel is spatially inverted before
          a "correlation" operation is done between the kernel and the image.


        """
        args = _convert_params(*args)
        
        return leptonica.kernelInvert(*args)
    
    

    try:
        leptonica.create2dFloatArray.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.create2dFloatArray.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_float))
    except AttributeError:
        os.stderr.write("Warning - function create2dFloatArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def create2dFloatArray(*args):
        """
        ('l_int32', 'sy')       
('l_int32', 'sx')       
  create2dFloatArray()

      Input:  sy (rows == height)
              sx (columns == width)
      Return: doubly indexed array (i.e., an array of sy row pointers,
              each of which points to an array of sx floats)

  Notes:
      (1) The array[sy][sx] is indexed in standard "matrix notation",
          with the row index first.


        """
        args = _convert_params(*args)
        
        return leptonica.create2dFloatArray(*args)
    
    

    try:
        leptonica.parseStringForNumbers.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.parseStringForNumbers.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function parseStringForNumbers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def parseStringForNumbers(*args):
        """
        ('const char', '*str')       
('const char', '*seps')       
  parseStringForNumbers()

      Input:  string (containing numbers; not changed)
              seps (string of characters that can be used between ints)
      Return: numa (of numbers found), or null on error

  Note:
     (1) The numbers can be ints or floats.


        """
        args = _convert_params(*args)
        
        return leptonica.parseStringForNumbers(*args)
    
    

    try:
        leptonica.kernelDisplayInPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelDisplayInPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelDisplayInPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelDisplayInPix(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'size')       
('l_int32', 'gthick')       
  kernelDisplayInPix()

      Input:  kernel
              size (of grid interiors; odd; either 1 or a minimum size
                    of 17 is enforced)
              gthick (grid thickness; either 0 or a minimum size of 2
                      is enforced)
      Return: pix (display of kernel), or null on error

  Notes:
      (1) This gives a visual representation of a kernel.
      (2) There are two modes of display:
          (a) Grid lines of minimum width 2, surrounding regions
              representing kernel elements of minimum size 17,
              with a "plus" mark at the kernel origin, or
          (b) A pix without grid lines and using 1 pixel per kernel element.
      (3) For both cases, the kernel absolute value is displayed,
          normalized such that the maximum absolute value is 255.
      (4) Large 2D separable kernels should be used for convolution
          with two 1D kernels.  However, for the bilateral filter,
          the computation time is independent of the size of the
          2D content kernel.


        """
        args = _convert_params(*args)
        
        return leptonica.kernelDisplayInPix(*args)
    
    

    try:
        leptonica.kernelGetMinMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelGetMinMax.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function kernelGetMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetMinMax(*args):
        """
        ('L_KERNEL', '*kel')       
('l_float32', '*pmin')       
('l_float32', '*pmax')       
  kernelGetMinMax()

      Input:  kernel
              &min (<optional return> minimum value)
              &max (<optional return> maximum value)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetMinMax(*args)
    
    

    try:
        leptonica.kernelRead.argtypes = [ctypes.c_void_p]
        leptonica.kernelRead.restype = lambda address: L_KERNEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function kernelRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelRead(*args):
        """
        ('const char', '*fname')       
  kernelRead()

      Input:  filename
      Return: kernel, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelRead(*args)
    




class pixarith(object):
    """  pixarith.c

      One-image grayscale arithmetic operations (8, 16, 32 bpp)
           l_int32     pixAddConstantGray()
           l_int32     pixMultConstantGray()

      Two-image grayscale arithmetic operations (8, 16, 32 bpp)
           PIX        *pixAddGray()
           PIX        *pixSubtractGray()

      Grayscale threshold operation (8, 16, 32 bpp)
           PIX        *pixThresholdToValue()

      Image accumulator arithmetic operations
           PIX        *pixInitAccumulate()
           PIX        *pixFinalAccumulate()
           PIX        *pixFinalAccumulateThreshold()
           l_int32     pixAccumulate()
           l_int32     pixMultConstAccumulate()

      Absolute value of difference
           PIX        *pixAbsDifference()

      Sum of color images
           PIX        *pixAddRGB()

      Two-image min and max operations (8 and 16 bpp)
           PIX        *pixMinOrMax()

      Scale pix for maximum dynamic range in 8 bpp image:
           PIX        *pixMaxDynamicRange()

      Log base2 lookup
           l_float32  *makeLogBase2Tab()
           l_float32   getLogBase2()

      The image accumulator operations are used when you expect
      overflow from 8 bits on intermediate results.  For example,
      you might want a tophat contrast operator which is
         3*I - opening(I,S) - closing(I,S)
      To use these operations, first use the init to generate
      a 16 bpp image, use the accumulate to add or subtract 8 bpp
      images from that, or the multiply constant to multiply
      by a small constant (much less than 256 -- we don't want
      overflow from the 16 bit images!), and when you're finished
      use final to bring the result back to 8 bpp, clipped
      if necessary.  There is also a divide function, which
      can be used to divide one image by another, scaling the
      result for maximum dynamic range, and giving back the
      8 bpp result.

      A simpler interface to the arithmetic operations is
      provided in pixacc.c.

"""
    
    try:
        leptonica.pixAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAccumulate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAccumulate(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'op')       
  pixAccumulate()

      Input:  pixd (32 bpp)
              pixs (1, 8, 16 or 32 bpp)
              op  (L_ARITH_ADD or L_ARITH_SUBTRACT)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This adds or subtracts each pixs value from pixd.
      (2) This clips to the minimum of pixs and pixd, so they
          do not need to be the same size.
      (3) The alignment is to the origin (UL corner) of pixs & pixd.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAccumulate(*args)
    
    

    try:
        leptonica.pixMaxDynamicRange.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMaxDynamicRange.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMaxDynamicRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaxDynamicRange(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  pixMaxDynamicRange()

      Input:  pixs  (4, 8, 16 or 32 bpp source)
              type  (L_LINEAR_SCALE or L_LOG_SCALE)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) Scales pixel values to fit maximally within the dest 8 bpp pixd
      (2) Uses a LUT for log scaling


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaxDynamicRange(*args)
    
    

    try:
        leptonica.pixMultConstantGray.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixMultConstantGray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMultConstantGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultConstantGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'val')       
  pixMultConstantGray()

      Input:  pixs (8, 16 or 32 bpp)
              val  (>= 0.0; amount to multiply by each pixel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) In-place operation; val must be >= 0.
      (2) No clipping for 32 bpp.
      (3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultConstantGray(*args)
    
    

    try:
        leptonica.pixFinalAccumulateThreshold.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixFinalAccumulateThreshold.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFinalAccumulateThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFinalAccumulateThreshold(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'offset')       
('l_uint32', 'threshold')       
  pixFinalAccumulateThreshold()

      Input:  pixs (32 bpp)
              offset (same as used for initialization)
              threshold (values less than this are set in the destination)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) The offset must be >= 0 and should not exceed 0x40000000.
      (2) The offset is subtracted from the src 32 bpp image


        """
        args = _convert_params(*args)
        
        return leptonica.pixFinalAccumulateThreshold(*args)
    
    

    try:
        leptonica.pixFinalAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixFinalAccumulate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFinalAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFinalAccumulate(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'offset')       
('l_int32', 'depth')       
  pixFinalAccumulate()

      Input:  pixs (32 bpp)
              offset (same as used for initialization)
              depth  (8, 16 or 32 bpp, of destination)
      Return: pixd (8, 16 or 32 bpp), or null on error

  Notes:
      (1) The offset must be >= 0 and should not exceed 0x40000000.
      (2) The offset is subtracted from the src 32 bpp image
      (3) For 8 bpp dest, the result is clipped to [0, 0xff]
      (4) For 16 bpp dest, the result is clipped to [0, 0xffff]


        """
        args = _convert_params(*args)
        
        return leptonica.pixFinalAccumulate(*args)
    
    

    try:
        leptonica.pixMinOrMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMinOrMax.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMinOrMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMinOrMax(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'type')       
  pixMinOrMax()

      Input:  pixd  (<optional> destination: this can be null,
                     equal to pixs1, or different from pixs1)
              pixs1 (can be == to pixd)
              pixs2
              type (L_CHOOSE_MIN, L_CHOOSE_MAX)
      Return: pixd always

  Notes:
      (1) This gives the min or max of two images, component-wise.
      (2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp
          for a 3 component image.  For 32 bpp, ignore the LSB
          of each word (the alpha channel)
      (3) There are 3 cases:
          -  if pixd == null,   Min(src1, src2) --> new pixd
          -  if pixd == pixs1,  Min(src1, src2) --> src1  (in-place)
          -  if pixd != pixs1,  Min(src1, src2) --> input pixd


        """
        args = _convert_params(*args)
        
        return leptonica.pixMinOrMax(*args)
    
    

    try:
        leptonica.pixThresholdToValue.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdToValue.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdToValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdToValue(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'threshval')       
('l_int32', 'setval')       
  pixThresholdToValue()

      Input:  pixd (<optional>; if not null, must be equal to pixs)
              pixs (8, 16, 32 bpp)
              threshval
              setval
      Return: pixd always

  Notes:
    - operation can be in-place (pixs == pixd) or to a new pixd
    - if setval > threshval, sets pixels with a value >= threshval to setval
    - if setval < threshval, sets pixels with a value <= threshval to setval
    - if setval == threshval, no-op


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdToValue(*args)
    
    

    try:
        leptonica.pixAddGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixAddGray()

      Input:  pixd (<optional>; this can be null, equal to pixs1, or
                    different from pixs1)
              pixs1 (can be == to pixd)
              pixs2
      Return: pixd always

  Notes:
      (1) Arithmetic addition of two 8, 16 or 32 bpp images.
      (2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,
          respectively.
      (3) Alignment is to UL corner.
      (4) There are 3 cases.  The result can go to a new dest,
          in-place to pixs1, or to an existing input dest:
          * pixd == null:   (src1 + src2) --> new pixd
          * pixd == pixs1:  (src1 + src2) --> src1  (in-place)
          * pixd != pixs1:  (src1 + src2) --> input pixd
      (5) pixs2 must be different from both pixd and pixs1.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddGray(*args)
    
    

    try:
        leptonica.pixAddRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddRGB(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixAddRGB()

      Input:  pixs1, pixs2  (32 bpp RGB, or colormapped)
      Return: pixd, or null on error

  Notes:
      (1) Clips computation to the minimum size, aligning the UL corners.
      (2) Removes any colormap to RGB, and ignores the LSB of each
          pixel word (the alpha channel).
      (3) Adds each component value, pixelwise, clipping to 255.
      (4) This is useful to combine two images where most of the
          pixels are essentially black, such as in pixPerceptualDiff().


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddRGB(*args)
    
    

    try:
        leptonica.pixMultConstAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixMultConstAccumulate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMultConstAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultConstAccumulate(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'factor')       
('l_uint32', 'offset')       
  pixMultConstAccumulate()

      Input:  pixs (32 bpp)
              factor
              offset (same as used for initialization)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The offset must be >= 0 and should not exceed 0x40000000.
      (2) This multiplies each pixel, relative to offset, by the input factor
      (3) The result is returned with the offset back in place.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultConstAccumulate(*args)
    
    

    try:
        leptonica.pixAbsDifference.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAbsDifference.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAbsDifference not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDifference(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixAbsDifference()

      Input:  pixs1, pixs2  (both either 8 or 16 bpp gray, or 32 bpp RGB)
      Return: pixd, or null on error

  Notes:
      (1) The depth of pixs1 and pixs2 must be equal.
      (2) Clips computation to the min size, aligning the UL corners
      (3) For 8 and 16 bpp, assumes one gray component.
      (4) For 32 bpp, assumes 3 color components, and ignores the
          LSB of each word (the alpha channel)
      (5) Computes the absolute value of the difference between
          each component value.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDifference(*args)
    
    

    try:
        leptonica.pixSubtractGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSubtractGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSubtractGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSubtractGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixSubtractGray()

      Input:  pixd (<optional>; this can be null, equal to pixs1, or
                    different from pixs1)
              pixs1 (can be == to pixd)
              pixs2
      Return: pixd always

  Notes:
      (1) Arithmetic subtraction of two 8, 16 or 32 bpp images.
      (2) Source pixs2 is always subtracted from source pixs1.
      (3) Do explicit clipping to 0.
      (4) Alignment is to UL corner.
      (5) There are 3 cases.  The result can go to a new dest,
          in-place to pixs1, or to an existing input dest:
          (a) pixd == null   (src1 - src2) --> new pixd
          (b) pixd == pixs1  (src1 - src2) --> src1  (in-place)
          (d) pixd != pixs1  (src1 - src2) --> input pixd
      (6) pixs2 must be different from both pixd and pixs1.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSubtractGray(*args)
    
    

    try:
        leptonica.pixAddConstantGray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAddConstantGray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAddConstantGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddConstantGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'val')       
  pixAddConstantGray()

      Input:  pixs (8, 16 or 32 bpp)
              val  (amount to add to each pixel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) In-place operation.
      (2) No clipping for 32 bpp.
      (3) For 8 and 16 bpp, if val > 0 the result is clipped
          to 0xff and 0xffff, rsp.
      (4) For 8 and 16 bpp, if val < 0 the result is clipped to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddConstantGray(*args)
    
    

    try:
        leptonica.pixInitAccumulate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixInitAccumulate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixInitAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixInitAccumulate(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_uint32', 'offset')       
  pixInitAccumulate()

      Input:  w, h (of accumulate array)
              offset (initialize the 32 bpp to have this
                      value; not more than 0x40000000)
      Return: pixd (32 bpp), or null on error

  Notes:
      (1) The offset must be >= 0.
      (2) The offset is used so that we can do arithmetic
          with negative number results on l_uint32 data; it
          prevents the l_uint32 data from going negative.
      (3) Because we use l_int32 intermediate data results,
          these should never exceed the max of l_int32 (0x7fffffff).
          We do not permit the offset to be above 0x40000000,
          which is half way between 0 and the max of l_int32.
      (4) The same offset should be used for initialization,
          multiplication by a constant, and final extraction!
      (5) If you're only adding positive values, offset can be 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixInitAccumulate(*args)
    




class bardecode(object):
    """  bardecode.c

      Dispatcher
          char            *barcodeDispatchDecoder()

      Format Determination
          static l_int32   barcodeFindFormat()
          l_int32          barcodeFormatIsSupported()
          static l_int32   barcodeVerifyFormat()

      Decode 2 of 5
          static char     *barcodeDecode2of5()

      Decode Interleaved 2 of 5
          static char     *barcodeDecodeI2of5()

      Decode Code 93
          static char     *barcodeDecode93()

      Decode Code 39
          static char     *barcodeDecode39()

      Decode Codabar
          static char     *barcodeDecodeCodabar()

      Decode UPC-A
          static char     *barcodeDecodeUpca()

      Decode EAN 13
          static char     *barcodeDecodeEan13()

"""
    
    try:
        leptonica.barcodeDispatchDecoder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.barcodeDispatchDecoder.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function barcodeDispatchDecoder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def barcodeDispatchDecoder(*args):
        """
        ('char', '*barstr')       
('l_int32', 'format')       
('l_int32', 'debugflag')       
  barcodeDispatchDecoder()

      Input:  barstr (string of integers in set {1,2,3,4} of bar widths)
              format (L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...)
              debugflag (use 1 to generate debug output)
      Return: data (string of decoded barcode data), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.barcodeDispatchDecoder(*args)
    
    

    try:
        leptonica.barcodeFormatIsSupported.argtypes = [ctypes.c_int32]
        leptonica.barcodeFormatIsSupported.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function barcodeFormatIsSupported not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def barcodeFormatIsSupported(*args):
        """
        ('l_int32', 'format')       
  barcodeFormatIsSupported()

      Input:  format
      Return: 1 if format is one of those supported; 0 otherwise



        """
        args = _convert_params(*args)
        
        return leptonica.barcodeFormatIsSupported(*args)
    




class rotateshear(object):
    """  rotateshear.c

      Shear rotation about arbitrary point using 2 and 3 shears

              PIX      *pixRotateShear()
              PIX      *pixRotate2Shear()
              PIX      *pixRotate3Shear()

      Shear rotation in-place about arbitrary point using 3 shears
              l_int32   pixRotateShearIP()

      Shear rotation around the image center
              PIX      *pixRotateShearCenter()    (2 or 3 shears)
              l_int32   pixRotateShearCenterIP()  (3 shears)

  Rotation is measured in radians; clockwise rotations are positive.

  Rotation by shear works on images of any depth,
  including 8 bpp color paletted images and 32 bpp
  rgb images.  It works by translating each src pixel
  value to the appropriate pixel in the rotated dest.
  For 8 bpp grayscale images, it is about 10-15x faster
  than rotation by area-mapping.

  This speed and flexibility comes at the following cost,
  relative to area-mapped rotation:

    -  Jaggies are created on edges of straight lines

    -  For large angles, where you must use 3 shears,
       there is some extra clipping from the shears.

  For small angles, typically less than 0.05 radians,
  rotation can be done with 2 orthogonal shears.
  Two such continuous shears (as opposed to the discrete
  shears on a pixel lattice that we have here) give
  a rotated image that has a distortion in the lengths
  of the two rotated and still-perpendicular axes.  The
  length/width ratio changes by a fraction

       0.5 * (angle)**2

  For an angle of 0.05 radians, this is about 1 part in
  a thousand.  This distortion is absent when you use
  3 continuous shears with the correct angles (see below).

  Of course, the image is on a discrete pixel lattice.
  Rotation by shear gives an approximation to a continuous
  rotation, leaving pixel jaggies at sharp boundaries.
  For very small rotations, rotating from a corner gives
  better sensitivity than rotating from the image center.
  Here's why.  Define the shear "center" to be the line such
  that the image is sheared in opposite directions on
  each side of and parallel to the line.  For small
  rotations there is a "dead space" on each side of the
  shear center of width equal to half the shear angle,
  in radians.  Thus, when the image is sheared about the center,
  the dead space width equals the shear angle, but when
  the image is sheared from a corner, the dead space
  width is only half the shear angle.

  All horizontal and vertical shears are implemented by
  rasterop.  The in-place rotation uses special in-place
  shears that copy rows sideways or columns vertically
  without buffering, and then rewrite old pixels that are
  no longer covered by sheared pixels.  For that rewriting,
  you have the choice of using white or black pixels.
  (Note that this may give undesirable results for colormapped
  images, where the white and black values are arbitrary
  indexes into the colormap, and may not even exist.)

  Rotation by shear is fast and depth-independent.  However, it
  does not work well for large rotation angles.  In fact, for
  rotation angles greater than about 7 degrees, more pixels are
  lost at the edges than when using pixRotationBySampling(), which
  only loses pixels because they are rotated out of the image.
  For larger rotations, use pixRotationBySampling() or, for
  more accuracy when d > 1 bpp, pixRotateAM().

  For small angles, when comparing the quality of rotation by
  sampling and by shear, you can see that rotation by sampling
  is slightly more accurate.  However, the difference in
  accuracy of rotation by sampling when compared to 3-shear and
  (for angles less than 2 degrees, when compared to 2-shear) is
  less than 1 pixel at any point.  For very small angles, rotation by
  sampling is much slower than rotation by shear.  The speed difference
  depends on the pixel depth and the rotation angle.  Rotation
  by shear is very fast for small angles and for small depth (esp. 1 bpp).
  Rotation by sampling speed is independent of angle and relatively
  more efficient for 8 and 32 bpp images.  Here are some timings
  for the ratio of rotation times: (time for sampling)/ (time for shear)
*
       depth (bpp)       ratio (2 deg)       ratio (10 deg)
       -----------------------------------------------------
          1                  25                  6
          8                   5                  2.6
          32                  1.6                1.0

  In summary:
    * For d == 1 and small angles, use rotation by shear.  By default
      this will use 2-shear rotations, because 3-shears cause more
      visible artifacts in straight lines and, for small angles, the
      distortion in asperity ratio is small.
    * For d > 1, shear is faster than sampling, which is faster than
      area mapping.  However, area mapping gives the best results.
  These results are used in selecting the rotation methods in
  pixRotateShear().

  There has been some work on what is called a "quasishear
  rotation" ("The Quasi-Shear Rotation, Eric Andres,
  DGCI 1996, pp. 307-314).  I believe they use a 3-shear
  approximation to the continuous rotation, exactly as
  we do here.  The approximation is due to being on
  a square pixel lattice.  They also use integers to specify
  the rotation angle and center offset, but that makes
  little sense on a machine where you have a few GFLOPS
  and only a few hundred floating point operations to do (!)
  They also allow subpixel specification of the center of
  rotation, which I haven't bothered with, and claim that
  better results are possible if each of the 4 quadrants is
  handled separately.

  But the bottom line is that you are going to see shear lines when
  you rotate 1 bpp images.  Although the 3-shear rotation is
  mathematically exact in the limit of infinitesimal pixels, artifacts
  will be evident in real images.  One might imagine using dithering
  to break up the horizontal and vertical shear lines, but this
  is hard with block shears, where you need to dither on the block
  boundaries.  Dithering (by accumulation of 'error') with sampling
  makes more sense, but I haven't tried to do this.  There is only
  so much you can do with 1 bpp images!

"""
    
    try:
        leptonica.pixRotate3Shear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotate3Shear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotate3Shear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate3Shear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotate3Shear()

      Input:  pixs
              xcen, ycen (center of rotation)
              angle (radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) This rotates the image about the given point, using the 3-shear
          method.  It should only be used for angles smaller than
          LIMIT_SHEAR_ANGLE.  For larger angles, a warning is issued.
      (2) A positive angle gives a clockwise rotation.
      (3) 3-shear rotation by a specified angle is equivalent
          to the sequential transformations
            y' = y + tan(angle/2) * (x - xcen)     for first y-shear
            x' = x + sin(angle) * (y - ycen)       for x-shear
            y' = y + tan(angle/2) * (x - xcen)     for second y-shear
      (4) Computation of tan(angle) is performed in the shear operations.
      (5) This brings in 'incolor' pixels from outside the image.
      (6) If the image has an alpha layer, it is rotated separately by
          two shears.
      (7) The algorithm was published by Alan Paeth: "A Fast Algorithm
          for General Raster Rotation," Graphics Interface '86,
          pp. 77-81, May 1986.  A description of the method, along with
          an implementation, can be found in Graphics Gems, p. 179,
          edited by Andrew Glassner, published by Academic Press, 1990.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate3Shear(*args)
    
    

    try:
        leptonica.pixRotateShearIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShearIP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRotateShearIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShearIP(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateShearIP()

      Input:  pixs (any depth; not colormapped)
              xcen, ycen (center of rotation)
              angle (radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This does an in-place rotation of the image about the
          specified point, using the 3-shear method.  It should only
          be used for angles smaller than LIMIT_SHEAR_ANGLE.
          For larger angles, a warning is issued.
      (2) A positive angle gives a clockwise rotation.
      (3) 3-shear rotation by a specified angle is equivalent
          to the sequential transformations
            y' = y + tan(angle/2) * (x - xcen)      for first y-shear
            x' = x + sin(angle) * (y - ycen)        for x-shear
            y' = y + tan(angle/2) * (x - xcen)      for second y-shear
      (4) Computation of tan(angle) is performed in the shear operations.
      (5) This brings in 'incolor' pixels from outside the image.
      (6) The pix cannot be colormapped, because the in-place operation
          only blits in 0 or 1 bits, not an arbitrary colormap index.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShearIP(*args)
    
    

    try:
        leptonica.pixRotate2Shear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotate2Shear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotate2Shear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate2Shear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotate2Shear()

      Input:  pixs
              xcen, ycen (center of rotation)
              angle (radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) This rotates the image about the given point, using the 2-shear
          method.  It should only be used for angles smaller than
          MAX_2_SHEAR_ANGLE.  For larger angles, a warning is issued.
      (2) A positive angle gives a clockwise rotation.
      (3) 2-shear rotation by a specified angle is equivalent
          to the sequential transformations
             x' = x + tan(angle) * (y - ycen)     for x-shear
             y' = y + tan(angle) * (x - xcen)     for y-shear
      (4) Computation of tan(angle) is performed within the shear operation.
      (5) This brings in 'incolor' pixels from outside the image.
      (6) If the image has an alpha layer, it is rotated separately by
          two shears.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate2Shear(*args)
    
    

    try:
        leptonica.pixRotateShearCenter.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShearCenter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateShearCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShearCenter(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateShearCenter()

      Input:  pixs
              angle (radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShearCenter(*args)
    
    

    try:
        leptonica.pixRotateShearCenterIP.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShearCenterIP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRotateShearCenterIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShearCenterIP(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateShearCenterIP()

      Input:  pixs
              angle (radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShearCenterIP(*args)
    
    

    try:
        leptonica.pixRotateShear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateShear()

      Input:  pixs
              xcen (x value for which there is no horizontal shear)
              ycen (y value for which there is no vertical shear)
              angle (radians)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK);
      Return: pixd, or null on error.

  Notes:
      (1) This rotates an image about the given point, using
          either 2 or 3 shears.
      (2) A positive angle gives a clockwise rotation.
      (3) This brings in 'incolor' pixels from outside the image.
      (4) For rotation angles larger than about 0.35 radians, we issue
          a warning because you should probably be using another method
          (either sampling or area mapping)


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShear(*args)
    




class rop(object):
    """  rop.c

      General rasterop
           l_int32    pixRasterop()

      In-place full band translation
           l_int32    pixRasteropVip()
           l_int32    pixRasteropHip()

      Full image translation (general and in-place)
           l_int32    pixTranslate()
           l_int32    pixRasteropIP()

      Full image rasterop with no translation
           l_int32    pixRasteropFullImage()

"""
    
    try:
        leptonica.pixRasterop.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasterop.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRasterop not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasterop(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'dx')       
('l_int32', 'dy')       
('l_int32', 'dw')       
('l_int32', 'dh')       
('l_int32', 'op')       
('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
  pixRasterop()

      Input:  pixd   (dest pix)
              dx     (x val of UL corner of dest rectangle)
              dy     (y val of UL corner of dest rectangle)
              dw     (width of dest rectangle)
              dh     (height of dest rectangle)
              op     (op code)
              pixs   (src pix)
              sx     (x val of UL corner of src rectangle)
              sy     (y val of UL corner of src rectangle)
      Return: 0 if OK; 1 on error.

  Notes:
      (1) This has the standard set of 9 args for rasterop.
          This function is your friend; it is worth memorizing!
      (2) If the operation involves only dest, this calls
          rasteropUniLow().  Otherwise, checks depth of the
          src and dest, and if they match, calls rasteropLow().
      (3) For the two-image operation, where both pixs and pixd
          are defined, they are typically different images.  However
          there are cases, such as pixSetMirroredBorder(), where
          in-place operations can be done, blitting pixels from
          one part of pixd to another.  Consequently, we permit
          such operations.  If you use them, be sure that there
          is no overlap between the source and destination rectangles
          in pixd (!)

  Background:
  -----------

  There are 18 operations, described by the op codes in pix.h.

  One, PIX_DST, is a no-op.

  Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.
  These are handled by the low-level rasteropUniLow().

  The other 14 involve the both the src and the dest, and depend on
  the bit values of either just the src or the bit values of both
  src and dest.  They are handled by rasteropLow():

          PIX_SRC                             s
          PIX_NOT(PIX_SRC)                   ~s
          PIX_SRC | PIX_DST                   s | d
          PIX_SRC & PIX_DST                   s & d
          PIX_SRC ^ PIX_DST                   s ^ d
          PIX_NOT(PIX_SRC) | PIX_DST         ~s | d
          PIX_NOT(PIX_SRC) & PIX_DST         ~s & d
          PIX_NOT(PIX_SRC) ^ PIX_DST         ~s ^ d
          PIX_SRC | PIX_NOT(PIX_DST)          s | ~d
          PIX_SRC & PIX_NOT(PIX_DST)          s & ~d
          PIX_SRC ^ PIX_NOT(PIX_DST)          s ^ ~d
          PIX_NOT(PIX_SRC | PIX_DST)         ~(s | d)
          PIX_NOT(PIX_SRC & PIX_DST)         ~(s & d)
          PIX_NOT(PIX_SRC ^ PIX_DST)         ~(s ^ d)

  Each of these is implemented with one of three low-level
  functions, depending on the alignment of the left edge
  of the src and dest rectangles:
      * a fastest implementation if both left edges are
        (32-bit) word aligned
      * a very slightly slower implementation if both left
        edges have the same relative (32-bit) word alignment
      * the general routine that is invoked when
        both left edges have different word alignment

  Of the 14 binary rasterops above, only 12 are unique
  logical combinations (out of a possible 16) of src
  and dst bits:

        (sd)         (11)   (10)   (01)   (00)
   -----------------------------------------------
         s            1      1      0      0
        ~s            0      1      0      1
       s | d          1      1      1      0
       s & d          1      0      0      0
       s ^ d          0      1      1      0
      ~s | d          1      0      1      1
      ~s & d          0      0      1      0
      ~s ^ d          1      0      0      1
       s | ~d         1      1      0      1
       s & ~d         0      1      0      0
       s ^ ~d         1      0      0      1
      ~(s | d)        0      0      0      1
      ~(s & d)        0      1      1      1
      ~(s ^ d)        1      0      0      1

  Note that the following three operations are equivalent:
      ~(s ^ d)
      ~s ^ d
      s ^ ~d
  and in the implementation, we call them out with the first form;
  namely, ~(s ^ d).

  Of the 16 possible binary combinations of src and dest bits,
  the remaining 4 unique ones are independent of the src bit.
  They depend on either just the dest bit or on neither
  the src nor dest bits:

         d            1      0      1      0    (indep. of s)
        ~d            0      1      0      1    (indep. of s)
        CLR           0      0      0      0    (indep. of both s & d)
        SET           1      1      1      1    (indep. of both s & d)

  As mentioned above, three of these are implemented by
  rasteropUniLow(), and one is a no-op.

  How can these operation codes be represented by bits
  in such a way that when the basic operations are performed
  on the bits the results are unique for unique
  operations, and mimic the logic table given above?

  The answer is to choose a particular order of the pairings:
         (sd)         (11)   (10)   (01)   (00)
  (which happens to be the same as in the above table)
  and to translate the result into 4-bit representations
  of s and d.  For example, the Sun rasterop choice
  (omitting the extra bit for clipping) is

      PIX_SRC      0xc
      PIX_DST      0xa

  This corresponds to our pairing order given above:
         (sd)         (11)   (10)   (01)   (00)
  where for s = 1 we get the bit pattern
       PIX_SRC:        1      1      0      0     (0xc)
  and for d = 1 we get the pattern
       PIX_DST:         1      0      1      0    (0xa)

  OK, that's the pairing order that Sun chose.  How many different
  ways can we assign bit patterns to PIX_SRC and PIX_DST to get
  the boolean ops to work out?  Any of the 4 pairs can be put
  in the first position, any of the remaining 3 pairs can go
  in the second; and one of the remaining 2 pairs can go the the third.
  There is a total of 4*3*2 = 24 ways these pairs can be permuted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasterop(*args)
    
    

    try:
        leptonica.pixRasteropIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasteropIP.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRasteropIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropIP(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'hshift')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       
  pixRasteropIP()

      Input:  pixd (in-place translation)
              hshift (horizontal shift; hshift > 0 is to right)
              vshift (vertical shift; vshift > 0 is down)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropIP(*args)
    
    

    try:
        leptonica.pixRasteropFullImage.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRasteropFullImage.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRasteropFullImage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropFullImage(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'op')       
  pixRasteropFullImage()

      Input:  pixd
              pixs
              op (any of the op-codes)
      Return: 0 if OK; 1 on error

  Notes:
      - this is a wrapper for a common 2-image raster operation
      - both pixs and pixd must be defined
      - the operation is performed with aligned UL corners of pixs and pixd
      - the operation clips to the smallest pix; if the width or height
        of pixd is larger than pixs, some pixels in pixd will be unchanged


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropFullImage(*args)
    
    

    try:
        leptonica.pixRasteropHip.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasteropHip.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRasteropHip not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropHip(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'by')       
('l_int32', 'bh')       
('l_int32', 'hshift')       
('l_int32', 'incolor')       
  pixRasteropHip()

      Input:  pixd (in-place operation)
              by  (top of horizontal band)
              bh  (height of horizontal band)
              hshift (horizontal shift of band; hshift > 0 is to right)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This rasterop translates a horizontal band of the
          image either left or right, bringing in either white
          or black pixels from outside the image.
      (2) The horizontal band extends the full width of pixd.
      (3) If a colormap exists, the nearest color to white or black
          is brought in.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropHip(*args)
    
    

    try:
        leptonica.pixRasteropVip.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasteropVip.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRasteropVip not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropVip(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'bx')       
('l_int32', 'bw')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       
  pixRasteropVip()

      Input:  pixd (in-place)
              bx  (left edge of vertical band)
              bw  (width of vertical band)
              vshift (vertical shift of band; vshift > 0 is down)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This rasterop translates a vertical band of the
          image either up or down, bringing in either white
          or black pixels from outside the image.
      (2) The vertical band extends the full height of pixd.
      (3) If a colormap exists, the nearest color to white or black
          is brought in.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropVip(*args)
    
    

    try:
        leptonica.pixTranslate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTranslate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTranslate(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hshift')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       
  pixTranslate()

      Input:  pixd (<optional> destination: this can be null,
                    equal to pixs, or different from pixs)
              pixs
              hshift (horizontal shift; hshift > 0 is to right)
              vshift (vertical shift; vshift > 0 is down)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error.

  Notes:
      (1) The general pattern is:
            pixd = pixTranslate(pixd, pixs, ...);
          For clarity, when you know the case, use one of these:
            pixd = pixTranslate(NULL, pixs, ...);  // new
            pixTranslate(pixs, pixs, ...);         // in-place
            pixTranslate(pixd, pixs, ...);         // to existing pixd
      (2) If an existing pixd is not the same size as pixs, the
          image data will be reallocated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTranslate(*args)
    




class watershed(object):
    """  watershed.c

      Top-level
            L_WSHED         *wshedCreate()
            void             wshedDestroy()
            l_int32          wshedApply()

      Helpers
            static l_int32   identifyWatershedBasin()
            static l_int32   mergeLookup()
            static l_int32   wshedGetHeight()
            static void      pushNewPixel()
            static void      popNewPixel()
            static void      pushWSPixel()
            static void      popWSPixel()
            static void      debugPrintLUT()
            static void      debugWshedMerge()

      Output
            l_int32          wshedBasins()
            PIX             *wshedRenderFill()
            PIX             *wshedRenderColors()

  The watershed function identifies the "catch basins" of the input
  8 bpp image, with respect to the specified seeds or "markers".
  The use is in segmentation, but the selection of the markers is
  critical to getting meaningful results.

  How are the markers selected?  You can't simply use the local
  minima, because a typical image has sufficient noise so that
  a useful catch basin can easily have multiple local minima.  However
  they are selected, the question for the watershed function is
  how to handle local minima that are not markers.  The reason
  this is important is because of the algorithm used to find the
  watersheds, which is roughly like this:

    (1) Identify the markers and the local minima, and enter them
        into a priority queue based on the pixel value.  Each marker
        is shrunk to a single pixel, if necessary, before the
        operation starts.
    (2) Feed the priority queue with neighbors of pixels that are
        popped off the queue.  Each of these queue pixels is labelled
        with the index value of its parent.
    (3) Each pixel is also labelled, in a 32-bit image, with the marker
        or local minimum index, from which it was originally derived.
    (4) There are actually 3 classes of labels: seeds, minima, and
        fillers.  The fillers are labels of regions that have already
        been identified as watersheds and are continuing to fill, for
        the purpose of finding higher watersheds.
    (5) When a pixel is popped that has already been labelled in the
        32-bit image and that label differs from the label of its
        parent (stored in the queue pixel), a boundary has been crossed.
        There are several cases:
         (a) Both parents are derived from markers but at least one
             is not deep enough to become a watershed.  Absorb the
             shallower basin into the deeper one, fixing the LUT to
             redirect the shallower index to the deeper one.
         (b) Both parents are derived from markers and both are deep
             enough.  Identify and save the watershed for each marker.
         (c) One parent was derived from a marker and the other from
             a minima: absorb the minima basin into the marker basin.
         (d) One parent was derived from a marker and the other is
             a filler: identify and save the watershed for the marker.
         (e) Both parents are derived from minima: merge them.
         (f) One parent is a filler and the other is derived from a
             minima: merge the minima into the filler.
    (6) The output of the watershed operation consists of:
         - a pixa of the basins
         - a pta of the markers
         - a numa of the watershed levels

  Typical usage:
      L_WShed *wshed = wshedCreate(pixs, pixseed, mindepth, 0);
      wshedApply(wshed);

      wshedBasins(wshed, &pixa, &nalevels);
        ... do something with pixa, nalevels ...
      pixaDestroy(&pixa);
      numaDestroy(&nalevels);

      Pix *pixd = wshedRenderFill(wshed);

      wshedDestroy(&wshed);

"""
    
    try:
        leptonica.wshedRenderColors.argtypes = [ctypes.c_void_p]
        leptonica.wshedRenderColors.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function wshedRenderColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedRenderColors(*args):
        """
        ('L_WSHED', '*wshed')       
  wshedRenderColors()

      Input:  wshed
      Return: pixd (initial image with all basins filled), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.wshedRenderColors(*args)
    
    

    try:
        leptonica.wshedApply.argtypes = [ctypes.c_void_p]
        leptonica.wshedApply.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function wshedApply not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedApply(*args):
        """
        ('L_WSHED', '*wshed')       
  wshedApply()

      Input:  wshed (generated from wshedCreate())
      Return: 0 if OK, 1 on error

  Iportant note:
      (1) This is buggy.  It seems to locate watersheds that are
          duplicates.  The watershed extraction after complete fill
          grabs some regions belonging to existing watersheds.
          See prog/watershedtest.c for testing.


        """
        args = _convert_params(*args)
        
        return leptonica.wshedApply(*args)
    
    

    try:
        leptonica.wshedCreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.wshedCreate.restype = lambda address: L_WSHED(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function wshedCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedCreate(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'mindepth')       
('l_int32', 'debugflag')       
  wshedCreate()

      Input:  pixs  (8 bpp source)
              pixm  (1 bpp 'marker' seed)
              mindepth (minimum depth; anything less is not saved)
              debugflag (1 for debug output)
      Return: WShed, or null on error

  Notes:
      (1) It is not necessary for the fg pixels in the seed image
          be at minima, or that they be isolated.  We extract a
          single pixel from each connected component, and a seed
          anywhere in a watershed will eventually label the watershed
          when the filling level reaches it.
      (2) Set mindepth to some value to ignore noise in pixs that
          can create small local minima.  Any watershed shallower
          than mindepth, even if it has a seed, will not be saved;
          It will either be incorporated in another watershed or
          eliminated.


        """
        args = _convert_params(*args)
        
        return leptonica.wshedCreate(*args)
    
    

    try:
        leptonica.wshedRenderFill.argtypes = [ctypes.c_void_p]
        leptonica.wshedRenderFill.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function wshedRenderFill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedRenderFill(*args):
        """
        ('L_WSHED', '*wshed')       
  wshedRenderFill()

      Input:  wshed
      Return: pixd (initial image with all basins filled), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.wshedRenderFill(*args)
    
    

    try:
        leptonica.wshedBasins.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.wshedBasins.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function wshedBasins not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedBasins(*args):
        """
        ('L_WSHED', '*wshed')       
('PIXA', '**ppixa')       
('NUMA', '**pnalevels')       
  wshedBasins()

      Input:  wshed
              &pixa  (<optional return> mask of watershed basins)
              &nalevels   (<optional return> watershed levels)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.wshedBasins(*args)
    
    

    try:
        leptonica.wshedDestroy.argtypes = [ctypes.c_void_p]
        leptonica.wshedDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function wshedDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedDestroy(*args):
        """
        ('L_WSHED', '**pwshed')       
  wshedDestroy()

      Input:  &wshed (<will be set to null before returning>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.wshedDestroy(*args)
    




class colormorph(object):
    """  colormorph.c

      Top-level color morphological operations

            PIX     *pixColorMorph()

      Method: Algorithm by van Herk and Gil and Werman, 1992
              Apply grayscale morphological operations separately
              to each component.

"""
    
    try:
        leptonica.pixColorMorph.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorMorph.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorMorph(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixColorMorph()

      Input:  pixs
              type  (L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN,
                     or L_MORPH_CLOSE)
              hsize  (of Sel; must be odd; origin implicitly in center)
              vsize  (ditto)
      Return: pixd

  Notes:
      (1) This does the morph operation on each component separately,
          and recombines the result.
      (2) Sel is a brick with all elements being hits.
      (3) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorMorph(*args)
    




class bilinear(object):
    """  bilinear.c

      Bilinear (4 pt) image transformation using a sampled
      (to nearest integer) transform on each dest point
           PIX      *pixBilinearSampledPta()
           PIX      *pixBilinearSampled()

      Bilinear (4 pt) image transformation using interpolation
      (or area mapping) for anti-aliasing images that are
      2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
           PIX      *pixBilinearPta()
           PIX      *pixBilinear()
           PIX      *pixBilinearPtaColor()
           PIX      *pixBilinearColor()
           PIX      *pixBilinearPtaGray()
           PIX      *pixBilinearGray()

      Bilinear transform including alpha (blend) component
           PIX      *pixBilinearPtaWithAlpha()

      Bilinear coordinate transformation
           l_int32   getBilinearXformCoeffs()
           l_int32   bilinearXformSampledPt()
           l_int32   bilinearXformPt()

      A bilinear transform can be specified as a specific functional
      mapping between 4 points in the source and 4 points in the dest.
      It can be used as an approximation to a (nonlinear) projective
      transform, because for small warps it is very similar and
      it is more stable.  (Projective transforms have a division
      by a quantity that can get arbitrarily small.)

      We give both a bilinear coordinate transformation and
      a bilinear image transformation.

      For the former, we ask for the coordinate value (x',y')
      in the transformed space for any point (x,y) in the original
      space.  The coefficients of the transformation are found by
      solving 8 simultaneous equations for the 8 coordinates of
      the 4 points in src and dest.  The transformation can then
      be used to compute the associated image transform, by
      computing, for each dest pixel, the relevant pixel(s) in
      the source.  This can be done either by taking the closest
      src pixel to each transformed dest pixel ("sampling") or
      by doing an interpolation and averaging over 4 source
      pixels with appropriate weightings ("interpolated").

      A typical application would be to remove some of the
      keystoning due to a projective transform in the imaging system.

      The bilinear transform is given by specifying two equations:

          x' = ax + by + cxy + d
          y' = ex + fy + gxy + h

      where the eight coefficients have been computed from four
      sets of these equations, each for two corresponding data pts.
      In practice, once the coefficients are known, we use the
      equations "backwards": for each point (x,y) in the dest image,
      these two equations are used to compute the corresponding point
      (x',y') in the src.  That computed point in the src is then used
      to determine the corresponding dest pixel value in one of two ways:

       - sampling: simply take the value of the src pixel in which this
                   point falls
       - interpolation: take appropriate linear combinations of the
                        four src pixels that this dest pixel would
                        overlap, with the coefficients proportional
                        to the amount of overlap

      For small warp, like rotation, area mapping in the
      interpolation is equivalent to linear interpolation.

      Typical relative timing of transforms (sampled = 1.0):
      8 bpp:   sampled        1.0
               interpolated   1.6
      32 bpp:  sampled        1.0
               interpolated   1.8
      Additionally, the computation time/pixel is nearly the same
      for 8 bpp and 32 bpp, for both sampled and interpolated.

"""
    
    try:
        leptonica.pixBilinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinear(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       
  pixBilinear()

      Input:  pixs (all depths; colormap ok)
              vc  (vector of 8 coefficients for bilinear transformation)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary
      (2) Removes any existing colormap, if necessary, before transforming


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinear(*args)
    
    

    try:
        leptonica.pixBilinearPtaColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixBilinearPtaColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearPtaColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPtaColor(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint32', 'colorval')       
  pixBilinearPtaColor()

      Input:  pixs (32 bpp)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPtaColor(*args)
    
    

    try:
        leptonica.bilinearXformSampledPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bilinearXformSampledPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bilinearXformSampledPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bilinearXformSampledPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       
  bilinearXformSampledPt()

      Input:  vc (vector of 8 coefficients)
              (x, y)  (initial point)
              (&xp, &yp)   (<return> transformed point)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds the nearest pixel coordinates of the transformed point.
      (2) It does not check ptrs for returned data!


        """
        args = _convert_params(*args)
        
        return leptonica.bilinearXformSampledPt(*args)
    
    

    try:
        leptonica.pixBilinearSampled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinearSampled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearSampled(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       
  pixBilinearSampled()

      Input:  pixs (all depths)
              vc  (vector of 8 coefficients for bilinear transformation)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary.
      (2) Retains colormap, which you can do for a sampled transform..
      (3) For 8 or 32 bpp, much better quality is obtained by the
          somewhat slower pixBilinear().  See that function
          for relative timings between sampled and interpolated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearSampled(*args)
    
    

    try:
        leptonica.pixBilinearPtaGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixBilinearPtaGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearPtaGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPtaGray(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint8', 'grayval')       
  pixBilinearPtaGray()

      Input:  pixs (8 bpp)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPtaGray(*args)
    
    

    try:
        leptonica.pixBilinearGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixBilinearGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint8', 'grayval')       
  pixBilinearGray()

      Input:  pixs (8 bpp)
              vc  (vector of 8 coefficients for bilinear transformation)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearGray(*args)
    
    

    try:
        leptonica.getBilinearXformCoeffs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getBilinearXformCoeffs.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getBilinearXformCoeffs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getBilinearXformCoeffs(*args):
        """
        ('PTA', '*ptas')       
('PTA', '*ptad')       
('l_float32', '**pvc')       
  getBilinearXformCoeffs()

      Input:  ptas  (source 4 points; unprimed)
              ptad  (transformed 4 points; primed)
              &vc   (<return> vector of coefficients of transform)
      Return: 0 if OK; 1 on error

  We have a set of 8 equations, describing the bilinear
  transformation that takes 4 points (ptas) into 4 other
  points (ptad).  These equations are:

          x1' = c[0]*x1 + c[1]*y1 + c[2]*x1*y1 + c[3]
          y1' = c[4]*x1 + c[5]*y1 + c[6]*x1*y1 + c[7]
          x2' = c[0]*x2 + c[1]*y2 + c[2]*x2*y2 + c[3]
          y2' = c[4]*x2 + c[5]*y2 + c[6]*x2*y2 + c[7]
          x3' = c[0]*x3 + c[1]*y3 + c[2]*x3*y3 + c[3]
          y3' = c[4]*x3 + c[5]*y3 + c[6]*x3*y3 + c[7]
          x4' = c[0]*x4 + c[1]*y4 + c[2]*x4*y4 + c[3]
          y4' = c[4]*x4 + c[5]*y4 + c[6]*x4*y4 + c[7]

  This can be represented as

           AC = B

  where B and C are column vectors

         B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
         C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]

  and A is the 8x8 matrix

             x1   y1   x1*y1   1   0    0      0     0
              0    0     0     0   x1   y1   x1*y1   1
             x2   y2   x2*y2   1   0    0      0     0
              0    0     0     0   x2   y2   x2*y2   1
             x3   y3   x3*y3   1   0    0      0     0
              0    0     0     0   x3   y3   x3*y3   1
             x4   y4   x4*y4   1   0    0      0     0
              0    0     0     0   x4   y4   x4*y4   1

  These eight equations are solved here for the coefficients C.

  These eight coefficients can then be used to find the mapping
  (x,y) --> (x',y'):

           x' = c[0]x + c[1]y + c[2]xy + c[3]
           y' = c[4]x + c[5]y + c[6]xy + c[7]

  that are implemented in bilinearXformSampledPt() and
  bilinearXFormPt().


        """
        args = _convert_params(*args)
        
        return leptonica.getBilinearXformCoeffs(*args)
    
    

    try:
        leptonica.bilinearXformPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bilinearXformPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bilinearXformPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bilinearXformPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pxp')       
('l_float32', '*pyp')       
  bilinearXformPt()

      Input:  vc (vector of 8 coefficients)
              (x, y)  (initial point)
              (&xp, &yp)   (<return> transformed point)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This computes the floating point location of the transformed point.
      (2) It does not check ptrs for returned data!


        """
        args = _convert_params(*args)
        
        return leptonica.bilinearXformPt(*args)
    
    

    try:
        leptonica.pixBilinearPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinearPta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       
  pixBilinearPta()

      Input:  pixs (all depths; colormap ok)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary
      (2) Removes any existing colormap, if necessary, before transforming


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPta(*args)
    
    

    try:
        leptonica.pixBilinearColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixBilinearColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint32', 'colorval')       
  pixBilinearColor()

      Input:  pixs (32 bpp)
              vc  (vector of 8 coefficients for bilinear transformation)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearColor(*args)
    
    

    try:
        leptonica.pixBilinearSampledPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinearSampledPta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearSampledPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearSampledPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       
  pixBilinearSampledPta()

      Input:  pixs (all depths)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary.
      (2) Retains colormap, which you can do for a sampled transform..
      (3) No 3 of the 4 points may be collinear.
      (4) For 8 and 32 bpp pix, better quality is obtained by the
          somewhat slower pixBilinearPta().  See that
          function for relative timings between sampled and interpolated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearSampledPta(*args)
    
    

    try:
        leptonica.pixBilinearPtaWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixBilinearPtaWithAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBilinearPtaWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPtaWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('PIX', '*pixg')       
('l_float32', 'fract')       
('l_int32', 'border')       
  pixBilinearPtaWithAlpha()

      Input:  pixs (32 bpp rgb)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              pixg (<optional> 8 bpp, can be null)
              fract (between 0.0 and 1.0, with 0.0 fully transparent
                     and 1.0 fully opaque)
              border (of pixels added to capture transformed source pixels)
      Return: pixd, or null on error

  Notes:
      (1) The alpha channel is transformed separately from pixs,
          and aligns with it, being fully transparent outside the
          boundary of the transformed pixs.  For pixels that are fully
          transparent, a blending function like pixBlendWithGrayMask()
          will give zero weight to corresponding pixels in pixs.
      (2) If pixg is NULL, it is generated as an alpha layer that is
          partially opaque, using @fract.  Otherwise, it is cropped
          to pixs if required and @fract is ignored.  The alpha channel
          in pixs is never used.
      (3) Colormaps are removed.
      (4) When pixs is transformed, it doesn't matter what color is brought
          in because the alpha channel will be transparent (0) there.
      (5) To avoid losing source pixels in the destination, it may be
          necessary to add a border to the source pix before doing
          the bilinear transformation.  This can be any non-negative number.
      (6) The input @ptad and @ptas are in a coordinate space before
          the border is added.  Internally, we compensate for this
          before doing the bilinear transform on the image after
          the border is added.
      (7) The default setting for the border values in the alpha channel
          is 0 (transparent) for the outermost ring of pixels and
          (0.5 * fract * 255) for the second ring.  When blended over
          a second image, this
          (a) shrinks the visible image to make a clean overlap edge
              with an image below, and
          (b) softens the edges by weakening the aliasing there.
          Use l_setAlphaMaskBorder() to change these values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPtaWithAlpha(*args)
    




class scale(object):
    """  scale.c

         Top-level scaling
               PIX      *pixScale()     ***
               PIX      *pixScaleToSize()     ***
               PIX      *pixScaleGeneral()     ***

         Linearly interpreted (usually up-) scaling
               PIX      *pixScaleLI()     ***
               PIX      *pixScaleColorLI()
               PIX      *pixScaleColor2xLI()   ***
               PIX      *pixScaleColor4xLI()   ***
               PIX      *pixScaleGrayLI()
               PIX      *pixScaleGray2xLI()
               PIX      *pixScaleGray4xLI()

         Scaling by closest pixel sampling
               PIX      *pixScaleBySampling()
               PIX      *pixScaleBySamplingToSize()
               PIX      *pixScaleByIntSampling()

         Fast integer factor subsampling RGB to gray and to binary
               PIX      *pixScaleRGBToGrayFast()
               PIX      *pixScaleRGBToBinaryFast()
               PIX      *pixScaleGrayToBinaryFast()

         Downscaling with (antialias) smoothing
               PIX      *pixScaleSmooth() ***
               PIX      *pixScaleRGBToGray2()   [special 2x reduction to gray]

         Downscaling with (antialias) area mapping
               PIX      *pixScaleAreaMap()     ***
               PIX      *pixScaleAreaMap2()

         Binary scaling by closest pixel sampling
               PIX      *pixScaleBinary()

         Scale-to-gray (1 bpp --> 8 bpp; arbitrary downscaling)
               PIX      *pixScaleToGray()
               PIX      *pixScaleToGrayFast()

         Scale-to-gray (1 bpp --> 8 bpp; integer downscaling)
               PIX      *pixScaleToGray2()
               PIX      *pixScaleToGray3()
               PIX      *pixScaleToGray4()
               PIX      *pixScaleToGray6()
               PIX      *pixScaleToGray8()
               PIX      *pixScaleToGray16()

         Scale-to-gray by mipmap(1 bpp --> 8 bpp, arbitrary reduction)
               PIX      *pixScaleToGrayMipmap()

         Grayscale scaling using mipmap
               PIX      *pixScaleMipmap()

         Replicated (integer) expansion (all depths)
               PIX      *pixExpandReplicate()

         Upscale 2x followed by binarization
               PIX      *pixScaleGray2xLIThresh()
               PIX      *pixScaleGray2xLIDither()

         Upscale 4x followed by binarization
               PIX      *pixScaleGray4xLIThresh()
               PIX      *pixScaleGray4xLIDither()

         Grayscale downscaling using min and max
               PIX      *pixScaleGrayMinMax()
               PIX      *pixScaleGrayMinMax2()

         Grayscale downscaling using rank value
               PIX      *pixScaleGrayRankCascade()
               PIX      *pixScaleGrayRank2()

         Helper function for transferring alpha with scaling
               l_int32   pixScaleAndTransferAlpha()

         RGB scaling including alpha (blend) component
               PIX      *pixScaleWithAlpha()   ***

  *** Note: these functions make an implicit assumption about RGB
            component ordering.

"""
    
    try:
        leptonica.pixScaleToGray16.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray16.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray16(*args):
        """
        ('PIX', '*pixs')       
  pixScaleToGray16()

      Input:  pixs (1 bpp)
      Return: pixd (8 bpp), scaled down by 16x in each direction,
              or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray16(*args)
    
    

    try:
        leptonica.pixExpandReplicate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExpandReplicate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExpandReplicate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExpandReplicate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixExpandReplicate()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)
              factor (integer scale factor for replicative expansion)
      Return: pixd (scaled up), or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExpandReplicate(*args)
    
    

    try:
        leptonica.pixScaleColor2xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleColor2xLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleColor2xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleColor2xLI(*args):
        """
        ('PIX', '*pixs')       
  pixScaleColor2xLI()

      Input:  pixs  (32 bpp, representing rgb)
      Return: pixd, or null on error

  Notes:
      (1) This is a special case of linear interpolated scaling,
          for 2x upscaling.  It is about 8x faster than using
          the generic pixScaleColorLI(), and about 4x faster than
          using the special 2x scale function pixScaleGray2xLI()
          on each of the three components separately.
      (2) The speed on intel hardware is about
          80 * 10^6 dest-pixels/sec/GHz.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleColor2xLI(*args)
    
    

    try:
        leptonica.pixScaleGray2xLIDither.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray2xLIDither.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGray2xLIDither not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray2xLIDither(*args):
        """
        ('PIX', '*pixs')       
  pixScaleGray2xLIDither()

      Input:  pixs (8 bpp, not cmapped)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This does 2x upscale on pixs, using linear interpolation,
          followed by Floyd-Steinberg dithering to binary.
      (2) Buffers are used to avoid making a large grayscale image.
          - Two line buffers are used for the src, required for the 2x
            LI upscale.
          - Three line buffers are used for the intermediate image.
            Two are filled with each 2xLI row operation; the third is
            needed because the upscale and dithering ops are out of sync.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray2xLIDither(*args)
    
    

    try:
        leptonica.pixScaleWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleWithAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('PIX', '*pixg')       
('l_float32', 'fract')       
  pixScaleWithAlpha()

      Input:  pixs (32 bpp rgb or cmapped)
              scalex, scaley (must be > 0.0)
              pixg (<optional> 8 bpp, can be null)
              fract (between 0.0 and 1.0, with 0.0 fully transparent
                     and 1.0 fully opaque)
      Return: pixd (32 bpp rgba), or null on error

  Notes:
      (1) The alpha channel is transformed separately from pixs,
          and aligns with it, being fully transparent outside the
          boundary of the transformed pixs.  For pixels that are fully
          transparent, a blending function like pixBlendWithGrayMask()
          will give zero weight to corresponding pixels in pixs.
      (2) Scaling is done with area mapping or linear interpolation,
          depending on the scale factors.  Default sharpening is done.
      (3) If pixg is NULL, it is generated as an alpha layer that is
          partially opaque, using @fract.  Otherwise, it is cropped
          to pixs if required, and @fract is ignored.  The alpha
          channel in pixs is never used.
      (4) Colormaps are removed to 32 bpp.
      (5) The default setting for the border values in the alpha channel
          is 0 (transparent) for the outermost ring of pixels and
          (0.5 * fract * 255) for the second ring.  When blended over
          a second image, this
          (a) shrinks the visible image to make a clean overlap edge
              with an image below, and
          (b) softens the edges by weakening the aliasing there.
          Use l_setAlphaMaskBorder() to change these values.
      (6) A subtle use of gamma correction is to remove gamma correction
          before scaling and restore it afterwards.  This is done
          by sandwiching this function between a gamma/inverse-gamma
          photometric transform:
              pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
              pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract);
              pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
              pixDestroy(&pixt);
          This has the side-effect of producing artifacts in the very
          dark regions.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleWithAlpha(*args)
    
    

    try:
        leptonica.pixScaleGrayLI.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleGrayLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGrayLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayLI(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleGrayLI()

      Input:  pixs (8 bpp grayscale, no cmap)
              scalex, scaley (must both be >= 0.7)
      Return: pixd, or null on error

  This function is appropriate for upscaling
  (magnification: scale factors > 1), and for a
  small amount of downscaling (reduction: scale
  factors > 0.5).   For scale factors less than 0.5,
  the best result is obtained by area mapping,
  but this is very expensive.  So for such large
  reductions, it is more appropriate to do low pass
  filtering followed by subsampling, a combination
  which is effectively a cheap form of area mapping.

  Some details follow.

  For each pixel in the dest, this does a linear
  interpolation of 4 neighboring pixels in the src.
  Specifically, consider the UL corner of src and
  dest pixels.  The UL corner of the dest falls within
  a src pixel, whose four corners are the UL corners
  of 4 adjacent src pixels.  The value of the dest
  is taken by linear interpolation using the values of
  the four src pixels and the distance of the UL corner
  of the dest from each corner.

  If the image is expanded so that the dest pixel is
  smaller than the src pixel, such interpolation
  is a reasonable approach.  This interpolation is
  also good for a small image reduction factor that
  is not more than a 2x reduction.

  Note that the linear interpolation algorithm for scaling
  is identical in form to the area-mapping algorithm
  for grayscale rotation.  The latter corresponds to a
  translation of each pixel without scaling.

  This function is NOT optimal if the scaling involves
  a large reduction.    If the image is significantly
  reduced, so that the dest pixel is much larger than
  the src pixels, this interpolation, which is over src
  pixels only near the UL corner of the dest pixel,
  is not going to give a good area-mapping average.
  Because area mapping for image scaling is considerably
  more computationally intensive than linear interpolation,
  we choose not to use it.   For large image reduction,
  linear interpolation over adjacent src pixels
  degenerates asymptotically to subsampling.  But
  subsampling without a low-pass pre-filter causes
  aliasing by the nyquist theorem.  To avoid aliasing,
  a low-pass filter (e.g., an averaging filter) of
  size roughly equal to the dest pixel (i.e., the
  reduction factor) should be applied to the src before
  subsampling.

  As an alternative to low-pass filtering and subsampling
  for large reduction factors, linear interpolation can
  also be done between the (widely separated) src pixels in
  which the corners of the dest pixel lie.  This also is
  not optimal, as it samples src pixels only near the
  corners of the dest pixel, and it is not implemented.

  Summary:
    (1) If this is used for scale factors less than 0.7,
        it will suffer from antialiasing.  A warning is issued.
        Particularly for document images with sharp edges,
        use pixScaleSmooth() or pixScaleAreaMap() instead.
    (2) The speed on intel hardware for the general case (not 2x)
        is about 13 * 10^6 dest-pixels/sec/GHz.  (The special 2x
        case runs at about 100 * 10^6 dest-pixels/sec/GHz.)


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayLI(*args)
    
    

    try:
        leptonica.pixScaleAndTransferAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleAndTransferAlpha.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixScaleAndTransferAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAndTransferAlpha(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleAndTransferAlpha()

      Input:  pixd  (32 bpp, scaled image)
              pixs  (32 bpp, original unscaled image)
              scalex, scaley (both > 0.0)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This scales the alpha component of pixs and inserts into pixd.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAndTransferAlpha(*args)
    
    

    try:
        leptonica.pixScaleToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleToSize.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       
  pixScaleToSize()

      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)
              wd  (target width; use 0 if using height as target)
              hd  (target height; use 0 if using width as target)
      Return: pixd, or null on error

  Notes:
      (1) This guarantees that the output scaled image has the
          dimension(s) you specify.
           - To specify the width with isotropic scaling, set @hd = 0.
           - To specify the height with isotropic scaling, set @wd = 0.
           - If both @wd and @hd are specified, the image is scaled
             (in general, anisotropically) to that size.
           - It is an error to set both @wd and @hd to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToSize(*args)
    
    

    try:
        leptonica.pixScaleBySampling.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleBySampling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleBySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleBySampling(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleBySampling()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)
              scalex, scaley (both > 0.0)
      Return: pixd, or null on error

  Notes:
      (1) This function samples from the source without
          filtering.  As a result, aliasing will occur for
          subsampling (@scalex and/or @scaley < 1.0).
      (2) If @scalex == 1.0 and @scaley == 1.0, returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleBySampling(*args)
    
    

    try:
        leptonica.pixScaleLI.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleLI(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleLI()

      Input:  pixs (2, 4, 8 or 32 bpp; with or without colormap)
              scalex, scaley (must both be >= 0.7)
      Return: pixd, or null on error

  Notes:
      (1) This function should only be used when the scale factors are
          greater than or equal to 0.7, and typically greater than 1.
          If either scale factor is smaller than 0.7, we issue a warning
          and invoke pixScale().
      (2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on
          2, 4 and 8 bpp images that have a colormap.  If there is a
          colormap, it is removed to either gray or RGB, depending
          on the colormap.
      (3) This does a linear interpolation on the src image.
      (4) It dispatches to much faster implementations for
          the special cases of 2x and 4x expansion.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleLI(*args)
    
    

    try:
        leptonica.pixScaleByIntSampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleByIntSampling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleByIntSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleByIntSampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixScaleByIntSampling()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp)
              factor (integer subsampling)
      Return: pixd, or null on error

  Notes:
      (1) Simple interface to pixScaleBySampling(), for
          isotropic integer reduction.
      (2) If @factor == 1, returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleByIntSampling(*args)
    
    

    try:
        leptonica.pixScaleGrayToBinaryFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleGrayToBinaryFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGrayToBinaryFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayToBinaryFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'thresh')       
  pixScaleGrayToBinaryFast()

      Input:  pixs (8 bpp grayscale)
              factor (integer reduction factor >= 1)
              thresh (binarization threshold)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This does simultaneous subsampling by an integer factor and
          thresholding from gray to binary.
      (2) It is designed for maximum speed, and is used for quickly
          generating a downsized binary image from a higher resolution
          gray image.  This would typically be used for image analysis.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayToBinaryFast(*args)
    
    

    try:
        leptonica.pixScaleToGrayMipmap.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleToGrayMipmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGrayMipmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGrayMipmap(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalefactor')       
  pixScaleToGrayMipmap()

      Input:  pixs (1 bpp)
              scalefactor (reduction: must be > 0.0 and < 1.0)
      Return: pixd (8 bpp), scaled down by scalefactor in each direction,
              or NULL on error.

  Notes:

  This function is here mainly for pedagogical reasons.
  Mip-mapping is widely used in graphics for texture mapping, because
  the texture changes smoothly with scale.  This is accomplished by
  constructing a multiresolution pyramid and, for each pixel,
  doing a linear interpolation between corresponding pixels in
  the two planes of the pyramid that bracket the desired resolution.
  The computation is very efficient, and is implemented in hardware
  in high-end graphics cards.

  We can use mip-mapping for scale-to-gray by using two scale-to-gray
  reduced images (we don't need the entire pyramid) selected from
  the set {2x, 4x, ... 16x}, and interpolating.  However, we get
  severe aliasing, probably because we are subsampling from the
  higher resolution image.  The method is very fast, but the result
  is very poor.  In fact, the results don't look any better than
  either subsampling off the higher-res grayscale image or oversampling
  on the lower-res image.  Consequently, this method should NOT be used
  for generating reduced images, scale-to-gray or otherwise.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGrayMipmap(*args)
    
    

    try:
        leptonica.pixScaleGrayRankCascade.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleGrayRankCascade.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGrayRankCascade not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayRankCascade(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level1')       
('l_int32', 'level2')       
('l_int32', 'level3')       
('l_int32', 'level4')       
  pixScaleGrayRankCascade()

      Input:  pixs (8 bpp, not cmapped)
              level1, ... level4 (rank thresholds, in set {0, 1, 2, 3, 4})
      Return: pixd (8 bpp, downscaled by up to 16x)

  Notes:
      (1) This performs up to four cascaded 2x rank reductions.
      (2) Use level = 0 to truncate the cascade.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayRankCascade(*args)
    
    

    try:
        leptonica.pixScaleRGBToGray2.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleRGBToGray2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleRGBToGray2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleRGBToGray2(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       
  pixScaleRGBToGray2()

      Input:  pixs (32 bpp rgb)
              rwt, gwt, bwt (must sum to 1.0)
      Return: pixd, (8 bpp, 2x reduced), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleRGBToGray2(*args)
    
    

    try:
        leptonica.pixScaleSmooth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleSmooth.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleSmooth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleSmooth(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleSmooth()

      Input:  pixs (2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap)
              scalex, scaley (must both be < 0.7)
      Return: pixd, or null on error

  Notes:
      (1) This function should only be used when the scale factors are less
          than or equal to 0.7 (i.e., more than about 1.42x reduction).
          If either scale factor is larger than 0.7, we issue a warning
          and invoke pixScale().
      (2) This works only on 2, 4, 8 and 32 bpp images, and if there is
          a colormap, it is removed by converting to RGB.  In other
          cases, we issue a warning and invoke pixScale().
      (3) It does simple (flat filter) convolution, with a filter size
          commensurate with the amount of reduction, to avoid antialiasing.
      (4) It does simple subsampling after smoothing, which is appropriate
          for this range of scaling.  Linear interpolation gives essentially
          the same result with more computation for these scale factors,
          so we don't use it.
      (5) The result is the same as doing a full block convolution followed by
          subsampling, but this is faster because the results of the block
          convolution are only computed at the subsampling locations.
          In fact, the computation time is approximately independent of
          the scale factor, because the convolution kernel is adjusted
          so that each source pixel is summed approximately once.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleSmooth(*args)
    
    

    try:
        leptonica.pixScaleGray4xLIDither.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray4xLIDither.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGray4xLIDither not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray4xLIDither(*args):
        """
        ('PIX', '*pixs')       
  pixScaleGray4xLIDither()

      Input:  pixs (8 bpp, not cmapped)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This does 4x upscale on pixs, using linear interpolation,
          followed by Floyd-Steinberg dithering to binary.
      (2) Buffers are used to avoid making a large grayscale image.
          - Two line buffers are used for the src, required for the
            4xLI upscale.
          - Five line buffers are used for the intermediate image.
            Four are filled with each 4xLI row operation; the fifth
            is needed because the upscale and dithering ops are
            out of sync.
      (3) If a full 4x expanded grayscale image can be kept in memory,
          this function is only about 5% faster than separately doing
          a linear interpolation to a large grayscale image, followed
          by error-diffusion dithering to binary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray4xLIDither(*args)
    
    

    try:
        leptonica.pixScaleColor4xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleColor4xLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleColor4xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleColor4xLI(*args):
        """
        ('PIX', '*pixs')       
  pixScaleColor4xLI()

      Input:  pixs  (32 bpp, representing rgb)
      Return: pixd, or null on error

  Notes:
      (1) This is a special case of color linear interpolated scaling,
          for 4x upscaling.  It is about 3x faster than using
          the generic pixScaleColorLI().
      (2) The speed on intel hardware is about
          30 * 10^6 dest-pixels/sec/GHz
      (3) This scales each component separately, using pixScaleGray4xLI().
          It would be about 4x faster to inline the color code properly,
          in analogy to scaleColor4xLILow(), and I leave this as
          an exercise for someone who really needs it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleColor4xLI(*args)
    
    

    try:
        leptonica.pixScaleToGray.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleToGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalefactor')       
  pixScaleToGray()

      Input:  pixs (1 bpp)
              scalefactor (reduction: must be > 0.0 and < 1.0)
      Return: pixd (8 bpp), scaled down by scalefactor in each direction,
              or NULL on error.

  Notes:

  For faster scaling in the range of scalefactors from 0.0625 to 0.5,
  with very little difference in quality, use pixScaleToGrayFast().

  Binary images have sharp edges, so they intrinsically have very
  high frequency content.  To avoid aliasing, they must be low-pass
  filtered, which tends to blur the edges.  How can we keep relatively
  crisp edges without aliasing?  The trick is to do binary upscaling
  followed by a power-of-2 scaleToGray.  For large reductions, where
  you don't end up with much detail, some corners can be cut.

  The intent here is to get high quality reduced grayscale
  images with relatively little computation.  We do binary
  pre-scaling followed by scaleToGrayN() for best results,
  esp. to avoid excess blur when the scale factor is near
  an inverse power of 2.  Where a low-pass filter is required,
  we use simple convolution kernels: either the hat filter for
  linear interpolation or a flat filter for larger downscaling.
  Other choices, such as a perfect bandpass filter with infinite extent
  (the sinc) or various approximations to it (e.g., lanczos), are
  unnecessarily expensive.

  The choices made are as follows:
      (1) Do binary upscaling before scaleToGrayN() for scalefactors > 1/8
      (2) Do binary downscaling before scaleToGray8() for scalefactors
          between 1/16 and 1/8.
      (3) Use scaleToGray16() before grayscale downscaling for
          scalefactors less than 1/16
  Another reasonable choice would be to start binary downscaling
  for scalefactors below 1/4, rather than below 1/8 as we do here.

  The general scaling rules, not all of which are used here, go as follows:
      (1) For grayscale upscaling, use pixScaleGrayLI().  However,
          note that edges will be visibly blurred for scalefactors
          near (but above) 1.0.  Replication will avoid edge blur,
          and should be considered for factors very near 1.0.
      (2) For grayscale downscaling with a scale factor larger than
          about 0.7, use pixScaleGrayLI().  For scalefactors near
          (but below) 1.0, you tread between Scylla and Charybdis.
          pixScaleGrayLI() again gives edge blurring, but
          pixScaleBySampling() gives visible aliasing.
      (3) For grayscale downscaling with a scale factor smaller than
          about 0.7, use pixScaleSmooth()
      (4) For binary input images, do as much scale to gray as possible
          using the special integer functions (2, 3, 4, 8 and 16).
      (5) It is better to upscale in binary, followed by scaleToGrayN()
          than to do scaleToGrayN() followed by an upscale using either
          LI or oversampling.
      (6) It may be better to downscale in binary, followed by
          scaleToGrayN() than to first use scaleToGrayN() followed by
          downscaling.  For downscaling between 8x and 16x, this is
          a reasonable option.
      (7) For reductions greater than 16x, it's reasonable to use
          scaleToGray16() followed by further grayscale downscaling.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray(*args)
    
    

    try:
        leptonica.pixScaleGray2xLIThresh.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGray2xLIThresh.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGray2xLIThresh not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray2xLIThresh(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
  pixScaleGray2xLIThresh()

      Input:  pixs (8 bpp, not cmapped)
              thresh  (between 0 and 256)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This does 2x upscale on pixs, using linear interpolation,
          followed by thresholding to binary.
      (2) Buffers are used to avoid making a large grayscale image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray2xLIThresh(*args)
    
    

    try:
        leptonica.pixScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScale.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScale(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScale()

      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)
              scalex, scaley
      Return: pixd, or null on error

  This function scales 32 bpp RGB; 2, 4 or 8 bpp palette color;
  2, 4, 8 or 16 bpp gray; and binary images.

  When the input has palette color, the colormap is removed and
  the result is either 8 bpp gray or 32 bpp RGB, depending on whether
  the colormap has color entries.  Images with 2, 4 or 16 bpp are
  converted to 8 bpp.

  Because pixScale() is meant to be a very simple interface to a
  number of scaling functions, including the use of unsharp masking,
  the type of scaling and the sharpening parameters are chosen
  by default.  Grayscale and color images are scaled using one
  of four methods, depending on the scale factors:
   (1) antialiased subsampling (lowpass filtering followed by
       subsampling, implemented here by area mapping), for scale factors
       less than 0.2
   (2) antialiased subsampling with sharpening, for scale factors
       between 0.2 and 0.7
   (3) linear interpolation with sharpening, for scale factors between
       0.7 and 1.4
   (4) linear interpolation without sharpening, for scale factors >= 1.4.

  One could use subsampling for scale factors very close to 1.0,
  because it preserves sharp edges.  Linear interpolation blurs
  edges because the dest pixels will typically straddle two src edge
  pixels.  Subsmpling removes entire columns and rows, so the edge is
  not blurred.  However, there are two reasons for not doing this.
  First, it moves edges, so that a straight line at a large angle to
  both horizontal and vertical will have noticable kinks where
  horizontal and vertical rasters are removed.  Second, although it
  is very fast, you get good results on sharp edges by applying
  a sharpening filter.

  For images with sharp edges, sharpening substantially improves the
  image quality for scale factors between about 0.2 and about 2.0.
  pixScale() uses a small amount of sharpening by default because
  it strengthens edge pixels that are weak due to anti-aliasing.
  The default sharpening factors are:
      * for scaling factors < 0.7:   sharpfract = 0.2    sharpwidth = 1
      * for scaling factors >= 0.7:  sharpfract = 0.4    sharpwidth = 2
  The cases where the sharpening halfwidth is 1 or 2 have special
  implementations and are about twice as fast as the general case.

  However, sharpening is computationally expensive, and one needs
  to consider the speed-quality tradeoff:
      * For upscaling of RGB images, linear interpolation plus default
        sharpening is about 5 times slower than upscaling alone.
      * For downscaling, area mapping plus default sharpening is
        about 10 times slower than downscaling alone.
  When the scale factor is larger than 1.4, the cost of sharpening,
  which is proportional to image area, is very large compared to the
  incremental quality improvement, so we cut off the default use of
  sharpening at 1.4.  Thus, for scale factors greater than 1.4,
  pixScale() only does linear interpolation.

  In many situations you will get a satisfactory result by scaling
  without sharpening: call pixScaleGeneral() with @sharpfract = 0.0.
  Alternatively, if you wish to sharpen but not use the default
  value, first call pixScaleGeneral() with @sharpfract = 0.0, and
  then sharpen explicitly using pixUnsharpMasking().

  Binary images are scaled to binary by sampling the closest pixel,
  without any low-pass filtering (averaging of neighboring pixels).
  This will introduce aliasing for reductions.  Aliasing can be
  prevented by using pixScaleToGray() instead.

  *** Warning: implicit assumption about RGB component order
               for LI color scaling


        """
        args = _convert_params(*args)
        
        return leptonica.pixScale(*args)
    
    

    try:
        leptonica.pixScaleAreaMap.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleAreaMap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleAreaMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAreaMap(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleAreaMap()

      Input:  pixs (2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap)
              scalex, scaley (must both be <= 0.7)
      Return: pixd, or null on error

  Notes:
      (1) This function should only be used when the scale factors are less
          than or equal to 0.7 (i.e., more than about 1.42x reduction).
          If either scale factor is larger than 0.7, we issue a warning
          and invoke pixScale().
      (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
          a colormap, it is removed by converting to RGB.  In other
          cases, we issue a warning and invoke pixScale().
      (3) It does a relatively expensive area mapping computation, to
          avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),
          but the results are much better on fine text.
      (4) This is typically about 20% faster for the special cases of
          2x, 4x, 8x and 16x reduction.
      (5) Surprisingly, there is no speedup (and a slight quality
          impairment) if you do as many successive 2x reductions as
          possible, ending with a reduction with a scale factor larger
          than 0.5.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAreaMap(*args)
    
    

    try:
        leptonica.pixScaleBinary.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleBinary(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleBinary()

      Input:  pixs (1 bpp)
              scalex, scaley (both > 0.0)
      Return: pixd, or null on error

  Notes:
      (1) This function samples from the source without
          filtering.  As a result, aliasing will occur for
          subsampling (scalex and scaley < 1.0).


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleBinary(*args)
    
    

    try:
        leptonica.pixScaleGeneral.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixScaleGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_float32', 'sharpfract')       
('l_int32', 'sharpwidth')       
  pixScaleGeneral()

      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)
              scalex, scaley (both > 0.0)
              sharpfract (use 0.0 to skip sharpening)
              sharpwidth (halfwidth of low-pass filter; typ. 1 or 2)
      Return: pixd, or null on error

  Notes:
      (1) See pixScale() for usage.
      (2) This interface may change in the future, as other special
          cases are added.
      (3) The actual sharpening factors used depend on the maximum
          of the two scale factors (maxscale):
            maxscale <= 0.2:        no sharpening
            0.2 < maxscale < 1.4:   uses the input parameters
            maxscale >= 1.4:        no sharpening
      (4) To avoid sharpening for grayscale and color images with
          scaling factors between 0.2 and 1.4, call this function
          with @sharpfract == 0.0.
      (5) To use arbitrary sharpening in conjunction with scaling,
          call this function with @sharpfract = 0.0, and follow this
          with a call to pixUnsharpMasking() with your chosen parameters.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGeneral(*args)
    
    

    try:
        leptonica.pixScaleRGBToGrayFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleRGBToGrayFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleRGBToGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleRGBToGrayFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'color')       
  pixScaleRGBToGrayFast()

      Input:  pixs (32 bpp rgb)
              factor (integer reduction factor >= 1)
              color (one of COLOR_RED, COLOR_GREEN, COLOR_BLUE)
      Return: pixd (8 bpp), or null on error

  Notes:
      (1) This does simultaneous subsampling by an integer factor and
          extraction of the color from the RGB pix.
      (2) It is designed for maximum speed, and is used for quickly
          generating a downsized grayscale image from a higher resolution
          RGB image.  This would typically be used for image analysis.
      (3) The standard color byte order (RGBA) is assumed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleRGBToGrayFast(*args)
    
    

    try:
        leptonica.pixScaleMipmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleMipmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleMipmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleMipmap(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_float32', 'scale')       
  pixScaleMipmap()

      Input:  pixs1 (high res 8 bpp, no cmap)
              pixs2 (low res -- 2x reduced -- 8 bpp, no cmap)
              scale (reduction with respect to high res image, > 0.5)
      Return: 8 bpp pix, scaled down by reduction in each direction,
              or NULL on error.

  Notes:
      (1) See notes in pixScaleToGrayMipmap().
      (2) This function suffers from aliasing effects that are
          easily seen in document images.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleMipmap(*args)
    
    

    try:
        leptonica.pixScaleGrayMinMax2.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGrayMinMax2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGrayMinMax2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayMinMax2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  pixScaleGrayMinMax2()

      Input:  pixs (8 bpp, not cmapped)
              type (L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAX_MIN_DIFF)
      Return: pixd (8 bpp downscaled by 2x)

  Notes:
      (1) Special version for 2x reduction.  The downscaled pixels
          in pixd are the min, max or (max - min) of the corresponding
          set of 4 pixels in pixs.
      (2) The max and min operations are a special case (for levels 1
          and 4) of grayscale analog to the binary rank scaling operation
          pixReduceRankBinary2().  Note, however, that because of
          the photometric definition that higher gray values are
          lighter, the erosion-like L_CHOOSE_MIN will darken
          the resulting image, corresponding to a threshold level 1
          in the binary case.  Likewise, L_CHOOSE_MAX will lighten
          the pixd, corresponding to a threshold level of 4.
      (3) To choose any of the four rank levels in a 2x grayscale
          reduction, use pixScaleGrayRank2().
      (4) This runs at about 70 MPix/sec/GHz of source data for
          erosion and dilation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayMinMax2(*args)
    
    

    try:
        leptonica.pixScaleToGrayFast.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleToGrayFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGrayFast(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalefactor')       
  pixScaleToGrayFast()

      Input:  pixs (1 bpp)
              scalefactor (reduction: must be > 0.0 and < 1.0)
      Return: pixd (8 bpp), scaled down by scalefactor in each direction,
              or NULL on error.

  Notes:
      (1) See notes in pixScaleToGray() for the basic approach.
      (2) This function is considerably less expensive than pixScaleToGray()
          for scalefactor in the range (0.0625 ... 0.5), and the
          quality is nearly as good.
      (3) Unlike pixScaleToGray(), which does binary upscaling before
          downscaling for scale factors >= 0.0625, pixScaleToGrayFast()
          first downscales in binary for all scale factors < 0.5, and
          then does a 2x scale-to-gray as the final step.  For
          scale factors < 0.0625, both do a 16x scale-to-gray, followed
          by further grayscale reduction.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGrayFast(*args)
    
    

    try:
        leptonica.pixScaleGray4xLIThresh.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGray4xLIThresh.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGray4xLIThresh not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray4xLIThresh(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
  pixScaleGray4xLIThresh()

      Input:  pixs (8 bpp)
              thresh  (between 0 and 256)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This does 4x upscale on pixs, using linear interpolation,
          followed by thresholding to binary.
      (2) Buffers are used to avoid making a large grayscale image.
      (3) If a full 4x expanded grayscale image can be kept in memory,
          this function is only about 10% faster than separately doing
          a linear interpolation to a large grayscale image, followed
          by thresholding to binary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray4xLIThresh(*args)
    
    

    try:
        leptonica.pixScaleRGBToBinaryFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleRGBToBinaryFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleRGBToBinaryFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleRGBToBinaryFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'thresh')       
  pixScaleRGBToBinaryFast()

      Input:  pixs (32 bpp RGB)
              factor (integer reduction factor >= 1)
              thresh (binarization threshold)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This does simultaneous subsampling by an integer factor and
          conversion from RGB to gray to binary.
      (2) It is designed for maximum speed, and is used for quickly
          generating a downsized binary image from a higher resolution
          RGB image.  This would typically be used for image analysis.
      (3) It uses the green channel to represent the RGB pixel intensity.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleRGBToBinaryFast(*args)
    
    

    try:
        leptonica.pixScaleColorLI.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleColorLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleColorLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleColorLI(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  pixScaleColorLI()

      Input:  pixs  (32 bpp, representing rgb)
              scalex, scaley (must both be >= 0.7)
      Return: pixd, or null on error

  Notes:
      (1) If this is used for scale factors less than 0.7,
          it will suffer from antialiasing.  A warning is issued.
          Particularly for document images with sharp edges,
          use pixScaleSmooth() or pixScaleAreaMap() instead.
      (2) For the general case, it's about 4x faster to manipulate
          the color pixels directly, rather than to make images
          out of each of the 3 components, scale each component
          using the pixScaleGrayLI(), and combine the results back
          into an rgb image.
      (3) The speed on intel hardware for the general case (not 2x)
          is about 10 * 10^6 dest-pixels/sec/GHz.  (The special 2x
          case runs at about 80 * 10^6 dest-pixels/sec/GHz.)


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleColorLI(*args)
    
    

    try:
        leptonica.pixScaleToGray8.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray8.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray8(*args):
        """
        ('PIX', '*pixs')       
  pixScaleToGray8()

      Input:  pixs (1 bpp)
      Return: pixd (8 bpp), scaled down by 8x in each direction,
              or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray8(*args)
    
    

    try:
        leptonica.pixScaleGray2xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray2xLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGray2xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray2xLI(*args):
        """
        ('PIX', '*pixs')       
  pixScaleGray2xLI()

      Input:  pixs (8 bpp grayscale, not cmapped)
      Return: pixd, or null on error

  Notes:
      (1) This is a special case of gray linear interpolated scaling,
          for 2x upscaling.  It is about 6x faster than using
          the generic pixScaleGrayLI().
      (2) The speed on intel hardware is about
          100 * 10^6 dest-pixels/sec/GHz


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray2xLI(*args)
    
    

    try:
        leptonica.pixScaleToGray4.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray4.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray4(*args):
        """
        ('PIX', '*pixs')       
  pixScaleToGray4()

      Input:  pixs (1 bpp)
      Return: pixd (8 bpp), scaled down by 4x in each direction,
              or null on error.

  Notes:
      (1) The width of pixd is truncated is truncated to a factor of 2.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray4(*args)
    
    

    try:
        leptonica.pixScaleToGray6.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray6.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray6 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray6(*args):
        """
        ('PIX', '*pixs')       
  pixScaleToGray6()

      Input:  pixs (1 bpp)
      Return: pixd (8 bpp), scaled down by 6x in each direction,
              or null on error.

  Notes:
      (1) The width of pixd is truncated is truncated to a factor of 8.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray6(*args)
    
    

    try:
        leptonica.pixScaleToGray2.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray2(*args):
        """
        ('PIX', '*pixs')       
  pixScaleToGray2()

      Input:  pixs (1 bpp)
      Return: pixd (8 bpp), scaled down by 2x in each direction,
              or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray2(*args)
    
    

    try:
        leptonica.pixScaleToGray3.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray3.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleToGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray3(*args):
        """
        ('PIX', '*pixs')       
  pixScaleToGray3()

      Input:  pixs (1 bpp)
      Return: pixd (8 bpp), scaled down by 3x in each direction,
              or null on error.

  Notes:
      (1) Speed is about 100 x 10^6 src-pixels/sec/GHz.
          Another way to express this is it processes 1 src pixel
          in about 10 cycles.
      (2) The width of pixd is truncated is truncated to a factor of 8.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray3(*args)
    
    

    try:
        leptonica.pixScaleAreaMap2.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleAreaMap2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleAreaMap2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAreaMap2(*args):
        """
        ('PIX', '*pix')       
  pixScaleAreaMap2()

      Input:  pixs (2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap)
      Return: pixd, or null on error

  Notes:
      (1) This function does an area mapping (average) for 2x
          reduction.
      (2) This works only on 2, 4, 8 and 32 bpp images.  If there is
          a colormap, it is removed by converting to RGB.
      (3) Speed on 3 GHz processor:
             Color: 160 Mpix/sec
             Gray: 700 Mpix/sec
          This contrasts with the speed of the general pixScaleAreaMap():
             Color: 35 Mpix/sec
             Gray: 50 Mpix/sec
      (4) From (3), we see that this special function is about 4.5x
          faster for color and 14x faster for grayscale
      (5) Consequently, pixScaleAreaMap2() is incorporated into the
          general area map scaling function, for the special cases
          of 2x, 4x, 8x and 16x reduction.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAreaMap2(*args)
    
    

    try:
        leptonica.pixScaleBySamplingToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleBySamplingToSize.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleBySamplingToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleBySamplingToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       
  pixScaleBySamplingToSize()

      Input:  pixs (1, 2, 4, 8, 16 and 32 bpp)
              wd  (target width; use 0 if using height as target)
              hd  (target height; use 0 if using width as target)
      Return: pixd, or null on error

  Notes:
      (1) This guarantees that the output scaled image has the
          dimension(s) you specify.
           - To specify the width with isotropic scaling, set @hd = 0.
           - To specify the height with isotropic scaling, set @wd = 0.
           - If both @wd and @hd are specified, the image is scaled
             (in general, anisotropically) to that size.
           - It is an error to set both @wd and @hd to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleBySamplingToSize(*args)
    
    

    try:
        leptonica.pixScaleGrayRank2.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGrayRank2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGrayRank2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayRank2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rank')       
  pixScaleGrayRank2()

      Input:  pixs (8 bpp, no cmap)
              rank (1 (darkest), 2, 3, 4 (lightest))
      Return: pixd (8 bpp, downscaled by 2x)

  Notes:
      (1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels
          in pixd are the min(max) of the corresponding set of
          4 pixels in pixs.  Values 2 and 3 are intermediate.
      (2) This is the grayscale analog to the binary rank scaling operation
          pixReduceRankBinary2().  Here, because of the photometric
          definition that higher gray values are lighter, rank 1 gives
          the darkest pixel, whereas rank 4 gives the lightest pixel.
          This is opposite to the binary rank operation.
      (3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),
          which runs at about 70 MPix/sec/GHz of source data.
          For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayRank2(*args)
    
    

    try:
        leptonica.pixScaleGrayMinMax.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleGrayMinMax.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGrayMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayMinMax(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xfact')       
('l_int32', 'yfact')       
('l_int32', 'type')       
  pixScaleGrayMinMax()

      Input:  pixs (8 bpp, not cmapped)
              xfact (x downscaling factor; integer)
              yfact (y downscaling factor; integer)
              type (L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAX_MIN_DIFF)
      Return: pixd (8 bpp)

  Notes:
      (1) The downscaled pixels in pixd are the min, max or (max - min)
          of the corresponding set of xfact * yfact pixels in pixs.
      (2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,
          using a brick Sel of size (xfact * yfact), followed by
          subsampling within each (xfact * yfact) cell.  Using
          L_CHOOSE_MAX is equivalent to the corresponding dilation.
      (3) Using L_CHOOSE_MAX_MIN_DIFF finds the difference between max
          and min values in each cell.
      (4) For the special case of downscaling by 2x in both directions,
          pixScaleGrayMinMax2() is about 2x more efficient.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayMinMax(*args)
    
    

    try:
        leptonica.pixScaleGray4xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray4xLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixScaleGray4xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray4xLI(*args):
        """
        ('PIX', '*pixs')       
  pixScaleGray4xLI()

      Input:  pixs (8 bpp grayscale, not cmapped)
      Return: pixd, or null on error

  Notes:
      (1) This is a special case of gray linear interpolated scaling,
          for 4x upscaling.  It is about 12x faster than using
          the generic pixScaleGrayLI().
      (2) The speed on intel hardware is about
          160 * 10^6 dest-pixels/sec/GHz.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray4xLI(*args)
    




class convolve(object):
    """  convolve.c

      Top level grayscale or color block convolution
          PIX       *pixBlockconv()

      Grayscale block convolution
          PIX       *pixBlockconvGray()

      Accumulator for 1, 8 and 32 bpp convolution
          PIX       *pixBlockconvAccum()

      Un-normalized grayscale block convolution
          PIX       *pixBlockconvGrayUnnormalized()

      Tiled grayscale or color block convolution
          PIX       *pixBlockconvTiled()
          PIX       *pixBlockconvGrayTile()

      Convolution for mean, mean square, variance and rms deviation
      in specified window
          l_int32    pixWindowedStats()
          PIX       *pixWindowedMean()
          PIX       *pixWindowedMeanSquare()
          l_int32    pixWindowedVariance()
          DPIX      *pixMeanSquareAccum()

      Binary block sum and rank filter
          PIX       *pixBlockrank()
          PIX       *pixBlocksum()

      Census transform
          PIX       *pixCensusTransform()

      Generic convolution (with Pix)
          PIX       *pixConvolve()
          PIX       *pixConvolveSep()
          PIX       *pixConvolveRGB()
          PIX       *pixConvolveRGBSep()

      Generic convolution (with float arrays)
          FPIX      *fpixConvolve()
          FPIX      *fpixConvolveSep()

      Convolution with bias (for non-negative output)
          PIX       *pixConvolveWithBias()

      Set parameter for convolution subsampling
          void       l_setConvolveSampling()

      Additive gaussian noise
          PIX       *pixAddGaussNoise()
          l_float32  gaussDistribSampling()

"""
    
    try:
        leptonica.pixCensusTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCensusTransform.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCensusTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCensusTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfsize')       
('PIX', '*pixacc')       
  pixCensusTransform()

      Input:  pixs (8 bpp)
              halfsize (of square over which neighbors are averaged)
              accum pix (<optional> 32 bpp)
      Return: pixd (1 bpp)

  Notes:
      (1) The Census transform was invented by Ramin Zabih and John Woodfill
          ("Non-parametric local transforms for computing visual
          correspondence", Third European Conference on Computer Vision,
          Stockholm, Sweden, May 1994); see publications at
             http://www.cs.cornell.edu/~rdz/index.htm
          This compares each pixel against the average of its neighbors,
          in a square of odd dimension centered on the pixel.
          If the pixel is greater than the average of its neighbors,
          the output pixel value is 1; otherwise it is 0.
      (2) This can be used as an encoding for an image that is
          fairly robust against slow illumination changes, with
          applications in image comparison and mosaicing.
      (3) The size of the convolution kernel is (2 * halfsize + 1)
          on a side.  The halfsize parameter must be >= 1.
      (4) If accum pix is null, make one, use it, and destroy it
          before returning; otherwise, just use the input accum pix


        """
        args = _convert_params(*args)
        
        return leptonica.pixCensusTransform(*args)
    
    

    try:
        leptonica.pixBlockconvAccum.argtypes = [ctypes.c_void_p]
        leptonica.pixBlockconvAccum.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockconvAccum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvAccum(*args):
        """
        ('PIX', '*pixs')       
  pixBlockconvAccum()

      Input:  pixs (1, 8 or 32 bpp)
      Return: accum pix (32 bpp), or null on error.

  Notes:
      (1) The general recursion relation is
            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
          For the first line, this reduces to the special case
            a(i,j) = v(i,j) + a(i, j-1)
          For the first column, the special case is
            a(i,j) = v(i,j) + a(i-1, j)


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvAccum(*args)
    
    

    try:
        leptonica.l_setConvolveSampling.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setConvolveSampling.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setConvolveSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setConvolveSampling(*args):
        """
        ('l_int32', 'xfact')       
('l_int32', 'yfact')       
  l_setConvolveSampling()


      Input:  xfact, yfact (integer >= 1)
      Return: void

  Notes:
      (1) This sets the x and y output subsampling factors for generic pix
          and fpix convolution.  The default values are 1 (no subsampling).


        """
        args = _convert_params(*args)
        
        return leptonica.l_setConvolveSampling(*args)
    
    

    try:
        leptonica.pixBlockconvGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockconvGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       
  pixBlockconvGray()

      Input:  pix (8 bpp)
              accum pix (32 bpp; can be null)
              wc, hc   (half width/height of convolution kernel)
      Return: pix (8 bpp), or null on error

  Notes:
      (1) If accum pix is null, make one and destroy it before
          returning; otherwise, just use the input accum pix.
      (2) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1).
      (3) Returns a copy if both wc and hc are 0.
      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
          where (w,h) are the dimensions of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvGray(*args)
    
    

    try:
        leptonica.pixWindowedVariance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWindowedVariance.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWindowedVariance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedVariance(*args):
        """
        ('PIX', '*pixm')       
('PIX', '*pixms')       
('FPIX', '**pfpixv')       
('FPIX', '**pfpixrv')       
  pixWindowedVariance()

      Input:  pixm (mean over window; 8 or 32 bpp grayscale)
              pixms (mean square over window; 32 bpp)
              &fpixv (<optional return> float variance -- the ms deviation
                      from the mean)
              &fpixrv (<optional return> float rms deviation from the mean)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The mean and mean square values are precomputed, using
          pixWindowedMean() and pixWindowedMeanSquare().
      (2) Either or both of the variance and square-root of variance
          are returned as an fpix, where the variance is the
          average over the window of the mean square difference of
          the pixel value from the mean:
                <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>
      (3) To visualize the results:
            - for both, use fpixDisplayMaxDynamicRange().
            - for rms deviation, simply convert the output fpix to pix,


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedVariance(*args)
    
    

    try:
        leptonica.gaussDistribSampling.argtypes = []
        leptonica.gaussDistribSampling.restype = ctypes.c_float
    except AttributeError:
        os.stderr.write("Warning - function gaussDistribSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gaussDistribSampling(*args):
        """
               
  gaussDistribSampling()

      Return: gaussian distributed variable with zero mean and unit stdev

  Notes:
      (1) For an explanation of the Box-Muller method for generating
          a normally distributed random variable with zero mean and
          unit standard deviation, see Numerical Recipes in C,
          2nd edition, p. 288ff.
      (2) This can be called sequentially to get samples that can be
          used for adding noise to each pixel of an image, for example.


        """
        args = _convert_params(*args)
        
        return leptonica.gaussDistribSampling(*args)
    
    

    try:
        leptonica.pixBlockconvTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvTiled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockconvTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvTiled(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'nx')       
('l_int32', 'ny')       
  pixBlockconvTiled()

      Input:  pix (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)
              wc, hc   (half width/height of convolution kernel)
              nx, ny  (subdivision into tiles)
      Return: pixd, or null on error

  Notes:
      (1) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1)
      (2) Returns a copy if both wc and hc are 0
      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
          where (w,h) are the dimensions of pixs.
      (4) For nx == ny == 1, this defaults to pixBlockconv(), which
          is typically about twice as fast, and gives nearly
          identical results as pixBlockconvGrayTile().
      (5) If the tiles are too small, nx and/or ny are reduced
          a minimum amount so that the tiles are expanded to the
          smallest workable size in the problematic direction(s).
      (6) Why a tiled version?  Three reasons:
          (a) Because the accumulator is a uint32, overflow can occur
              for an image with more than 16M pixels.
          (b) The accumulator array for 16M pixels is 64 MB; using
              tiles reduces the size of this array.
          (c) Each tile can be processed independently, in parallel,
              on a multicore processor.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvTiled(*args)
    
    

    try:
        leptonica.pixBlocksum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlocksum.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlocksum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlocksum(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       
  pixBlocksum()

      Input:  pixs (1 bpp)
              accum pix (<optional> 32 bpp)
              wc, hc   (half width/height of block sum/rank kernel)
      Return: pixd (8 bpp)

  Notes:
      (1) If accum pix is null, make one and destroy it before
          returning; otherwise, just use the input accum pix
      (2) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1)
      (3) Use of wc = hc = 1, followed by pixInvert() on the
          8 bpp result, gives a nice anti-aliased, and somewhat
          darkened, result on text.
      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
          where (w,h) are the dimensions of pixs.
      (5) Returns in each dest pixel the sum of all src pixels
          that are within a block of size of the kernel, centered
          on the dest pixel.  This sum is the number of src ON
          pixels in the block at each location, normalized to 255
          for a block containing all ON pixels.  For pixels near
          the boundary, where the block is not entirely contained
          within the image, we then multiply by a second normalization
          factor that is greater than one, so that all results
          are normalized by the number of participating pixels
          within the block.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlocksum(*args)
    
    

    try:
        leptonica.pixConvolveRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvolveRGB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvolveRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveRGB(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel')       
  pixConvolveRGB()

      Input:  pixs (32 bpp rgb)
              kernel
      Return: pixd (32 bpp rgb)

  Notes:
      (1) This gives a convolution on an RGB image using an
          arbitrary kernel (which we normalize to keep each
          component within the range [0 ... 255].
      (2) The input pixs must be RGB.
      (3) The kernel values can be positive or negative, but the
          result for the convolution can only be stored as a positive
          number.  Consequently, if it goes negative, we clip the
          result to 0.
      (4) To get a subsampled output, call l_setConvolveSampling().
          The time to make a subsampled output is reduced by the
          product of the sampling factors.
      (5) This uses a mirrored border to avoid special casing on
          the boundaries.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveRGB(*args)
    
    

    try:
        leptonica.pixWindowedMean.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWindowedMean.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixWindowedMean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedMean(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'hasborder')       
('l_int32', 'normflag')       
  pixWindowedMean()

      Input:  pixs (8 or 32 bpp grayscale)
              wc, hc   (half width/height of convolution kernel)
              hasborder (use 1 if it already has (wc + 1) border pixels
                         on left and right, and (hc + 1) on top and bottom;
                         use 0 to add kernel-dependent border)
              normflag (1 for normalization to get average in window;
                        0 for the sum in the window (un-normalized))
      Return: pixd (8 or 32 bpp, average over kernel window)

  Notes:
      (1) The input and output depths are the same.
      (2) A set of border pixels of width (wc + 1) on left and right,
          and of height (hc + 1) on top and bottom, must be on the
          pix before the accumulator is found.  The output pixd
          (after convolution) has this border removed.
          If @hasborder = 0, the required border is added.
      (3) Typically, @normflag == 1.  However, if you want the sum
          within the window, rather than a normalized convolution,
          use @normflag == 0.
      (4) This builds a block accumulator pix, uses it here, and
          destroys it.
      (5) The added border, along with the use of an accumulator array,
          allows computation without special treatment of pixels near
          the image boundary, and runs in a time that is independent
          of the size of the convolution kernel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedMean(*args)
    
    

    try:
        leptonica.pixBlockconv.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconv.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockconv not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconv(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'wc')       
('l_int32', 'hc')       
  pixBlockconv()

      Input:  pix (8 or 32 bpp; or 2, 4 or 8 bpp with colormap)
              wc, hc   (half width/height of convolution kernel)
      Return: pixd, or null on error

  Notes:
      (1) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1)
      (2) Returns a copy if both wc and hc are 0
      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
          where (w,h) are the dimensions of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconv(*args)
    
    

    try:
        leptonica.pixAddGaussianNoise.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixAddGaussianNoise.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddGaussianNoise not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddGaussianNoise(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'stdev')       
  pixAddGaussianNoise()

      Input:  pixs (8 bpp gray or 32 bpp rgb; no colormap)
              stdev (of noise)
      Return: pixd (8 or 32 bpp), or null on error

  Notes:
      (1) This adds noise to each pixel, taken from a normal
          distribution with zero mean and specified standard deviation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddGaussianNoise(*args)
    
    

    try:
        leptonica.pixConvolveRGBSep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvolveRGBSep.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvolveRGBSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveRGBSep(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kelx')       
('L_KERNEL', '*kely')       
  pixConvolveRGBSep()

      Input:  pixs (32 bpp rgb)
              kelx (x-dependent kernel)
              kely (y-dependent kernel)
      Return: pixd (32 bpp rgb)

  Notes:
      (1) This does a convolution on an RGB image using a separable
          kernel that is a sequence of convolutions in x and y.  The two
          one-dimensional kernel components must be input separately;
          the full kernel is the product of these components.
          The support for the full kernel is thus a rectangular region.
      (2) The kernel values can be positive or negative, but the
          result for the convolution can only be stored as a positive
          number.  Consequently, if it goes negative, we clip the
          result to 0.
      (3) To get a subsampled output, call l_setConvolveSampling().
          The time to make a subsampled output is reduced by the
          product of the sampling factors.
      (4) This uses a mirrored border to avoid special casing on
          the boundaries.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveRGBSep(*args)
    
    

    try:
        leptonica.pixConvolveWithBias.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixConvolveWithBias.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvolveWithBias not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveWithBias(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel1')       
('L_KERNEL', '*kel2')       
('l_int32', 'force8')       
('l_int32', '*pbias')       
  pixConvolveWithBias()

      Input:  pixs (8 bpp; no colormap)
              kel1
              kel2  (can be null; use if separable)
              force8 (if 1, force output to 8 bpp; otherwise, determine
                      output depth by the dynamic range of pixel values)
              &bias (<return> applied bias)
      Return: pixd (8 or 16 bpp)

  Notes:
      (1) This does a convolution with either a single kernel or
          a pair of separable kernels, and automatically applies whatever
          bias (shift) is required so that the resulting pixel values
          are non-negative.
      (2) The kernel is always normalized.  If there are no negative
          values in the kernel, a standard normalized convolution is
          performed, with 8 bpp output.  If the sum of kernel values is
          very close to zero, the kernel can not be normalized and
          the convolution will not be performed.  An error message results.
      (3) If there are negative values in the kernel, the pix is
          converted to an fpix, the convolution is done on the fpix, and
          a bias (shift) may need to be applied.
      (4) If force8 == TRUE and the range of values after the convolution
          is > 255, the output values will be scaled to fit in [0 ... 255].
          If force8 == FALSE, the output will be either 8 or 16 bpp,
          to accommodate the dynamic range of output values without scaling.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveWithBias(*args)
    
    

    try:
        leptonica.pixConvolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvolve.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvolve not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolve(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel')       
('l_int32', 'outdepth')       
('l_int32', 'normflag')       
  pixConvolve()

      Input:  pixs (8, 16, 32 bpp; no colormap)
              kernel
              outdepth (of pixd: 8, 16 or 32)
              normflag (1 to normalize kernel to unit sum; 0 otherwise)
      Return: pixd (8, 16 or 32 bpp)

  Notes:
      (1) This gives a convolution with an arbitrary kernel.
      (2) The input pixs must have only one sample/pixel.
          To do a convolution on an RGB image, use pixConvolveRGB().
      (3) The parameter @outdepth determines the depth of the result.
          If the kernel is normalized to unit sum, the output values
          can never exceed 255, so an output depth of 8 bpp is sufficient.
          If the kernel is not normalized, it may be necessary to use
          16 or 32 bpp output to avoid overflow.
      (4) If normflag == 1, the result is normalized by scaling all
          kernel values for a unit sum.  If the sum of kernel values
          is very close to zero, the kernel can not be normalized and
          the convolution will not be performed.  A warning is issued.
      (5) The kernel values can be positive or negative, but the
          result for the convolution can only be stored as a positive
          number.  Consequently, if it goes negative, the choices are
          to clip to 0 or take the absolute value.  We're choosing
          to take the absolute value.  (Another possibility would be
          to output a second unsigned image for the negative values.)
          If you want to get a clipped result, or to keep the negative
          values in the result, use fpixConvolve(), with the
          converters in fpix2.c between pix and fpix.
      (6) This uses a mirrored border to avoid special casing on
          the boundaries.
      (7) To get a subsampled output, call l_setConvolveSampling().
          The time to make a subsampled output is reduced by the
          product of the sampling factors.
      (8) The function is slow, running at about 12 machine cycles for
          each pixel-op in the convolution.  For example, with a 3 GHz
          cpu, a 1 Mpixel grayscale image, and a kernel with
          (sx * sy) = 25 elements, the convolution takes about 100 msec.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolve(*args)
    
    

    try:
        leptonica.pixBlockconvGrayUnnormalized.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvGrayUnnormalized.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockconvGrayUnnormalized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvGrayUnnormalized(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
  pixBlockconvGrayUnnormalized()

      Input:  pixs (8 bpp)
              wc, hc   (half width/height of convolution kernel)
      Return: pix (32 bpp; containing the convolution without normalizing
                   for the window size), or null on error

  Notes:
      (1) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1).
      (2) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
          where (w,h) are the dimensions of pixs.
      (3) Returns a copy if both wc and hc are 0.
      (3) Adds mirrored border to avoid treating the boundary pixels
          specially.  Note that we add wc + 1 pixels to the left
          and wc to the right.  The added width is 2 * wc + 1 pixels,
          and the particular choice simplifies the indexing in the loop.
          Likewise, add hc + 1 pixels to the top and hc to the bottom.
      (4) To get the normalized result, divide by the area of the
          convolution kernel: (2 * wc + 1) * (2 * hc + 1)
          Specifically, do this:
               pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);
               fract = 1. / ((2 * wc + 1) * (2 * hc + 1));
               pixMultConstantGray(pixc, fract);
               pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);
      (5) Unlike pixBlockconvGray(), this always computes the accumulation
          pix because its size is tied to wc and hc.
      (6) Compare this implementation with pixBlockconvGray(), where
          most of the code in blockconvLow() is special casing for
          efficiently handling the boundary.  Here, the use of
          mirrored borders and destination indexing makes the
          implementation very simple.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvGrayUnnormalized(*args)
    
    

    try:
        leptonica.pixMeanSquareAccum.argtypes = [ctypes.c_void_p]
        leptonica.pixMeanSquareAccum.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMeanSquareAccum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeanSquareAccum(*args):
        """
        ('PIX', '*pixs')       
  pixMeanSquareAccum()

      Input:  pixs (8 bpp grayscale)
      Return: dpix (64 bit array), or null on error

  Notes:
      (1) Similar to pixBlockconvAccum(), this computes the
          sum of the squares of the pixel values in such a way
          that the value at (i,j) is the sum of all squares in
          the rectangle from the origin to (i,j).
      (2) The general recursion relation (v are squared pixel values) is
            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
          For the first line, this reduces to the special case
            a(i,j) = v(i,j) + a(i, j-1)
          For the first column, the special case is
            a(i,j) = v(i,j) + a(i-1, j)


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeanSquareAccum(*args)
    
    

    try:
        leptonica.pixBlockrank.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixBlockrank.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockrank not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockrank(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_float32', 'rank')       
  pixBlockrank()

      Input:  pixs (1 bpp)
              accum pix (<optional> 32 bpp)
              wc, hc   (half width/height of block sum/rank kernel)
              rank   (between 0.0 and 1.0; 0.5 is median filter)
      Return: pixd (1 bpp)

  Notes:
      (1) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1)
      (2) This returns a pixd where each pixel is a 1 if the
          neighborhood (2 * wc + 1) x (2 * hc + 1)) pixels
          contains the rank fraction of 1 pixels.  Otherwise,
          the returned pixel is 0.  Note that the special case
          of rank = 0.0 is always satisfied, so the returned
          pixd has all pixels with value 1.
      (3) If accum pix is null, make one, use it, and destroy it
          before returning; otherwise, just use the input accum pix
      (4) If both wc and hc are 0, returns a copy unless rank == 0.0,
          in which case this returns an all-ones image.
      (5) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
          where (w,h) are the dimensions of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockrank(*args)
    
    

    try:
        leptonica.fpixConvolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixConvolve.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixConvolve not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvolve(*args):
        """
        ('FPIX', '*fpixs')       
('L_KERNEL', '*kel')       
('l_int32', 'normflag')       
  fpixConvolve()

      Input:  fpixs (32 bit float array)
              kernel
              normflag (1 to normalize kernel to unit sum; 0 otherwise)
      Return: fpixd (32 bit float array)

  Notes:
      (1) This gives a float convolution with an arbitrary kernel.
      (2) If normflag == 1, the result is normalized by scaling all
          kernel values for a unit sum.  If the sum of kernel values
          is very close to zero, the kernel can not be normalized and
          the convolution will not be performed.  A warning is issued.
      (3) With the FPix, there are no issues about negative
          array or kernel values.  The convolution is performed
          with single precision arithmetic.
      (4) To get a subsampled output, call l_setConvolveSampling().
          The time to make a subsampled output is reduced by the
          product of the sampling factors.
      (5) This uses a mirrored border to avoid special casing on
          the boundaries.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvolve(*args)
    
    

    try:
        leptonica.fpixConvolveSep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixConvolveSep.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixConvolveSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvolveSep(*args):
        """
        ('FPIX', '*fpixs')       
('L_KERNEL', '*kelx')       
('L_KERNEL', '*kely')       
('l_int32', 'normflag')       
  fpixConvolveSep()

      Input:  fpixs (32 bit float array)
              kelx (x-dependent kernel)
              kely (y-dependent kernel)
              normflag (1 to normalize kernel to unit sum; 0 otherwise)
      Return: fpixd (32 bit float array)

  Notes:
      (1) This does a convolution with a separable kernel that is
          is a sequence of convolutions in x and y.  The two
          one-dimensional kernel components must be input separately;
          the full kernel is the product of these components.
          The support for the full kernel is thus a rectangular region.
      (2) The normflag parameter is used as in fpixConvolve().
      (3) Warning: if you use l_setConvolveSampling() to get a
          subsampled output, and the sampling factor is larger than
          the kernel half-width, it is faster to use the non-separable
          version pixConvolve().  This is because the first convolution
          here must be done on every raster line, regardless of the
          vertical sampling factor.  If the sampling factor is smaller
          than kernel half-width, it's faster to use the separable
          convolution.
      (4) This uses mirrored borders to avoid special casing on
          the boundaries.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvolveSep(*args)
    
    

    try:
        leptonica.pixWindowedStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWindowedStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWindowedStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'hasborder')       
('PIX', '**ppixm')       
('PIX', '**ppixms')       
('FPIX', '**pfpixv')       
('FPIX', '**pfpixrv')       
  pixWindowedStats()

      Input:  pixs (8 bpp grayscale)
              wc, hc   (half width/height of convolution kernel)
              hasborder (use 1 if it already has (wc + 1) border pixels
                         on left and right, and (hc + 1) on top and bottom;
                         use 0 to add kernel-dependent border)
              &pixm (<optional return> 8 bpp mean value in window)
              &pixms (<optional return> 32 bpp mean square value in window)
              &fpixv (<optional return> float variance in window)
              &fpixrv (<optional return> float rms deviation from the mean)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a high-level convenience function for calculating
          any or all of these derived images.
      (2) If @hasborder = 0, a border is added and the result is
          computed over all pixels in pixs.  Otherwise, no border is
          added and the border pixels are removed from the output images.
      (3) These statistical measures over the pixels in the
          rectangular window are:
            - average value: <p>  (pixm)
            - average squared value: <p*p> (pixms)
            - variance: <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>  (pixv)
            - square-root of variance: (pixrv)
          where the brackets < .. > indicate that the average value is
          to be taken over the window.
      (4) Note that the variance is just the mean square difference from
          the mean value; and the square root of the variance is the
          root mean square difference from the mean, sometimes also
          called the 'standard deviation'.
      (5) The added border, along with the use of an accumulator array,
          allows computation without special treatment of pixels near
          the image boundary, and runs in a time that is independent
          of the size of the convolution kernel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedStats(*args)
    
    

    try:
        leptonica.pixConvolveSep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvolveSep.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvolveSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveSep(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kelx')       
('L_KERNEL', '*kely')       
('l_int32', 'outdepth')       
('l_int32', 'normflag')       
  pixConvolveSep()

      Input:  pixs (8, 16, 32 bpp; no colormap)
              kelx (x-dependent kernel)
              kely (y-dependent kernel)
              outdepth (of pixd: 8, 16 or 32)
              normflag (1 to normalize kernel to unit sum; 0 otherwise)
      Return: pixd (8, 16 or 32 bpp)

  Notes:
      (1) This does a convolution with a separable kernel that is
          is a sequence of convolutions in x and y.  The two
          one-dimensional kernel components must be input separately;
          the full kernel is the product of these components.
          The support for the full kernel is thus a rectangular region.
      (2) The input pixs must have only one sample/pixel.
          To do a convolution on an RGB image, use pixConvolveSepRGB().
      (3) The parameter @outdepth determines the depth of the result.
          If the kernel is normalized to unit sum, the output values
          can never exceed 255, so an output depth of 8 bpp is sufficient.
          If the kernel is not normalized, it may be necessary to use
          16 or 32 bpp output to avoid overflow.
      (2) The @normflag parameter is used as in pixConvolve().
      (4) The kernel values can be positive or negative, but the
          result for the convolution can only be stored as a positive
          number.  Consequently, if it goes negative, the choices are
          to clip to 0 or take the absolute value.  We're choosing
          the former for now.  Another possibility would be to output
          a second unsigned image for the negative values.
      (5) Warning: if you use l_setConvolveSampling() to get a
          subsampled output, and the sampling factor is larger than
          the kernel half-width, it is faster to use the non-separable
          version pixConvolve().  This is because the first convolution
          here must be done on every raster line, regardless of the
          vertical sampling factor.  If the sampling factor is smaller
          than kernel half-width, it's faster to use the separable
          convolution.
      (6) This uses mirrored borders to avoid special casing on
          the boundaries.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveSep(*args)
    
    

    try:
        leptonica.pixBlockconvGrayTile.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvGrayTile.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlockconvGrayTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvGrayTile(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       
  pixBlockconvGrayTile()

      Input:  pixs (8 bpp gray)
              pixacc (32 bpp accum pix)
              wc, hc   (half width/height of convolution kernel)
      Return: pixd, or null on error

  Notes:
      (1) The full width and height of the convolution kernel
          are (2 * wc + 1) and (2 * hc + 1)
      (2) Assumes that the input pixs is padded with (wc + 1) pixels on
          left and right, and with (hc + 1) pixels on top and bottom.
          The returned pix has these stripped off; they are only used
          for computation.
      (3) Returns a copy if both wc and hc are 0
      (4) Require that w > 2 * wc + 1 and h > 2 * hc + 1,
          where (w,h) are the dimensions of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvGrayTile(*args)
    
    

    try:
        leptonica.pixWindowedMeanSquare.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWindowedMeanSquare.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixWindowedMeanSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedMeanSquare(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'hasborder')       
  pixWindowedMeanSquare()

      Input:  pixs (8 bpp grayscale)
              wc, hc   (half width/height of convolution kernel)
              hasborder (use 1 if it already has (wc + 1) border pixels
                         on left and right, and (hc + 1) on top and bottom;
                         use 0 to add kernel-dependent border)
      Return: pixd (32 bpp, average over rectangular window of
                    width = 2 * wc + 1 and height = 2 * hc + 1)

  Notes:
      (1) A set of border pixels of width (wc + 1) on left and right,
          and of height (hc + 1) on top and bottom, must be on the
          pix before the accumulator is found.  The output pixd
          (after convolution) has this border removed.
          If @hasborder = 0, the required border is added.
      (2) The advantage is that we are unaffected by the boundary, and
          it is not necessary to treat pixels within @wc and @hc of the
          border differently.  This is because processing for pixd
          only takes place for pixels in pixs for which the
          kernel is entirely contained in pixs.
      (3) Why do we have an added border of width (@wc + 1) and
          height (@hc + 1), when we only need @wc and @hc pixels
          to satisfy this condition?  Answer: the accumulators
          are asymmetric, requiring an extra row and column of
          pixels at top and left to work accurately.
      (4) The added border, along with the use of an accumulator array,
          allows computation without special treatment of pixels near
          the image boundary, and runs in a time that is independent
          of the size of the convolution kernel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedMeanSquare(*args)
    




class grayquant(object):
    """  grayquant.c

      Thresholding from 8 bpp to 1 bpp

          Floyd-Steinberg dithering to binary
              PIX    *pixDitherToBinary()
              PIX    *pixDitherToBinarySpec()

          Simple (pixelwise) binarization with fixed threshold
              PIX    *pixThresholdToBinary()

          Binarization with variable threshold
              PIX    *pixVarThresholdToBinary()

          Binarization by adaptive mapping
              PIX    *pixAdaptThresholdToBinary()
              PIX    *pixAdaptThresholdToBinaryGen()

          Slower implementation of Floyd-Steinberg dithering, using LUTs
              PIX    *pixDitherToBinaryLUT()

          Generate a binary mask from pixels of particular values
              PIX    *pixGenerateMaskByValue()
              PIX    *pixGenerateMaskByBand()

      Thresholding from 8 bpp to 2 bpp

          Dithering to 2 bpp
              PIX      *pixDitherTo2bpp()
              PIX      *pixDitherTo2bppSpec()

          Simple (pixelwise) thresholding to 2 bpp with optional cmap
              PIX      *pixThresholdTo2bpp()

      Simple (pixelwise) thresholding from 8 bpp to 4 bpp
              PIX      *pixThresholdTo4bpp()

      Simple (pixelwise) quantization on 8 bpp grayscale
              PIX      *pixThresholdOn8bpp()

      Arbitrary (pixelwise) thresholding from 8 bpp to 2, 4 or 8 bpp
              PIX      *pixThresholdGrayArb()

      Quantization tables for linear thresholds of grayscale images
              l_int32  *makeGrayQuantIndexTable()
              l_int32  *makeGrayQuantTargetTable()

      Quantization table for arbitrary thresholding of grayscale images
              l_int32   makeGrayQuantTableArb()
              l_int32   makeGrayQuantColormapArb()

      Thresholding from 32 bpp rgb to 1 bpp
      (really color quantization, but it's better placed in this file)
              PIX      *pixGenerateMaskByBand32()
              PIX      *pixGenerateMaskByDiscr32()

      Histogram-based grayscale quantization
              PIX      *pixGrayQuantFromHisto()
       static l_int32   numaFillCmapFromHisto()

      Color quantize grayscale image using existing colormap
              PIX      *pixGrayQuantFromCmap()

"""
    
    try:
        leptonica.pixGrayQuantFromCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGrayQuantFromCmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGrayQuantFromCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGrayQuantFromCmap(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       
  pixGrayQuantFromCmap()

      Input:  pixs (8 bpp grayscale without cmap)
              cmap (to quantize to; of dest pix)
              mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp)
      Return: pixd (2, 4 or 8 bpp, colormapped), or null on error

  Notes:
      (1) In use, pixs is an 8 bpp grayscale image without a colormap.
          If there is an existing colormap, a warning is issued and
          a copy of the input pixs is returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGrayQuantFromCmap(*args)
    
    

    try:
        leptonica.makeGrayQuantTargetTable.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.makeGrayQuantTargetTable.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function makeGrayQuantTargetTable not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGrayQuantTargetTable(*args):
        """
        ('l_int32', 'nlevels')       
('l_int32', 'depth')       
  makeGrayQuantTargetTable()

      Input:  nlevels (number of output levels)
              depth (of dest pix, in bpp; 2, 4 or 8 bpp)
      Return: table (maps input gray level to thresholded gray level,
                     or null on error)

  Notes:
      (1) nlevels is some number between 2 and 2^(depth)
      (2) The table is used in two similar ways:
           - for 8 bpp, it quantizes to a given number of target levels
           - for 2 and 4 bpp, it thresholds to appropriate target values
             that will use the full dynamic range of the dest pix.
      (3) For depth = 8, the number of thresholds chosen is
          ('nlevels' - 1), and the 'nlevels' values stored in the
          table are at the two at the extreme ends, (0, 255), plus
          plus ('nlevels' - 2) values chosen at equal intervals between.
          For example, for depth = 8 and 'nlevels' = 3, the two
          threshold values are 3f and bf, and the three target pixel
          values are 0, 7f and ff.
      (4) For depth < 8, we ignore nlevels, and always use the maximum
          number of levels, which is 2^(depth).
          If you want nlevels < the maximum number, you should always
          use a colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.makeGrayQuantTargetTable(*args)
    
    

    try:
        leptonica.pixDitherToBinary.argtypes = [ctypes.c_void_p]
        leptonica.pixDitherToBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDitherToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherToBinary(*args):
        """
        ('PIX', '*pixs')       
  pixDitherToBinary()

      Input:  pixs
      Return: pixd (dithered binary), or null on error

  The Floyd-Steinberg error diffusion dithering algorithm
  binarizes an 8 bpp grayscale image to a threshold of 128.
  If a pixel has a value above 127, it is binarized to white
  and the excess (below 255) is subtracted from three
  neighboring pixels in the fractions 3/8 to (i, j+1),
  3/8 to (i+1, j) and 1/4 to (i+1,j+1), truncating to 0
  if necessary.  Likewise, if it the pixel has a value
  below 128, it is binarized to black and the excess above 0
  is added to the neighboring pixels, truncating to 255 if necessary.

  This function differs from straight dithering in that it allows
  clipping of grayscale to 0 or 255 if the values are
  sufficiently close, without distribution of the excess.
  This uses default values to specify the range of lower
  and upper values (near 0 and 255, rsp) that are clipped
  to black and white without propagating the excess.
  Not propagating the excess has the effect of reducing the
  snake patterns in parts of the image that are nearly black or white;
  however, it also prevents the attempt to reproduce gray for those values.

  The implementation is straightforward.  It uses a pair of
  line buffers to avoid changing pixs.  It is about 2x faster
  than the implementation using LUTs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherToBinary(*args)
    
    

    try:
        leptonica.pixGenerateMaskByValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGenerateMaskByValue.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateMaskByValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'val')       
('l_int32', 'usecmap')       
  pixGenerateMaskByValue()

      Input:  pixs (2, 4 or 8 bpp, or colormapped)
              val (of pixels for which we set 1 in dest)
              usecmap (1 to retain cmap values; 0 to convert to gray)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) @val is the pixel value that we are selecting.  It can be
          either a gray value or a colormap index.
      (2) If pixs is colormapped, @usecmap determines if the colormap
          index values are used, or if the colormap is removed to gray and
          the gray values are used.  For the latter, it generates
          an approximate grayscale value for each pixel, and then looks
          for gray pixels with the value @val.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByValue(*args)
    
    

    try:
        leptonica.pixAdaptThresholdToBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixAdaptThresholdToBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAdaptThresholdToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAdaptThresholdToBinary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'gamma')       
  pixAdaptThresholdToBinary()

      Input:  pixs (8 bpp)
              pixm (<optional> 1 bpp image mask; can be null)
              gamma (gamma correction; must be > 0.0; typically ~1.0)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This is a simple convenience function for doing adaptive
          thresholding on a grayscale image with variable background.
          It uses default parameters appropriate for typical text images.
      (2) @pixm is a 1 bpp mask over "image" regions, which are not
          expected to have a white background.  The mask inhibits
          background finding under the fg pixels of the mask.  For
          images with both text and image, the image regions would
          be binarized (or quantized) by a different set of operations.
      (3) As @gamma is increased, the foreground pixels are reduced.
      (4) Under the covers:  The default background value for normalization
          is 200, so we choose 170 for 'maxval' in pixGammaTRC.  Likewise,
          the default foreground threshold for normalization is 60,
          so we choose 50 for 'minval' in pixGammaTRC.  Because
          170 was mapped to 255, choosing 200 for the threshold is
          quite safe for avoiding speckle noise from the background.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAdaptThresholdToBinary(*args)
    
    

    try:
        leptonica.pixThresholdGrayArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdGrayArb.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdGrayArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdGrayArb(*args):
        """
        ('PIX', '*pixs')       
('const char', '*edgevals')       
('l_int32', 'outdepth')       
('l_int32', 'use_average')       
('l_int32', 'setblack')       
('l_int32', 'setwhite')       
  pixThresholdGrayArb()

      Input:  pixs (8 bpp grayscale; can have colormap)
              edgevals (string giving edge value of each bin)
              outdepth (0, 2, 4 or 8 bpp; 0 is default for min depth)
              use_average (1 if use the average pixel value in colormap)
              setblack (1 if darkest color is set to black)
              setwhite (1 if lightest color is set to white)
      Return: pixd (2, 4 or 8 bpp quantized image with colormap),
                    or null on error

  Notes:
      (1) This function allows exact specification of the quantization bins.
          The string @edgevals is a space-separated set of values
          specifying the dividing points between output quantization bins.
          These threshold values are assigned to the bin with higher
          values, so that each of them is the smallest value in their bin.
      (2) The output image (pixd) depth is specified by @outdepth.  The
          number of bins is the number of edgevals + 1.  The
          relation between outdepth and the number of bins is:
               outdepth = 2       nbins <= 4
               outdepth = 4       nbins <= 16
               outdepth = 8       nbins <= 256
          With @outdepth == 0, the minimum required depth for the
          given number of bins is used.
          The output pixd has a colormap.
      (3) The last 3 args determine the specific values that go into
          the colormap.
      (4) For @use_average:
            - if TRUE, the average value of pixels falling in the bin is
              chosen as the representative gray value.  Otherwise,
            - if FALSE, the central value of each bin is chosen as
              the representative value.
          The colormap holds the representative value.
      (5) For @setblack, if TRUE the darkest color is set to (0,0,0).
      (6) For @setwhite, if TRUE the lightest color is set to (255,255,255).
      (7) An alternative to using this function to quantize to
          unequally-spaced bins is to first transform the 8 bpp pixs
          using pixGammaTRC(), and follow this with pixThresholdTo4bpp().


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdGrayArb(*args)
    
    

    try:
        leptonica.pixThresholdToBinary.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixThresholdToBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdToBinary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
  pixThresholdToBinary()

      Input:  pixs (4 or 8 bpp)
              threshold value
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) If the source pixel is less than the threshold value,
          the dest will be 1; otherwise, it will be 0


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdToBinary(*args)
    
    

    try:
        leptonica.pixVarThresholdToBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarThresholdToBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVarThresholdToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarThresholdToBinary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       
  pixVarThresholdToBinary()

      Input:  pixs (8 bpp)
              pixg (8 bpp; contains threshold values for each pixel)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) If the pixel in pixs is less than the corresponding pixel
          in pixg, the dest will be 1; otherwise it will be 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarThresholdToBinary(*args)
    
    

    try:
        leptonica.pixDitherTo2bppSpec.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDitherTo2bppSpec.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDitherTo2bppSpec not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherTo2bppSpec(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       
('l_int32', 'cmapflag')       
  pixDitherTo2bppSpec()

      Input:  pixs (8 bpp)
              lowerclip (lower clip distance to black; use 0 for default)
              upperclip (upper clip distance to white; use 0 for default)
              cmapflag (1 to generate a colormap)
      Return: pixd (dithered 2 bpp), or null on error

  Notes:
      (1) See comments above in pixDitherTo2bpp() for details.
      (2) The input parameters lowerclip and upperclip specify the range
          of lower and upper values (near 0 and 255, rsp) that are
          clipped to black and white without propagating the excess.
          For that reason, lowerclip and upperclip should be small numbers.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherTo2bppSpec(*args)
    
    

    try:
        leptonica.pixGrayQuantFromHisto.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixGrayQuantFromHisto.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGrayQuantFromHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGrayQuantFromHisto(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'minfract')       
('l_int32', 'maxsize')       
  pixGrayQuantFromHisto()

      Input:  pixd (<optional> quantized pix with cmap; can be null)
              pixs (8 bpp gray input pix; not cmapped)
              pixm (<optional> mask over pixels in pixs to quantize)
              minfract (minimum fraction of pixels in a set of adjacent
                        histo bins that causes the set to be automatically
                        set aside as a color in the colormap; must be
                        at least 0.01)
              maxsize (maximum number of adjacent bins allowed to represent
                       a color, regardless of the population of pixels
                       in the bins; must be at least 2)
      Return: pixd (8 bpp, cmapped), or null on error

  Notes:
      (1) This is useful for quantizing images with relatively few
          colors, but which may have both color and gray pixels.
          If there are color pixels, it is assumed that an input
          rgb image has been color quantized first so that:
            - pixd has a colormap describing the color pixels
            - pixm is a mask over the non-color pixels in pixd
            - the colormap in pixd, and the color pixels in pixd,
              have been repacked to go from 0 to n-1 (n colors)
          If there are no color pixels, pixd and pixm are both null,
          and all pixels in pixs are quantized to gray.
      (2) A 256-entry histogram is built of the gray values in pixs.
          If pixm exists, the pixels contributing to the histogram are
          restricted to the fg of pixm.  A colormap and LUT are generated
          from this histogram.  We break up the array into a set
          of intervals, each one constituting a color in the colormap:
          An interval is identified by summing histogram bins until
          either the sum equals or exceeds the @minfract of the total
          number of pixels, or the span itself equals or exceeds @maxsize.
          The color of each bin is always an average of the pixels
          that constitute it.
      (3) Note that we do not specify the number of gray colors in
          the colormap.  Instead, we specify two parameters that
          describe the accuracy of the color assignments; this and
          the actual image determine the number of resulting colors.
      (4) If a mask exists and it is not the same size as pixs, make
          a new mask the same size as pixs, with the original mask
          aligned at the UL corners.  Set all additional pixels
          in the (larger) new mask set to 1, causing those pixels
          in pixd to be set as gray.
      (5) We estimate the total number of colors (color plus gray);
          if it exceeds 255, return null.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGrayQuantFromHisto(*args)
    
    

    try:
        leptonica.pixThresholdTo2bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdTo2bpp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdTo2bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdTo2bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       
  pixThresholdTo2bpp()

      Input:  pixs (8 bpp)
              nlevels (equally spaced; must be between 2 and 4)
              cmapflag (1 to build colormap; 0 otherwise)
      Return: pixd (2 bpp, optionally with colormap), or null on error

  Notes:
      (1) Valid values for nlevels is the set {2, 3, 4}.
      (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
      (3) This function is typically invoked with cmapflag == 1.
          In the situation where no colormap is desired, nlevels is
          ignored and pixs is thresholded to 4 levels.
      (4) The target output colors are equally spaced, with the
          darkest at 0 and the lightest at 255.  The thresholds are
          chosen halfway between adjacent output values.  A table
          is built that specifies the mapping from src to dest.
      (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
          and the pixel values in pixs are replaced by their
          appropriate color indices.  The number of holdouts,
          4 - nlevels, will be between 0 and 2.
      (6) If you don't want the thresholding to be equally spaced,
          either first transform the 8 bpp src using pixGammaTRC().
          or, if cmapflag == 1, after calling this function you can use
          pixcmapResetColor() to change any individual colors.
      (7) If a colormap is generated, it will specify (to display
          programs) exactly how each level is to be represented in RGB
          space.  When representing text, 3 levels is far better than
          2 because of the antialiasing of the single gray level,
          and 4 levels (black, white and 2 gray levels) is getting
          close to the perceptual quality of a (nearly continuous)
          grayscale image.  With 2 bpp, you can set up a colormap
          and allocate from 2 to 4 levels to represent antialiased text.
          Any left over colormap entries can be used for coloring regions.
          For the same number of levels, the file size of a 2 bpp image
          is about 10% smaller than that of a 4 bpp result for the same
          number of levels.  For both 2 bpp and 4 bpp, using 4 levels you
          get compression far better than that of jpeg, because the
          quantization to 4 levels will remove the jpeg ringing in the
          background near character edges.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdTo2bpp(*args)
    
    

    try:
        leptonica.pixThresholdOn8bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdOn8bpp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdOn8bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdOn8bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       
  pixThresholdOn8bpp()

      Input:  pixs (8 bpp, can have colormap)
              nlevels (equally spaced; must be between 2 and 256)
              cmapflag (1 to build colormap; 0 otherwise)
      Return: pixd (8 bpp, optionally with colormap), or null on error

  Notes:
      (1) Valid values for nlevels is the set {2,...,256}.
      (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
      (3) If cmapflag == 1, a colormap of size 'nlevels' is made,
          and the pixel values in pixs are replaced by their
          appropriate color indices.  Otherwise, the pixel values
          are the actual thresholded (i.e., quantized) grayscale values.
      (4) If you don't want the thresholding to be equally spaced,
          first transform the input 8 bpp src using pixGammaTRC().


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdOn8bpp(*args)
    
    

    try:
        leptonica.pixAdaptThresholdToBinaryGen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAdaptThresholdToBinaryGen.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAdaptThresholdToBinaryGen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAdaptThresholdToBinaryGen(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'gamma')       
('l_int32', 'blackval')       
('l_int32', 'whiteval')       
('l_int32', 'thresh')       
  pixAdaptThresholdToBinaryGen()

      Input:  pixs (8 bpp)
              pixm (<optional> 1 bpp image mask; can be null)
              gamma (gamma correction; must be > 0.0; typically ~1.0)
              blackval (dark value to set to black (0))
              whiteval (light value to set to white (255))
              thresh (final threshold for binarization)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) This is a convenience function for doing adaptive thresholding
          on a grayscale image with variable background.  Also see notes
          in pixAdaptThresholdToBinary().
      (2) Reducing @gamma increases the foreground (text) pixels.
          Use a low value (e.g., 0.5) for images with light text.
      (3) For normal images, see default args in pixAdaptThresholdToBinary().
          For images with very light text, these values are appropriate:
             gamma     ~0.5
             blackval  ~70
             whiteval  ~190
             thresh    ~200


        """
        args = _convert_params(*args)
        
        return leptonica.pixAdaptThresholdToBinaryGen(*args)
    
    

    try:
        leptonica.makeGrayQuantColormapArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.makeGrayQuantColormapArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeGrayQuantColormapArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGrayQuantColormapArb(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_int32', 'outdepth')       
('PIXCMAP', '**pcmap')       
  makeGrayQuantColormapArb()

      Input:  pixs (8 bpp)
              tab (table mapping input gray level to cmap index)
              outdepth (of colormap: 1, 2, 4 or 8)
              &cmap (<return> colormap)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The table is a 256-entry inverse colormap: it maps input gray
          level to colormap index (the bin number).  It is computed
          using makeGrayQuantTableArb().
      (2) The colormap generated here has quantized values at the
          average gray value of the pixels that are in each bin.
      (3) Returns an error if there are not enough levels in the
          output colormap for the number of bins.  The number
          of bins must not exceed 2^outdepth.


        """
        args = _convert_params(*args)
        
        return leptonica.makeGrayQuantColormapArb(*args)
    
    

    try:
        leptonica.pixGenerateMaskByBand32.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixGenerateMaskByBand32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateMaskByBand32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByBand32(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'refval')       
('l_int32', 'delm')       
('l_int32', 'delp')       
('l_float32', 'fractm')       
('l_float32', 'fractp')       
  pixGenerateMaskByBand32()

      Input:  pixs (32 bpp)
              refval (reference rgb value)
              delm (max amount below the ref value for any component)
              delp (max amount above the ref value for any component)
              fractm (fractional amount below ref value for all components)
              fractp (fractional amount above ref value for all components)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) Generates a 1 bpp mask pixd, the same size as pixs, where
          the fg pixels in the mask within a band of rgb values
          surrounding @refval.  The band can be chosen in two ways
          for each component:
          (a) Use (@delm, @delp) to specify how many levels down and up
          (b) Use (@fractm, @fractp) to specify the fractional
              distance toward 0 and 255, respectively.
          Note that @delm and @delp must be in [0 ... 255], whereas
          @fractm and @fractp must be in [0.0 - 1.0].
      (2) Either (@delm, @delp) or (@fractm, @fractp) can be used.
          Set each value in the other pair to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByBand32(*args)
    
    

    try:
        leptonica.pixDitherToBinaryLUT.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDitherToBinaryLUT.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDitherToBinaryLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherToBinaryLUT(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       
  pixDitherToBinaryLUT()

      Input:  pixs
              lowerclip (lower clip distance to black; use -1 for default)
              upperclip (upper clip distance to white; use -1 for default)
      Return: pixd (dithered binary), or null on error

  This implementation is deprecated.  You should use pixDitherToBinary().

  See comments in pixDitherToBinary()

  This implementation additionally uses three lookup tables to
  generate the output pixel value and the excess or deficit
  carried over to the neighboring pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherToBinaryLUT(*args)
    
    

    try:
        leptonica.makeGrayQuantTableArb.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.makeGrayQuantTableArb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeGrayQuantTableArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGrayQuantTableArb(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'outdepth')       
('l_int32', '**ptab')       
('PIXCMAP', '**pcmap')       
  makeGrayQuantTableArb()

      Input:  na (numa of bin boundaries)
              outdepth (of colormap: 1, 2, 4 or 8)
              &tab (<return> table mapping input gray level to cmap index)
              &cmap (<return> colormap)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The number of bins is the count of @na + 1.
      (2) The bin boundaries in na must be sorted in increasing order.
      (3) The table is an inverse colormap: it maps input gray level
          to colormap index (the bin number).
      (4) The colormap generated here has quantized values at the
          center of each bin.  If you want to use the average gray
          value of pixels within the bin, discard the colormap and
          compute it using makeGrayQuantColormapArb().
      (5) Returns an error if there are not enough levels in the
          output colormap for the number of bins.  The number
          of bins must not exceed 2^outdepth.


        """
        args = _convert_params(*args)
        
        return leptonica.makeGrayQuantTableArb(*args)
    
    

    try:
        leptonica.pixThresholdTo4bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdTo4bpp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdTo4bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdTo4bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       
  pixThresholdTo4bpp()

      Input:  pixs (8 bpp, can have colormap)
              nlevels (equally spaced; must be between 2 and 16)
              cmapflag (1 to build colormap; 0 otherwise)
      Return: pixd (4 bpp, optionally with colormap), or null on error

  Notes:
      (1) Valid values for nlevels is the set {2, ... 16}.
      (2) Any colormap on the input pixs is removed to 8 bpp grayscale.
      (3) This function is typically invoked with cmapflag == 1.
          In the situation where no colormap is desired, nlevels is
          ignored and pixs is thresholded to 16 levels.
      (4) The target output colors are equally spaced, with the
          darkest at 0 and the lightest at 255.  The thresholds are
          chosen halfway between adjacent output values.  A table
          is built that specifies the mapping from src to dest.
      (5) If cmapflag == 1, a colormap of size 'nlevels' is made,
          and the pixel values in pixs are replaced by their
          appropriate color indices.  The number of holdouts,
          16 - nlevels, will be between 0 and 14.
      (6) If you don't want the thresholding to be equally spaced,
          either first transform the 8 bpp src using pixGammaTRC().
          or, if cmapflag == 1, after calling this function you can use
          pixcmapResetColor() to change any individual colors.
      (7) If a colormap is generated, it will specify, to display
          programs, exactly how each level is to be represented in RGB
          space.  When representing text, 3 levels is far better than
          2 because of the antialiasing of the single gray level,
          and 4 levels (black, white and 2 gray levels) is getting
          close to the perceptual quality of a (nearly continuous)
          grayscale image.  Therefore, with 4 bpp, you can set up a
          colormap, allocate a relatively small fraction of the 16
          possible values to represent antialiased text, and use the
          other colormap entries for other things, such as coloring
          text or background.  Two other reasons for using a small number
          of gray values for antialiased text are (1) PNG compression
          gets worse as the number of levels that are used is increased,
          and (2) using a small number of levels will filter out most of
          the jpeg ringing that is typically introduced near sharp edges
          of text.  This filtering is partly responsible for the improved
          compression.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdTo4bpp(*args)
    
    

    try:
        leptonica.pixGenerateMaskByBand.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGenerateMaskByBand.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateMaskByBand not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByBand(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lower')       
('l_int32', 'upper')       
('l_int32', 'inband')       
('l_int32', 'usecmap')       
  pixGenerateMaskByBand()

      Input:  pixs (2, 4 or 8 bpp, or colormapped)
              lower, upper (two pixel values from which a range, either
                            between (inband) or outside of (!inband),
                            determines which pixels in pixs cause us to
                            set a 1 in the dest mask)
              inband (1 for finding pixels in [lower, upper];
                      0 for finding pixels in [0, lower) union (upper, 255])
              usecmap (1 to retain cmap values; 0 to convert to gray)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) Generates a 1 bpp mask pixd, the same size as pixs, where
          the fg pixels in the mask are those either within the specified
          band (for inband == 1) or outside the specified band
          (for inband == 0).
      (2) If pixs is colormapped, @usecmap determines if the colormap
          values are used, or if the colormap is removed to gray and
          the gray values are used.  For the latter, it generates
          an approximate grayscale value for each pixel, and then looks
          for gray pixels with the value @val.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByBand(*args)
    
    

    try:
        leptonica.pixGenerateMaskByDiscr32.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixGenerateMaskByDiscr32.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateMaskByDiscr32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByDiscr32(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'refval1')       
('l_uint32', 'refval2')       
('l_int32', 'distflag')       
  pixGenerateMaskByDiscr32()

      Input:  pixs (32 bpp)
              refval1 (reference rgb value)
              refval2 (reference rgb value)
              distflag (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE)
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) Generates a 1 bpp mask pixd, the same size as pixs, where
          the fg pixels in the mask are those where the pixel in pixs
          is "closer" to refval1 than to refval2.
      (2) "Closer" can be defined in several ways, such as:
            - manhattan distance (L1)
            - euclidean distance (L2)
            - majority vote of the individual components
          Here, we have a choice of L1 or L2.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByDiscr32(*args)
    
    

    try:
        leptonica.makeGrayQuantIndexTable.argtypes = [ctypes.c_int32]
        leptonica.makeGrayQuantIndexTable.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function makeGrayQuantIndexTable not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGrayQuantIndexTable(*args):
        """
        ('l_int32', 'nlevels')       
  makeGrayQuantIndexTable()

      Input:  nlevels (number of output levels)
      Return: table (maps input gray level to colormap index,
                     or null on error)
  Notes:
      (1) 'nlevels' is some number between 2 and 256 (typically 8 or less).
      (2) The table is typically used for quantizing 2, 4 and 8 bpp
          grayscale src pix, and generating a colormapped dest pix.


        """
        args = _convert_params(*args)
        
        return leptonica.makeGrayQuantIndexTable(*args)
    
    

    try:
        leptonica.pixDitherTo2bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDitherTo2bpp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDitherTo2bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherTo2bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'cmapflag')       
  pixDitherTo2bpp()

      Input:  pixs (8 bpp)
              cmapflag (1 to generate a colormap)
      Return: pixd (dithered 2 bpp), or null on error

  An analog of the Floyd-Steinberg error diffusion dithering
  algorithm is used to "dibitize" an 8 bpp grayscale image
  to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255,
  which are served by thresholds of 43, 128 and 213.
  If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255.
  If a pixel has a value between 0 and 42, it is dibitized
  to 0, and the excess (above 0) is added to the
  three neighboring pixels, in the fractions 3/8 to (i, j+1),
  3/8 to (i+1, j) and 1/4 to (i+1, j+1), truncating to 255 if
  necessary.  If a pixel has a value between 43 and 127, it is
  dibitized to 1, and the excess (above 85) is added to the three
  neighboring pixels as before.  If the value is below 85, the
  excess is subtracted.  With a value between 128
  and 212, it is dibitized to 2, with the excess on either side
  of 170 distributed as before.  Finally, with a value between
  213 and 255, it is dibitized to 3, with the excess (below 255)
  subtracted from the neighbors.  We always truncate to 0 or 255.
  The details can be seen in the lookup table generation.

  This function differs from straight dithering in that it allows
  clipping of grayscale to 0 or 255 if the values are
  sufficiently close, without distribution of the excess.
  This uses default values (from pix.h) to specify the range of lower
  and upper values (near 0 and 255, rsp) that are clipped to black
  and white without propagating the excess.
  Not propagating the excess has the effect of reducing the snake
  patterns in parts of the image that are nearly black or white;
  however, it also prevents any attempt to reproduce gray for those values.

  The implementation uses 3 lookup tables for simplicity, and
  a pair of line buffers to avoid modifying pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherTo2bpp(*args)
    
    

    try:
        leptonica.pixDitherToBinarySpec.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDitherToBinarySpec.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDitherToBinarySpec not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherToBinarySpec(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       
  pixDitherToBinarySpec()

      Input:  pixs
              lowerclip (lower clip distance to black; use 0 for default)
              upperclip (upper clip distance to white; use 0 for default)
      Return: pixd (dithered binary), or null on error

  Notes:
      (1) See comments above in pixDitherToBinary() for details.
      (2) The input parameters lowerclip and upperclip specify the range
          of lower and upper values (near 0 and 255, rsp) that are
          clipped to black and white without propagating the excess.
          For that reason, lowerclip and upperclip should be small numbers.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherToBinarySpec(*args)
    




class colormap(object):
    """  colormap.c

      Colormap creation, copy, destruction, addition
           PIXCMAP    *pixcmapCreate()
           PIXCMAP    *pixcmapCreateRandom()
           PIXCMAP    *pixcmapCreateLinear()
           PIXCMAP    *pixcmapCopy()
           void        pixcmapDestroy()
           l_int32     pixcmapAddColor()
           l_int32     pixcmapAddRGBA()
           l_int32     pixcmapAddNewColor()
           l_int32     pixcmapAddNearestColor()
           l_int32     pixcmapUsableColor()
           l_int32     pixcmapAddBlackOrWhite()
           l_int32     pixcmapSetBlackAndWhite()
           l_int32     pixcmapGetCount()
           l_int32     pixcmapGetDepth()
           l_int32     pixcmapGetMinDepth()
           l_int32     pixcmapGetFreeCount()
           l_int32     pixcmapClear()

      Colormap random access and test
           l_int32     pixcmapGetColor()
           l_int32     pixcmapGetColor32()
           l_int32     pixcmapGetRGBA()
           l_int32     pixcmapGetRGBA32()
           l_int32     pixcmapResetColor()
           l_int32     pixcmapGetIndex()
           l_int32     pixcmapHasColor()
           l_int32     pixcmapIsOpaque()
           l_int32     pixcmapCountGrayColors()
           l_int32     pixcmapGetRankIntensity()
           l_int32     pixcmapGetNearestIndex()
           l_int32     pixcmapGetNearestGrayIndex()
           l_int32     pixcmapGetComponentRange()
           l_int32     pixcmapGetExtremeValue()

      Colormap conversion
           PIXCMAP    *pixcmapGrayToColor()
           PIXCMAP    *pixcmapColorToGray()

      Colormap I/O
           l_int32     pixcmapReadStream()
           l_int32     pixcmapWriteStream()

      Extract colormap arrays and serialization
           l_int32     pixcmapToArrays()
           l_int32     pixcmapToRGBTable()
           l_int32     pixcmapSerializeToMemory()
           PIXCMAP    *pixcmapDeserializeFromMemory()
           char       *pixcmapConvertToHex()

      Colormap transforms
           l_int32     pixcmapGammaTRC()
           l_int32     pixcmapContrastTRC()
           l_int32     pixcmapShiftIntensity()
           l_int32     pixcmapShiftByComponent()

"""
    
    try:
        leptonica.pixcmapHasColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapHasColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapHasColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapHasColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pcolor')       
  pixcmapHasColor()

      Input:  cmap
              &color (<return> TRUE if cmap has color; FALSE otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapHasColor(*args)
    
    

    try:
        leptonica.pixcmapGetDepth.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapGetDepth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetDepth(*args):
        """
        ('PIXCMAP', '*cmap')       
  pixcmapGetDepth()

      Input:  cmap
      Return: depth, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetDepth(*args)
    
    

    try:
        leptonica.pixcmapAddRGBA.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapAddRGBA.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapAddRGBA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddRGBA(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'aval')       
  pixcmapAddRGBA()

      Input:  cmap
              rval, gval, bval, aval (colormap entry to be added;
                                      each number is in range [0, ... 255])
      Return: 0 if OK, 1 on error

  Notes:
      (1) This always adds the color if there is room.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddRGBA(*args)
    
    

    try:
        leptonica.pixcmapGetIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetIndex.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetIndex(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       
  pixcmapGetIndex()

      Input:  cmap
              rval, gval, bval (colormap colors to search for; each number
                                is in range [0, ... 255])
              &index (<return>)
      Return: 0 if found, 1 if not found (caller must check)


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetIndex(*args)
    
    

    try:
        leptonica.pixcmapAddColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapAddColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapAddColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixcmapAddColor()

      Input:  cmap
              rval, gval, bval (colormap entry to be added; each number
                                is in range [0, ... 255])
      Return: 0 if OK, 1 on error

  Notes:
      (1) This always adds the color if there is room.
      (2) The alpha component is 255 (opaque)


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddColor(*args)
    
    

    try:
        leptonica.pixcmapGrayToColor.argtypes = [ctypes.c_uint32]
        leptonica.pixcmapGrayToColor.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGrayToColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGrayToColor(*args):
        """
        ('l_uint32', 'color')       
  pixcmapGrayToColor()

      Input:  color
      Return: cmap, or null on error

  Notes:
      (1) This creates a colormap that maps from gray to
          a specific color.  In the mapping, each component
          is faded to white, depending on the gray value.
      (2) In use, this is simply attached to a grayscale pix
          to give it the input color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGrayToColor(*args)
    
    

    try:
        leptonica.pixcmapGetRGBA.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetRGBA.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetRGBA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRGBA(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
('l_int32', '*paval')       
  pixcmapGetRGBA()

      Input:  cmap
              index
              &rval, &gval, &bval, &aval (<return> each color value)
      Return: 0 if OK, 1 if not accessable (caller should check)


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRGBA(*args)
    
    

    try:
        leptonica.pixcmapClear.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapClear.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapClear(*args):
        """
        ('PIXCMAP', '*cmap')       
  pixcmapClear()

      Input:  cmap
      Return: 0 if OK, 1 on error

  Note: this removes the colors by setting the count to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapClear(*args)
    
    

    try:
        leptonica.pixcmapCreateLinear.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapCreateLinear.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapCreateLinear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCreateLinear(*args):
        """
        ('l_int32', 'd')       
('l_int32', 'nlevels')       
  pixcmapCreateLinear()

      Input:  d (depth of pix for this colormap; 1, 2, 4 or 8)
              nlevels (valid in range [2, 2^d])
      Return: cmap, or null on error

  Notes:
      (1) Colormap has equally spaced gray color values
          from black (0, 0, 0) to white (255, 255, 255).


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCreateLinear(*args)
    
    

    try:
        leptonica.pixcmapCountGrayColors.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapCountGrayColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapCountGrayColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCountGrayColors(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pngray')       
  pixcmapCountGrayColors()

      Input:  cmap
              &ngray (<return> number of gray colors)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This counts the unique gray colors, including black and white.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCountGrayColors(*args)
    
    

    try:
        leptonica.pixcmapCreateRandom.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapCreateRandom.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapCreateRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCreateRandom(*args):
        """
        ('l_int32', 'depth')       
('l_int32', 'hasblack')       
('l_int32', 'haswhite')       
  pixcmapCreateRandom()

      Input:  depth (bpp, of pix; 2, 4 or 8)
              hasblack (1 if the first color is black; 0 if no black)
              haswhite (1 if the last color is white; 0 if no white)
      Return: cmap, or null on error

  Notes:
      (1) This sets up a colormap with random colors,
          where the first color is optionally black, the last color
          is optionally white, and the remaining colors are
          chosen randomly.
      (2) The number of randomly chosen colors is:
               2^(depth) - haswhite - hasblack
      (3) Because rand() is seeded, it might disrupt otherwise
          deterministic results if also used elsewhere in a program.
      (4) rand() is not threadsafe, and will generate garbage if run
          on multiple threads at once -- though garbage is generally
          what you want from a random number generator!
      (5) Modern rand()s have equal randomness in low and high order
          bits, but older ones don't.  Here, we're just using rand()
          to choose colors for output.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCreateRandom(*args)
    
    

    try:
        leptonica.pixcmapColorToGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixcmapColorToGray.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapColorToGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapColorToGray(*args):
        """
        ('PIXCMAP', '*cmaps')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       
  pixcmapColorToGray()

      Input:  cmap
              rwt, gwt, bwt  (non-negative; these should add to 1.0)
      Return: cmap (gray), or null on error

  Notes:
      (1) This creates a gray colormap from an arbitrary colormap.
      (2) In use, attach the output gray colormap to the pix
          (or a copy of it) that provided the input colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapColorToGray(*args)
    
    

    try:
        leptonica.pixcmapGetFreeCount.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapGetFreeCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetFreeCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetFreeCount(*args):
        """
        ('PIXCMAP', '*cmap')       
  pixcmapGetFreeCount()

      Input:  cmap
      Return: free entries, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetFreeCount(*args)
    
    

    try:
        leptonica.pixcmapUsableColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapUsableColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapUsableColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapUsableColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pusable')       
  pixcmapUsableColor()

      Input:  cmap
              rval, gval, bval (colormap entry to be added; each number
                                is in range [0, ... 255])
              usable (<return> 1 if usable; 0 if not)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This checks if the color already exists or if there is
          room to add it.  It makes no change in the colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapUsableColor(*args)
    
    

    try:
        leptonica.pixcmapAddBlackOrWhite.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapAddBlackOrWhite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapAddBlackOrWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddBlackOrWhite(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'color')       
('l_int32', '*pindex')       
  pixcmapAddBlackOrWhite()

      Input:  cmap
              color (0 for black, 1 for white)
              &index (<optional return> index of color; can be null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This only adds color if not already there.
      (2) The alpha component is 255 (opaque)
      (3) This sets index to the requested color.
      (4) If there is no room in the colormap, returns the index
          of the closest color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddBlackOrWhite(*args)
    
    

    try:
        leptonica.pixcmapGetNearestIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetNearestIndex.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetNearestIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetNearestIndex(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       
  pixcmapGetNearestIndex()

      Input:  cmap
              rval, gval, bval (colormap colors to search for; each number
                                is in range [0, ... 255])
              &index (<return> the index of the nearest color)
      Return: 0 if OK, 1 on error (caller must check)

  Notes:
      (1) Returns the index of the exact color if possible, otherwise the
          index of the color closest to the target color.
      (2) Nearest color is that which is the least sum-of-squares distance
          from the target color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetNearestIndex(*args)
    
    

    try:
        leptonica.pixcmapGetRGBA32.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetRGBA32.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetRGBA32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRGBA32(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_uint32', '*pval32')       
  pixcmapGetRGBA32()

      Input:  cmap
              index
              &val32 (<return> 32-bit rgba color value)
      Return: 0 if OK, 1 if not accessable (caller should check)


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRGBA32(*args)
    
    

    try:
        leptonica.pixcmapGetNearestGrayIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetNearestGrayIndex.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetNearestGrayIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetNearestGrayIndex(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'val')       
('l_int32', '*pindex')       
  pixcmapGetNearestGrayIndex()

      Input:  cmap
              val (gray value to search for; in range [0, ... 255])
              &index (<return> the index of the nearest color)
      Return: 0 if OK, 1 on error (caller must check)

  Notes:
      (1) This should be used on gray colormaps.  It uses only the
          green value of the colormap.
      (2) Returns the index of the exact color if possible, otherwise the
          index of the color closest to the target color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetNearestGrayIndex(*args)
    
    

    try:
        leptonica.pixcmapSetBlackAndWhite.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapSetBlackAndWhite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapSetBlackAndWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapSetBlackAndWhite(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'setblack')       
('l_int32', 'setwhite')       
  pixcmapSetBlackAndWhite()

      Input:  cmap
              setblack (0 for no operation; 1 to set darkest color to black)
              setwhite (0 for no operation; 1 to set lightest color to white)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapSetBlackAndWhite(*args)
    
    

    try:
        leptonica.pixcmapGetCount.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetCount(*args):
        """
        ('PIXCMAP', '*cmap')       
  pixcmapGetCount()

      Input:  cmap
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetCount(*args)
    
    

    try:
        leptonica.pixcmapAddNearestColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapAddNearestColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapAddNearestColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddNearestColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       
  pixcmapAddNearestColor()

      Input:  cmap
              rval, gval, bval (colormap entry to be added; each number
                                is in range [0, ... 255])
              &index (<return> index of color)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This only adds color if not already there.
      (2) The alpha component is 255 (opaque)
      (3) If it's not in the colormap and there is no room to add
          another color, this returns the index of the nearest color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddNearestColor(*args)
    
    

    try:
        leptonica.pixcmapWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXCMAP', '*cmap')       
  pixcmapWriteStream()

      Input:  stream, cmap
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapWriteStream(*args)
    
    

    try:
        leptonica.pixcmapGetComponentRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetComponentRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetComponentRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetComponentRange(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'color')       
('l_int32', '*pminval')       
('l_int32', '*pmaxval')       
  pixcmapGetComponentRange()

      Input:  cmap
              color (L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE)
              &minval (<optional return> minimum value of component)
              &maxval (<optional return> minimum value of component)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Returns for selected components the extreme value
          (either min or max) of the color component that is
          found in the colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetComponentRange(*args)
    
    

    try:
        leptonica.pixcmapToRGBTable.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapToRGBTable.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapToRGBTable not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapToRGBTable(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_uint32', '**ptab')       
('l_int32', '*pncolors')       
  pixcmapToRGBTable()

      Input:  colormap
              &tab (<return> table of rgba values for the colormap)
              &ncolors (<optional return> size of table)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapToRGBTable(*args)
    
    

    try:
        leptonica.pixcmapDeserializeFromMemory.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapDeserializeFromMemory.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapDeserializeFromMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapDeserializeFromMemory(*args):
        """
        ('l_uint8', '*data')       
('l_int32', 'cpc')       
('l_int32', 'ncolors')       
  pixcmapDeserializeFromMemory()

      Input:  data (binary string, 3 or 4 bytes per color)
              cpc (components/color: 3 for rgb, 4 for rgba)
              ncolors
      Return: cmap, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapDeserializeFromMemory(*args)
    
    

    try:
        leptonica.pixcmapCopy.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapCopy.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCopy(*args):
        """
        ('PIXCMAP', '*cmaps')       
  pixcmapCopy()

      Input:  cmaps
      Return: cmapd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCopy(*args)
    
    

    try:
        leptonica.pixcmapConvertToHex.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixcmapConvertToHex.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function pixcmapConvertToHex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertToHex(*args):
        """
        ('l_uint8', '*data')       
('l_int32', 'ncolors')       
  pixcmapConvertToHex()

      Input:  data  (binary serialized data)
              ncolors (in colormap)
      Return: hexdata (bracketed, space-separated ascii hex string),
                       or null on error.

  Notes:
      (1) The number of bytes in @data is 3 * ncolors.
      (2) Output is in form:
             < r0g0b0 r1g1b1 ... rngnbn >
          where r0, g0, b0 ... are each 2 bytes of hex ascii
      (3) This is used in pdf files to express the colormap as an
          array in ascii (human-readable) format.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertToHex(*args)
    
    

    try:
        leptonica.pixcmapGetColor32.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetColor32.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetColor32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetColor32(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_uint32', '*pval32')       
  pixcmapGetColor32()

      Input:  cmap
              index
              &val32 (<return> 32-bit rgb color value)
      Return: 0 if OK, 1 if not accessable (caller should check)

  Notes:
      (1) The returned alpha channel value is 255.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetColor32(*args)
    
    

    try:
        leptonica.pixcmapGetMinDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetMinDepth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetMinDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetMinDepth(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pmindepth')       
  pixcmapGetMinDepth()

      Input:  cmap
              &mindepth (<return> minimum depth to support the colormap)
      Return: 0 if OK, 1 on error

  Notes:
      (1) On error, &mindepth is returned as 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetMinDepth(*args)
    
    

    try:
        leptonica.pixcmapGetRankIntensity.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixcmapGetRankIntensity.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetRankIntensity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRankIntensity(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'rankval')       
('l_int32', '*pindex')       
  pixcmapGetRankIntensity()

      Input:  cmap
              rankval (0.0 for darkest, 1.0 for lightest color)
              &index (<return> the index into the colormap that
                      corresponds to the rank intensity color)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRankIntensity(*args)
    
    

    try:
        leptonica.pixcmapGammaTRC.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapGammaTRC.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGammaTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGammaTRC(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
  pixcmapGammaTRC()

      Input:  colormap
              gamma (gamma correction; must be > 0.0)
              minval  (input value that gives 0 for output; can be < 0)
              maxval  (input value that gives 255 for output; can be > 255)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place transform
      (2) See pixGammaTRC() and numaGammaTRC() in enhance.c
          for description and use of transform


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGammaTRC(*args)
    
    

    try:
        leptonica.pixcmapGetColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
  pixcmapGetColor()

      Input:  cmap
              index
              &rval, &gval, &bval (<return> each color value)
      Return: 0 if OK, 1 if not accessable (caller should check)


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetColor(*args)
    
    

    try:
        leptonica.pixcmapContrastTRC.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixcmapContrastTRC.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapContrastTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapContrastTRC(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'factor')       
  pixcmapContrastTRC()

      Input:  colormap
              factor (generally between 0.0 (no enhancement)
                      and 1.0, but can be larger than 1.0)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place transform
      (2) See pixContrastTRC() and numaContrastTRC() in enhance.c
          for description and use of transform


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapContrastTRC(*args)
    
    

    try:
        leptonica.pixcmapDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixcmapDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapDestroy(*args):
        """
        ('PIXCMAP', '**pcmap')       
  pixcmapDestroy()

      Input:  &cmap (<set to null>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapDestroy(*args)
    
    

    try:
        leptonica.pixcmapShiftIntensity.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixcmapShiftIntensity.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapShiftIntensity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapShiftIntensity(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'fraction')       
  pixcmapShiftIntensity()

      Input:  colormap
              fraction (between -1.0 and +1.0)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place transform
      (2) It does a proportional shift of the intensity for each color.
      (3) If fraction < 0.0, it moves all colors towards (0,0,0).
          This darkens the image.
          If fraction > 0.0, it moves all colors towards (255,255,255)
          This fades the image.
      (4) The equivalent transform can be accomplished with pixcmapGammaTRC(),
          but it is considerably more difficult (see numaGammaTRC()).


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapShiftIntensity(*args)
    
    

    try:
        leptonica.pixcmapAddNewColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapAddNewColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapAddNewColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddNewColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       
  pixcmapAddNewColor()

      Input:  cmap
              rval, gval, bval (colormap entry to be added; each number
                                is in range [0, ... 255])
              &index (<return> index of color)
      Return: 0 if OK, 1 on error; 2 if unable to add color

  Notes:
      (1) This only adds color if not already there.
      (2) The alpha component is 255 (opaque)
      (3) This returns the index of the new (or existing) color.
      (4) Returns 2 with a warning if unable to add this color;
          the caller should check the return value.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddNewColor(*args)
    
    

    try:
        leptonica.pixcmapReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapReadStream.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapReadStream(*args):
        """
        ('FILE', '*fp')       
  pixcmapReadStream()

      Input:  stream
      Return: cmap, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapReadStream(*args)
    
    

    try:
        leptonica.pixcmapToArrays.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapToArrays.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapToArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapToArrays(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '**prmap')       
('l_int32', '**pgmap')       
('l_int32', '**pbmap')       
('l_int32', '**pamap')       
  pixcmapToArrays()

      Input:  colormap
              &rmap, &gmap, &bmap  (<return> colormap arrays)
              &amap (<optional return> alpha array)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapToArrays(*args)
    
    

    try:
        leptonica.pixcmapSerializeToMemory.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapSerializeToMemory.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapSerializeToMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapSerializeToMemory(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'cpc')       
('l_int32', '*pncolors')       
('l_uint8', '**pdata')       
  pixcmapSerializeToMemory()

      Input:  colormap
              cpc (components/color: 3 for rgb, 4 for rgba)
              &ncolors (<return> number of colors in table)
              &data (<return> binary string, cpc bytes per color)
      Return: 0 if OK; 1 on error

  Notes:
      (1) When serializing to store in a pdf, use @cpc = 3.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapSerializeToMemory(*args)
    
    

    try:
        leptonica.pixcmapIsOpaque.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapIsOpaque.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapIsOpaque not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapIsOpaque(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*popaque')       
  pixcmapIsOpaque()

      Input:  cmap
              &opaque (<return> TRUE if fully opaque: all entries are 255)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapIsOpaque(*args)
    
    

    try:
        leptonica.pixcmapGetExtremeValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetExtremeValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapGetExtremeValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetExtremeValue(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'type')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
  pixcmapGetExtremeValue()

      Input:  cmap
              type (L_SELECT_MIN or L_SELECT_MAX)
              &rval (<optional return> red component)
              &gval (<optional return> green component)
              &bval (<optional return> blue component)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Returns for selected components the extreme value
          (either min or max) of the color component that is
          found in the colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetExtremeValue(*args)
    
    

    try:
        leptonica.pixcmapResetColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapResetColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapResetColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapResetColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixcmapResetColor()

      Input:  cmap
              index
              rval, gval, bval (colormap entry to be reset; each number
                                is in range [0, ... 255])
      Return: 0 if OK, 1 if not accessable (caller should check)

  Notes:
      (1) This resets sets the color of an entry that has already
          been set and included in the count of colors.
      (2) The alpha component is 255 (opaque)


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapResetColor(*args)
    
    

    try:
        leptonica.pixcmapCreate.argtypes = [ctypes.c_int32]
        leptonica.pixcmapCreate.restype = lambda address: PIXCMAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcmapCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCreate(*args):
        """
        ('l_int32', 'depth')       
  pixcmapCreate()

      Input:  depth (bpp, of pix)
      Return: cmap, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCreate(*args)
    
    

    try:
        leptonica.pixcmapShiftByComponent.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixcmapShiftByComponent.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcmapShiftByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapShiftByComponent(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       
  pixcmapShiftByComponent()

      Input:  colormap
              srcval (source color: 0xrrggbb00)
              dstval (target color: 0xrrggbb00)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place transform
      (2) It implements pixelShiftByComponent() for each color.
          The mapping is specified by srcval and dstval.
      (3) If a component decreases, the component in the colormap
          decreases by the same ratio.  Likewise for increasing, except
          all ratios are taken with respect to the distance from 255.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapShiftByComponent(*args)
    




class tiffiostub(object):
    """  tiffiostub.c

     Stubs for tiffio.c functions

"""
    



class jpegio(object):
    """  jpegio.c

    Read jpeg from file
          PIX             *pixReadJpeg()  [special top level]
          PIX             *pixReadStreamJpeg()

    Read jpeg metadata from file
          l_int32          readHeaderJpeg()
          l_int32          freadHeaderJpeg()
          l_int32          fgetJpegResolution()
          l_int32          fgetJpegComment()

    Write jpeg to file
          l_int32          pixWriteJpeg()  [special top level]
          l_int32          pixWriteStreamJpeg()

    Read/write to memory
          PIX             *pixReadMemJpeg()
          l_int32          readHeaderMemJpeg()
          l_int32          pixWriteMemJpeg()

    Setting special flag for chroma sampling on write
          l_int32          pixSetChromaSampling()

    Static system helpers
          static void      jpeg_error_catch_all_1()
          static void      jpeg_error_catch_all_2()
          static l_uint8   jpeg_getc()
          static l_int32   jpeg_comment_callback()

    Documentation: libjpeg.doc can be found, along with all
    source code, at ftp://ftp.uu.net/graphics/jpeg
    Download and untar the file:  jpegsrc.v6b.tar.gz
    A good paper on jpeg can also be found there: wallace.ps.gz

    The functions in libjpeg make it very simple to compress
    and decompress images.  On input (decompression from file),
    3 component color images can be read into either an 8 bpp Pix
    with a colormap or a 32 bpp Pix with RGB components.  For output
    (compression to file), all color Pix, whether 8 bpp with a
    colormap or 32 bpp, are written compressed as a set of three
    8 bpp (rgb) images.

    Low-level error handling
    ------------------------
    The default behavior of the jpeg library is to call exit.
    This is often undesirable, and the caller should make the
    decision when to abort a process.  To prevent the jpeg library
    from calling exit(), setjmp() has been inserted into all
    readers and writers, and the cinfo struct has been set up so that
    the low-level jpeg library will call a special error handler
    that doesn't exit, instead of the default function error_exit().

    To avoid race conditions and make these functions thread-safe in
    the rare situation where calls to two threads are simultaneously
    failing on bad jpegs, we insert a local copy of the jmp_buf struct
    into the cinfo.client_data field, and use this on longjmp.
    For extracting the jpeg comment, we have the added complication
    that the client_data field must also return the jpeg comment,
    and we use a different error handler.

    How to avoid subsampling the chroma channels
    --------------------------------------------
    When writing, you can avoid subsampling the U,V (chroma)
    channels.  This gives higher quality for the color, which is
    important for some situations.  The default subsampling is 2x2 on
    both channels.  Before writing, call pixSetChromaSampling(pix, 0)
    to prevent chroma subsampling.

    How to extract just the luminance channel in reading RGB
    --------------------------------------------------------
    For higher resolution and faster decoding of an RGB image, you
    can extract just the 8 bpp luminance channel, using pixReadJpeg(),
    where you use L_JPEG_READ_LUMINANCE for the @hint arg.

    How to fail to read if the data is corrupted
    ---------------------------------------------
    By default, if the low-level jpeg library functions do not abort,
    a pix will be returned, even if the data is corrupted and warnings
    are issued.  In order to be most likely to fail to read when there
    is data corruption, use L_JPEG_FAIL_ON_BAD_DATA in the @hint arg.

    Compressing to memory and decompressing from memory
    ---------------------------------------------------
    On systems like windows without fmemopen() and open_memstream(),
    we write data to a temp file and read it back for operations
    between pix and compressed-data, such as pixReadMemJpeg() and
    pixWriteMemJpeg().

    Vestigial code: parsing the jpeg file for header metadata
    ---------------------------------------------------------
    For extracting header metadata, we previously parsed the file, looking
    for specific markers.  This is error-prone because of non-standard
    jpeg files, and we now use readHeaderJpeg() and readHeaderMemJpeg().
    The vestigial code is retained in jpegio_notused.c to help you
    understand a bit about how to parse jpeg markers.  It is not compiled
    into the library.

"""
    
    try:
        leptonica.freadHeaderJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderJpeg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function freadHeaderJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderJpeg(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
('l_int32', '*pycck')       
('l_int32', '*pcmyk')       
  freadHeaderJpeg()

      Input:  stream
              &w (<optional return>)
              &h (<optional return>)
              &spp (<optional return>, samples/pixel)
              &ycck (<optional return>, 1 if ycck color space; 0 otherwise)
              &cmyk (<optional return>, 1 if cmyk color space; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderJpeg(*args)
    
    

    try:
        leptonica.pixReadJpeg.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadJpeg.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadJpeg(*args):
        """
        ('const char', '*filename')       
('l_int32', 'cmflag')       
('l_int32', 'reduction')       
('l_int32', '*pnwarn')       
('l_int32', 'hint')       
  pixReadJpeg()

      Input:  filename
              colormap flag (0 means return RGB image if color;
                             1 means create a colormap and return
                             an 8 bpp colormapped image if color)
              reduction (scaling factor: 1, 2, 4 or 8)
              &nwarn (<optional return> number of warnings about
                       corrupted data)
              hint (a bitwise OR of L_JPEG_* values; 0 for default)
      Return: pix, or null on error

  Notes:
      (1) This is a special function for reading jpeg files.
      (2) Use this if you want the jpeg library to create
          an 8 bpp colormapped image.
      (3) Images reduced by factors of 2, 4 or 8 can be returned
          significantly faster than full resolution images.
      (4) If the jpeg data is bad, the jpeg library will continue
          silently, or return warnings, or attempt to exit.  Depending
          on the severity of the data corruption, there are two possible
          outcomes:
          (a) a possibly damaged pix can be generated, along with zero
              or more warnings, or
          (b) the library will attempt to exit (caught by our error
              handler) and no pix will be returned.
          If a pix is generated with at least one warning of data
          corruption, and if L_JPEG_FAIL_ON_BAD_DATA is included in @hint,
          no pix will be returned.
      (5) The possible hint values are given in the enum in imageio.h:
            * L_JPEG_READ_LUMINANCE
            * L_JPEG_FAIL_ON_BAD_DATA
          Default (0) is to do neither.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadJpeg(*args)
    
    

    try:
        leptonica.pixWriteJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteJpeg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteJpeg(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'progressive')       
  pixWriteJpeg()

      Input:  filename
              pix  (any depth; cmap is OK)
              quality (1 - 100; 75 is default)
              progressive (0 for baseline sequential; 1 for progressive)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteJpeg(*args)
    
    

    try:
        leptonica.pixWriteMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteMemJpeg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemJpeg(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'progressive')       
  pixWriteMemJpeg()

      Input:  &data (<return> data of jpeg compressed image)
              &size (<return> size of returned data)
              pix  (any depth; cmap is OK)
              quality  (1 - 100; 75 is default value; 0 is also default)
              progressive (0 for baseline sequential; 1 for progressive)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixWriteStreamJpeg() for usage.  This version writes to
          memory instead of to a file stream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemJpeg(*args)
    
    

    try:
        leptonica.readHeaderMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemJpeg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemJpeg(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
('l_int32', '*pycck')       
('l_int32', '*pcmyk')       
  readHeaderMemJpeg()

      Input:  data (const; jpeg-encoded)
              size (of data)
              &w (<optional return>)
              &h (<optional return>)
              &spp (<optional return>, samples/pixel)
              &ycck (<optional return>, 1 if ycck color space; 0 otherwise)
              &cmyk (<optional return>, 1 if cmyk color space; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemJpeg(*args)
    
    

    try:
        leptonica.pixWriteStreamJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteStreamJpeg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamJpeg(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'progressive')       
  pixWriteStreamJpeg()

      Input:  stream
              pixs  (any depth; cmap is OK)
              quality  (1 - 100; 75 is default value; 0 is also default)
              progressive (0 for baseline sequential; 1 for progressive)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Progressive encoding gives better compression, at the
          expense of slower encoding and decoding.
      (2) Standard chroma subsampling is 2x2 on both the U and V
          channels.  For highest quality, use no subsampling; this
          option is set by pixSetChromaSampling(pix, 0).
      (3) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
          and 32 bpp.  However, it is possible, and in some cases desirable,
          to write out a jpeg file using an rgb pix that has 24 bpp.
          This can be created by appending the raster data for a 24 bpp
          image (with proper scanline padding) directly to a 24 bpp
          pix that was created without a data array.
      (4) There are two compression paths in this function:
          * Grayscale image, no colormap: compress as 8 bpp image.
          * rgb full color image: copy each line into the color
            line buffer, and compress as three 8 bpp images.
      (5) Under the covers, the jpeg library transforms rgb to a
          luminance-chromaticity triple, each component of which is
          also 8 bits, and compresses that.  It uses 2 Huffman tables,
          a higher resolution one (with more quantization levels)
          for luminosity and a lower resolution one for the chromas.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamJpeg(*args)
    
    

    try:
        leptonica.pixReadStreamJpeg.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadStreamJpeg.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamJpeg(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'cmflag')       
('l_int32', 'reduction')       
('l_int32', '*pnwarn')       
('l_int32', 'hint')       
  pixReadStreamJpeg()

      Input:  stream
              colormap flag (0 means return RGB image if color;
                             1 means create a colormap and return
                             an 8 bpp colormapped image if color)
              reduction (scaling factor: 1, 2, 4 or 8)
              &nwarn (<optional return> number of warnings)
              hint (a bitwise OR of L_JPEG_* values; 0 for default)
      Return: pix, or null on error

  Usage: see pixReadJpeg()
  Notes:
      (1) This does not get the jpeg comment.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamJpeg(*args)
    
    

    try:
        leptonica.readHeaderJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderJpeg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderJpeg(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
('l_int32', '*pycck')       
('l_int32', '*pcmyk')       
  readHeaderJpeg()

      Input:  filename
              &w (<optional return>)
              &h (<optional return>)
              &spp (<optional return>, samples/pixel)
              &ycck (<optional return>, 1 if ycck color space; 0 otherwise)
              &cmyk (<optional return>, 1 if cmyk color space; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderJpeg(*args)
    
    

    try:
        leptonica.pixSetChromaSampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetChromaSampling.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetChromaSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetChromaSampling(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'sampling')       
  pixSetChromaSampling()

      Input:  pix
              sampling (1 for subsampling; 0 for no subsampling)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The default is for 2x2 chroma subsampling because the files are
          considerably smaller and the appearance is typically satisfactory.
          Call this with @sampling == 0 for full resolution output in
          chroma channels for jpeg writing.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetChromaSampling(*args)
    
    

    try:
        leptonica.pixReadMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadMemJpeg.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemJpeg(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', 'cmflag')       
('l_int32', 'reduction')       
('l_int32', '*pnwarn')       
('l_int32', 'hint')       
  pixReadMemJpeg()

      Input:  data (const; jpeg-encoded)
              size (of data)
              colormap flag (0 means return RGB image if color;
                             1 means create a colormap and return
                             an 8 bpp colormapped image if color)
              reduction (scaling factor: 1, 2, 4 or 8)
              &nwarn (<optional return> number of warnings)
              hint (a bitwise OR of L_JPEG_* values; 0 for default)
      Return: pix, or null on error

  Notes:
      (1) The @size byte of @data must be a null character.
      (2) The only hint flag so far is L_JPEG_READ_LUMINANCE,
          given in the enum in imageio.h.
      (3) See pixReadJpeg() for usage.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemJpeg(*args)
    




class binreduce(object):
    """  binreduce.c

      Subsampled 2x reduction
           PIX      *pixReduceBinary2()

      Rank filtered 2x reductions
           PIX      *pixReduceRankBinaryCascade()
           PIX      *pixReduceRankBinary2()

      Permutation table for 2x rank binary reduction
           l_uint8  *makeSubsampleTab2x(void)

"""
    
    try:
        leptonica.pixReduceRankBinaryCascade.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReduceRankBinaryCascade.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReduceRankBinaryCascade not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReduceRankBinaryCascade(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level1')       
('l_int32', 'level2')       
('l_int32', 'level3')       
('l_int32', 'level4')       
  pixReduceRankBinaryCascade()

      Input:  pixs (1 bpp)
              level1, ... level 4 (thresholds, in the set {0, 1, 2, 3, 4})
      Return: pixd, or null on error

  Notes:
      (1) This performs up to four cascaded 2x rank reductions.
      (2) Use level = 0 to truncate the cascade.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReduceRankBinaryCascade(*args)
    
    

    try:
        leptonica.makeSubsampleTab2x.argtypes = []
        leptonica.makeSubsampleTab2x.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function makeSubsampleTab2x not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeSubsampleTab2x(*args):
        """
               
  makeSubsampleTab2x()

  This table permutes the bits in a byte, from
      0 4 1 5 2 6 3 7
  to
      0 1 2 3 4 5 6 7


        """
        args = _convert_params(*args)
        
        return leptonica.makeSubsampleTab2x(*args)
    
    

    try:
        leptonica.pixReduceBinary2.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixReduceBinary2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReduceBinary2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReduceBinary2(*args):
        """
        ('PIX', '*pixs')       
('l_uint8', '*intab')       
  pixReduceBinary2()

      Input:  pixs
              tab (<optional>; if null, a table is made here
                   and destroyed before exit)
      Return: pixd (2x subsampled), or null on error

  Notes:
      (1) After folding, the data is in bytes 0 and 2 of the word,
          and the bits in each byte are in the following order
          (with 0 being the leftmost originating pair and 7 being
          the rightmost originating pair):
               0 4 1 5 2 6 3 7
          These need to be permuted to
               0 1 2 3 4 5 6 7
          which is done with an 8-bit table generated by makeSubsampleTab2x().


        """
        args = _convert_params(*args)
        
        return leptonica.pixReduceBinary2(*args)
    
    

    try:
        leptonica.pixReduceRankBinary2.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixReduceRankBinary2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReduceRankBinary2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReduceRankBinary2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_uint8', '*intab')       
  pixReduceRankBinary2()

      Input:  pixs (1 bpp)
              level (rank threshold: 1, 2, 3, 4)
              intab (<optional>; if null, a table is made here
                     and destroyed before exit)
      Return: pixd (1 bpp, 2x rank threshold reduced), or null on error

  Notes:
      (1) pixd is downscaled by 2x from pixs.
      (2) The rank threshold specifies the minimum number of ON
          pixels in each 2x2 region of pixs that are required to
          set the corresponding pixel ON in pixd.
      (3) Rank filtering is done to the UL corner of each 2x2 pixel block,
          using only logical operations.  Then these pixels are chosen
          in the 2x subsampling process, subsampled, as described
          above in pixReduceBinary2().


        """
        args = _convert_params(*args)
        
        return leptonica.pixReduceRankBinary2(*args)
    




class pixacc(object):
    """   pixacc.c

      Pixacc creation, destruction
           PIXACC   *pixaccCreate()
           PIXACC   *pixaccCreateFromPix()
           void      pixaccDestroy()

      Pixacc finalization
           PIX      *pixaccFinal()

      Pixacc accessors
           PIX      *pixaccGetPix()
           l_int32   pixaccGetOffset()

      Pixacc accumulators
           l_int32   pixaccAdd()
           l_int32   pixaccSubtract()
           l_int32   pixaccMultConst()
           l_int32   pixaccMultConstAccumulate()

  This is a simple interface for some of the pixel arithmetic operations
  in pixarith.c.  These are easy to code up, but not as fast as
  hand-coded functions that do arithmetic on corresponding pixels.

  Suppose you want to make a linear combination of pix1 and pix2:
     pixd = 0.4 * pix1 + 0.6 * pix2
  where pix1 and pix2 are the same size and have depth 'd'.  Then:
     Pixacc *pacc = pixaccCreateFromPix(pix1, 0);  // first; addition only
     pixaccMultConst(pacc, 0.4);
     pixaccMultConstAccumulate(pacc, pix2, 0.6);  // Add in 0.6 of the second
     pixd = pixaccFinal(pacc, d);  // Get the result
     pixaccDestroy(&pacc);

"""
    
    try:
        leptonica.pixaccDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixaccDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixaccDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccDestroy(*args):
        """
        ('PIXACC', '**ppixacc')       
  pixaccDestroy()

      Input:  &pixacc (<can be null>)
      Return: void

  Notes:
      (1) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccDestroy(*args)
    
    

    try:
        leptonica.pixaccSubtract.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaccSubtract.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaccSubtract not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccSubtract(*args):
        """
        ('PIXACC', '*pixacc')       
('PIX', '*pix')       
  pixaccSubtract()

      Input:  pixacc
              pix (to be subtracted)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccSubtract(*args)
    
    

    try:
        leptonica.pixaccMultConstAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixaccMultConstAccumulate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaccMultConstAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccMultConstAccumulate(*args):
        """
        ('PIXACC', '*pixacc')       
('PIX', '*pix')       
('l_float32', 'factor')       
  pixaccMultConstAccumulate()

      Input:  pixacc
              pix
              factor
      Return: 0 if OK, 1 on error

  Notes:
      (1) This creates a temp pix that is @pix multiplied by the
          constant @factor.  It then adds that into @pixacc.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccMultConstAccumulate(*args)
    
    

    try:
        leptonica.pixaccFinal.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaccFinal.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaccFinal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccFinal(*args):
        """
        ('PIXACC', '*pixacc')       
('l_int32', 'outdepth')       
  pixaccFinal()

      Input:  pixacc
              outdepth (8, 16 or 32 bpp)
      Return: pixd (8 , 16 or 32 bpp), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccFinal(*args)
    
    

    try:
        leptonica.pixaccMultConst.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixaccMultConst.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaccMultConst not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccMultConst(*args):
        """
        ('PIXACC', '*pixacc')       
('l_float32', 'factor')       
  pixaccMultConst()

      Input:  pixacc
              factor
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccMultConst(*args)
    
    

    try:
        leptonica.pixaccGetOffset.argtypes = [ctypes.c_void_p]
        leptonica.pixaccGetOffset.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaccGetOffset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccGetOffset(*args):
        """
        ('PIXACC', '*pixacc')       
  pixaccGetOffset()

      Input:  pixacc
      Return: offset, or -1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccGetOffset(*args)
    
    

    try:
        leptonica.pixaccGetPix.argtypes = [ctypes.c_void_p]
        leptonica.pixaccGetPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaccGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccGetPix(*args):
        """
        ('PIXACC', '*pixacc')       
  pixaccGetPix()

      Input:  pixacc
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccGetPix(*args)
    
    

    try:
        leptonica.pixaccCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaccCreate.restype = lambda address: PIXACC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaccCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccCreate(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'negflag')       
  pixaccCreate()

      Input:  w, h (of 32 bpp internal Pix)
              negflag (0 if only positive numbers are involved;
                       1 if there will be negative numbers)
      Return: pixacc, or null on error

  Notes:
      (1) Use @negflag = 1 for safety if any negative numbers are going
          to be used in the chain of operations.  Negative numbers
          arise, e.g., by subtracting a pix, or by adding a pix
          that has been pre-multiplied by a negative number.
      (2) Initializes the internal 32 bpp pix, similarly to the
          initialization in pixInitAccumulate().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccCreate(*args)
    
    

    try:
        leptonica.pixaccCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaccCreateFromPix.restype = lambda address: PIXACC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaccCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'negflag')       
  pixaccCreateFromPix()

      Input:  pix
              negflag (0 if only positive numbers are involved;
                       1 if there will be negative numbers)
      Return: pixacc, or null on error

  Notes:
      (1) See pixaccCreate()


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccCreateFromPix(*args)
    
    

    try:
        leptonica.pixaccAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaccAdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaccAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccAdd(*args):
        """
        ('PIXACC', '*pixacc')       
('PIX', '*pix')       
  pixaccAdd()

      Input:  pixacc
              pix (to be added)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccAdd(*args)
    




class pngiostub(object):
    """  pngiostub.c

     Stubs for pngio.c functions

"""
    



class affinecompose(object):
    """  affinecompose.c

      Composable coordinate transforms
           l_float32   *createMatrix2dTranslate()
           l_float32   *createMatrix2dScale()
           l_float32   *createMatrix2dRotate()

      Special coordinate transforms on pta
           PTA         *ptaTranslate()
           PTA         *ptaScale()
           PTA         *ptaRotate()

      Special coordinate transforms on boxa
           BOXA        *boxaTranslate()
           BOXA        *boxaScale()
           BOXA        *boxaRotate()

      General coordinate transform on pta and boxa
           PTA         *ptaAffineTransform()
           BOXA        *boxaAffineTransform()

      Matrix operations
           l_int32      l_productMatVec()
           l_int32      l_productMat2()
           l_int32      l_productMat3()
           l_int32      l_productMat4()

"""
    
    try:
        leptonica.ptaScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.ptaScale.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaScale(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  ptaScale()

      Input:  ptas (for initial points)
              scalex  (horizontal scale factor)
              scaley  (vertical scale factor)
      Return: 0 if OK; 1 on error

  Notes;
      (1) See createMatrix2dScale() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaScale(*args)
    
    

    try:
        leptonica.boxaTranslate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.boxaTranslate.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaTranslate(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'transx')       
('l_float32', 'transy')       
  boxaTranslate()

      Input:  boxas
              transx  (x component of translation wrt. the origin)
              transy  (y component of translation wrt. the origin)
      Return: boxad  (translated boxas), or null on error

  Notes;
      (1) See createMatrix2dTranslate() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaTranslate(*args)
    
    

    try:
        leptonica.boxaAffineTransform.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaAffineTransform.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaAffineTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAffineTransform(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', '*mat')       
  boxaAffineTransform()

      Input:  boxas
              mat  (3x3 transform matrix; canonical form)
      Return: boxad  (transformed boxas), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAffineTransform(*args)
    
    

    try:
        leptonica.l_productMat3.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMat3.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_productMat3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMat3(*args):
        """
        ('l_float32', '*mat1')       
('l_float32', '*mat2')       
('l_float32', '*mat3')       
('l_float32', '*matd')       
('l_int32', 'size')       
  l_productMat3()

      Input:  mat1  (square matrix, as a 1-dimensional size^2 array)
              mat2  (square matrix, as a 1-dimensional size^2 array)
              mat3  (square matrix, as a 1-dimensional size^2 array)
              matd  (square matrix; product stored here)
              size  (of matrices)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMat3(*args)
    
    

    try:
        leptonica.ptaAffineTransform.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaAffineTransform.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaAffineTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaAffineTransform(*args):
        """
        ('PTA', '*ptas')       
('l_float32', '*mat')       
  ptaAffineTransform()

      Input:  ptas (for initial points)
              mat  (3x3 transform matrix; canonical form)
      Return: ptad  (transformed points), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaAffineTransform(*args)
    
    

    try:
        leptonica.boxaScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.boxaScale.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaScale(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  boxaScale()

      Input:  boxas
              scalex  (horizontal scale factor)
              scaley  (vertical scale factor)
      Return: boxad  (scaled boxas), or null on error

  Notes;
      (1) See createMatrix2dScale() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaScale(*args)
    
    

    try:
        leptonica.l_productMatVec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMatVec.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_productMatVec not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMatVec(*args):
        """
        ('l_float32', '*mat')       
('l_float32', '*vecs')       
('l_float32', '*vecd')       
('l_int32', 'size')       
  l_productMatVec()

      Input:  mat  (square matrix, as a 1-dimensional @size^2 array)
              vecs (input column vector of length @size)
              vecd (result column vector)
              size (matrix is @size x @size; vectors are length @size)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMatVec(*args)
    
    

    try:
        leptonica.createMatrix2dTranslate.argtypes = [ctypes.c_float, ctypes.c_float]
        leptonica.createMatrix2dTranslate.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        os.stderr.write("Warning - function createMatrix2dTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def createMatrix2dTranslate(*args):
        """
        ('l_float32', 'transx')       
('l_float32', 'transy')       
  createMatrix2dTranslate()

      Input:  transx  (x component of translation wrt. the origin)
              transy  (y component of translation wrt. the origin)
      Return: 3x3 transform matrix, or null on error

  Notes;
      (1) The translation is equivalent to:
             v' = Av
          where v and v' are 1x3 column vectors in the form
             v = [x, y, 1]^    (^ denotes transpose)
          and the affine tranlation matrix is
             A = [ 1   0   tx
                   0   1   ty
                   0   0    1  ]

      (2) We consider translation as with respect to a fixed origin.
          In a clipping operation, the origin moves and the points
          are fixed, and you use (-tx, -ty) where (tx, ty) is the
          translation vector of the origin.


        """
        args = _convert_params(*args)
        
        return leptonica.createMatrix2dTranslate(*args)
    
    

    try:
        leptonica.ptaTranslate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.ptaTranslate.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTranslate(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'transx')       
('l_float32', 'transy')       
  ptaTranslate()

      Input:  ptas (for initial points)
              transx  (x component of translation wrt. the origin)
              transy  (y component of translation wrt. the origin)
      Return: ptad  (translated points), or null on error

  Notes;
      (1) See createMatrix2dTranslate() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTranslate(*args)
    
    

    try:
        leptonica.createMatrix2dScale.argtypes = [ctypes.c_float, ctypes.c_float]
        leptonica.createMatrix2dScale.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        os.stderr.write("Warning - function createMatrix2dScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def createMatrix2dScale(*args):
        """
        ('l_float32', 'scalex')       
('l_float32', 'scaley')       
  createMatrix2dScale()

      Input:  scalex  (horizontal scale factor)
              scaley  (vertical scale factor)
      Return: 3x3 transform matrix, or null on error

  Notes;
      (1) The scaling is equivalent to:
             v' = Av
          where v and v' are 1x3 column vectors in the form
             v = [x, y, 1]^    (^ denotes transpose)
          and the affine scaling matrix is
             A = [ sx  0    0
                   0   sy   0
                   0   0    1  ]

      (2) We consider scaling as with respect to a fixed origin.
          In other words, the origin is the only point that doesn't
          move in the scaling transform.


        """
        args = _convert_params(*args)
        
        return leptonica.createMatrix2dScale(*args)
    
    

    try:
        leptonica.ptaRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.ptaRotate.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRotate(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'xc')       
('l_float32', 'yc')       
('l_float32', 'angle')       
  ptaRotate()

      Input:  ptas (for initial points)
              (xc, yc)  (location of center of rotation)
              angle  (rotation in radians; clockwise is positive)
      Return: 0 if OK; 1 on error

  Notes;
      (1) See createMatrix2dScale() for details of transform.
      (2) This transform can be thought of as composed of the
          sum of two parts:
          (a) an (x,y)-dependent rotation about the origin:
              xr = x * cosa - y * sina
              yr = x * sina + y * cosa
          (b) an (x,y)-independent translation that depends on the
              rotation center and the angle:
              xt = xc - xc * cosa + yc * sina
              yt = yc - xc * sina - yc * cosa
          The translation part (xt,yt) is equal to the difference
          between the center (xc,yc) and the location of the
          center after it is rotated about the origin.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRotate(*args)
    
    

    try:
        leptonica.boxaRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.boxaRotate.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRotate(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'xc')       
('l_float32', 'yc')       
('l_float32', 'angle')       
  boxaRotate()

      Input:  boxas
              (xc, yc)  (location of center of rotation)
              angle  (rotation in radians; clockwise is positive)
      Return: boxad  (scaled boxas), or null on error

  Notes;
      (1) See createMatrix2dRotate() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRotate(*args)
    
    

    try:
        leptonica.l_productMat4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMat4.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_productMat4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMat4(*args):
        """
        ('l_float32', '*mat1')       
('l_float32', '*mat2')       
('l_float32', '*mat3')       
('l_float32', '*mat4')       
('l_float32', '*matd')       
('l_int32', 'size')       
  l_productMat4()

      Input:  mat1  (square matrix, as a 1-dimensional size^2 array)
              mat2  (square matrix, as a 1-dimensional size^2 array)
              mat3  (square matrix, as a 1-dimensional size^2 array)
              mat4  (square matrix, as a 1-dimensional size^2 array)
              matd  (square matrix; product stored here)
              size  (of matrices)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMat4(*args)
    
    

    try:
        leptonica.createMatrix2dRotate.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.createMatrix2dRotate.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        os.stderr.write("Warning - function createMatrix2dRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def createMatrix2dRotate(*args):
        """
        ('l_float32', 'xc')       
('l_float32', 'yc')       
('l_float32', 'angle')       
  createMatrix2dRotate()

      Input:  xc, yc  (location of center of rotation)
              angle  (rotation in radians; clockwise is positive)
      Return: 3x3 transform matrix, or null on error

  Notes;
      (1) The rotation is equivalent to:
             v' = Av
          where v and v' are 1x3 column vectors in the form
             v = [x, y, 1]^    (^ denotes transpose)
          and the affine rotation matrix is
             A = [ cosa   -sina    xc*(1-cosa) + yc*sina
                   sina    cosa    yc*(1-cosa) - xc*sina
                     0       0                 1         ]

          If the rotation is about the origin, (xc, yc) = (0, 0) and
          this simplifies to
             A = [ cosa   -sina    0
                   sina    cosa    0
                     0       0     1 ]

          These relations follow from the following equations, which
          you can convince yourself are correct as follows.  Draw a
          circle centered on (xc,yc) and passing through (x,y), with
          (x',y') on the arc at an angle 'a' clockwise from (x,y).
          [ Hint: cos(a + b) = cosa * cosb - sina * sinb
                  sin(a + b) = sina * cosb + cosa * sinb ]

            x' - xc =  (x - xc) * cosa - (y - yc) * sina
            y' - yc =  (x - xc) * sina + (y - yc) * cosa


        """
        args = _convert_params(*args)
        
        return leptonica.createMatrix2dRotate(*args)
    
    

    try:
        leptonica.l_productMat2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMat2.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_productMat2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMat2(*args):
        """
        ('l_float32', '*mat1')       
('l_float32', '*mat2')       
('l_float32', '*matd')       
('l_int32', 'size')       
  l_productMat2()

      Input:  mat1  (square matrix, as a 1-dimensional size^2 array)
              mat2  (square matrix, as a 1-dimensional size^2 array)
              matd  (square matrix; product stored here)
              size (of matrices)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMat2(*args)
    




class queue(object):
    """   queue.c

      Create/Destroy L_Queue
          L_QUEUE        *lqueueCreate()
          void           *lqueueDestroy()

      Operations to add/remove to/from a L_Queue
          l_int32         lqueueAdd()
          static l_int32  lqueueExtendArray()
          void           *lqueueRemove()

      Accessors
          l_int32         lqueueGetCount()

      Debug output
          l_int32         lqueuePrint()

    The lqueue is a fifo that implements a queue of void* pointers.
    It can be used to hold a queue of any type of struct.
    Internally, it maintains two counters:
        nhead:  location of head (in ptrs) from the beginning
                of the buffer
        nelem:  number of ptr elements stored in the queue
    As items are added to the queue, nelem increases.
    As items are removed, nhead increases and nelem decreases.
    Any time the tail reaches the end of the allocated buffer,
      all the pointers are shifted to the left, so that the head
      is at the beginning of the array.
    If the buffer becomes more than 3/4 full, it doubles in size.

    [A circular queue would allow us to skip the shifting and
    to resize only when the buffer is full.  For most applications,
    the extra work we do for a linear queue is not significant.]

"""
    
    try:
        leptonica.lqueuePrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lqueuePrint.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lqueuePrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueuePrint(*args):
        """
        ('FILE', '*fp')       
('L_QUEUE', '*lq')       
  lqueuePrint()

      Input:  stream
              lqueue
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lqueuePrint(*args)
    
    

    try:
        leptonica.lqueueRemove.argtypes = [ctypes.c_void_p]
        leptonica.lqueueRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function lqueueRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueRemove(*args):
        """
        ('L_QUEUE', '*lq')       
  lqueueRemove()

      Input:  lqueue
      Return: ptr to item popped from the head of the queue,
              or null if the queue is empty or on error

  Notes:
      (1) If this is the last item on the queue, so that the queue
          becomes empty, nhead is reset to the beginning of the array.


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueRemove(*args)
    
    

    try:
        leptonica.lqueueGetCount.argtypes = [ctypes.c_void_p]
        leptonica.lqueueGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lqueueGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueGetCount(*args):
        """
        ('L_QUEUE', '*lq')       
  lqueueGetCount()

      Input:  lqueue
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueGetCount(*args)
    
    

    try:
        leptonica.lqueueAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lqueueAdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lqueueAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueAdd(*args):
        """
        ('L_QUEUE', '*lq')       
('void', '*item')       
  lqueueAdd()

      Input:  lqueue
              item to be added to the tail of the queue
      Return: 0 if OK, 1 on error

  Notes:
      (1) The algorithm is as follows.  If the queue is populated
          to the end of the allocated array, shift all ptrs toward
          the beginning of the array, so that the head of the queue
          is at the beginning of the array.  Then, if the array is
          more than 0.75 full, realloc with double the array size.
          Finally, add the item to the tail of the queue.


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueAdd(*args)
    
    

    try:
        leptonica.lqueueCreate.argtypes = [ctypes.c_int32]
        leptonica.lqueueCreate.restype = lambda address: L_QUEUE(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function lqueueCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueCreate(*args):
        """
        ('l_int32', 'nalloc')       
  lqueueCreate()

      Input:  size of ptr array to be alloc'd (0 for default)
      Return: lqueue, or null on error

  Notes:
      (1) Allocates a ptr array of given size, and initializes counters.


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueCreate(*args)
    
    

    try:
        leptonica.lqueueDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lqueueDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function lqueueDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueDestroy(*args):
        """
        ('L_QUEUE', '**plq')       
('l_int32', 'freeflag')       
  lqueueDestroy()

      Input:  &lqueue  (<to be nulled>)
              freeflag (TRUE to free each remaining struct in the array)
      Return: void

  Notes:
      (1) If freeflag is TRUE, frees each struct in the array.
      (2) If freeflag is FALSE but there are elements on the array,
          gives a warning and destroys the array.  This will
          cause a memory leak of all the items that were on the queue.
          So if the items require their own destroy function, they
          must be destroyed before the queue.  The same applies to the
          auxiliary stack, if it is used.
      (3) To destroy the L_Queue, we destroy the ptr array, then
          the lqueue, and then null the contents of the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueDestroy(*args)
    




class morph(object):
    """  morph.c

     Generic binary morphological ops implemented with rasterop
         PIX     *pixDilate()
         PIX     *pixErode()
         PIX     *pixHMT()
         PIX     *pixOpen()
         PIX     *pixClose()
         PIX     *pixCloseSafe()
         PIX     *pixOpenGeneralized()
         PIX     *pixCloseGeneralized()

     Binary morphological (raster) ops with brick Sels
         PIX     *pixDilateBrick()
         PIX     *pixErodeBrick()
         PIX     *pixOpenBrick()
         PIX     *pixCloseBrick()
         PIX     *pixCloseSafeBrick()

     Binary composed morphological (raster) ops with brick Sels
         l_int32  selectComposableSels()
         l_int32  selectComposableSizes()
         PIX     *pixDilateCompBrick()
         PIX     *pixErodeCompBrick()
         PIX     *pixOpenCompBrick()
         PIX     *pixCloseCompBrick()
         PIX     *pixCloseSafeCompBrick()

     Functions associated with boundary conditions
         void     resetMorphBoundaryCondition()
         l_int32  getMorphBorderPixelColor()

     Static helpers for arg processing
         static PIX     *processMorphArgs1()
         static PIX     *processMorphArgs2()

  You are provided with many simple ways to do binary morphology.
  In particular, if you are using brick Sels, there are six
  convenient methods, all specially tailored for separable operations
  on brick Sels.  A "brick" Sel is a Sel that is a rectangle
  of solid SEL_HITs with the origin at or near the center.
  Note that a brick Sel can have one dimension of size 1.
  This is very common.  All the brick Sel operations are
  separable, meaning the operation is done first in the horizontal
  direction and then in the vertical direction.  If one of the
  dimensions is 1, this is a special case where the operation is
  only performed in the other direction.

  These six brick Sel methods are enumerated as follows:

  (1) Brick Sels: pix*Brick(), where * = {Dilate, Erode, Open, Close}.
      These are separable rasterop implementations.  The Sels are
      automatically generated, used, and destroyed at the end.
      You can get the result as a new Pix, in-place back into the src Pix,
      or written to another existing Pix.

  (2) Brick Sels: pix*CompBrick(), where * = {Dilate, Erode, Open, Close}.
      These are separable, 2-way composite, rasterop implementations.
      The Sels are automatically generated, used, and destroyed at the end.
      You can get the result as a new Pix, in-place back into the src Pix,
      or written to another existing Pix.  For large Sels, these are
      considerably faster than the corresponding pix*Brick() functions.
      N.B.:  The size of the Sels that are actually used are typically
      close to, but not exactly equal to, the size input to the function.

  (3) Brick Sels: pix*BrickDwa(), where * = {Dilate, Erode, Open, Close}.
      These are separable dwa (destination word accumulation)
      implementations.  They use auto-gen'd dwa code.  You can get
      the result as a new Pix, in-place back into the src Pix,
      or written to another existing Pix.  This is typically
      about 3x faster than the analogous rasterop pix*Brick()
      function, but it has the limitation that the Sel size must
      be less than 63.  This is pre-set to work on a number
      of pre-generated Sels.  If you want to use other Sels, the
      code can be auto-gen'd for them; see the instructions in morphdwa.c.

  (4) Same as (1), but you run it through pixMorphSequence(), with
      the sequence string either compiled in or generated using sprintf.
      All intermediate images and Sels are created, used and destroyed.
      You always get the result as a new Pix.  For example, you can
      specify a separable 11 x 17 brick opening as "o11.17",
      or you can specify the horizontal and vertical operations
      explicitly as "o11.1 + o1.11".  See morphseq.c for details.

  (5) Same as (2), but you run it through pixMorphCompSequence(), with
      the sequence string either compiled in or generated using sprintf.
      All intermediate images and Sels are created, used and destroyed.
      You always get the result as a new Pix.  See morphseq.c for details.

  (6) Same as (3), but you run it through pixMorphSequenceDwa(), with
      the sequence string either compiled in or generated using sprintf.
      All intermediate images and Sels are created, used and destroyed.
      You always get the result as a new Pix.  See morphseq.c for details.

  If you are using Sels that are not bricks, you have two choices:
      (a) simplest: use the basic rasterop implementations (pixDilate(), ...)
      (b) fastest: generate the destination word accumumlation (dwa)
          code for your Sels and compile it with the library.

      For an example, see flipdetect.c, which gives implementations
      using hit-miss Sels with both the rasterop and dwa versions.
      For the latter, the dwa code resides in fliphmtgen.c, and it
      was generated by prog/flipselgen.c.  Both the rasterop and dwa
      implementations are tested by prog/fliptest.c.

  A global constant MORPH_BC is used to set the boundary conditions
  for rasterop-based binary morphology.  MORPH_BC, in morph.c,
  is set by default to ASYMMETRIC_MORPH_BC for a non-symmetric
  convention for boundary pixels in dilation and erosion:
      All pixels outside the image are assumed to be OFF
      for both dilation and erosion.
  To use a symmetric definition, see comments in pixErode()
  and reset MORPH_BC to SYMMETRIC_MORPH_BC, using
  resetMorphBoundaryCondition().

  Boundary artifacts are possible in closing when the non-symmetric
  boundary conditions are used, because foreground pixels very close
  to the edge can be removed.  This can be avoided by using either
  the symmetric boundary conditions or the function pixCloseSafe(),
  which adds a border before the operation and removes it afterwards.

  The hit-miss transform (HMT) is the bit-and of 2 erosions:
     (erosion of the src by the hits)  &  (erosion of the bit-inverted
                                           src by the misses)

  The 'generalized opening' is an HMT followed by a dilation that uses
  only the hits of the hit-miss Sel.
  The 'generalized closing' is a dilation (again, with the hits
  of a hit-miss Sel), followed by the HMT.
  Both of these 'generalized' functions are idempotent.

  These functions are extensively tested in prog/binmorph1_reg.c,
  prog/binmorph2_reg.c, and prog/binmorph3_reg.c.

"""
    
    try:
        leptonica.pixCloseSafeBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseSafeBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseSafeBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseSafeBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseSafeBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do separably if both hsize and vsize are > 1.
      (4) Safe closing adds a border of 0 pixels, of sufficient size so
          that all pixels in input image are processed within
          32-bit words in the expanded image.  As a result, there is
          no special processing for pixels near the boundary, and there
          are no boundary effects.  The border is removed at the end.
      (5) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (6) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseBrick(NULL, pixs, ...);
          (b) pixCloseBrick(pixs, pixs, ...);
          (c) pixCloseBrick(pixd, pixs, ...);
      (7) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseSafeBrick(*args)
    
    

    try:
        leptonica.pixOpenBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do separably if both hsize and vsize are > 1.
      (4) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (5) For clarity, if the case is known, use these patterns:
          (a) pixd = pixOpenBrick(NULL, pixs, ...);
          (b) pixOpenBrick(pixs, pixs, ...);
          (c) pixOpenBrick(pixd, pixs, ...);
      (6) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenBrick(*args)
    
    

    try:
        leptonica.pixDilateBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do separably if both hsize and vsize are > 1.
      (4) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (5) For clarity, if the case is known, use these patterns:
          (a) pixd = pixDilateBrick(NULL, pixs, ...);
          (b) pixDilateBrick(pixs, pixs, ...);
          (c) pixDilateBrick(pixd, pixs, ...);
      (6) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateBrick(*args)
    
    

    try:
        leptonica.pixOpenGeneralized.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOpenGeneralized.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenGeneralized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenGeneralized(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixOpenGeneralized()

      Input:  pixd (<optional>; this can be null, equal to pixs,
                    or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) Generalized morphological opening, using both hits and
          misses in the Sel.
      (2) This does a hit-miss transform, followed by a dilation
          using the hits.
      (3) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (4) For clarity, if the case is known, use these patterns:
          (a) pixd = pixOpenGeneralized(NULL, pixs, ...);
          (b) pixOpenGeneralized(pixs, pixs, ...);
          (c) pixOpenGeneralized(pixd, pixs, ...);
      (5) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenGeneralized(*args)
    
    

    try:
        leptonica.getMorphBorderPixelColor.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.getMorphBorderPixelColor.restype = ctypes.c_uint32
    except AttributeError:
        os.stderr.write("Warning - function getMorphBorderPixelColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getMorphBorderPixelColor(*args):
        """
        ('l_int32', 'type')       
('l_int32', 'depth')       
  getMorphBorderPixelColor()

      Input:  type (L_MORPH_DILATE, L_MORPH_ERODE)
              depth (of pix)
      Return: color of border pixels for this operation


        """
        args = _convert_params(*args)
        
        return leptonica.getMorphBorderPixelColor(*args)
    
    

    try:
        leptonica.pixHMT.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixHMT.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHMT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHMT(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixHMT()

      Input:  pixd (<optional>; this can be null, equal to pixs,
                    or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) The hit-miss transform erodes the src, using both hits
          and misses in the Sel.  It ANDs the shifted src for hits
          and ANDs the inverted shifted src for misses.
      (2) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (3) For clarity, if the case is known, use these patterns:
          (a) pixd = pixHMT(NULL, pixs, ...);
          (b) pixHMT(pixs, pixs, ...);
          (c) pixHMT(pixd, pixs, ...);
      (4) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHMT(*args)
    
    

    try:
        leptonica.resetMorphBoundaryCondition.argtypes = [ctypes.c_int32]
        leptonica.resetMorphBoundaryCondition.restype = None
    except AttributeError:
        os.stderr.write("Warning - function resetMorphBoundaryCondition not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def resetMorphBoundaryCondition(*args):
        """
        ('l_int32', 'bc')       
  resetMorphBoundaryCondition()

      Input:  bc (SYMMETRIC_MORPH_BC, ASYMMETRIC_MORPH_BC)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.resetMorphBoundaryCondition(*args)
    
    

    try:
        leptonica.pixCloseSafe.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCloseSafe.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseSafe not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseSafe(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixCloseSafe()

      Input:  pixd (<optional>; this can be null, equal to pixs,
                    or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) Generic morphological closing, using hits in the Sel.
      (2) If non-symmetric boundary conditions are used, this
          function adds a border of OFF pixels that is of
          sufficient size to avoid losing pixels from the dilation,
          and it removes the border after the operation is finished.
          It thus enforces a correct extensive result for closing.
      (3) If symmetric b.c. are used, it is not necessary to add
          and remove this border.
      (4) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (5) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseSafe(NULL, pixs, ...);
          (b) pixCloseSafe(pixs, pixs, ...);
          (c) pixCloseSafe(pixd, pixs, ...);
      (6) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseSafe(*args)
    
    

    try:
        leptonica.pixDilateCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateCompBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateCompBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do compositely for each dimension > 1.
      (4) Do separably if both hsize and vsize are > 1.
      (5) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (6) For clarity, if the case is known, use these patterns:
          (a) pixd = pixDilateCompBrick(NULL, pixs, ...);
          (b) pixDilateCompBrick(pixs, pixs, ...);
          (c) pixDilateCompBrick(pixd, pixs, ...);
      (7) The dimensions of the resulting image are determined by pixs.
      (8) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
          but not necessarily equal to it.  It attempts to optimize:
             (a) for consistency with the input values: the product
                 of terms is close to the input size
             (b) for efficiency of the operation: the sum of the
                 terms is small; ideally about twice the square
                 root of the input size.
          So, for example, if the input hsize = 37, which is
          a prime number, the decomposer will break this into two
          terms, 6 and 6, so that the net result is a dilation
          with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateCompBrick(*args)
    
    

    try:
        leptonica.pixCloseCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseCompBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseCompBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do compositely for each dimension > 1.
      (4) Do separably if both hsize and vsize are > 1.
      (5) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (6) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseCompBrick(NULL, pixs, ...);
          (b) pixCloseCompBrick(pixs, pixs, ...);
          (c) pixCloseCompBrick(pixd, pixs, ...);
      (7) The dimensions of the resulting image are determined by pixs.
      (8) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
          but not necessarily equal to it.  It attempts to optimize:
             (a) for consistency with the input values: the product
                 of terms is close to the input size
             (b) for efficiency of the operation: the sum of the
                 terms is small; ideally about twice the square
                 root of the input size.
          So, for example, if the input hsize = 37, which is
          a prime number, the decomposer will break this into two
          terms, 6 and 6, so that the net result is a dilation
          with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseCompBrick(*args)
    
    

    try:
        leptonica.selectComposableSizes.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selectComposableSizes.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selectComposableSizes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selectComposableSizes(*args):
        """
        ('l_int32', 'size')       
('l_int32', '*pfactor1')       
('l_int32', '*pfactor2')       
  selectComposableSizes()

      Input:  size (of sel to be decomposed)
              &factor1 (<return> larger factor)
              &factor2 (<return> smaller factor)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This works for Sel sizes up to 62500, which seems sufficient.
      (2) The composable sel size is typically within +- 1 of
          the requested size.  Up to size = 300, the maximum difference
          is +- 2.
      (3) We choose an overall cost function where the penalty for
          the size difference between input and actual is 4 times
          the penalty for additional rasterops.
      (4) Returned values: factor1 >= factor2
          If size > 1, then factor1 > 1.


        """
        args = _convert_params(*args)
        
        return leptonica.selectComposableSizes(*args)
    
    

    try:
        leptonica.pixCloseSafeCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseSafeCompBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseSafeCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseSafeCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseSafeCompBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do compositely for each dimension > 1.
      (4) Do separably if both hsize and vsize are > 1.
      (5) Safe closing adds a border of 0 pixels, of sufficient size so
          that all pixels in input image are processed within
          32-bit words in the expanded image.  As a result, there is
          no special processing for pixels near the boundary, and there
          are no boundary effects.  The border is removed at the end.
      (6) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (7) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...);
          (b) pixCloseSafeCompBrick(pixs, pixs, ...);
          (c) pixCloseSafeCompBrick(pixd, pixs, ...);
      (8) The dimensions of the resulting image are determined by pixs.
      (9) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
          but not necessarily equal to it.  It attempts to optimize:
             (a) for consistency with the input values: the product
                 of terms is close to the input size
             (b) for efficiency of the operation: the sum of the
                 terms is small; ideally about twice the square
                 root of the input size.
          So, for example, if the input hsize = 37, which is
          a prime number, the decomposer will break this into two
          terms, 6 and 6, so that the net result is a dilation
          with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseSafeCompBrick(*args)
    
    

    try:
        leptonica.pixOpen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOpen.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpen(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixOpen()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) Generic morphological opening, using hits in the Sel.
      (2) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (3) For clarity, if the case is known, use these patterns:
          (a) pixd = pixOpen(NULL, pixs, ...);
          (b) pixOpen(pixs, pixs, ...);
          (c) pixOpen(pixd, pixs, ...);
      (4) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpen(*args)
    
    

    try:
        leptonica.pixCloseGeneralized.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCloseGeneralized.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseGeneralized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseGeneralized(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixCloseGeneralized()

      Input:  pixd (<optional>; this can be null, equal to pixs,
                    or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) Generalized morphological closing, using both hits and
          misses in the Sel.
      (2) This does a dilation using the hits, followed by a
          hit-miss transform.
      (3) This operation is a dual of the generalized opening.
      (4) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (5) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseGeneralized(NULL, pixs, ...);
          (b) pixCloseGeneralized(pixs, pixs, ...);
          (c) pixCloseGeneralized(pixd, pixs, ...);
      (6) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseGeneralized(*args)
    
    

    try:
        leptonica.pixErode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixErode.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErode(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixErode()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) This erodes src using hits in Sel.
      (2) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (3) For clarity, if the case is known, use these patterns:
          (a) pixd = pixErode(NULL, pixs, ...);
          (b) pixErode(pixs, pixs, ...);
          (c) pixErode(pixd, pixs, ...);
      (4) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErode(*args)
    
    

    try:
        leptonica.pixClose.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClose.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixClose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClose(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixClose()

      Input:  pixd (<optional>; this can be null, equal to pixs,
                    or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) Generic morphological closing, using hits in the Sel.
      (2) This implementation is a strict dual of the opening if
          symmetric boundary conditions are used (see notes at top
          of this file).
      (3) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (4) For clarity, if the case is known, use these patterns:
          (a) pixd = pixClose(NULL, pixs, ...);
          (b) pixClose(pixs, pixs, ...);
          (c) pixClose(pixd, pixs, ...);
      (5) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClose(*args)
    
    

    try:
        leptonica.pixOpenCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenCompBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenCompBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do compositely for each dimension > 1.
      (4) Do separably if both hsize and vsize are > 1.
      (5) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (6) For clarity, if the case is known, use these patterns:
          (a) pixd = pixOpenCompBrick(NULL, pixs, ...);
          (b) pixOpenCompBrick(pixs, pixs, ...);
          (c) pixOpenCompBrick(pixd, pixs, ...);
      (7) The dimensions of the resulting image are determined by pixs.
      (8) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
          but not necessarily equal to it.  It attempts to optimize:
             (a) for consistency with the input values: the product
                 of terms is close to the input size
             (b) for efficiency of the operation: the sum of the
                 terms is small; ideally about twice the square
                 root of the input size.
          So, for example, if the input hsize = 37, which is
          a prime number, the decomposer will break this into two
          terms, 6 and 6, so that the net result is a dilation
          with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenCompBrick(*args)
    
    

    try:
        leptonica.pixDilate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDilate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilate(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       
  pixDilate()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              sel
      Return: pixd

  Notes:
      (1) This dilates src using hits in Sel.
      (2) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (3) For clarity, if the case is known, use these patterns:
          (a) pixd = pixDilate(NULL, pixs, ...);
          (b) pixDilate(pixs, pixs, ...);
          (c) pixDilate(pixd, pixs, ...);
      (4) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilate(*args)
    
    

    try:
        leptonica.pixCloseBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do separably if both hsize and vsize are > 1.
      (4) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (5) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseBrick(NULL, pixs, ...);
          (b) pixCloseBrick(pixs, pixs, ...);
          (c) pixCloseBrick(pixd, pixs, ...);
      (6) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseBrick(*args)
    
    

    try:
        leptonica.pixErodeBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do separably if both hsize and vsize are > 1.
      (4) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (5) For clarity, if the case is known, use these patterns:
          (a) pixd = pixErodeBrick(NULL, pixs, ...);
          (b) pixErodeBrick(pixs, pixs, ...);
          (c) pixErodeBrick(pixd, pixs, ...);
      (6) The size of the result is determined by pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeBrick(*args)
    
    

    try:
        leptonica.pixErodeCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeCompBrick.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeCompBrick()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd, or null on error

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) The origin is at (x, y) = (hsize/2, vsize/2)
      (3) Do compositely for each dimension > 1.
      (4) Do separably if both hsize and vsize are > 1.
      (5) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (6) For clarity, if the case is known, use these patterns:
          (a) pixd = pixErodeCompBrick(NULL, pixs, ...);
          (b) pixErodeCompBrick(pixs, pixs, ...);
          (c) pixErodeCompBrick(pixd, pixs, ...);
      (7) The dimensions of the resulting image are determined by pixs.
      (8) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
          but not necessarily equal to it.  It attempts to optimize:
             (a) for consistency with the input values: the product
                 of terms is close to the input size
             (b) for efficiency of the operation: the sum of the
                 terms is small; ideally about twice the square
                 root of the input size.
          So, for example, if the input hsize = 37, which is
          a prime number, the decomposer will break this into two
          terms, 6 and 6, so that the net result is a dilation
          with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeCompBrick(*args)
    




class rotateorth(object):
    """  rotateorth.c

      Top-level rotation by multiples of 90 degrees
            PIX             *pixRotateOrth()

      180-degree rotation
            PIX             *pixRotate180()

      90-degree rotation (both directions)
            PIX             *pixRotate90()

      Left-right flip
            PIX             *pixFlipLR()

      Top-bottom flip
            PIX             *pixFlipTB()

      Byte reverse tables
            static l_uint8  *makeReverseByteTab1()
            static l_uint8  *makeReverseByteTab2()
            static l_uint8  *makeReverseByteTab4()

"""
    
    try:
        leptonica.pixRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRotateOrth.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateOrth(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'quads')       
  pixRotateOrth()

      Input:  pixs (all depths)
              quads (0-3; number of 90 degree cw rotations)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateOrth(*args)
    
    

    try:
        leptonica.pixFlipLR.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFlipLR.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFlipLR not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFlipLR(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixFlipLR()

      Input:  pixd  (<optional>; can be null, equal to pixs,
                     or different from pixs)
              pixs (all depths)
      Return: pixd, or null on error

  Notes:
      (1) This does a left-right flip of the image, which is
          equivalent to a rotation out of the plane about a
          vertical line through the image center.
      (2) There are 3 cases for input:
          (a) pixd == null (creates a new pixd)
          (b) pixd == pixs (in-place operation)
          (c) pixd != pixs (existing pixd)
      (3) For clarity, use these three patterns, respectively:
          (a) pixd = pixFlipLR(NULL, pixs);
          (b) pixFlipLR(pixs, pixs);
          (c) pixFlipLR(pixd, pixs);
      (4) If an existing pixd is not the same size as pixs, the
          image data will be reallocated.
      (5) The pixel access routines allow a trivial implementation.
          However, for d < 8, it is more efficient to right-justify
          each line to a 32-bit boundary and then extract bytes and
          do pixel reversing.   In those cases, as in the 180 degree
          rotation, we right-shift the data (if necessary) to
          right-justify on the 32 bit boundary, and then read the
          bytes off each raster line in reverse order, reversing
          the pixels in each byte using a table.  These functions
          for 1, 2 and 4 bpp were tested against the "trivial"
          version (shown here for 4 bpp):
              for (i = 0; i < h; i++) {
                  line = data + i * wpl;
                  memcpy(buffer, line, bpl);
                    for (j = 0; j < w; j++) {
                      val = GET_DATA_QBIT(buffer, w - 1 - j);
                        SET_DATA_QBIT(line, j, val);
                  }
              }


        """
        args = _convert_params(*args)
        
        return leptonica.pixFlipLR(*args)
    
    

    try:
        leptonica.pixRotate180.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRotate180.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotate180 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate180(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixRotate180()

      Input:  pixd  (<optional>; can be null, equal to pixs,
                     or different from pixs)
              pixs (all depths)
      Return: pixd, or null on error

  Notes:
      (1) This does a 180 rotation of the image about the center,
          which is equivalent to a left-right flip about a vertical
          line through the image center, followed by a top-bottom
          flip about a horizontal line through the image center.
      (2) There are 3 cases for input:
          (a) pixd == null (creates a new pixd)
          (b) pixd == pixs (in-place operation)
          (c) pixd != pixs (existing pixd)
      (3) For clarity, use these three patterns, respectively:
          (a) pixd = pixRotate180(NULL, pixs);
          (b) pixRotate180(pixs, pixs);
          (c) pixRotate180(pixd, pixs);


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate180(*args)
    
    

    try:
        leptonica.pixRotate90.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRotate90.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotate90 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate90(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'direction')       
  pixRotate90()

      Input:  pixs (all depths)
              direction (1 = clockwise,  -1 = counter-clockwise)
      Return: pixd, or null on error

  Notes:
      (1) This does a 90 degree rotation of the image about the center,
          either cw or ccw, returning a new pix.
      (2) The direction must be either 1 (cw) or -1 (ccw).


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate90(*args)
    
    

    try:
        leptonica.pixFlipTB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFlipTB.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFlipTB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFlipTB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixFlipTB()

      Input:  pixd  (<optional>; can be null, equal to pixs,
                     or different from pixs)
              pixs (all depths)
      Return: pixd, or null on error

  Notes:
      (1) This does a top-bottom flip of the image, which is
          equivalent to a rotation out of the plane about a
          horizontal line through the image center.
      (2) There are 3 cases for input:
          (a) pixd == null (creates a new pixd)
          (b) pixd == pixs (in-place operation)
          (c) pixd != pixs (existing pixd)
      (3) For clarity, use these three patterns, respectively:
          (a) pixd = pixFlipTB(NULL, pixs);
          (b) pixFlipTB(pixs, pixs);
          (c) pixFlipTB(pixd, pixs);
      (4) If an existing pixd is not the same size as pixs, the
          image data will be reallocated.
      (5) This is simple and fast.  We use the memcpy function
          to do all the work on aligned data, regardless of pixel
          depth.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFlipTB(*args)
    




class warper(object):
    """  warper.c

      High-level captcha interface
          PIX               *pixSimpleCaptcha()

      Random sinusoidal warping
          PIX               *pixRandomHarmonicWarp()

      Helper functions
          static l_float64  *generateRandomNumberArray()
          static l_int32     applyWarpTransform()

      Version using a LUT for sin
          PIX               *pixRandomHarmonicWarpLUT()
          static l_int32     applyWarpTransformLUT()
          static l_int32     makeSinLUT()
          static l_float32   getSinFromLUT()

      Stereoscopic warping
          PIX               *pixWarpStereoscopic()

      Linear and quadratic horizontal stretching
          PIX               *pixStretchHorizontal()
          PIX               *pixStretchHorizontalSampled()
          PIX               *pixStretchHorizontalLI()

      Quadratic vertical shear
          PIX               *pixQuadraticVShear()
          PIX               *pixQuadraticVShearSampled()
          PIX               *pixQuadraticVShearLI()

      Stereo from a pair of images
          PIX               *pixStereoFromPair()

"""
    
    try:
        leptonica.pixWarpStereoscopic.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWarpStereoscopic.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixWarpStereoscopic not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWarpStereoscopic(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'zbend')       
('l_int32', 'zshiftt')       
('l_int32', 'zshiftb')       
('l_int32', 'ybendt')       
('l_int32', 'ybendb')       
('l_int32', 'redleft')       
  pixWarpStereoscopic()

      Input:  pixs (any depth, colormap ok)
              zbend (horizontal separation in pixels of red and cyan
                    at the left and right sides, that gives rise to
                    quadratic curvature out of the image plane)
              zshiftt (uniform pixel translation difference between
                      red and cyan, that pushes the top of the image
                      plane away from the viewer (zshiftt > 0) or
                      towards the viewer (zshiftt < 0))
              zshiftb (uniform pixel translation difference between
                      red and cyan, that pushes the bottom of the image
                      plane away from the viewer (zshiftb > 0) or
                      towards the viewer (zshiftb < 0))
              ybendt (multiplicative parameter for in-plane vertical
                      displacement at the left or right edge at the top:
                        y = ybendt * (2x/w - 1)^2 )
              ybendb (same as ybendt, except at the left or right edge
                      at the bottom)
              redleft (1 if the red filter is on the left; 0 otherwise)
      Return: pixd (32 bpp), or null on error

  Notes:
      (1) This function splits out the red channel, mucks around with
          it, then recombines with the unmolested cyan channel.
      (2) By using a quadratically increasing shift of the red
          pixels horizontally and away from the vertical centerline,
          the image appears to bend quadratically out of the image
          plane, symmetrically with respect to the vertical center
          line.  A positive value of @zbend causes the plane to be
          curved away from the viewer.  We use linearly interpolated
          stretching to avoid the appearance of kinks in the curve.
      (3) The parameters @zshiftt and @zshiftb tilt the image plane
          about a horizontal line through the center, and at the
          same time move that line either in toward the viewer or away.
          This is implemented by a combination of horizontal shear
          about the center line (for the tilt) and horizontal
          translation (to move the entire plane in or out).
          A positive value of @zshiftt moves the top of the plane
          away from the viewer, and a positive value of @zshiftb
          moves the bottom of the plane away.  We use linear interpolated
          shear to avoid visible vertical steps in the tilted image.
      (4) The image can be bent in the plane and about the vertical
          centerline.  The centerline does not shift, and the
          parameter @ybend gives the relative shift at left and right
          edges, with a downward shift for positive values of @ybend.
      (6) When writing out a steroscopic (red/cyan) image in jpeg,
          first call pixSetChromaSampling(pix, 0) to get sufficient
          resolution in the red channel.
      (7) Typical values are:
             zbend = 20
             zshiftt = 15
             zshiftb = -15
             ybendt = 30
             ybendb = 0
          If the disparity z-values are too large, it is difficult for
          the brain to register the two images.
      (8) This function has been cleverly reimplemented by Jeff Breidenbach.
          The original implementation used two 32 bpp rgb images,
          and merged them at the end.  The result is somewhat faded,
          and has a parameter "thresh" that controls the amount of
          color in the result.  (The present implementation avoids these
          two problems, skipping both the colorization and the alpha
          blending at the end, and is about 3x faster)
          The basic operations with 32 bpp are as follows:
               // Immediate conversion to 32 bpp
            Pix *pixt1 = pixConvertTo32(pixs);
               // Do vertical shear
            Pix *pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,
                                                  ybendt, ybendb,
                                                  L_BRING_IN_WHITE);
               // Colorize two versions, toward red and cyan
            Pix *pixc = pixCopy(NULL, pixr);
            l_int32 thresh = 150;  // if higher, get less original color
            pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0);
            pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255);
               // Shift the red pixels; e.g., by stretching
            Pix *pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,
                                              L_QUADRATIC_WARP, zbend,
                                              L_INTERPOLATED,
                                              L_BRING_IN_WHITE);
               // Blend the shifted red and unshifted cyan 50:50
            Pix *pixg = pixCreate(w, h, 8);
            pixSetAllArbitrary(pixg, 128);
            pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0);


        """
        args = _convert_params(*args)
        
        return leptonica.pixWarpStereoscopic(*args)
    
    

    try:
        leptonica.pixStretchHorizontal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStretchHorizontal.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixStretchHorizontal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStretchHorizontal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'type')       
('l_int32', 'hmax')       
('l_int32', 'operation')       
('l_int32', 'incolor')       
  pixStretchHorizontal()

      Input:  pixs (1, 8 or 32 bpp)
              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)
              type (L_LINEAR_WARP or L_QUADRATIC_WARP)
              hmax (horizontal displacement at edge)
              operation (L_SAMPLED or L_INTERPOLATED)
              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)
      Return: pixd (stretched/compressed), or null on error

  Notes:
      (1) If @hmax > 0, this is an increase in the coordinate value of
          pixels in pixd, relative to the same pixel in pixs.
      (2) If @dir == L_WARP_TO_LEFT, the pixels on the right edge of
          the image are not moved. So, for example, if @hmax > 0
          and @dir == L_WARP_TO_LEFT, the pixels in pixd are
          contracted toward the right edge of the image, relative
          to those in pixs.
      (3) If @type == L_LINEAR_WARP, the pixel positions are moved
          to the left or right by an amount that varies linearly with
          the horizontal location.
      (4) If @operation == L_SAMPLED, the dest pixels are taken from
          the nearest src pixel.  Otherwise, we use linear interpolation
          between pairs of sampled pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixStretchHorizontal(*args)
    
    

    try:
        leptonica.pixStereoFromPair.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixStereoFromPair.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixStereoFromPair not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStereoFromPair(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       
  pixStereoFromPair()

      Input:  pix1 (32 bpp rgb)
              pix2 (32 bpp rgb)
              rwt, gwt, bwt (weighting factors used for each component in
                             pix1 to determine the output red channel)
      Return: pixd (stereo enhanced), or null on error

  Notes:
      (1) pix1 and pix2 are a pair of stereo images, ideally taken
          concurrently in the same plane, with some lateral translation.
      (2) The output red channel is determined from @pix1.
          The output green and blue channels are taken from the green
          and blue channels, respectively, of @pix2.
      (3) The weights determine how much of each component in @pix1
          goes into the output red channel.  The sum of weights
          must be 1.0.  If it's not, we scale the weights to
          satisfy this criterion.
      (4) The most general pixel mapping allowed here is:
            rval = rwt * r1 + gwt * g1 + bwt * b1  (from pix1)
            gval = g2   (from pix2)
            bval = b2   (from pix2)
      (5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,
          but this causes unpleasant visual artifacts with red in the image.
          Use of green and blue from @pix1 in the red channel,
          instead of red, tends to fix that problem.


        """
        args = _convert_params(*args)
        
        return leptonica.pixStereoFromPair(*args)
    
    

    try:
        leptonica.pixStretchHorizontalSampled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStretchHorizontalSampled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixStretchHorizontalSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStretchHorizontalSampled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'type')       
('l_int32', 'hmax')       
('l_int32', 'incolor')       
  pixStretchHorizontalSampled()

      Input:  pixs (1, 8 or 32 bpp)
              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)
              type (L_LINEAR_WARP or L_QUADRATIC_WARP)
              hmax (horizontal displacement at edge)
              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)
      Return: pixd (stretched/compressed), or null on error

  Notes:
      (1) See pixStretchHorizontal() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixStretchHorizontalSampled(*args)
    
    

    try:
        leptonica.pixQuadraticVShearLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuadraticVShearLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixQuadraticVShearLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadraticVShearLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'vmaxt')       
('l_int32', 'vmaxb')       
('l_int32', 'incolor')       
  pixQuadraticVShearLI()

      Input:  pixs (8 or 32 bpp, or colormapped)
              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)
              vmaxt (max vertical displacement at edge and at top)
              vmaxb (max vertical displacement at edge and at bottom)
              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)
      Return: pixd (stretched), or null on error

  Notes:
      (1) See pixQuadraticVShear() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadraticVShearLI(*args)
    
    

    try:
        leptonica.pixRandomHarmonicWarp.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixRandomHarmonicWarp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRandomHarmonicWarp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRandomHarmonicWarp(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'xmag')       
('l_float32', 'ymag')       
('l_float32', 'xfreq')       
('l_float32', 'yfreq')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_uint32', 'seed')       
('l_int32', 'grayval')       
  pixRandomHarmonicWarp()

      Input:  pixs (8 bpp; no colormap)
              xmag, ymag (maximum magnitude of x and y distortion)
              xfreq, yfreq (maximum magnitude of x and y frequency)
              nx, ny (number of x and y harmonic terms)
              seed (of random number generator)
              grayval (color brought in from the outside;
                       0 for black, 255 for white)
      Return: pixd (8 bpp; no colormap), or null on error

  Notes:
      (1) To generate the warped image p(x',y'), set up the transforms
          that are in getWarpTransform().  For each (x',y') in the
          dest, the warp function computes the originating location
          (x, y) in the src.  The differences (x - x') and (y - y')
          are given as a sum of products of sinusoidal terms.  Each
          term is multiplied by a maximum amplitude (in pixels), and the
          angle is determined by a frequency and phase, and depends
          on the (x', y') value of the dest.  Random numbers with
          a variable input seed are used to allow the warping to be
          unpredictable.  A linear interpolation is used to find
          the value for the source at (x, y); this value is written
          into the dest.
      (2) This can be used to generate 'captcha's, which are somewhat
          randomly distorted images of text.  A typical set of parameters
          for a captcha are:
                    xmag = 4.0     ymag = 6.0
                    xfreq = 0.10   yfreq = 0.13
                    nx = 3         ny = 3
          Other examples can be found in prog/warptest.c.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRandomHarmonicWarp(*args)
    
    

    try:
        leptonica.pixSimpleCaptcha.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSimpleCaptcha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSimpleCaptcha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSimpleCaptcha(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'border')       
('l_int32', 'nterms')       
('l_uint32', 'seed')       
('l_uint32', 'color')       
('l_int32', 'cmapflag')       
  pixSimpleCaptcha()

      Input:  pixs (8 bpp; no colormap)
              border (added white pixels on each side)
              nterms (number of x and y harmonic terms)
              seed (of random number generator)
              color (for colorizing; in 0xrrggbb00 format; use 0 for black)
              cmapflag (1 for colormap output; 0 for rgb)
      Return: pixd (8 bpp cmap or 32 bpp rgb), or null on error

  Notes:
      (1) This uses typical default values for generating captchas.
          The magnitudes of the harmonic warp are typically to be
          smaller when more terms are used, even though the phases
          are random.  See, for example, prog/warptest.c.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSimpleCaptcha(*args)
    
    

    try:
        leptonica.pixQuadraticVShear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuadraticVShear.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixQuadraticVShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadraticVShear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'vmaxt')       
('l_int32', 'vmaxb')       
('l_int32', 'operation')       
('l_int32', 'incolor')       
  pixQuadraticVShear()

      Input:  pixs (1, 8 or 32 bpp)
              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)
              vmaxt (max vertical displacement at edge and at top)
              vmaxb (max vertical displacement at edge and at bottom)
              operation (L_SAMPLED or L_INTERPOLATED)
              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)
      Return: pixd (stretched), or null on error

  Notes:
      (1) This gives a quadratic bending, upward or downward, as you
          move to the left or right.
      (2) If @dir == L_WARP_TO_LEFT, the right edge is unchanged, and
          the left edge pixels are moved maximally up or down.
      (3) Parameters @vmaxt and @vmaxb control the maximum amount of
          vertical pixel shear at the top and bottom, respectively.
          If @vmaxt > 0, the vertical displacement of pixels at the
          top is downward.  Likewise, if @vmaxb > 0, the vertical
          displacement of pixels at the bottom is downward.
      (4) If @operation == L_SAMPLED, the dest pixels are taken from
          the nearest src pixel.  Otherwise, we use linear interpolation
          between pairs of sampled pixels.
      (5) This is for quadratic shear.  For uniform (linear) shear,
          use the standard shear operators.


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadraticVShear(*args)
    
    

    try:
        leptonica.pixQuadraticVShearSampled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuadraticVShearSampled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixQuadraticVShearSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadraticVShearSampled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'vmaxt')       
('l_int32', 'vmaxb')       
('l_int32', 'incolor')       
  pixQuadraticVShearSampled()

      Input:  pixs (1, 8 or 32 bpp)
              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)
              vmaxt (max vertical displacement at edge and at top)
              vmaxb (max vertical displacement at edge and at bottom)
              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)
      Return: pixd (stretched), or null on error

  Notes:
      (1) See pixQuadraticVShear() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadraticVShearSampled(*args)
    
    

    try:
        leptonica.pixStretchHorizontalLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStretchHorizontalLI.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixStretchHorizontalLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStretchHorizontalLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'type')       
('l_int32', 'hmax')       
('l_int32', 'incolor')       
  pixStretchHorizontalLI()

      Input:  pixs (1, 8 or 32 bpp)
              dir (L_WARP_TO_LEFT or L_WARP_TO_RIGHT)
              type (L_LINEAR_WARP or L_QUADRATIC_WARP)
              hmax (horizontal displacement at edge)
              incolor (L_BRING_IN_WHITE or L_BRING_IN_BLACK)
      Return: pixd (stretched/compressed), or null on error

  Notes:
      (1) See pixStretchHorizontal() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixStretchHorizontalLI(*args)
    




class bbuffer(object):
    """   bbuffer.c

      Create/Destroy BBuffer
          BBUFFER        *bbufferCreate()
          void           *bbufferDestroy()
          l_uint8        *bbufferDestroyAndSaveData()

      Operations to read data TO a BBuffer
          l_int32         bbufferRead()
          l_int32         bbufferReadStream()
          l_int32         bbufferExtendArray()

      Operations to write data FROM a BBuffer
          l_int32         bbufferWrite()
          l_int32         bbufferWriteStream()

      Accessors
          l_int32         bbufferBytesToWrite()


    The bbuffer is an implementation of a byte queue.
    The bbuffer holds a byte array from which bytes are
    processed in a first-in/first-out fashion.  As with
    any queue, bbuffer maintains two "pointers," one to the
    tail of the queue (where you read new bytes onto it)
    and one to the head of the queue (where you start from
    when writing bytes out of it.

    The queue can be visualized:


  byte 0                                           byte (nalloc - 1)
       |                                                |
       --------------------------------------------------
                 H                             T
       [   aw   ][  bytes currently on queue  ][  anr   ]

       ---:  all allocated data in bbuffer
       H:    queue head (ptr to next byte to be written out)
       T:    queue tail (ptr to first byte to be written to)
       aw:   already written from queue
       anr:  allocated but not yet read to

    The purpose of bbuffer is to allow you to safely read
    bytes in, and to sequentially write them out as well.
    In the process of writing bytes out, you don't actually
    remove the bytes in the array; you just move the pointer
    (nwritten) which points to the head of the queue.  In
    the process of reading bytes in, you sometimes need to
    expand the array size.  If a read is performed after a
    write, so that the head of the queue is not at the
    beginning of the array, the bytes already written are
    first removed by copying the others over them; then the
    new bytes are read onto the tail of the queue.

    Note that the meaning of "read into" and "write from"
    the bbuffer is OPPOSITE to that for a stream, where
    you read "from" a stream and write "into" a stream.
    As a mnemonic for remembering the direction:
        - to read bytes from a stream into the bbuffer,
          you call fread on the stream
        - to write bytes from the bbuffer into a stream,
          you call fwrite on the stream

    See zlibmem.c for an example use of bbuffer, where we
    compress and decompress an array of bytes in memory.

    We can also use the bbuffer trivially to read from stdin
    into memory; e.g., to capture bytes piped from the stdout
    of another program.  This is equivalent to repeatedly
    calling bbufferReadStream() until the input queue is empty.
    This is implemented in l_binaryReadStream().

"""
    
    try:
        leptonica.bbufferCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferCreate.restype = lambda address: BBUFFER(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function bbufferCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferCreate(*args):
        """
        ('l_uint8', '*indata')       
('l_int32', 'nalloc')       
  bbufferCreate()

      Input:  buffer address in memory (<optional>)
              size of byte array to be alloc'd (0 for default)
      Return: bbuffer, or null on error

  Notes:
      (1) If a buffer address is given, you should read all the data in.
      (2) Allocates a bbuffer with associated byte array of
          the given size.  If a buffer address is given,
          it then reads the number of bytes into the byte array.


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferCreate(*args)
    
    

    try:
        leptonica.bbufferReadStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferReadStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bbufferReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferReadStream(*args):
        """
        ('BBUFFER', '*bb')       
('FILE', '*fp')       
('l_int32', 'nbytes')       
  bbufferReadStream()

      Input:  bbuffer
              fp      (source stream from which bytes are read)
              nbytes   (bytes to be read)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferReadStream(*args)
    
    

    try:
        leptonica.bbufferRead.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferRead.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bbufferRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferRead(*args):
        """
        ('BBUFFER', '*bb')       
('l_uint8', '*src')       
('l_int32', 'nbytes')       
  bbufferRead()

      Input:  bbuffer
              src      (source memory buffer from which bytes are read)
              nbytes   (bytes to be read)
      Return: 0 if OK, 1 on error

  Notes:
      (1) For a read after write, first remove the written
          bytes by shifting the unwritten bytes in the array,
          then check if there is enough room to add the new bytes.
          If not, realloc with bbufferExpandArray(), resulting
          in a second writing of the unwritten bytes.  While less
          efficient, this is simpler than making a special case
          of reallocNew().


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferRead(*args)
    
    

    try:
        leptonica.bbufferBytesToWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bbufferBytesToWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bbufferBytesToWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferBytesToWrite(*args):
        """
        ('BBUFFER', '*bb')       
('size_t', '*pnbytes')       
  bbufferBytesToWrite()

      Input:  bbuffer
              &nbytes (<return>)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferBytesToWrite(*args)
    
    

    try:
        leptonica.bbufferWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.bbufferWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bbufferWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferWriteStream(*args):
        """
        ('BBUFFER', '*bb')       
('FILE', '*fp')       
('size_t', 'nbytes')       
('size_t', '*pnout')       
  bbufferWriteStream()

      Input:  bbuffer
              fp       (dest stream to which bytes are written)
              nbytes   (bytes requested to be written)
              &nout    (<return> bytes actually written)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferWriteStream(*args)
    
    

    try:
        leptonica.bbufferExtendArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferExtendArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bbufferExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferExtendArray(*args):
        """
        ('BBUFFER', '*bb')       
('l_int32', 'nbytes')       
  bbufferExtendArray()

      Input:  bbuffer
              nbytes  (number of bytes to extend array size)
      Return: 0 if OK, 1 on error

  Notes:
      (1) reallocNew() copies all bb->nalloc bytes, even though
          only bb->n are data.


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferExtendArray(*args)
    
    

    try:
        leptonica.bbufferDestroy.argtypes = [ctypes.c_void_p]
        leptonica.bbufferDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function bbufferDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferDestroy(*args):
        """
        ('BBUFFER', '**pbb')       
  bbufferDestroy()

      Input:  &bbuffer  (<to be nulled>)
      Return: void

  Notes:
      (1) Destroys the byte array in the bbuffer and then the bbuffer;
          then nulls the contents of the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferDestroy(*args)
    
    

    try:
        leptonica.bbufferWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.bbufferWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bbufferWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferWrite(*args):
        """
        ('BBUFFER', '*bb')       
('l_uint8', '*dest')       
('size_t', 'nbytes')       
('size_t', '*pnout')       
  bbufferWrite()

      Input:  bbuffer
              dest     (dest memory buffer to which bytes are written)
              nbytes   (bytes requested to be written)
              &nout    (<return> bytes actually written)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferWrite(*args)
    
    

    try:
        leptonica.bbufferDestroyAndSaveData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bbufferDestroyAndSaveData.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function bbufferDestroyAndSaveData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferDestroyAndSaveData(*args):
        """
        ('BBUFFER', '**pbb')       
('size_t', '*pnbytes')       
  bbufferDestroyAndSaveData()

      Input:  &bbuffer (<to be nulled>)
              &nbytes  (<return> number of bytes saved in array)
      Return: barray (newly allocated array of data)

  Notes:
      (1) Copies data to newly allocated array; then destroys the bbuffer.


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferDestroyAndSaveData(*args)
    




class ccbord(object):
    """  ccbord.c

     CCBORDA and CCBORD creation and destruction
         CCBORDA     *ccbaCreate()
         void        *ccbaDestroy()
         CCBORD      *ccbCreate()
         void        *ccbDestroy()

     CCBORDA addition
         l_int32      ccbaAddCcb()
         static l_int32  ccbaExtendArray()

     CCBORDA accessors
         l_int32      ccbaGetCount()
         l_int32      ccbaGetCcb()

     Top-level border-finding routines
         CCBORDA     *pixGetAllCCBorders()
         CCBORD      *pixGetCCBorders()
         PTAA        *pixGetOuterBordersPtaa()
         PTA         *pixGetOuterBorderPta()

     Lower-level border location routines
         l_int32      pixGetOuterBorder()
         l_int32      pixGetHoleBorder()
         l_int32      findNextBorderPixel()
         void         locateOutsideSeedPixel()

     Border conversions
         l_int32      ccbaGenerateGlobalLocs()
         l_int32      ccbaGenerateStepChains()
         l_int32      ccbaStepChainsToPixCoords()
         l_int32      ccbaGenerateSPGlobalLocs()

     Conversion to single path
         l_int32      ccbaGenerateSinglePath()
         PTA         *getCutPathForHole()

     Border and full image rendering
         PIX         *ccbaDisplayBorder()
         PIX         *ccbaDisplaySPBorder()
         PIX         *ccbaDisplayImage1()
         PIX         *ccbaDisplayImage2()

     Serialize for I/O
         l_int32      ccbaWrite()
         l_int32      ccbaWriteStream()
         l_int32      ccbaRead()
         l_int32      ccbaReadStream()

     SVG output
         l_int32      ccbaWriteSVG()
         char        *ccbaWriteSVGString()


     Border finding is tricky because components can have
     holes, which also need to be traced out.  The outer
     border can be connected with all the hole borders,
     so that there is a single border for each component.
     [Alternatively, the connecting paths can be eliminated if
     you're willing to have a set of borders for each
     component (an exterior border and some number of
     interior ones), with "line to" operations tracing
     out each border and "move to" operations going from
     one border to the next.]

     Here's the plan.  We get the pix for each connected
     component, and trace its exterior border.  We then
     find the holes (if any) in the pix, and separately
     trace out their borders, all using the same
     border-following rule that has ON pixels on the right
     side of the path.

     [For svg, we may want to turn each set of borders for a c.c.
     into a closed path.  This can be done by tunnelling
     through the component from the outer border to each of the
     holes, going in and coming out along the same path so
     the connection will be invisible in any rendering
     (display or print) from the outline.  The result is a
     closed path, where the outside border is traversed
     cw and each hole is traversed ccw.  The svg renderer
     is assumed to handle these closed borders properly.]

     Each border is a closed path that is traversed in such
     a way that the stuff inside the c.c. is on the right
     side of the traveller.  The border of a singly-connected
     component is thus traversed cw, and the border of the
     holes inside a c.c. are traversed ccw.  Suppose we have
     a list of all the borders of each c.c., both the cw and ccw
     traversals.  How do we reconstruct the image?

   Reconstruction:

     Method 1.  Topological method using connected components.
     We have closed borders composed of cw border pixels for the
     exterior of c.c. and ccw border pixels for the interior (holes)
     in the c.c.
         (a) Initialize the destination to be OFF.  Then,
             in any order:
         (b) Fill the components within and including the cw borders,
             and sequentially XOR them onto the destination.
         (c) Fill the components within but not including the ccw
             borders and sequentially XOR them onto the destination.
     The components that are XOR'd together can be generated as follows:
         (a) For each closed cw path, use pixFillClosedBorders():
               (1) Turn on the path pixels in a subimage that
                   minimally supports the border.
               (2) Do a 4-connected fill from a seed of 1 pixel width
                   on the border, using the inverted image in (1) as
                   a filling mask.
               (3) Invert the fill result: this gives the component
                   including the exterior cw path, with all holes
                   filled.
         (b) For each closed ccw path (hole):
               (1) Turn on the path pixels in a subimage that minimally
                   supports the path.
               (2) Find a seed pixel on the inside of this path.
               (3) Do a 4-connected fill from this seed pixel, using
                   the inverted image of the path in (1) as a filling
                   mask.

     ------------------------------------------------------

     Method 2.  A variant of Method 1.  Topological.
     In Method 1, we treat the exterior border differently from
     the interior (hole) borders.  Here, all borders in a c.c.
     are treated equally:
         (1) Start with a pix with a 1 pixel OFF boundary
             enclosing all the border pixels of the c.c.
             This is the filling mask.
         (2) Make a seed image of the same size as follows:  for
             each border, put one seed pixel OUTSIDE the border
             (where OUTSIDE is determined by the inside/outside
             convention for borders).
         (3) Seedfill into the seed image, filling in the regions
             determined by the filling mask.  The fills are clipped
             by the border pixels.
         (4) Inverting this, we get the c.c. properly filled,
             with the holes empty!
         (5) Rasterop using XOR the filled c.c. (but not the 1
             pixel boundary) into the full dest image.

     Method 2 is about 1.2x faster than Method 1 on text images,
     and about 2x faster on complex images (e.g., with halftones).

     ------------------------------------------------------

     Method 3.  The traditional way to fill components delineated
     by boundaries is through scan line conversion.  It's a bit
     tricky, and I have not yet tried to implement it.

     ------------------------------------------------------

     Method 4.  [Nota Bene: this method probably doesn't work, and
     won't be implemented.  If I get a more traditional scan line
     conversion algorithm working, I'll erase these notes.]
     Render all border pixels on a destination image,
     which will be the final result after scan conversion.  Assign
     a value 1 to pixels on cw paths, 2 to pixels on ccw paths,
     and 3 to pixels that are on both paths.  Each of the paths
     is an 8-connected component.  Now scan across each raster
     line.  The attempt is to make rules for each scan line
     that are independent of neighboring scanlines.  Here are
     a set of rules for writing ON pixels on a destination raster image:

         (a) The rasterizer will be in one of two states: ON and OFF.
         (b) Start each line in the OFF state.  In the OFF state,
             skip pixels until you hit a path of any type.  Turn
             the path pixel ON.
         (c) If the state is ON, each pixel you encounter will
             be turned on, until and including hitting a path pixel.
         (d) When you hit a path pixel, if the path does NOT cut
             through the line, so that there is not an 8-cc path
             pixel (of any type) both above and below, the state
             is unchanged (it stays either ON or OFF).
         (e) If the path does cut through, but with a possible change
             of pixel type, then we decide whether or
             not to toggle the state based on the values of the
             path pixel and the path pixels above and below:
               (1) if a 1 path cuts through, toggle;
               (1) if a 2 path cuts through, toggle;
               (3) if a 3 path cuts through, do not toggle;
               (4) if on one side a 3 touches both a 1 and a 2, use the 2
               (5) if a 3 has any 1 neighbors, toggle; else if it has
                   no 1 neighbors, do not toggle;
               (6) if a 2 has any neighbors that are 1 or 3,
                   do not toggle
               (7) if a 1 has neighbors 1 and x (x = 2 or 3),
                   toggle


     To visualize how these rules work, consider the following
     component with border pixels labeled according to the scheme
     above.  We also show the values of the interior pixels
     (w=OFF, b=ON), but these of course must be inferred properly
     from the rules above:

                     3
                  3  w  3             1  1  1
                  1  2  1          1  b  2  b  1
                  1  b  1             3  w  2  1
                  3  b  1          1  b  2  b  1
               3  w  3                1  1  1
               3  w  3
            1  b  2  b  1
            1  2  w  2  1
         1  b  2  w  2  b  1
            1  2  w  2  1
               1  2  b  1
               1  b  1
                  1


     Even if this works, which is unlikely, it will certainly be
     slow because decisions have to be made on a pixel-by-pixel
     basis when encountering borders.


"""
    
    try:
        leptonica.ccbaGenerateStepChains.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGenerateStepChains.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaGenerateStepChains not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateStepChains(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaGenerateStepChains()

      Input:  ccba (with local chain ptaa of borders computed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This uses the pixel locs in the local ptaa,
          which are all relative to each c.c., to find
          the step directions for successive pixels in
          the chain, and stores them in the step numaa.
      (2) To get the step direction, use
              1   2   3
              0   P   4
              7   6   5
          where P is the previous pixel at (px, py).  The step direction
          is the number (from 0 through 7) for each relative location
          of the current pixel at (cx, cy).  It is easily found by
          indexing into a 2-d 3x3 array (dirtab).


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateStepChains(*args)
    
    

    try:
        leptonica.ccbaGenerateSPGlobalLocs.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaGenerateSPGlobalLocs.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaGenerateSPGlobalLocs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateSPGlobalLocs(*args):
        """
        ('CCBORDA', '*ccba')       
('l_int32', 'ptsflag')       
  ccbaGenerateSPGlobalLocs()

      Input:  ccba
              ptsflag  (CCB_SAVE_ALL_PTS or CCB_SAVE_TURNING_PTS)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This calculates the splocal rep if not yet made.
      (2) It uses the local pixel values in splocal, the single
          path pta, which are all relative to each c.c., to find
          the corresponding global pixel locations, and stores
          them in the spglobal pta.
      (3) This lists only the turning points: it both makes a
          valid svg file and is typically about half the size
          when all border points are listed.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateSPGlobalLocs(*args)
    
    

    try:
        leptonica.ccbaCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaCreate.restype = lambda address: CCBORDA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaCreate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'n')       
   ccbaCreate()

       Input:  pixs  (binary image; can be null)
               n  (initial number of ptrs)
       Return: ccba, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaCreate(*args)
    
    

    try:
        leptonica.ccbaDisplayBorder.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplayBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaDisplayBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplayBorder(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaDisplayBorder()

      Input:  ccba
      Return: pix of border pixels, or null on error

  Notes:
      (1) Uses global ptaa, which gives each border pixel in
          global coordinates, and must be computed in advance
          by calling ccbaGenerateGlobalLocs().


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplayBorder(*args)
    
    

    try:
        leptonica.ccbaGetCcb.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaGetCcb.restype = lambda address: CCBORD(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaGetCcb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGetCcb(*args):
        """
        ('CCBORDA', '*ccba')       
('l_int32', 'index')       
  ccbaGetCcb()

     Input:  ccba
     Return: ccb, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGetCcb(*args)
    
    

    try:
        leptonica.findNextBorderPixel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findNextBorderPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function findNextBorderPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findNextBorderPixel(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_uint32', '*data')       
('l_int32', 'wpl')       
('l_int32', 'px')       
('l_int32', 'py')       
('l_int32', '*pqpos')       
('l_int32', '*pnpx')       
('l_int32', '*pnpy')       
  findNextBorderPixel()

      Input:  w, h, data, wpl
              (px, py),     (current P)
              &qpos (input current Q; <return> new Q)
              (&npx, &npy)    (<return> new P)
      Return: 0 if next pixel found; 1 otherwise

  Notes:
      (1) qpos increases clockwise from 0 to 7, with 0 at
          location with Q to left of P:   Q P
      (2) this is a low-level function that does not check input
          parameters.  All calling functions should check them.


        """
        args = _convert_params(*args)
        
        return leptonica.findNextBorderPixel(*args)
    
    

    try:
        leptonica.ccbaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGetCount(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaGetCount()

     Input:  ccba
     Return: count, with 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGetCount(*args)
    
    

    try:
        leptonica.ccbaStepChainsToPixCoords.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaStepChainsToPixCoords.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaStepChainsToPixCoords not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaStepChainsToPixCoords(*args):
        """
        ('CCBORDA', '*ccba')       
('l_int32', 'coordtype')       
  ccbaStepChainsToPixCoords()

      Input:  ccba (with step chains numaa of borders)
              coordtype  (CCB_GLOBAL_COORDS or CCB_LOCAL_COORDS)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This uses the step chain data in each ccb to determine
          the pixel locations, either global or local,
          and stores them in the appropriate ptaa,
          either global or local.  For the latter, the
          pixel locations are relative to the c.c.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaStepChainsToPixCoords(*args)
    
    

    try:
        leptonica.locateOutsideSeedPixel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.locateOutsideSeedPixel.restype = None
    except AttributeError:
        os.stderr.write("Warning - function locateOutsideSeedPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def locateOutsideSeedPixel(*args):
        """
        ('l_int32', 'fpx')       
('l_int32', 'fpy')       
('l_int32', 'spx')       
('l_int32', 'spy')       
('l_int32', '*pxs')       
('l_int32', '*pys')       
  locateOutsideSeedPixel()

      Input: fpx, fpy    (location of first pixel)
             spx, spy    (location of second pixel)
             &xs, &xy    (seed pixel to be returned)

  Notes:
      (1) the first and second pixels must be 8-adjacent,
          so |dx| <= 1 and |dy| <= 1 and both dx and dy
          cannot be 0.  There are 8 possible cases.
      (2) the seed pixel is OUTSIDE the foreground of the c.c.
      (3) these rules are for the situation where the INSIDE
          of the c.c. is on the right as you follow the border:
          cw for an exterior border and ccw for a hole border.


        """
        args = _convert_params(*args)
        
        return leptonica.locateOutsideSeedPixel(*args)
    
    

    try:
        leptonica.pixGetAllCCBorders.argtypes = [ctypes.c_void_p]
        leptonica.pixGetAllCCBorders.restype = lambda address: CCBORDA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetAllCCBorders not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAllCCBorders(*args):
        """
        ('PIX', '*pixs')       
  pixGetAllCCBorders()

      Input:  pixs (1 bpp)
      Return: ccborda, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAllCCBorders(*args)
    
    

    try:
        leptonica.ccbaWriteSVG.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaWriteSVG.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaWriteSVG not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWriteSVG(*args):
        """
        ('const char', '*filename')       
('CCBORDA', '*ccba')       
  ccbaWriteSVG()

      Input:  filename
              ccba
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWriteSVG(*args)
    
    

    try:
        leptonica.pixGetHoleBorder.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetHoleBorder.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetHoleBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetHoleBorder(*args):
        """
        ('CCBORD', '*ccb')       
('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'xs')       
('l_int32', 'ys')       
  pixGetHoleBorder()

      Input:  ccb  (the exterior border is already made)
              pixs (for the connected component at hand)
              box  (for the specific hole border, in relative
                    coordinates to the c.c.)
              xs, ys   (first pixel on hole border, relative to c.c.)
      Return: 0 if OK, 1 on error

  Notes:
      (1) we trace out hole border on pixs without addition
          of single pixel added border to pixs
      (2) therefore all coordinates are relative within the c.c. (pixs)
      (3) same position tables and stopping condition as for
          exterior borders


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetHoleBorder(*args)
    
    

    try:
        leptonica.ccbaGenerateSinglePath.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGenerateSinglePath.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaGenerateSinglePath not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateSinglePath(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaGenerateSinglePath()

      Input:  ccba
      Return: 0 if OK, 1 on error

  Notes:
      (1) Generates a single border in local pixel coordinates.
          For each c.c., if there is just an outer border, copy it.
          If there are also hole borders, for each hole border,
          determine the smallest horizontal or vertical
          distance from the border to the outside of the c.c.,
          and find a path through the c.c. for this cut.
          We do this in a way that guarantees a pixel from the
          hole border is the starting point of the path, and
          we must verify that the path intersects the outer
          border (if it intersects it, then it ends on it).
          One can imagine pathological cases, but they may not
          occur in images of text characters and un-textured
          line graphics.
      (2) Once it is verified that the path through the c.c.
          intersects both the hole and outer borders, we
          generate the full single path for all borders in the
          c.c.  Starting at the start point on the outer
          border, when we hit a line on a cut, we take
          the cut, do the hold border, and return on the cut
          to the outer border.  We compose a pta of the
          outer border pts that are on cut paths, and for
          every point on the outer border (as we go around),
          we check against this pta.  When we find a matching
          point in the pta, we do its cut path and hole border.
          The single path is saved in the ccb.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateSinglePath(*args)
    
    

    try:
        leptonica.pixGetCCBorders.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetCCBorders.restype = lambda address: CCBORD(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetCCBorders not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCCBorders(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
  pixGetCCBorders()

      Input:  pixs (1 bpp, one 8-connected component)
              box  (xul, yul, width, height) in global coords
      Return: ccbord, or null on error

  Notes:
      (1) We are finding the exterior and interior borders
          of an 8-connected component.   This should be used
          on a pix that has exactly one 8-connected component.
      (2) Typically, pixs is a c.c. in some larger pix.  The
          input box gives its location in global coordinates.
          This box is saved, as well as the boxes for the
          borders of any holes within the c.c., but the latter
          are given in relative coords within the c.c.
      (3) The calculations for the exterior border are done
          on a pix with a 1-pixel
          added border, but the saved pixel coordinates
          are the correct (relative) ones for the input pix
          (without a 1-pixel border)
      (4) For the definition of the three tables -- xpostab[], ypostab[]
          and qpostab[] -- see above where they are defined.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCCBorders(*args)
    
    

    try:
        leptonica.pixGetOuterBordersPtaa.argtypes = [ctypes.c_void_p]
        leptonica.pixGetOuterBordersPtaa.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetOuterBordersPtaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetOuterBordersPtaa(*args):
        """
        ('PIX', '*pixs')       
  pixGetOuterBordersPtaa()

      Input:  pixs (1 bpp)
      Return: ptaa (of outer borders, in global coords), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetOuterBordersPtaa(*args)
    
    

    try:
        leptonica.ccbaRead.argtypes = [ctypes.c_void_p]
        leptonica.ccbaRead.restype = lambda address: CCBORDA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaRead(*args):
        """
        ('const char', '*filename')       
  ccbaRead()

      Input:  filename
      Return: ccba, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaRead(*args)
    
    

    try:
        leptonica.ccbaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWrite(*args):
        """
        ('const char', '*filename')       
('CCBORDA', '*ccba')       
  ccbaWrite()

      Input:  filename
              ccba
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWrite(*args)
    
    

    try:
        leptonica.getCutPathForHole.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getCutPathForHole.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function getCutPathForHole not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getCutPathForHole(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('BOX', '*boxinner')       
('l_int32', '*pdir')       
('l_int32', '*plen')       
  getCutPathForHole()

      Input:  pix  (of c.c.)
              pta  (of outer border)
              boxinner (b.b. of hole path)
              &dir  (direction (0-3), returned; only needed for debug)
              &len  (length of path, returned)
      Return: pta of pts on cut path from the hole border
              to the outer border, including end points on
              both borders; or null on error

  Notes:
      (1) If we don't find a path, we return a pta with no pts
          in it and len = 0.
      (2) The goal is to get a reasonably short path between the
          inner and outer borders, that goes entirely within the fg of
          the pix.  This function is cheap-and-dirty, may fail for some
          holes in complex topologies such as those you might find in a
          moderately dark scanned halftone.  If it fails to find a
          path to any particular hole, it gives a warning, and because
          that hole path is not included, the hole will not be rendered.


        """
        args = _convert_params(*args)
        
        return leptonica.getCutPathForHole(*args)
    
    

    try:
        leptonica.pixGetOuterBorderPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetOuterBorderPta.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetOuterBorderPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetOuterBorderPta(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
  pixGetOuterBorderPta()

      Input:  pixs (1 bpp, one 8-connected component)
              box  (<optional> of pixs, in global coordinates)
      Return: pta (of outer border, in global coords), or null on error

  Notes:
      (1) We are finding the exterior border of a single 8-connected
          component.
      (2) If box is NULL, the outline returned is in the local coords
          of the input pix.  Otherwise, box is assumed to give the
          location of the pix in global coordinates, and the returned
          pta will be in those global coordinates.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetOuterBorderPta(*args)
    
    

    try:
        leptonica.ccbaGenerateGlobalLocs.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGenerateGlobalLocs.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaGenerateGlobalLocs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateGlobalLocs(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaGenerateGlobalLocs()

      Input:  ccba (with local chain ptaa of borders computed)
      Return: 0 if OK, 1 on error

  Action: this uses the pixel locs in the local ptaa, which are all
          relative to each c.c., to find the global pixel locations,
          and stores them in the global ptaa.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateGlobalLocs(*args)
    
    

    try:
        leptonica.ccbCreate.argtypes = [ctypes.c_void_p]
        leptonica.ccbCreate.restype = lambda address: CCBORD(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbCreate(*args):
        """
        ('PIX', '*pixs')       
  ccbCreate()

     Input:  pixs  (<optional>)
     Return: ccb or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbCreate(*args)
    
    

    try:
        leptonica.ccbaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWriteStream(*args):
        """
        ('FILE', '*fp')       
('CCBORDA', '*ccba')       
  ccbaWriteStream()

      Input:  stream
              ccba
      Return: 0 if OK; 1 on error

  Format:  ccba: %7d cc\n (num. c.c.) (ascii)   (18B)
           pix width (4B)
           pix height (4B)
           [for i = 1, ncc]
               ulx  (4B)
               uly  (4B)
               w    (4B)       -- not req'd for reconstruction
               h    (4B)       -- not req'd for reconstruction
               number of borders (4B)
               [for j = 1, nb]
                   startx  (4B)
                   starty  (4B)
                   [for k = 1, nb]
                        2 steps (1B)
                   end in z8 or 88  (1B)


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWriteStream(*args)
    
    

    try:
        leptonica.ccbaWriteSVGString.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaWriteSVGString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function ccbaWriteSVGString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWriteSVGString(*args):
        """
        ('const char', '*filename')       
('CCBORDA', '*ccba')       
  ccbaWriteSVGString()

      Input:  filename
              ccba
      Return: string in svg-formatted, that can be written to file,
              or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWriteSVGString(*args)
    
    

    try:
        leptonica.pixGetOuterBorder.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetOuterBorder.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetOuterBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetOuterBorder(*args):
        """
        ('CCBORD', '*ccb')       
('PIX', '*pixs')       
('BOX', '*box')       
  pixGetOuterBorder()

      Input:  ccb  (unfilled)
              pixs (for the component at hand)
              box  (for the component, in global coords)
      Return: 0 if OK, 1 on error

  Notes:
      (1) the border is saved in relative coordinates within
          the c.c. (pixs).  Because the calculation is done
          in pixb with added 1 pixel border, we must subtract
          1 from each pixel value before storing it.
      (2) the stopping condition is that after the first pixel is
          returned to, the next pixel is the second pixel.  Having
          these 2 pixels recur in sequence proves the path is closed,
          and we do not store the second pixel again.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetOuterBorder(*args)
    
    

    try:
        leptonica.ccbDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ccbDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function ccbDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbDestroy(*args):
        """
        ('CCBORD', '**pccb')       
  ccbDestroy()

     Input:  &ccb (<to be nulled>)
     Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.ccbDestroy(*args)
    
    

    try:
        leptonica.ccbaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.ccbaReadStream.restype = lambda address: CCBORDA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaReadStream(*args):
        """
        ('FILE', '*fp')       
  ccbaReadStream()

      Input:   stream
      Return:  ccba, or null on error

  Format:  ccba: %7d cc\n (num. c.c.) (ascii)   (17B)
           pix width (4B)
           pix height (4B)
           [for i = 1, ncc]
               ulx  (4B)
               uly  (4B)
               w    (4B)       -- not req'd for reconstruction
               h    (4B)       -- not req'd for reconstruction
               number of borders (4B)
               [for j = 1, nb]
                   startx  (4B)
                   starty  (4B)
                   [for k = 1, nb]
                        2 steps (1B)
                   end in z8 or 88  (1B)


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaReadStream(*args)
    
    

    try:
        leptonica.ccbaDisplayImage1.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplayImage1.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaDisplayImage1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplayImage1(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaDisplayImage1()

      Input:  ccborda
      Return: pix of image, or null on error

  Notes:
      (1) Uses local ptaa, which gives each border pixel in
          local coordinates, so the actual pixel positions must
          be computed using all offsets.
      (2) For the holes, use coordinates relative to the c.c.
      (3) This is slower than Method 2.
      (4) This uses topological properties (Method 1) to do scan
          conversion to raster

  This algorithm deserves some commentary.

  I first tried the following:
    - outer borders: 4-fill from outside, stopping at the
         border, using pixFillClosedBorders()
    - inner borders: 4-fill from outside, stopping again
         at the border, XOR with the border, and invert
         to get the hole.  This did not work, because if
         you have a hole border that looks like:

                x x x x x x
                x          x
                x   x x x   x
                  x x o x   x
                      x     x
                      x     x
                        x x x

         if you 4-fill from the outside, the pixel 'o' will
         not be filled!  XORing with the border leaves it OFF.
         Inverting then gives a single bad ON pixel that is not
         actually part of the hole.

  So what you must do instead is 4-fill the holes from inside.
  You can do this from a seedfill, using a pix with the hole
  border as the filling mask.  But you need to start with a
  pixel inside the hole.  How is this determined?  The best
  way is from the contour.  We have a right-hand shoulder
  rule for inside (i.e., the filled region).   Take the
  first 2 pixels of the hole border, and compute dx and dy
  (second coord minus first coord:  dx = sx - fx, dy = sy - fy).
  There are 8 possibilities, depending on the values of dx and
  dy (which can each be -1, 0, and +1, but not both 0).
  These 8 cases can be broken into 4; see the simple algorithm below.
  Once you have an interior seed pixel, you fill from the seed,
  clipping with the hole border pix by filling into its invert.

  You then successively XOR these interior filled components, in any order.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplayImage1(*args)
    
    

    try:
        leptonica.ccbaDisplayImage2.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplayImage2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaDisplayImage2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplayImage2(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaDisplayImage2()

      Input: ccborda
      Return: pix of image, or null on error

  Notes:
      (1) Uses local chain ptaa, which gives each border pixel in
          local coordinates, so the actual pixel positions must
          be computed using all offsets.
      (2) Treats exterior and hole borders on equivalent
          footing, and does all calculations on a pix
          that spans the c.c. with a 1 pixel added boundary.
      (3) This uses topological properties (Method 2) to do scan
          conversion to raster
      (4) The algorithm is described at the top of this file (Method 2).
          It is preferred to Method 1 because it is between 1.2x and 2x
          faster than Method 1.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplayImage2(*args)
    
    

    try:
        leptonica.ccbaAddCcb.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaAddCcb.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ccbaAddCcb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaAddCcb(*args):
        """
        ('CCBORDA', '*ccba')       
('CCBORD', '*ccb')       
  ccbaAddCcb()

      Input:  ccba
              ccb (to be added by insertion)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaAddCcb(*args)
    
    

    try:
        leptonica.ccbaDisplaySPBorder.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplaySPBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ccbaDisplaySPBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplaySPBorder(*args):
        """
        ('CCBORDA', '*ccba')       
  ccbaDisplaySPBorder()

      Input:  ccba
      Return: pix of border pixels, or null on error

  Notes:
      (1) Uses spglobal pta, which gives each border pixel in
          global coordinates, one path per c.c., and must
          be computed in advance by calling ccbaGenerateSPGlobalLocs().


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplaySPBorder(*args)
    
    

    try:
        leptonica.ccbaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function ccbaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDestroy(*args):
        """
        ('CCBORDA', '**pccba')       
  ccbaDestroy()

     Input:  &ccba  (<to be nulled>)
     Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDestroy(*args)
    




class readfile(object):
    """  readfile.c:  reads image on file into memory

      Top-level functions for reading images from file
           PIXA      *pixaReadFiles()
           PIXA      *pixaReadFilesSA()
           PIX       *pixRead()
           PIX       *pixReadWithHint()
           PIX       *pixReadIndexed()
           PIX       *pixReadStream()

      Read header information from file
           l_int32    pixReadHeader()

      Format finders
           l_int32    findFileFormat()
           l_int32    findFileFormatStream()
           l_int32    findFileFormatBuffer()
           l_int32    fileFormatIsTiff()

      Read from memory
           PIX       *pixReadMem()
           l_int32    pixReadHeaderMem()

      Test function for I/O with different formats
           l_int32    ioFormatTest()

  Supported file formats:
  (1) Reading is supported without any external libraries:
          bmp
          pnm   (including pbm, pgm, etc)
          spix  (raw serialized)
  (2) Reading is supported with installation of external libraries:
          png
          jpg   (standard jfif version)
          tiff  (including most varieties of compression)
          gif
          webp
  (3) This file format is recognized by the library but reading
      is not supported:
          jp2 (jpeg2000)
  (4) All other file types will get an "unknown format" error.

"""
    
    try:
        leptonica.pixReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMem.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
  pixReadMem()

      Input:  data (const; encoded)
              datasize (size of data)
      Return: pix, or null on error

  Notes:
      (1) This is a variation of pixReadStream(), where the data is read
          from a memory buffer rather than a file.
      (2) On windows, this only reads tiff formatted files directly from
          memory.  For other formats, it write to a temp file and
          decompress from file.
      (3) findFileFormatBuffer() requires up to 8 bytes to decide on
          the format.  That determines the constraint here.  But in
          fact the data must contain the entire compressed string for
          the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMem(*args)
    
    

    try:
        leptonica.pixRead.argtypes = [ctypes.c_void_p]
        leptonica.pixRead.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRead(*args):
        """
        ('const char', '*filename')       
  pixRead()

      Input:  filename (with full pathname or in local directory)
      Return: pix if OK; null on error

  Notes:
      (1) See at top of file for supported formats.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRead(*args)
    
    

    try:
        leptonica.pixaReadFilesSA.argtypes = [ctypes.c_void_p]
        leptonica.pixaReadFilesSA.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaReadFilesSA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadFilesSA(*args):
        """
        ('SARRAY', '*sa')       
  pixaReadFilesSA()

      Input:  sarray (full pathnames for all files)
      Return: pixa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadFilesSA(*args)
    
    

    try:
        leptonica.findFileFormat.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findFileFormat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function findFileFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findFileFormat(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pformat')       
  findFileFormat()

      Input:  filename
              &format (<return>)
      Return: 0 if OK, 1 on error or if format is not recognized


        """
        args = _convert_params(*args)
        
        return leptonica.findFileFormat(*args)
    
    

    try:
        leptonica.pixReadHeader.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixReadHeader.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixReadHeader not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadHeader(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pformat')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  pixReadHeader()

      Input:  filename (with full pathname or in local directory)
              &format (<optional return> file format)
              &w, &h (<optional returns> width and height)
              &bps <optional return> bits/sample
              &spp <optional return> samples/pixel (1, 3 or 4)
              &iscmap (<optional return> 1 if cmap exists; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This reads the actual headers for jpeg, png, tiff and pnm.
          For bmp and gif, we cheat and read the entire file into a pix,
          from which we extract the "header" information.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadHeader(*args)
    
    

    try:
        leptonica.fileFormatIsTiff.argtypes = [ctypes.c_void_p]
        leptonica.fileFormatIsTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fileFormatIsTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileFormatIsTiff(*args):
        """
        ('FILE', '*fp')       
  fileFormatIsTiff()

      Input:  fp (file stream)
      Return: 1 if file is tiff; 0 otherwise or on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileFormatIsTiff(*args)
    
    

    try:
        leptonica.pixReadWithHint.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadWithHint.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadWithHint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadWithHint(*args):
        """
        ('const char', '*filename')       
('l_int32', 'hint')       
  pixReadWithHint()

      Input:  filename (with full pathname or in local directory)
              hint (bitwise OR of L_HINT_* values for jpeg; use 0 for no hint)
      Return: pix if OK; null on error

  Notes:
      (1) The hint is not binding, but may be used to optimize jpeg decoding.
          Use 0 for no hinting.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadWithHint(*args)
    
    

    try:
        leptonica.findFileFormatBuffer.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findFileFormatBuffer.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function findFileFormatBuffer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findFileFormatBuffer(*args):
        """
        ('const l_uint8', '*buf')       
('l_int32', '*pformat')       
  findFileFormatBuffer()

      Input:  byte buffer (at least 12 bytes in size; we can't check)
              &format (<return>)
      Return: 0 if OK, 1 on error or if format is not recognized

  Notes:
      (1) This determines the file format from the first 12 bytes in
          the compressed data stream, which are stored in memory.
      (2) For tiff files, this returns IFF_TIFF.  The specific tiff
          compression is then determined using findTiffCompression().


        """
        args = _convert_params(*args)
        
        return leptonica.findFileFormatBuffer(*args)
    
    

    try:
        leptonica.ioFormatTest.argtypes = [ctypes.c_void_p]
        leptonica.ioFormatTest.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ioFormatTest not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ioFormatTest(*args):
        """
        ('const char', '*filename')       
  ioFormatTest()

      Input:  filename (input file)
      Return: 0 if OK; 1 on error or if the test fails

  Notes:
      (1) This writes and reads a set of output files losslessly
          in different formats to /tmp/format/, and tests that the
          result before and after is unchanged.
      (2) This should work properly on input images of any depth,
          with and without colormaps.
      (3) All supported formats are tested for bmp, png, tiff and
          non-ascii pnm.  Ascii pnm also works (but who'd ever want
          to use it?)   We allow 2 bpp bmp, although it's not
          supported elsewhere.  And we don't support reading
          16 bpp png, although this can be turned on in pngio.c.
      (4) This silently skips png or tiff testing if HAVE_LIBPNG
          or HAVE_LIBTIFF are 0, respectively.


        """
        args = _convert_params(*args)
        
        return leptonica.ioFormatTest(*args)
    
    

    try:
        leptonica.pixReadStream.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadStream.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStream(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'hint')       
  pixReadStream()

      Input:  fp (file stream)
              hint (bitwise OR of L_HINT_* values for jpeg; use 0 for no hint)
      Return: pix if OK; null on error

  Notes:
      (1) The hint only applies to jpeg.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStream(*args)
    
    

    try:
        leptonica.pixReadIndexed.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadIndexed.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadIndexed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadIndexed(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       
  pixReadIndexed()

      Input:  sarray (of full pathnames)
              index (into pathname array)
      Return: pix if OK; null if not found

  Notes:
      (1) This function is useful for selecting image files from a
          directory, where the integer @index is embedded into
          the file name.
      (2) This is typically done by generating the sarray using
          getNumberedPathnamesInDirectory(), so that the @index
          pathname would have the number @index in it.  The size
          of the sarray should be the largest number (plus 1) appearing
          in the file names, respecting the constraints in the
          call to getNumberedPathnamesInDirectory().
      (3) Consequently, for some indices into the sarray, there may
          be no pathnames in the directory containing that number.
          By convention, we place empty C strings ("") in those
          locations in the sarray, and it is not an error if such
          a string is encountered and no pix is returned.
          Therefore, the caller must verify that a pix is returned.
      (4) See convertSegmentedPagesToPS() in src/psio1.c for an
          example of usage.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadIndexed(*args)
    
    

    try:
        leptonica.findFileFormatStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findFileFormatStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function findFileFormatStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findFileFormatStream(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pformat')       
  findFileFormatStream()

      Input:  fp (file stream)
              &format (<return>)
      Return: 0 if OK, 1 on error or if format is not recognized

  Notes:
      (1) Important: Side effect -- this resets fp to BOF.


        """
        args = _convert_params(*args)
        
        return leptonica.findFileFormatStream(*args)
    
    

    try:
        leptonica.pixReadHeaderMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixReadHeaderMem.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixReadHeaderMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadHeaderMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pformat')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  pixReadHeaderMem()

      Input:  data (const; encoded)
              datasize (size of data)
              &format (<optional returns> image format)
              &w, &h (<optional returns> width and height)
              &bps <optional return> bits/sample
              &spp <optional return> samples/pixel (1, 3 or 4)
              &iscmap (<optional return> 1 if cmap exists; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This reads the actual headers for jpeg, png, tiff, jp2k and pnm.
          For bmp and gif, we cheat and read all the data into a pix,
          from which we extract the "header" information.
      (2) The amount of data required depends on the format.  For
          png, it requires less than 30 bytes, but for jpeg it can
          require most of the compressed file.  In practice, the data
          is typically the entire compressed file in memory.
      (3) findFileFormatBuffer() requires up to 8 bytes to decide on
          the format, which we require.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadHeaderMem(*args)
    
    

    try:
        leptonica.pixaReadFiles.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaReadFiles.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaReadFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
  pixaReadFiles()

      Input:  dirname
              substr (<optional> substring filter on filenames; can be null)
      Return: pixa, or null on error

  Notes:
      (1) @dirname is the full path for the directory.
      (2) @substr is the part of the file name (excluding
          the directory) that is to be matched.  All matching
          filenames are read into the Pixa.  If substr is NULL,
          all filenames are read into the Pixa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadFiles(*args)
    




class webpiostub(object):
    """  webpiostub.c

     Stubs for webpio.c functions

"""
    



class classapp(object):
    """  classapp.c

      Top-level jb2 correlation and rank-hausdorff

         l_int32         jbCorrelation()
         l_int32         jbRankHaus()

      Extract and classify words in textline order

         JBCLASSER      *jbWordsInTextlines()
         l_int32         pixGetWordsInTextlines()
         l_int32         pixGetWordBoxesInTextlines()

      Use word bounding boxes to compare page images

         NUMAA          *boxaExtractSortedPattern()
         l_int32         numaaCompareImagesByBoxes()
         static l_int32  testLineAlignmentX()
         static l_int32  countAlignedMatches()
         static void     printRowIndices()

"""
    
    try:
        leptonica.numaaCompareImagesByBoxes.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaaCompareImagesByBoxes.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function numaaCompareImagesByBoxes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaCompareImagesByBoxes(*args):
        """
        ('NUMAA', '*naa1')       
('NUMAA', '*naa2')       
('l_int32', 'nperline')       
('l_int32', 'nreq')       
('l_int32', 'maxshiftx')       
('l_int32', 'maxshifty')       
('l_int32', 'delx')       
('l_int32', 'dely')       
('l_int32', '*psame')       
('l_int32', 'debugflag')       
  numaaCompareImagesByBoxes()

      Input:  naa1 (for image 1, formatted by boxaExtractSortedPattern())
              naa2 (ditto; for image 2)
              nperline (number of box regions to be used in each textline)
              nreq (number of complete row matches required)
              maxshiftx (max allowed x shift between two patterns, in pixels)
              maxshifty (max allowed y shift between two patterns, in pixels)
              delx (max allowed difference in x data, after alignment)
              dely (max allowed difference in y data, after alignment)
              &same (<return> 1 if @nreq row matches are found; 0 otherwise)
              debugflag (1 for debug output)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Each input numaa describes a set of sorted bounding boxes
          (sorted by textline and, within each textline, from
          left to right) in the images from which they are derived.
          See boxaExtractSortedPattern() for a description of the data
          format in each of the input numaa.
      (2) This function does an alignment between the input
          descriptions of bounding boxes for two images. The
          input parameter @nperline specifies the number of boxes
          to consider in each line when testing for a match, and
          @nreq is the required number of lines that must be well-aligned
          to get a match.
      (3) Testing by alignment has 3 steps:
          (a) Generating the location of word bounding boxes from the
              images (prior to calling this function).
          (b) Listing all possible pairs of aligned rows, based on
              tolerances in horizontal and vertical positions of
              the boxes.  Specifically, all pairs of rows are enumerated
              whose first @nperline boxes can be brought into close
              alignment, based on the delx parameter for boxes in the
              line and within the overall the @maxshiftx and @maxshifty
              constraints.
          (c) Each pair, starting with the first, is used to search
              for a set of @nreq - 1 other pairs that can all be aligned
              with a difference in global translation of not more
              than (@delx, @dely).


        """
        args = _convert_params(*args)
        
        return leptonica.numaaCompareImagesByBoxes(*args)
    
    

    try:
        leptonica.pixGetWordsInTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetWordsInTextlines.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetWordsInTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetWordsInTextlines(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'reduction')       
('l_int32', 'minwidth')       
('l_int32', 'minheight')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxad')       
('PIXA', '**ppixad')       
('NUMA', '**pnai')       
  pixGetWordsInTextlines()

      Input:  pixs (1 bpp, typ. 300 ppi)
              reduction (1 for input res; 2 for 2x reduction of input res)
              minwidth, minheight (of saved components; smaller are discarded)
              maxwidth, maxheight (of saved components; larger are discarded)
              &boxad (<return> word boxes sorted in textline line order)
              &pixad (<return> word images sorted in textline line order)
              &naindex (<return> index of textline for each word)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The input should be at a resolution of about 300 ppi.
          The word masks and word images can be computed at either
          150 ppi or 300 ppi.  For the former, set reduction = 2.
      (2) The four size constraints on saved components are all
          scaled by @reduction.
      (3) The result are word images (and their b.b.), extracted in
          textline order, at either full res or 2x reduction,
          and with a numa giving the textline index for each word.
      (4) The pixa and boxa interfaces should make this type of
          application simple to put together.  The steps are:
           - optionally reduce by 2x
           - generate first estimate of word masks
           - get b.b. of these, and remove the small and big ones
           - extract pixa of the word images, using the b.b.
           - sort actual word images in textline order (2d)
           - flatten them to a pixa (1d), saving the textline index
             for each pix
      (5) In an actual application, it may be desirable to pre-filter
          the input image to remove large components, to extract
          single columns of text, and to deskew them.  For example,
          to remove both large components and small noisy components
          that can interfere with the statistics used to estimate
          parameters for segmenting by words, but still retain text lines,
          the following image preprocessing can be done:
                Pix *pixt = pixMorphSequence(pixs, "c40.1", 0);
                Pix *pixf = pixSelectBySize(pixt, 0, 60, 8,
                                     L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL);
                pixAnd(pixf, pixf, pixs);  // the filtered image
          The closing turns text lines into long blobs, but does not
          significantly increase their height.  But if there are many
          small connected components in a dense texture, this is likely
          to generate tall components that will be eliminated in pixf.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetWordsInTextlines(*args)
    
    

    try:
        leptonica.pixGetWordBoxesInTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetWordBoxesInTextlines.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetWordBoxesInTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetWordBoxesInTextlines(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'reduction')       
('l_int32', 'minwidth')       
('l_int32', 'minheight')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxad')       
('NUMA', '**pnai')       
  pixGetWordBoxesInTextlines()

      Input:  pixs (1 bpp, typ. 300 ppi)
              reduction (1 for input res; 2 for 2x reduction of input res)
              minwidth, minheight (of saved components; smaller are discarded)
              maxwidth, maxheight (of saved components; larger are discarded)
              &boxad (<return> word boxes sorted in textline line order)
              &naindex (<optional return> index of textline for each word)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The input should be at a resolution of about 300 ppi.
          The word masks can be computed at either 150 ppi or 300 ppi.
          For the former, set reduction = 2.
      (2) This is a special version of pixGetWordsInTextlines(), that
          just finds the word boxes in line order, with a numa
          giving the textline index for each word.
          See pixGetWordsInTextlines() for more details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetWordBoxesInTextlines(*args)
    
    

    try:
        leptonica.boxaExtractSortedPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaExtractSortedPattern.restype = lambda address: NUMAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaExtractSortedPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractSortedPattern(*args):
        """
        ('BOXA', '*boxa')       
('NUMA', '*na')       
  boxaExtractSortedPattern()

      Input:  boxa (typ. of word bounding boxes, in textline order)
              numa (index of textline for each box in boxa)
      Return: naa (numaa, where each numa represents one textline),
                   or null on error

  Notes:
      (1) The input is expected to come from pixGetWordBoxesInTextlines().
      (2) Each numa in the output consists of an average y coordinate
          of the first box in the textline, followed by pairs of
          x coordinates representing the left and right edges of each
          of the boxes in the textline.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractSortedPattern(*args)
    
    

    try:
        leptonica.jbWordsInTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.jbWordsInTextlines.restype = lambda address: JBCLASSER(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbWordsInTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbWordsInTextlines(*args):
        """
        ('const char', '*dirin')       
('l_int32', 'reduction')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_float32', 'thresh')       
('l_float32', 'weight')       
('NUMA', '**pnatl')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
  jbWordsInTextlines()

      Input:  dirin (directory of input pages)
              reduction (1 for full res; 2 for half-res)
              maxwidth (of word mask components, to be kept)
              maxheight (of word mask components, to be kept)
              thresh (on correlation; 0.80 is reasonable)
              weight (for handling thick text; 0.6 is reasonable)
              natl (<return> numa with textline index for each component)
              firstpage (0-based)
              npages (use 0 for all pages in dirin)
      Return: classer (for the set of pages)

  Notes:
      (1) This is a high-level function.  See prog/jbwords for example
          of usage.
      (2) Typically, words can be found reasonably well at a resolution
          of about 150 ppi.  For highest accuracy, you should use 300 ppi.
          Assuming that the input images are 300 ppi, use reduction = 1
          for finding words at full res, and reduction = 2 for finding
          them at 150 ppi.


        """
        args = _convert_params(*args)
        
        return leptonica.jbWordsInTextlines(*args)
    
    

    try:
        leptonica.jbRankHaus.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.jbRankHaus.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbRankHaus not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbRankHaus(*args):
        """
        ('const char', '*dirin')       
('l_int32', 'size')       
('l_float32', 'rank')       
('l_int32', 'components')       
('const char', '*rootname')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
('l_int32', 'renderflag')       
  jbRankHaus()

       Input:  dirin (directory of input images)
               size (of Sel used for dilation; typ. 2)
               rank (rank value of match; typ. 0.97)
               components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)
               rootname (for output files)
               firstpage (0-based)
               npages (use 0 for all pages in dirin)
               renderflag (1 to render from templates; 0 to skip)
       Return: 0 if OK, 1 on error

  Notes:
      (1) See prog/jbrankhaus for generating more output (e.g.,
          for debugging)


        """
        args = _convert_params(*args)
        
        return leptonica.jbRankHaus(*args)
    
    

    try:
        leptonica.jbCorrelation.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.jbCorrelation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbCorrelation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbCorrelation(*args):
        """
        ('const char', '*dirin')       
('l_float32', 'thresh')       
('l_float32', 'weight')       
('l_int32', 'components')       
('const char', '*rootname')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
('l_int32', 'renderflag')       
  jbCorrelation()

       Input:  dirin (directory of input images)
               thresh (typically ~0.8)
               weight (typically ~0.6)
               components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)
               rootname (for output files)
               firstpage (0-based)
               npages (use 0 for all pages in dirin)
               renderflag (1 to render from templates; 0 to skip)
       Return: 0 if OK, 1 on error

  Notes:
      (1) The images must be 1 bpp.  If they are not, you can convert
          them using convertFilesTo1bpp().
      (2) See prog/jbcorrelation for generating more output (e.g.,
          for debugging)


        """
        args = _convert_params(*args)
        
        return leptonica.jbCorrelation(*args)
    




class pixcomp(object):
    """   pixcomp.c

      Pixcomp creation and destruction
           PIXC     *pixcompCreateFromPix()
           PIXC     *pixcompCreateFromString()
           PIXC     *pixcompCreateFromFile()
           void      pixcompDestroy()

      Pixcomp accessors
           l_int32   pixcompGetDimensions()
           l_int32   pixcompDetermineFormat()

      Pixcomp conversion to Pix
           PIX      *pixCreateFromPixcomp()

      Pixacomp creation and destruction
           PIXAC    *pixacompCreate()
           PIXAC    *pixacompCreateWithInit()
           PIXAC    *pixacompCreateFromPixa()
           PIXAC    *pixacompCreateFromFiles()
           PIXAC    *pixacompCreateFromSA()
           void      pixacompDestroy()

      Pixacomp addition/replacement
           l_int32   pixacompAddPix()
           l_int32   pixacompAddPixcomp()
           static l_int32  pixacompExtendArray()
           l_int32   pixacompReplacePix()
           l_int32   pixacompReplacePixcomp()
           l_int32   pixacompAddBox()

      Pixacomp accessors
           l_int32   pixacompGetCount()
           PIXC     *pixacompGetPixcomp()
           PIX      *pixacompGetPix()
           l_int32   pixacompGetPixDimensions()
           BOXA     *pixacompGetBoxa()
           l_int32   pixacompGetBoxaCount()
           BOX      *pixacompGetBox()
           l_int32   pixacompGetBoxGeometry()
           l_int32   pixacompGetOffset()
           l_int32   pixacompSetOffset()

      Pixacomp conversion to Pixa
           PIXA     *pixaCreateFromPixacomp()

      Pixacomp serialized I/O
           PIXAC    *pixacompRead()
           PIXAC    *pixacompReadStream()
           l_int32   pixacompWrite()
           l_int32   pixacompWriteStream()

      Conversion to pdf
           l_int32   pixacompConvertToPdf()
           l_int32   pixacompConvertToPdfData()

      Output for debugging
           l_int32   pixacompWriteStreamInfo()
           l_int32   pixcompWriteStreamInfo()
           PIX      *pixacompDisplayTiledAndScaled()

   The Pixacomp is an array of Pixcomp, where each Pixcomp is a compressed
   string of the image.  We don't use reference counting here.
   The basic application is to allow a large array of highly
   compressible images to reside in memory.  We purposely don't
   reuse the Pixa for this, to avoid confusion and programming errors.

   Three compression formats are used: g4, png and jpeg.
   The compression type can be either specified or defaulted.
   If specified and it is not possible to compress (for example,
   you specify a jpeg on a 1 bpp image or one with a colormap),
   the compression type defaults to png.

   The serialized version of the Pixacomp is similar to that for
   a Pixa, except that each Pixcomp can be compressed by one of
   tiffg4, png, or jpeg.  Unlike serialization of the Pixa,
   serialization of the Pixacomp does not require any imaging
   libraries because it simply reads and writes the compressed data.

   There are two modes of use in accumulating images:
     (1) addition to the end of the array
     (2) random insertion (replacement) into the array

   In use, we assume that the array is fully populated up to the
   index value (n - 1), where n is the value of the pixcomp field n.
   Addition can only be made to the end of the fully populated array,
   at the index value n.  Insertion can be made randomly, but again
   only within the array of pixcomps; i.e., within the set of
   indices {0 .... n-1}.  The functions are pixacompReplacePix()
   and pixacompReplacePixcomp(), and they destroy the existing pixcomp.

   For addition to the end of the array, use pixacompCreate(), which
   generates an initially empty array of pixcomps.  For random
   insertion and replacement of pixcomp into a pixacomp,
   initialize a fully populated array using pixacompCreateWithInit().

   The offset field allows you to use an offset-based index to
   access the 0-based ptr array in the pixacomp.  This would typically
   be used to map the pixacomp array index to a page number, or v.v.
   By default, the offset is 0.  For example, suppose you have 50 images,
   corresponding to page numbers 10 - 59.  Then you would use
      pixac = pixacompCreateWithInit(50, 10, ...);
   This would allocate an array of 50 pixcomps, but if you asked for
   the pix at index 10, using pixacompGetPix(pixac, 10), it would
   apply the offset internally, returning the pix at index 0 in the array.

"""
    
    try:
        leptonica.pixacompGetPixcomp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompGetPixcomp.restype = lambda address: PIXC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetPixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetPixcomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
  pixacompGetPixcomp()

      Input:  pixac
              index (caller's view of index within pixac; includes offset)
      Return: pixc, or null on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.
      (2) Important: this is just a ptr to the pixc owned by the pixac.
          Do not destroy unless you are replacing the pixc.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetPixcomp(*args)
    
    

    try:
        leptonica.pixacompWriteStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompWriteStreamInfo.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompWriteStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWriteStreamInfo(*args):
        """
        ('FILE', '*fp')       
('PIXAC', '*pixac')       
('const char', '*text')       
  pixacompWriteStreamInfo()

      Input:  fp (file stream)
              pixac
              text (<optional> identifying string; can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWriteStreamInfo(*args)
    
    

    try:
        leptonica.pixaCreateFromPixacomp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaCreateFromPixacomp.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCreateFromPixacomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreateFromPixacomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'accesstype')       
  pixaCreateFromPixacomp()

      Input:  pixac
              accesstype (L_COPY, L_CLONE, L_COPY_CLONE; for boxa)
      Return: pixa if OK, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreateFromPixacomp(*args)
    
    

    try:
        leptonica.pixacompRead.argtypes = [ctypes.c_void_p]
        leptonica.pixacompRead.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompRead(*args):
        """
        ('const char', '*filename')       
  pixacompRead()

      Input:  filename
      Return: pixac, or null on error

  Notes:
      (1) Unlike the situation with serialized Pixa, where the image
          data is stored in png format, the Pixacomp image data
          can be stored in tiffg4, png and jpg formats.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompRead(*args)
    
    

    try:
        leptonica.pixacompAddPixcomp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompAddPixcomp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompAddPixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompAddPixcomp(*args):
        """
        ('PIXAC', '*pixac')       
('PIXC', '*pixc')       
  pixacompAddPixcomp()

      Input:  pixac
              pixc  (to be added by insertion)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompAddPixcomp(*args)
    
    

    try:
        leptonica.pixCreateFromPixcomp.argtypes = [ctypes.c_void_p]
        leptonica.pixCreateFromPixcomp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreateFromPixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateFromPixcomp(*args):
        """
        ('PIXC', '*pixc')       
  pixCreateFromPixcomp()

      Input:  pixc
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateFromPixcomp(*args)
    
    

    try:
        leptonica.pixacompGetPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompGetPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetPix(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
  pixacompGetPix()

      Input:  pixac
              index (caller's view of index within pixac; includes offset)
      Return: pix, or null on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetPix(*args)
    
    

    try:
        leptonica.pixacompGetBoxGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompGetBoxGeometry.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetBoxGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBoxGeometry(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  pixacompGetBoxGeometry()

      Input:  pixac
              index (caller's view of index within pixac; includes offset)
              &x, &y, &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBoxGeometry(*args)
    
    

    try:
        leptonica.pixcompCreateFromString.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.pixcompCreateFromString.restype = lambda address: PIXC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcompCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCreateFromString(*args):
        """
        ('l_uint8', '*data')       
('size_t', 'size')       
('l_int32', 'copyflag')       
  pixcompCreateFromString()

      Input:  data (compressed string)
              size (number of bytes)
              copyflag (L_INSERT or L_COPY)
      Return: pixc, or null on error

  Notes:
      (1) This works when the compressed string is png, jpeg or tiffg4.
      (2) The copyflag determines if the data in the new Pixcomp is
          a copy of the input data.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCreateFromString(*args)
    
    

    try:
        leptonica.pixacompGetBoxaCount.argtypes = [ctypes.c_void_p]
        leptonica.pixacompGetBoxaCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetBoxaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBoxaCount(*args):
        """
        ('PIXAC', '*pixac')       
  pixacompGetBoxaCount()

      Input:  pixac
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBoxaCount(*args)
    
    

    try:
        leptonica.pixacompGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompGetBox.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBox(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', 'accesstype')       
  pixacompGetBox()

      Input:  pixac
              index (caller's view of index within pixac; includes offset)
              accesstype  (L_COPY or L_CLONE)
      Return: box (if null, not automatically an error), or null on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.
      (2) There is always a boxa with a pixac, and it is initialized so
          that each box ptr is NULL.
      (3) In general, we expect that there is either a box associated
          with each pixc, or no boxes at all in the boxa.
      (4) Having no boxes is thus not an automatic error.  Whether it
          is an actual error is determined by the calling program.
          If the caller expects to get a box, it is an error; see, e.g.,
          pixacGetBoxGeometry().


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBox(*args)
    
    

    try:
        leptonica.pixacompAddPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompAddPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompAddPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompAddPix(*args):
        """
        ('PIXAC', '*pixac')       
('PIX', '*pix')       
('l_int32', 'comptype')       
  pixacompAddPix()

      Input:  pixac
              pix  (to be added)
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The array is filled up to the (n-1)-th element, and this
          converts the input pix to a pixcomp and adds it at
          the n-th position.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompAddPix(*args)
    
    

    try:
        leptonica.pixacompDisplayTiledAndScaled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompDisplayTiledAndScaled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompDisplayTiledAndScaled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompDisplayTiledAndScaled(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'outdepth')       
('l_int32', 'tilewidth')       
('l_int32', 'ncols')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       
  pixacompDisplayTiledAndScaled()

      Input:  pixac
              outdepth (output depth: 1, 8 or 32 bpp)
              tilewidth (each pix is scaled to this width)
              ncols (number of tiles in each row)
              background (0 for white, 1 for black; this is the color
                 of the spacing between the images)
              spacing  (between images, and on outside)
              border (width of additional black border on each image;
                      use 0 for no border)
      Return: pix of tiled images, or null on error

  Notes:
      (1) This is the same function as pixaDisplayTiledAndScaled(),
          except it works on a Pixacomp instead of a Pix.  It is particularly
          useful for showing the images in a Pixacomp at reduced resolution.
      (2) This can be used to tile a number of renderings of
          an image that are at different scales and depths.
      (3) Each image, after scaling and optionally adding the
          black border, has width 'tilewidth'.  Thus, the border does
          not affect the spacing between the image tiles.  The
          maximum allowed border width is tilewidth / 5.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompDisplayTiledAndScaled(*args)
    
    

    try:
        leptonica.pixacompConvertToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompConvertToPdfData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompConvertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompConvertToPdfData(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
  pixacompConvertToPdfData()

      Input:  pixac (containing images all at the same resolution)
              res (input resolution of all images)
              scalefactor (scaling factor applied to each image; > 0.0)
              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
                    L_FLATE_ENCODE, or 0 for default)
              quality (used for JPEG only; 0 for default (75))
              title (<optional> pdf title)
              &data (<return> output pdf data (of all images)
              &nbytes (<return> size of output pdf data)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixacompConvertToPdf().


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompConvertToPdfData(*args)
    
    

    try:
        leptonica.pixacompGetCount.argtypes = [ctypes.c_void_p]
        leptonica.pixacompGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetCount(*args):
        """
        ('PIXAC', '*pixac')       
  pixacompGetCount()

      Input:  pixac
      Return: count, or 0 if no pixa


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetCount(*args)
    
    

    try:
        leptonica.pixacompCreate.argtypes = [ctypes.c_int32]
        leptonica.pixacompCreate.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreate(*args):
        """
        ('l_int32', 'n')       
  pixacompCreate()

      Input:  n  (initial number of ptrs)
      Return: pixac, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreate(*args)
    
    

    try:
        leptonica.pixacompAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompAddBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompAddBox(*args):
        """
        ('PIXAC', '*pixac')       
('BOX', '*box')       
('l_int32', 'copyflag')       
  pixacompAddBox()

      Input:  pixac
              box
              copyflag (L_INSERT, L_COPY)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompAddBox(*args)
    
    

    try:
        leptonica.pixacompConvertToPdf.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompConvertToPdf.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompConvertToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompConvertToPdf(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('const char', '*fileout')       
  pixacompConvertToPdf()

      Input:  pixac (containing images all at the same resolution)
              res (override the resolution of each input image, in ppi;
                   use 0 to respect the resolution embedded in the input)
              scalefactor (scaling factor applied to each image; > 0.0)
              type (encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
                    L_FLATE_ENCODE, or 0 for default)
              quality (used for JPEG only; 0 for default (75))
              title (<optional> pdf title)
              fileout (pdf file of all images)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This follows closely the function pixaConvertToPdf() in pdfio.c.
      (2) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
          colormap and many colors, or 32 bpp; FLATE for anything else.
      (3) The scalefactor must be > 0.0; otherwise it is set to 1.0.
      (4) Specifying one of the three encoding types for @type forces
          all images to be compressed with that type.  Use 0 to have
          the type determined for each image based on depth and whether
          or not it has a colormap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompConvertToPdf(*args)
    
    

    try:
        leptonica.pixacompWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXAC', '*pixac')       
  pixacompWriteStream()

      Input:  stream
              pixac
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWriteStream(*args)
    
    

    try:
        leptonica.pixacompWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWrite(*args):
        """
        ('const char', '*filename')       
('PIXAC', '*pixac')       
  pixacompWrite()

      Input:  filename
              pixac
      Return: 0 if OK, 1 on error

  Notes:
      (1) Unlike the situation with serialized Pixa, where the image
          data is stored in png format, the Pixacomp image data
          can be stored in tiffg4, png and jpg formats.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWrite(*args)
    
    

    try:
        leptonica.pixcompGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcompGetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcompGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompGetDimensions(*args):
        """
        ('PIXC', '*pixc')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
  pixcompGetDimensions()

      Input:  pixc
              &w, &h, &d (<optional return>)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompGetDimensions(*args)
    
    

    try:
        leptonica.pixacompDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixacompDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixacompDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompDestroy(*args):
        """
        ('PIXAC', '**ppixac')       
  pixacompDestroy()

      Input:  &pixac (<to be nulled>)
      Return: void

  Notes:
      (1) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompDestroy(*args)
    
    

    try:
        leptonica.pixacompReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixacompReadStream.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReadStream(*args):
        """
        ('FILE', '*fp')       
  pixacompReadStream()

      Input:  stream
      Return: pixac, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReadStream(*args)
    
    

    try:
        leptonica.pixacompCreateFromSA.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompCreateFromSA.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompCreateFromSA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateFromSA(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'comptype')       
  pixacompCreateFromSA()

      Input:  sarray (full pathnames for all files)
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: pixac, or null on error

  Notes:
      (1) Use @comptype == IFF_DEFAULT to have the compression
          type automatically determined for each file.
      (2) If the comptype is invalid for a file, the default will
          be substituted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateFromSA(*args)
    
    

    try:
        leptonica.pixacompCreateFromFiles.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompCreateFromFiles.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompCreateFromFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateFromFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'comptype')       
  pixacompCreateFromFiles()

      Input:  dirname
              substr (<optional> substring filter on filenames; can be null)
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: pixac, or null on error

  Notes:
      (1) @dirname is the full path for the directory.
      (2) @substr is the part of the file name (excluding
          the directory) that is to be matched.  All matching
          filenames are read into the Pixa.  If substr is NULL,
          all filenames are read into the Pixa.
      (3) Use @comptype == IFF_DEFAULT to have the compression
          type automatically determined for each file.
      (4) If the comptype is invalid for a file, the default will
          be substituted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateFromFiles(*args)
    
    

    try:
        leptonica.pixacompCreateWithInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompCreateWithInit.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompCreateWithInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateWithInit(*args):
        """
        ('l_int32', 'n')       
('l_int32', 'offset')       
('PIX', '*pix')       
('l_int32', 'comptype')       
  pixacompCreateWithInit()

      Input:  n  (initial number of ptrs)
              offset (difference: accessor index - pixacomp array index)
              pix (<optional> initialize each ptr in pixacomp to this pix;
                   can be NULL)
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: pixac, or null on error

  Notes:
      (1) Initializes a pixacomp to be fully populated with @pix,
          compressed using @comptype.  If @pix == NULL, @comptype
          is ignored.
      (2) Typically, the array is initialized with a tiny pix.
          This is most easily done by setting @pix == NULL, causing
          initialization of each array element with a tiny placeholder
          pix (w = h = d = 1), using comptype = IFF_TIFF_G4 .
      (3) Example usage:
            // Generate pixacomp for pages 30 - 49.  This has an array
            // size of 20 and the page number offset is 30.
            PixaComp *pixac = pixacompCreateWithInit(20, 30, NULL,
                                                     IFF_TIFF_G4);
            // Now insert png-compressed images into the initialized array
            for (pageno = 30; pageno < 50; pageno++) {
                Pix *pixt = ...   // derived from image[pageno]
                if (pixt)
                    pixacompReplacePix(pixac, pageno, pixt, IFF_PNG);
                pixDestroy(&pixt);
            }
          The result is a pixac with 20 compressed strings, and with
          selected pixt replacing the placeholders.
          To extract the image for page 38, which is decompressed
          from element 8 in the array, use:
            pixt = pixacompGetPix(pixac, 38);


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateWithInit(*args)
    
    

    try:
        leptonica.pixacompCreateFromPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompCreateFromPixa.restype = lambda address: PIXAC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompCreateFromPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateFromPixa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'comptype')       
('l_int32', 'accesstype')       
  pixacompCreateFromPixa()

      Input:  pixa
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
              accesstype (L_COPY, L_CLONE, L_COPY_CLONE)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If @format == IFF_DEFAULT, the conversion format for each
          image is chosen automatically.  Otherwise, we use the
          specified format unless it can't be done (e.g., jpeg
          for a 1, 2 or 4 bpp pix, or a pix with a colormap),
          in which case we use the default (assumed best) compression.
      (2) @accesstype is used to extract a boxa from @pixa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateFromPixa(*args)
    
    

    try:
        leptonica.pixacompGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompGetBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBoxa(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'accesstype')       
  pixacompGetBoxa()

      Input:  pixac
              accesstype  (L_COPY, L_CLONE, L_COPY_CLONE)
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBoxa(*args)
    
    

    try:
        leptonica.pixacompReplacePix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompReplacePix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompReplacePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReplacePix(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('PIX', '*pix')       
('l_int32', 'comptype')       
  pixacompReplacePix()

      Input:  pixac
              index (caller's view of index within pixac; includes offset)
              pix  (owned by the caller)
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.
      (2) The input @pix is converted to a pixc, which is then inserted
          into the pixac.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReplacePix(*args)
    
    

    try:
        leptonica.pixcompCreateFromFile.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixcompCreateFromFile.restype = lambda address: PIXC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcompCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCreateFromFile(*args):
        """
        ('const char', '*filename')       
('l_int32', 'comptype')       
  pixcompCreateFromFile()

      Input:  filename
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: pixc, or null on error

  Notes:
      (1) Use @comptype == IFF_DEFAULT to have the compression
          type automatically determined.
      (2) If the comptype is invalid for this file, the default will
          be substituted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCreateFromFile(*args)
    
    

    try:
        leptonica.pixacompSetOffset.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompSetOffset.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompSetOffset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompSetOffset(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'offset')       
  pixacompSetOffset()

      Input:  pixac
              offset (non-negative)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The offset is the difference between the caller's view of
          the index into the array and the actual array index.
          By default it is 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompSetOffset(*args)
    
    

    try:
        leptonica.pixcompCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixcompCreateFromPix.restype = lambda address: PIXC(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixcompCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'comptype')       
  pixcompCreateFromPix()

      Input:  pix
              comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
      Return: pixc, or null on error

  Notes:
      (1) Use @comptype == IFF_DEFAULT to have the compression
          type automatically determined.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCreateFromPix(*args)
    
    

    try:
        leptonica.pixcompDetermineFormat.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcompDetermineFormat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcompDetermineFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompDetermineFormat(*args):
        """
        ('l_int32', 'comptype')       
('l_int32', 'd')       
('l_int32', 'cmapflag')       
('l_int32', '*pformat')       
  pixcompDetermineFormat()

      Input:  comptype (IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG)
              d (pix depth)
              cmapflag (1 if pix to be compressed as a colormap; 0 otherwise)
              &format (return IFF_TIFF, IFF_PNG or IFF_JFIF_JPEG)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This determines the best format for a pix, given both
          the request (@comptype) and the image characteristics.
      (2) If @comptype == IFF_DEFAULT, this does not necessarily result
          in png encoding.  Instead, it returns one of the three formats
          that is both valid and most likely to give best compression.
      (3) If the pix cannot be compressed by the input value of
          @comptype, this selects IFF_PNG, which can compress all pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompDetermineFormat(*args)
    
    

    try:
        leptonica.pixacompGetOffset.argtypes = [ctypes.c_void_p]
        leptonica.pixacompGetOffset.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetOffset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetOffset(*args):
        """
        ('PIXAC', '*pixac')       
  pixacompGetOffset()

      Input:  pixac
      Return: offset, or 0 on error

  Notes:
      (1) The offset is the difference between the caller's view of
          the index into the array and the actual array index.
          By default it is 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetOffset(*args)
    
    

    try:
        leptonica.pixacompReplacePixcomp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixacompReplacePixcomp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompReplacePixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReplacePixcomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('PIXC', '*pixc')       
  pixacompReplacePixcomp()

      Input:  pixac
              index (caller's view of index within pixac; includes offset)
              pixc  (to replace existing one, which is destroyed)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.
      (2) The inserted @pixc is now owned by the pixac.  The caller
          must not destroy it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReplacePixcomp(*args)
    
    

    try:
        leptonica.pixacompGetPixDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompGetPixDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixacompGetPixDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetPixDimensions(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
  pixacompGetPixDimensions()

      Input:  pixa
              index (caller's view of index within pixac; includes offset)
              &w, &h, &d (<optional return>; each can be null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The @index includes the offset, which must be subtracted
          to get the actual index into the ptr array.


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetPixDimensions(*args)
    
    

    try:
        leptonica.pixcompDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixcompDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixcompDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompDestroy(*args):
        """
        ('PIXC', '**ppixc')       
  pixcompDestroy()

      Input:  &pixc <will be nulled>
      Return: void

  Notes:
      (1) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompDestroy(*args)
    
    

    try:
        leptonica.pixcompWriteStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcompWriteStreamInfo.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixcompWriteStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompWriteStreamInfo(*args):
        """
        ('FILE', '*fp')       
('PIXC', '*pixc')       
('const char', '*text')       
  pixcompWriteStreamInfo()

      Input:  fp (file stream)
              pixc
              text (<optional> identifying string; can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompWriteStreamInfo(*args)
    




class seedfill(object):
    """  seedfill.c

      Binary seedfill (source: Luc Vincent)
               PIX      *pixSeedfillBinary()
               PIX      *pixSeedfillBinaryRestricted()

      Applications of binary seedfill to find and fill holes,
      remove c.c. touching the border and fill bg from border:
               PIX      *pixHolesByFilling()
               PIX      *pixFillClosedBorders()
               PIX      *pixExtractBorderConnComps()
               PIX      *pixRemoveBorderConnComps()
               PIX      *pixFillBgFromBorder()

      Hole-filling of components to bounding rectangle
               PIX      *pixFillHolesToBoundingRect()

      Gray seedfill (source: Luc Vincent:fast-hybrid-grayscale-reconstruction)
               l_int32   pixSeedfillGray()
               l_int32   pixSeedfillGrayInv()

      Gray seedfill (source: Luc Vincent: sequential-reconstruction algorithm)
               l_int32   pixSeedfillGraySimple()
               l_int32   pixSeedfillGrayInvSimple()

      Gray seedfill variations
               PIX      *pixSeedfillGrayBasin()

      Distance function (source: Luc Vincent)
               PIX      *pixDistanceFunction()

      Seed spread (based on distance function)
               PIX      *pixSeedspread()

      Local extrema:
               l_int32   pixLocalExtrema()
        static l_int32   pixQualifyLocalMinima()
               l_int32   pixSelectedLocalExtrema()
               PIX      *pixFindEqualValues()

      Selection of minima in mask of connected components
               PTA      *pixSelectMinInConnComp()

      Removal of seeded connected components from a mask
               PIX      *pixRemoveSeededComponents()


           ITERATIVE RASTER-ORDER SEEDFILL

      The basic method in the Vincent seedfill (aka reconstruction)
      algorithm is simple.  We describe here the situation for
      binary seedfill.  Pixels are sampled in raster order in
      the seed image.  If they are 4-connected to ON pixels
      either directly above or to the left, and are not masked
      out by the mask image, they are turned on (or remain on).
      (Ditto for 8-connected, except you need to check 3 pixels
      on the previous line as well as the pixel to the left
      on the current line.  This is extra computational work
      for relatively little gain, so it is preferable
      in most situations to use the 4-connected version.)
      The algorithm proceeds from UR to LL of the image, and
      then reverses and sweeps up from LL to UR.
      These double sweeps are iterated until there is no change.
      At this point, the seed has entirely filled the region it
      is allowed to, as delimited by the mask image.

      The grayscale seedfill is a straightforward generalization
      of the binary seedfill, and is described in seedfillLowGray().

      For some applications, the filled seed will later be OR'd
      with the negative of the mask.   This is used, for example,
      when you flood fill into a 4-connected region of OFF pixels
      and you want the result after those pixels are turned ON.

      Note carefully that the mask we use delineates which pixels
      are allowed to be ON as the seed is filled.  We will call this
      a "filling mask".  As the seed expands, it is repeatedly
      ANDed with the filling mask: s & fm.  The process can equivalently
      be formulated using the inverse of the filling mask, which
      we will call a "blocking mask": bm = ~fm.   As the seed
      expands, the blocking mask is repeatedly used to prevent
      the seed from expanding into the blocking mask.  This is done
      by set subtracting the blocking mask from the expanded seed:
      s - bm.  Set subtraction of the blocking mask is equivalent
      to ANDing with the inverse of the blocking mask: s & (~bm).
      But from the inverse relation between blocking and filling
      masks, this is equal to s & fm, which proves the equivalence.

      For efficiency, the pixels can be taken in larger units
      for processing, but still in raster order.  It is natural
      to take them in 32-bit words.  The outline of the work
      to be done for 4-cc (not including special cases for boundary
      words, such as the first line or the last word in each line)
      is as follows.  Let the filling mask be m.  The
      seed is to fill "under" the mask; i.e., limited by an AND
      with the mask.  Let the current word be w, the word
      in the line above be wa, and the previous word in the
      current line be wp.   Let t be a temporary word that
      is used in computation.  Note that masking is performed by
      w & m.  (If we had instead used a "blocking" mask, we
      would perform masking by the set subtraction operation,
      w - m, which is defined to be w & ~m.)

      The entire operation can be implemented with shifts,
      logical operations and tests.  For each word in the seed image
      there are two steps.  The first step is to OR the word with
      the word above and with the rightmost pixel in wp (call it "x").
      Because wp is shifted one pixel to its right, "x" is ORed
      to the leftmost pixel of w.  We then clip to the ON pixels in
      the mask.  The result is
               t  <--  (w | wa | x000... ) & m
      We've now finished taking data from above and to the left.
      The second step is to allow filling to propagate horizontally
      in t, always making sure that it is properly masked at each
      step.  So if filling can be done (i.e., t is neither all 0s
      nor all 1s), iteratively take:
           t  <--  (t | (t >> 1) | (t << 1)) & m
      until t stops changing.  Then write t back into w.

      Finally, the boundary conditions require we note that in doing
      the above steps:
          (a) The words in the first row have no wa
          (b) The first word in each row has no wp in that row
          (c) The last word in each row must be masked so that
              pixels don't propagate beyond the right edge of the
              actual image.  (This is easily accomplished by
              setting the out-of-bound pixels in m to OFF.)

"""
    
    try:
        leptonica.pixSeedfillBinaryRestricted.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillBinaryRestricted.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillBinaryRestricted not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillBinaryRestricted(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
('l_int32', 'xmax')       
('l_int32', 'ymax')       
  pixSeedfillBinaryRestricted()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs; 1 bpp)
              pixs  (1 bpp seed)
              pixm  (1 bpp filling mask)
              connectivity  (4 or 8)
              xmax (max distance in x direction of fill into the mask)
              ymax (max distance in y direction of fill into the mask)
      Return: pixd always

  Notes:
      (1) See usage for pixSeedfillBinary(), which has unrestricted fill.
          In pixSeedfillBinary(), the filling distance is unrestricted
          and can be larger than pixs, depending on the topology of
          th mask.
      (2) There are occasions where it is useful not to permit the
          fill to go more than a certain distance into the mask.
          @xmax specifies the maximum horizontal distance allowed
          in the fill; @ymax does likewise in the vertical direction.
      (3) Operationally, the max "distance" allowed for the fill
          is a linear distance from the original seed, independent
          of the actual mask topology.
      (4) Another formulation of this problem, not implemented,
          would use the manhattan distance from the seed, as
          determined by a breadth-first search starting at the seed
          boundaries and working outward where the mask fg allows.
          How this might use the constraints of separate xmax and ymax
          is not clear.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillBinaryRestricted(*args)
    
    

    try:
        leptonica.pixRemoveBorderConnComps.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRemoveBorderConnComps.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveBorderConnComps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorderConnComps(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixRemoveBorderConnComps()

      Input:  pixs (1 bpp)
              filling connectivity (4 or 8)
      Return: pixd  (all pixels in the src that are not touching the
                     border) or null on error

  Notes:
      (1) This removes all fg components touching the border.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorderConnComps(*args)
    
    

    try:
        leptonica.pixSelectMinInConnComp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSelectMinInConnComp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSelectMinInConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectMinInConnComp(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('PTA', '**ppta')       
('NUMA', '**pnav')       
  pixSelectMinInConnComp()

      Input:  pixs (8 bpp)
              pixm (1 bpp)
              &pta (<return> pta of min pixel locations)
              &nav (<optional return> numa of minima values)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) For each 8 connected component in pixm, this finds
          a pixel in pixs that has the lowest value, and saves
          it in a Pta.  If several pixels in pixs have the same
          minimum value, it picks the first one found.
      (2) For a mask pixm of true local minima, all pixels in each
          connected component have the same value in pixs, so it is
          fastest to select one of them using a special seedfill
          operation.  Not yet implemented.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectMinInConnComp(*args)
    
    

    try:
        leptonica.pixFillClosedBorders.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFillClosedBorders.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFillClosedBorders not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillClosedBorders(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixFillClosedBorders()

      Input:  pixs (1 bpp)
              filling connectivity (4 or 8)
      Return: pixd  (all topologically outer closed borders are filled
                     as connected comonents), or null on error

  Notes:
      (1) Start with 1-pixel black border on otherwise white pixd
      (2) Subtract input pixs to remove border pixels that were
          also on the closed border
      (3) Use the inverted pixs as the filling mask to fill in
          all the pixels from the outer border to the closed border
          on pixs
      (4) Invert the result to get the filled component, including
          the input border
      (5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.
      (6) Closed borders within c.c. that represent holes, etc., are filled.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillClosedBorders(*args)
    
    

    try:
        leptonica.pixSeedfillGrayBasin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillGrayBasin.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillGrayBasin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGrayBasin(*args):
        """
        ('PIX', '*pixb')       
('PIX', '*pixm')       
('l_int32', 'delta')       
('l_int32', 'connectivity')       
  pixSeedfillGrayBasin()

      Input:  pixb  (binary mask giving seed locations)
              pixm  (8 bpp basin-type filling mask)
              delta (amount of seed value above mask)
              connectivity  (4 or 8)
      Return: pixd (filled seed) if OK, null on error

  Notes:
      (1) This fills from a seed within basins defined by a filling mask.
          The seed value(s) are greater than the corresponding
          filling mask value, and the result has the bottoms of
          the basins raised by the initial seed value.
      (2) The seed has value 255 except where pixb has fg (1), which
          are the seed 'locations'.  At the seed locations, the seed
          value is the corresponding value of the mask pixel in pixm
          plus @delta.  If @delta == 0, we return a copy of pixm.
      (3) The actual filling is done using the standard grayscale filling
          operation on the inverse of the mask and using the inverse
          of the seed image.  After filling, we return the inverse of
          the filled seed.
      (4) As an example of use: pixm can describe a grayscale image
          of text, where the (dark) text pixels are basins of
          low values; pixb can identify the local minima in pixm (say, at
          the bottom of the basins); and delta is the amount that we wish
          to raise (lighten) the basins.  We construct the seed
          (a.k.a marker) image from pixb, pixm and @delta.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGrayBasin(*args)
    
    

    try:
        leptonica.pixFillHolesToBoundingRect.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixFillHolesToBoundingRect.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFillHolesToBoundingRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillHolesToBoundingRect(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minsize')       
('l_float32', 'maxhfract')       
('l_float32', 'minfgfract')       
  pixFillHolesToBoundingRect()

      Input:  pixs (1 bpp)
              minsize (min number of pixels in the hole)
              maxhfract (max hole area as fraction of fg pixels in the cc)
              minfgfract (min fg area as fraction of bounding rectangle)
      Return: pixd (pixs, with some holes possibly filled and some c.c.
                    possibly expanded to their bounding rects),
                    or null on error

  Notes:
      (1) This does not fill holes that are smaller in area than 'minsize'.
      (2) This does not fill holes with an area larger than
          'maxhfract' times the fg area of the c.c.
      (3) This does not expand the fg of the c.c. to bounding rect if
          the fg area is less than 'minfgfract' times the area of the
          bounding rect.
      (4) The decisions are made as follows:
           - Decide if we are filling the holes; if so, when using
             the fg area, include the filled holes.
           - Decide based on the fg area if we are filling to a bounding rect.
             If so, do it.
             If not, fill the holes if the condition is satisfied.
      (5) The choice of minsize depends on the resolution.
      (6) For solidifying image mask regions on printed materials,
          which tend to be rectangular, values for maxhfract
          and minfgfract around 0.5 are reasonable.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillHolesToBoundingRect(*args)
    
    

    try:
        leptonica.pixSeedfillGraySimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGraySimple.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillGraySimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGraySimple(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
  pixSeedfillGraySimple()

      Input:  pixs  (8 bpp seed; filled in place)
              pixm  (8 bpp filling mask)
              connectivity  (4 or 8)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place filling operation on the seed, pixs,
          where the clipping mask is always above or at the level
          of the seed as it is filled.
      (2) For details of the operation, see the description in
          seedfillGrayLowSimple() and the code there.
      (3) As an example of use, see the description in pixHDome().
          There, the seed is an image where each pixel is a fixed
          amount smaller than the corresponding mask pixel.
      (4) Reference paper :
            L. Vincent, Morphological grayscale reconstruction in image
            analysis: applications and efficient algorithms, IEEE Transactions
            on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGraySimple(*args)
    
    

    try:
        leptonica.pixDistanceFunction.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDistanceFunction.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDistanceFunction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDistanceFunction(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('l_int32', 'outdepth')       
('l_int32', 'boundcond')       
  pixDistanceFunction()

      Input:  pixs  (1 bpp source)
              connectivity  (4 or 8)
              outdepth (8 or 16 bits for pixd)
              boundcond (L_BOUNDARY_BG, L_BOUNDARY_FG)
      Return: pixd, or null on error

  Notes:
      (1) This computes the distance of each pixel from the nearest
          background pixel.  All bg pixels therefore have a distance of 0,
          and the fg pixel distances increase linearly from 1 at the
          boundary.  It can also be used to compute the distance of
          each pixel from the nearest fg pixel, by inverting the input
          image before calling this function.  Then all fg pixels have
          a distance 0 and the bg pixel distances increase linearly
          from 1 at the boundary.
      (2) The algorithm, described in Leptonica on the page on seed
          filling and connected components, is due to Luc Vincent.
          In brief, we generate an 8 or 16 bpp image, initialized
          with the fg pixels of the input pix set to 1 and the
          1-boundary pixels (i.e., the boundary pixels of width 1 on
          the four sides set as either:
            * L_BOUNDARY_BG: 0
            * L_BOUNDARY_FG:  max
          where max = 0xff for 8 bpp and 0xffff for 16 bpp.
          Then do raster/anti-raster sweeps over all pixels interior
          to the 1-boundary, where the value of each new pixel is
          taken to be 1 more than the minimum of the previously-seen
          connected pixels (using either 4 or 8 connectivity).
          Finally, set the 1-boundary pixels using the mirrored method;
          this removes the max values there.
      (3) Using L_BOUNDARY_BG clamps the distance to 0 at the
          boundary.  Using L_BOUNDARY_FG allows the distance
          at the image boundary to "float".
      (4) For 4-connected, one could initialize only the left and top
          1-boundary pixels, and go all the way to the right
          and bottom; then coming back reset left and top.  But we
          instead use a method that works for both 4- and 8-connected.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDistanceFunction(*args)
    
    

    try:
        leptonica.pixHolesByFilling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixHolesByFilling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixHolesByFilling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHolesByFilling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixHolesByFilling()

      Input:  pixs (1 bpp)
              connectivity (4 or 8)
      Return: pixd  (inverted image of all holes), or null on error

 Action:
     (1) Start with 1-pixel black border on otherwise white pixd
     (2) Use the inverted pixs as the filling mask to fill in
         all the pixels from the border to the pixs foreground
     (3) OR the result with pixs to have an image with all
         ON pixels except for the holes.
     (4) Invert the result to get the holes as foreground

 Notes:
     (1) To get 4-c.c. holes of the 8-c.c. as foreground, use
         4-connected filling; to get 8-c.c. holes of the 4-c.c.
         as foreground, use 8-connected filling.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHolesByFilling(*args)
    
    

    try:
        leptonica.pixSeedspread.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedspread.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedspread not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedspread(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixSeedspread()

      Input:  pixs  (8 bpp source)
              connectivity  (4 or 8)
      Return: pixd, or null on error

  Notes:
      (1) The raster/anti-raster method for implementing this filling
          operation was suggested by Ray Smith.
      (2) This takes an arbitrary set of nonzero pixels in pixs, which
          can be sparse, and spreads (extrapolates) the values to
          fill all the pixels in pixd with the nonzero value it is
          closest to in pixs.  This is similar (though not completely
          equivalent) to doing a Voronoi tiling of the image, with a
          tile surrounding each pixel that has a nonzero value.
          All pixels within a tile are then closer to its "central"
          pixel than to any others.  Then assign the value of the
          "central" pixel to each pixel in the tile.
      (3) This is implemented by computing a distance function in parallel
          with the fill.  The distance function uses free boundary
          conditions (assumed maxval outside), and it controls the
          propagation of the pixels in pixd away from the nonzero
          (seed) values.  This is done in 2 traversals (raster/antiraster).
          In the raster direction, whenever the distance function
          is nonzero, the spread pixel takes on the value of its
          predecessor that has the minimum distance value.  In the
          antiraster direction, whenever the distance function is nonzero
          and its value is replaced by a smaller value, the spread
          pixel takes the value of the predecessor with the minimum
          distance value.
      (4) At boundaries where a pixel is equidistant from two
          nearest nonzero (seed) pixels, the decision of which value
          to use is arbitrary (greedy in search for minimum distance).
          This can give rise to strange-looking results, particularly
          for 4-connectivity where the L1 distance is computed from
          steps in N,S,E and W directions (no diagonals).


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedspread(*args)
    
    

    try:
        leptonica.pixExtractBorderConnComps.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBorderConnComps.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractBorderConnComps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBorderConnComps(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixExtractBorderConnComps()

      Input:  pixs (1 bpp)
              filling connectivity (4 or 8)
      Return: pixd  (all pixels in the src that are in connected
                     components touching the border), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBorderConnComps(*args)
    
    

    try:
        leptonica.pixFindEqualValues.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindEqualValues.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindEqualValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindEqualValues(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixFindEqualValues()

      Input:  pixs1 (8 bpp)
              pixs2 (8 bpp)
      Return: pixd (1 bpp mask), or null on error

  Notes:
      (1) The two images are aligned at the UL corner, and the returned
          image has ON pixels where the pixels in pixs1 and pixs2
          have equal values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindEqualValues(*args)
    
    

    try:
        leptonica.pixFillBgFromBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFillBgFromBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFillBgFromBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillBgFromBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixFillBgFromBorder()

      Input:  pixs (1 bpp)
              filling connectivity (4 or 8)
      Return: pixd (with the background c.c. touching the border
                    filled to foreground), or null on error

  Notes:
      (1) This fills all bg components touching the border to fg.
          It is the photometric inverse of pixRemoveBorderConnComps().
      (2) Invert the result to get the "holes" left after this fill.
          This can be done multiple times, extracting holes within
          holes after each pair of fillings.  Specifically, this code
          peels away n successive embeddings of components:
              pix1 = <initial image>
              for (i = 0; i < 2 * n; i++) {
                   pix2 = pixFillBgFromBorder(pix1, 8);
                   pixInvert(pix2, pix2);
                   pixDestroy(&pix1);
                   pix1 = pix2;
              }



        """
        args = _convert_params(*args)
        
        return leptonica.pixFillBgFromBorder(*args)
    
    

    try:
        leptonica.pixSeedfillGrayInvSimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGrayInvSimple.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillGrayInvSimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGrayInvSimple(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
  pixSeedfillGrayInvSimple()

      Input:  pixs  (8 bpp seed; filled in place)
              pixm  (8 bpp filling mask)
              connectivity  (4 or 8)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place filling operation on the seed, pixs,
          where the clipping mask is always below or at the level
          of the seed as it is filled.  Think of filling up a basin
          to a particular level, given by the maximum seed value
          in the basin.  Outside the filled region, the mask
          is above the filling level.
      (2) Contrast this with pixSeedfillGraySimple(), where the clipping mask
          is always above or at the level of the fill.  An example
          of its use is the hdome fill, where the seed is an image
          where each pixel is a fixed amount smaller than the
          corresponding mask pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGrayInvSimple(*args)
    
    

    try:
        leptonica.pixLocalExtrema.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixLocalExtrema.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixLocalExtrema not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLocalExtrema(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxmin')       
('l_int32', 'minmax')       
('PIX', '**ppixmin')       
('PIX', '**ppixmax')       
  pixLocalExtrema()

      Input:  pixs  (8 bpp)
              maxmin (max allowed for the min in a 3x3 neighborhood;
                      use 0 for default which is to have no upper bound)
              minmax (min allowed for the max in a 3x3 neighborhood;
                      use 0 for default which is to have no lower bound)
              &ppixmin (<optional return> mask of local minima)
              &ppixmax (<optional return> mask of local maxima)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives the actual local minima and maxima.
          A local minimum is a pixel whose surrounding pixels all
          have values at least as large, and likewise for a local
          maximum.  For the local minima, @maxmin is the upper
          bound for the value of pixs.  Likewise, for the local maxima,
          @minmax is the lower bound for the value of pixs.
      (2) The minima are found by starting with the erosion-and-equality
          approach of pixSelectedLocalExtrema().  This is followed
          by a qualification step, where each c.c. in the resulting
          minimum mask is extracted, the pixels bordering it are
          located, and they are queried.  If all of those pixels
          are larger than the value of that minimum, it is a true
          minimum and its c.c. is saved; otherwise the c.c. is
          rejected.  Note that if a bordering pixel has the
          same value as the minimum, it must then have a
          neighbor that is smaller, so the component is not a
          true minimum.
      (3) The maxima are found by inverting the image and looking
          for the minima there.
      (4) The generated masks can be used as markers for
          further operations.


        """
        args = _convert_params(*args)
        
        return leptonica.pixLocalExtrema(*args)
    
    

    try:
        leptonica.pixSeedfillBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillBinary(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
  pixSeedfillBinary()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs; 1 bpp)
              pixs  (1 bpp seed)
              pixm  (1 bpp filling mask)
              connectivity  (4 or 8)
      Return: pixd always

  Notes:
      (1) This is for binary seedfill (aka "binary reconstruction").
      (2) There are 3 cases:
            (a) pixd == null (make a new pixd)
            (b) pixd == pixs (in-place)
            (c) pixd != pixs
      (3) If you know the case, use these patterns for clarity:
            (a) pixd = pixSeedfillBinary(NULL, pixs, ...);
            (b) pixSeedfillBinary(pixs, pixs, ...);
            (c) pixSeedfillBinary(pixd, pixs, ...);
      (4) The resulting pixd contains the filled seed.  For some
          applications you want to OR it with the inverse of
          the filling mask.
      (5) The input seed and mask images can be different sizes, but
          in typical use the difference, if any, would be only
          a few pixels in each direction.  If the sizes differ,
          the clipping is handled by the low-level function
          seedfillBinaryLow().


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillBinary(*args)
    
    

    try:
        leptonica.pixRemoveSeededComponents.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveSeededComponents.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveSeededComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveSeededComponents(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
('l_int32', 'bordersize')       
  pixRemoveSeededComponents()

      Input:  pixd  (<optional>; this can be null or equal to pixm; 1 bpp)
              pixs  (1 bpp seed)
              pixm  (1 bpp filling mask)
              connectivity  (4 or 8)
              bordersize (amount of border clearing)
      Return: pixd, or null on error

  Notes:
      (1) This removes each component in pixm for which there is
          at least one seed in pixs.  If pixd == NULL, this returns
          the result in a new pixd.  Otherwise, it is an in-place
          operation on pixm.  In no situation is pixs altered,
          because we do the filling with a copy of pixs.
      (2) If bordersize > 0, it also clears all pixels within a
          distance @bordersize of the edge of pixd.  This is here
          because pixLocalExtrema() typically finds local minima
          at the border.  Use @bordersize >= 2 to remove these.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveSeededComponents(*args)
    
    

    try:
        leptonica.pixSelectedLocalExtrema.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSelectedLocalExtrema.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSelectedLocalExtrema not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectedLocalExtrema(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'mindist')       
('PIX', '**ppixmin')       
('PIX', '**ppixmax')       
  pixSelectedLocalExtrema()

      Input:  pixs  (8 bpp)
              mindist (-1 for keeping all pixels; >= 0 specifies distance)
              &ppixmin (<return> mask of local minima)
              &ppixmax (<return> mask of local maxima)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This selects those local 3x3 minima that are at least a
          specified distance from the nearest local 3x3 maxima, and v.v.
          for the selected set of local 3x3 maxima.
          The local 3x3 minima is the set of pixels whose value equals
          the value after a 3x3 brick erosion, and the local 3x3 maxima
          is the set of pixels whose value equals the value after
          a 3x3 brick dilation.
      (2) mindist is the minimum distance allowed between
          local 3x3 minima and local 3x3 maxima, in an 8-connected sense.
          mindist == 1 keeps all pixels found in step 1.
          mindist == 0 removes all pixels from each mask that are
          both a local 3x3 minimum and a local 3x3 maximum.
          mindist == 1 removes any local 3x3 minimum pixel that touches a
          local 3x3 maximum pixel, and likewise for the local maxima.
          To make the decision, visualize each local 3x3 minimum pixel
          as being surrounded by a square of size (2 * mindist + 1)
          on each side, such that no local 3x3 maximum pixel is within
          that square; and v.v.
      (3) The generated masks can be used as markers for further operations.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectedLocalExtrema(*args)
    
    

    try:
        leptonica.pixSeedfillGrayInv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGrayInv.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillGrayInv not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGrayInv(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
  pixSeedfillGrayInv()

      Input:  pixs  (8 bpp seed; filled in place)
              pixm  (8 bpp filling mask)
              connectivity  (4 or 8)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place filling operation on the seed, pixs,
          where the clipping mask is always below or at the level
          of the seed as it is filled.  Think of filling up a basin
          to a particular level, given by the maximum seed value
          in the basin.  Outside the filled region, the mask
          is above the filling level.
      (2) Contrast this with pixSeedfillGray(), where the clipping mask
          is always above or at the level of the fill.  An example
          of its use is the hdome fill, where the seed is an image
          where each pixel is a fixed amount smaller than the
          corresponding mask pixel.
      (3) The basin fill, pixSeedfillGrayBasin(), is a special case
          where the seed pixel values are generated from the mask,
          and where the implementation uses pixSeedfillGray() by
          inverting both the seed and mask.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGrayInv(*args)
    
    

    try:
        leptonica.pixSeedfillGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
  pixSeedfillGray()

      Input:  pixs  (8 bpp seed; filled in place)
              pixm  (8 bpp filling mask)
              connectivity  (4 or 8)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place filling operation on the seed, pixs,
          where the clipping mask is always above or at the level
          of the seed as it is filled.
      (2) For details of the operation, see the description in
          seedfillGrayLow() and the code there.
      (3) As an example of use, see the description in pixHDome().
          There, the seed is an image where each pixel is a fixed
          amount smaller than the corresponding mask pixel.
      (4) Reference paper :
            L. Vincent, Morphological grayscale reconstruction in image
            analysis: applications and efficient algorithms, IEEE Transactions
            on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGray(*args)
    




class parseprotos(object):
    """ parseprotos.c

       char             *parseForProtos()

    Static helpers
       static l_int32    getNextNonCommentLine()
       static l_int32    getNextNonBlankLine()
       static l_int32    getNextNonDoubleSlashLine()
       static l_int32    searchForProtoSignature()
       static char      *captureProtoSignature()
       static char      *cleanProtoSignature()
       static l_int32    skipToEndOfFunction()
       static l_int32    skipToMatchingBrace()
       static l_int32    skipToSemicolon()
       static l_int32    getOffsetForCharacter()
       static l_int32    getOffsetForMatchingRP()

"""
    



class psio2stub(object):
    """  psio2stub.c

     Stubs for psio2.c functions

"""
    



class skew(object):
    """  skew.c

      Top-level deskew interfaces
          PIX       *pixDeskew()
          PIX       *pixFindSkewAndDeskew()
          PIX       *pixDeskewGeneral()

      Top-level angle-finding interface
          l_int32    pixFindSkew()

      Basic angle-finding functions
          l_int32    pixFindSkewSweep()
          l_int32    pixFindSkewSweepAndSearch()
          l_int32    pixFindSkewSweepAndSearchScore()
          l_int32    pixFindSkewSweepAndSearchScorePivot()

      Search over arbitrary range of angles in orthogonal directions
          l_int32    pixFindSkewOrthogonalRange()

      Differential square sum function for scoring
          l_int32    pixFindDifferentialSquareSum()

      Measures of variance of row sums
          l_int32    pixFindNormalizedSquareSum()


      ==============================================================
      Page skew detection

      Skew is determined by pixel profiles, which are computed
      as pixel sums along the raster line for each line in the
      image.  By vertically shearing the image by a given angle,
      the sums can be computed quickly along the raster lines
      rather than along lines at that angle.  The score is
      computed from these line sums by taking the square of
      the DIFFERENCE between adjacent line sums, summed over
      all lines.  The skew angle is then found as the angle
      that maximizes the score.  The actual computation for
      any sheared image is done in the function
      pixFindDifferentialSquareSum().

      The search for the angle that maximizes this score is
      most efficiently performed by first sweeping coarsely
      over angles, using a significantly reduced image (say, 4x
      reduction), to find the approximate maximum within a half
      degree or so, and then doing an interval-halving binary
      search at higher resolution to get the skew angle to
      within 1/20 degree or better.

      The differential signal is used (rather than just using
      that variance of line sums) because it rejects the
      background noise due to total number of black pixels,
      and has maximum contributions from the baselines and
      x-height lines of text when the textlines are aligned
      with the raster lines.  It also works well in multicolumn
      pages where the textlines do not line up across columns.

      The method is fast, accurate to within an angle (in radians)
      of approximately the inverse width in pixels of the image,
      and will work on a surprisingly small amount of text data
      (just a couple of text lines).  Consequently, it can
      also be used to find local skew if the skew were to vary
      significantly over the page.  Local skew determination
      is not very important except for locating lines of
      handwritten text that may be mixed with printed text.

"""
    
    try:
        leptonica.pixDeskewGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDeskewGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDeskewGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsweep')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_int32', 'redsearch')       
('l_int32', 'thresh')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
  pixDeskewGeneral()

      Input:  pixs  (any depth)
              redsweep  (for linear search: reduction factor = 1, 2 or 4;
                         use 0 for default)
              sweeprange (in degrees in each direction from 0;
                          use 0.0 for default)
              sweepdelta (in degrees; use 0.0 for default)
              redsearch  (for binary search: reduction factor = 1, 2 or 4;
                          use 0 for default;)
              thresh (for binarizing the image; use 0 for default)
              &angle   (<optional return> angle required to deskew,
                        in degrees; use NULL to skip)
              &conf    (<optional return> conf value is ratio
                        of max/min scores; use NULL to skip)
      Return: pixd (deskewed pix), or null on error

  Notes:
      (1) This binarizes if necessary and finds the skew angle.  If the
          angle is large enough and there is sufficient confidence,
          it returns a deskewed image; otherwise, it returns a clone.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewGeneral(*args)
    
    

    try:
        leptonica.pixDeskew.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDeskew.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDeskew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskew(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsearch')       
  pixDeskew()

      Input:  pixs (any depth)
              redsearch (for binary search: reduction factor = 1, 2 or 4;
                         use 0 for default)
      Return: pixd (deskewed pix), or null on error

  Notes:
      (1) This binarizes if necessary and finds the skew angle.  If the
          angle is large enough and there is sufficient confidence,
          it returns a deskewed image; otherwise, it returns a clone.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskew(*args)
    
    

    try:
        leptonica.pixFindSkew.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindSkew.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindSkew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkew(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
  pixFindSkew()

      Input:  pixs  (1 bpp)
              &angle   (<return> angle required to deskew, in degrees)
              &conf    (<return> confidence value is ratio max/min scores)
      Return: 0 if OK, 1 on error or if angle measurment not valid

  Notes:
      (1) This is a simple high-level interface, that uses default
          values of the parameters for reasonable speed and accuracy.
      (2) The angle returned is the negative of the skew angle of
          the image.  It is the angle required for deskew.
          Clockwise rotations are positive angles.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkew(*args)
    
    

    try:
        leptonica.pixFindSkewSweepAndSearchScorePivot.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixFindSkewSweepAndSearchScorePivot.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindSkewSweepAndSearchScorePivot not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweepAndSearchScorePivot(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
('l_float32', '*pendscore')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweepcenter')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
('l_int32', 'pivot')       
  pixFindSkewSweepAndSearchScorePivot()

      Input:  pixs  (1 bpp)
              &angle   (<return> angle required to deskew; in degrees)
              &conf    (<return> confidence given by ratio of max/min score)
              &endscore (<optional return> max score; use NULL to ignore)
              redsweep  (sweep reduction factor = 1, 2, 4 or 8)
              redsearch  (binary search reduction factor = 1, 2, 4 or 8;
                          and must not exceed redsweep)
              sweepcenter  (angle about which sweep is performed; in degrees)
              sweeprange   (half the full range, taken about sweepcenter;
                            in degrees)
              sweepdelta   (angle increment of sweep; in degrees)
              minbsdelta   (min binary search increment angle; in degrees)
              pivot  (L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER)
      Return: 0 if OK, 1 on error or if angle measurment not valid

  Notes:
      (1) See notes in pixFindSkewSweepAndSearchScore().
      (2) This allows choice of shear pivoting from either the UL corner
          or the center.  For small angles, the ability to discriminate
          angles is better with shearing from the UL corner.  However,
          for large angles (say, greater than 20 degrees), it is better
          to shear about the center because a shear from the UL corner
          loses too much of the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweepAndSearchScorePivot(*args)
    
    

    try:
        leptonica.pixFindNormalizedSquareSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindNormalizedSquareSum.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindNormalizedSquareSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindNormalizedSquareSum(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*phratio')       
('l_float32', '*pvratio')       
('l_float32', '*pfract')       
  pixFindNormalizedSquareSum()

      Input:  pixs
              &hratio (<optional return> ratio of normalized horiz square sum
                       to result if the pixel distribution were uniform)
              &vratio (<optional return> ratio of normalized vert square sum
                       to result if the pixel distribution were uniform)
              &fract  (<optional return> ratio of fg pixels to total pixels)
      Return: 0 if OK, 1 on error or if there are no fg pixels

  Notes:
      (1) Let the image have h scanlines and N fg pixels.
          If the pixels were uniformly distributed on scanlines,
          the sum of squares of fg pixels on each scanline would be
          h * (N / h)^2.  However, if the pixels are not uniformly
          distributed (e.g., for text), the sum of squares of fg
          pixels will be larger.  We return in hratio and vratio the
          ratio of these two values.
      (2) If there are no fg pixels, hratio and vratio are returned as 0.0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindNormalizedSquareSum(*args)
    
    

    try:
        leptonica.pixFindSkewSweepAndSearch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixFindSkewSweepAndSearch.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindSkewSweepAndSearch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweepAndSearch(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
  pixFindSkewSweepAndSearch()

      Input:  pixs  (1 bpp)
              &angle   (<return> angle required to deskew; in degrees)
              &conf    (<return> confidence given by ratio of max/min score)
              redsweep  (sweep reduction factor = 1, 2, 4 or 8)
              redsearch  (binary search reduction factor = 1, 2, 4 or 8;
                          and must not exceed redsweep)
              sweeprange   (half the full range, assumed about 0; in degrees)
              sweepdelta   (angle increment of sweep; in degrees)
              minbsdelta   (min binary search increment angle; in degrees)
      Return: 0 if OK, 1 on error or if angle measurment not valid

  Notes:
      (1) This finds the skew angle, doing first a sweep through a set
          of equal angles, and then doing a binary search until
          convergence.
      (2) Caller must check the return value for validity of the result.
      (3) In computing the differential line sum variance score, we sum
          the result over scanlines, but we always skip:
           - at least one scanline
           - not more than 10% of the image height
           - not more than 5% of the image width
      (4) See also notes in pixFindSkewSweepAndSearchScore()


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweepAndSearch(*args)
    
    

    try:
        leptonica.pixFindSkewSweep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixFindSkewSweep.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindSkewSweep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweep(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_int32', 'reduction')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
  pixFindSkewSweep()

      Input:  pixs  (1 bpp)
              &angle   (<return> angle required to deskew, in degrees)
              reduction  (factor = 1, 2, 4 or 8)
              sweeprange   (half the full range; assumed about 0; in degrees)
              sweepdelta   (angle increment of sweep; in degrees)
      Return: 0 if OK, 1 on error or if angle measurment not valid

  Notes:
      (1) This examines the 'score' for skew angles with equal intervals.
      (2) Caller must check the return value for validity of the result.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweep(*args)
    
    

    try:
        leptonica.pixFindDifferentialSquareSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindDifferentialSquareSum.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindDifferentialSquareSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindDifferentialSquareSum(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*psum')       
  pixFindDifferentialSquareSum()

      Input:  pixs
              &sum  (<return> result)
      Return: 0 if OK, 1 on error

  Notes:
      (1) At the top and bottom, we skip:
           - at least one scanline
           - not more than 10% of the image height
           - not more than 5% of the image width


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindDifferentialSquareSum(*args)
    
    

    try:
        leptonica.pixFindSkewAndDeskew.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindSkewAndDeskew.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindSkewAndDeskew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewAndDeskew(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsearch')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
  pixFindSkewAndDeskew()

      Input:  pixs (any depth)
              redsearch (for binary search: reduction factor = 1, 2 or 4;
                         use 0 for default)
              &angle   (<optional return> angle required to deskew,
                        in degrees; use NULL to skip)
              &conf    (<optional return> conf value is ratio
                        of max/min scores; use NULL to skip)
      Return: pixd (deskewed pix), or null on error

  Notes:
      (1) This binarizes if necessary and finds the skew angle.  If the
          angle is large enough and there is sufficient confidence,
          it returns a deskewed image; otherwise, it returns a clone.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewAndDeskew(*args)
    
    

    try:
        leptonica.pixFindSkewSweepAndSearchScore.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixFindSkewSweepAndSearchScore.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindSkewSweepAndSearchScore not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweepAndSearchScore(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
('l_float32', '*pendscore')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweepcenter')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
  pixFindSkewSweepAndSearchScore()

      Input:  pixs  (1 bpp)
              &angle   (<return> angle required to deskew; in degrees)
              &conf    (<return> confidence given by ratio of max/min score)
              &endscore (<optional return> max score; use NULL to ignore)
              redsweep  (sweep reduction factor = 1, 2, 4 or 8)
              redsearch  (binary search reduction factor = 1, 2, 4 or 8;
                          and must not exceed redsweep)
              sweepcenter  (angle about which sweep is performed; in degrees)
              sweeprange   (half the full range, taken about sweepcenter;
                            in degrees)
              sweepdelta   (angle increment of sweep; in degrees)
              minbsdelta   (min binary search increment angle; in degrees)
      Return: 0 if OK, 1 on error or if angle measurment not valid

  Notes:
      (1) This finds the skew angle, doing first a sweep through a set
          of equal angles, and then doing a binary search until convergence.
      (2) There are two built-in constants that determine if the
          returned confidence is nonzero:
            - MIN_VALID_MAXSCORE (minimum allowed maxscore)
            - MINSCORE_THRESHOLD_CONSTANT (determines minimum allowed
                 minscore, by multiplying by (height * width^2)
          If either of these conditions is not satisfied, the returned
          confidence value will be zero.  The maxscore is optionally
          returned in this function to allow evaluation of the
          resulting angle by a method that is independent of the
          returned confidence value.
      (3) The larger the confidence value, the greater the probability
          that the proper alignment is given by the angle that maximizes
          variance.  It should be compared to a threshold, which depends
          on the application.  Values between 3.0 and 6.0 are common.
      (4) By default, the shear is about the UL corner.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweepAndSearchScore(*args)
    




class makefile(object):
    """"""
    



class maze(object):
    """  maze.c

      This is a game with a pedagogical slant.  A maze is represented
      by a binary image.  The ON pixels (fg) are walls.  The goal is
      to navigate on OFF pixels (bg), using Manhattan steps
      (N, S, E, W), between arbitrary start and end positions.
      The problem is thus to find the shortest route between two points
      in a binary image that are 4-connected in the bg.  This is done
      with a breadth-first search, implemented with a queue.
      We also use a queue of pointers to generate the maze (image).

          PIX             *generateBinaryMaze()
          static MAZEEL   *mazeelCreate()

          PIX             *pixSearchBinaryMaze()
          static l_int32   localSearchForBackground()

      Generalizing a maze to a grayscale image, the search is
      now for the "shortest" or least cost path, for some given
      cost function.

          PIX             *pixSearchGrayMaze()


      Elegant method for finding largest white (or black) rectangle
      in an image.

          l_int32          pixFindLargestRectangle()

"""
    
    try:
        leptonica.pixSearchBinaryMaze.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSearchBinaryMaze.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSearchBinaryMaze not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSearchBinaryMaze(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xi')       
('l_int32', 'yi')       
('l_int32', 'xf')       
('l_int32', 'yf')       
('PIX', '**ppixd')       
  pixSearchBinaryMaze()

      Input:  pixs (1 bpp, maze)
              xi, yi  (beginning point; use same initial point
                       that was used to generate the maze)
              xf, yf  (end point, or close to it)
              &ppixd (<optional return> maze with path illustrated, or
                     if no path possible, the part of the maze
                     that was searched)
      Return: pta (shortest path), or null if either no path
              exists or on error

  Notes:
      (1) Because of the overhead in calling pixGetPixel() and
          pixSetPixel(), we have used raster line pointers and the
          GET_DATA* and SET_DATA* macros for many of the pix accesses.
      (2) Commentary:
            The goal is to find the shortest path between beginning and
          end points, without going through walls, and there are many
          ways to solve this problem.
            We use a queue to implement a breadth-first search.  Two auxiliary
          "image" data structures can be used: one to mark the visited
          pixels and one to give the direction to the parent for each
          visited pixel.  The first structure is used to avoid putting
          pixels on the queue more than once, and the second is used
          for retracing back to the origin, like the breadcrumbs in
          Hansel and Gretel.  Each pixel taken off the queue is destroyed
          after it is used to locate the allowed neighbors.  In fact,
          only one distance image is required, if you initialize it
          to some value that signifies "not yet visited."  (We use
          a binary image for marking visited pixels because it is clearer.)
          This method for a simple search of a binary maze is implemented in
          pixSearchBinaryMaze().
            An alternative method would store the (manhattan) distance
          from the start point with each pixel on the queue.  The children
          of each pixel get a distance one larger than the parent.  These
          values can be stored in an auxiliary distance map image
          that is constructed simultaneously with the search.  Once the
          end point is reached, the distance map is used to backtrack
          along a minimum path.  There may be several equal length
          minimum paths, any one of which can be chosen this way.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSearchBinaryMaze(*args)
    
    

    try:
        leptonica.pixFindLargestRectangle.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindLargestRectangle.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindLargestRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindLargestRectangle(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'polarity')       
('BOX', '**pbox')       
('const char', '*debugfile')       
  pixFindLargestRectangle()

      Input:  pixs  (1 bpp)
              polarity (0 within background, 1 within foreground)
              &box (<return> largest rectangle, either by area or
                    by perimeter)
              debugflag (1 to output image with rectangle drawn on it)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Why is this here?  This is a simple and elegant solution to
          a problem in computational geometry that at first appears
          quite difficult: what is the largest rectangle that can
          be placed in the image, covering only pixels of one polarity
          (bg or fg)?  The solution is O(n), where n is the number
          of pixels in the image, and it requires nothing more than
          using a simple recursion relation in a single sweep of the image.
      (2) In a sweep from UL to LR with left-to-right being the fast
          direction, calculate the largest white rectangle at (x, y),
          using previously calculated values at pixels #1 and #2:
             #1:    (x, y - 1)
             #2:    (x - 1, y)
          We also need the most recent "black" pixels that were seen
          in the current row and column.
          Consider the largest area.  There are only two possibilities:
             (a)  Min(w(1), horizdist) * (h(1) + 1)
             (b)  Min(h(2), vertdist) * (w(2) + 1)
          where
             horizdist: the distance from the rightmost "black" pixel seen
                        in the current row across to the current pixel
             vertdist: the distance from the lowest "black" pixel seen
                       in the current column down to the current pixel
          and we choose the Max of (a) and (b).
      (3) To convince yourself that these recursion relations are correct,
          it helps to draw the maximum rectangles at #1 and #2.
          Then for #1, you try to extend the rectangle down one line,
          so that the height is h(1) + 1.  Do you get the full
          width of #1, w(1)?  It depends on where the black pixels are
          in the current row.  You know the final width is bounded by w(1)
          and w(2) + 1, but the actual value depends on the distribution
          of black pixels in the current row that are at a distance
          from the current pixel that is between these limits.
          We call that value "horizdist", and the area is then given
          by the expression (a) above.  Using similar reasoning for #2,
          where you attempt to extend the rectangle to the right
          by 1 pixel, you arrive at (b).  The largest rectangle is
          then found by taking the Max.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindLargestRectangle(*args)
    
    

    try:
        leptonica.generateBinaryMaze.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.generateBinaryMaze.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function generateBinaryMaze not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateBinaryMaze(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'xi')       
('l_int32', 'yi')       
('l_float32', 'wallps')       
('l_float32', 'ranis')       
  generateBinaryMaze()

      Input:  w, h  (size of maze)
              xi, yi  (initial location)
              wallps (probability that a pixel to the side is ON)
              ranis (ratio of prob that pixel in forward direction
                     is a wall to the probability that pixel in
                     side directions is a wall)
      Return: pix, or null on error

  Notes:
      (1) We have two input probability factors that determine the
          density of walls and average length of straight passages.
          When ranis < 1.0, you are more likely to generate a wall
          to the side than going forward.  Enter 0.0 for either if
          you want to use the default values.
      (2) This is a type of percolation problem, and exhibits
          different phases for different parameters wallps and ranis.
          For larger values of these parameters, regions in the maze
          are not explored because the maze generator walls them
          off and cannot get through.  The boundary between the
          two phases in this two-dimensional parameter space goes
          near these values:
                wallps       ranis
                0.35         1.00
                0.40         0.85
                0.45         0.70
                0.50         0.50
                0.55         0.40
                0.60         0.30
                0.65         0.25
                0.70         0.19
                0.75         0.15
                0.80         0.11
      (3) Because there is a considerable amount of overhead in calling
          pixGetPixel() and pixSetPixel(), this function can be sped
          up with little effort using raster line pointers and the
          GET_DATA* and SET_DATA* macros.


        """
        args = _convert_params(*args)
        
        return leptonica.generateBinaryMaze(*args)
    
    

    try:
        leptonica.pixSearchGrayMaze.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSearchGrayMaze.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSearchGrayMaze not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSearchGrayMaze(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xi')       
('l_int32', 'yi')       
('l_int32', 'xf')       
('l_int32', 'yf')       
('PIX', '**ppixd')       
  pixSearchGrayMaze()

      Input:  pixs (1 bpp, maze)
              xi, yi  (beginning point; use same initial point
                       that was used to generate the maze)
              xf, yf  (end point, or close to it)
              &ppixd (<optional return> maze with path illustrated, or
                     if no path possible, the part of the maze
                     that was searched)
      Return: pta (shortest path), or null if either no path
              exists or on error

  Commentary:
      Consider first a slight generalization of the binary maze
      search problem.  Suppose that you can go through walls,
      but the cost is higher (say, an increment of 3 to go into
      a wall pixel rather than 1)?  You're still trying to find
      the shortest path.  One way to do this is with an ordered
      queue, and a simple way to visualize an ordered queue is as
      a set of stacks, each stack being marked with the distance
      of each pixel in the stack from the start.  We place the
      start pixel in stack 0, pop it, and process its 4 children.
      Each pixel is given a distance that is incremented from that
      of its parent (0 in this case), depending on if it is a wall
      pixel or not.  That value may be recorded on a distance map,
      according to the algorithm below.  For children of the first
      pixel, those not on a wall go in stack 1, and wall
      children go in stack 3.  Stack 0 being emptied, the process
      then continues with pixels being popped from stack 1.
      Here is the algorithm for each child pixel.  The pixel's
      distance value, were it to be placed on a stack, is compared
      with the value for it that is on the distance map.  There
      are three possible cases:
         (1) If the pixel has not yet been registered, it is pushed
             on its stack and the distance is written to the map.
         (2) If it has previously been registered with a higher distance,
             the distance on the map is relaxed to that of the
             current pixel, which is then placed on its stack.
         (3) If it has previously been registered with an equal
             or lower value, the pixel is discarded.
      The pixels are popped and processed successively from
      stack 1, and when stack 1 is empty, popping starts on stack 2.
      This continues until the destination pixel is popped off
      a stack.   The minimum path is then derived from the distance map,
      going back from the end point as before.  This is just Dijkstra's
      algorithm for a directed graph; here, the underlying graph
      (consisting of the pixels and four edges connecting each pixel
      to its 4-neighbor) is a special case of a directed graph, where
      each edge is bi-directional.  The implementation of this generalized
      maze search is left as an exercise to the reader.

      Let's generalize a bit further.  Suppose the "maze" is just
      a grayscale image -- think of it as an elevation map.  The cost
      of moving on this surface depends on the height, or the gradient,
      or whatever you want.  All that is required is that the cost
      is specified and non-negative on each link between adjacent
      pixels.  Now the problem becomes: find the least cost path
      moving on this surface between two specified end points.
      For example, if the cost across an edge between two pixels
      depends on the "gradient", you can use:
           cost = 1 + L_ABS(deltaV)
      where deltaV is the difference in value between two adjacent
      pixels.  If the costs are all integers, we can still use an array
      of stacks to avoid ordering the queue (e.g., by using a heap sort.)
      This is a neat problem, because you don't even have to build a
      maze -- you can can use it on any grayscale image!

      Rather than using an array of stacks, a more practical
      approach is to implement with a priority queue, which is
      a queue that is sorted so that the elements with the largest
      (or smallest) key values always come off first.  The
      priority queue is efficiently implemented as a heap, and
      this is how we do it.  Suppose you run the algorithm
      using a priority queue, doing the bookkeeping with an
      auxiliary image data structure that saves the distance of
      each pixel put on the queue as before, according to the method
      described above.  We implement it as a 2-way choice by
      initializing the distance array to a large value and putting
      a pixel on the queue if its distance is less than the value
      found on the array.  When you finally pop the end pixel from
      the queue, you're done, and you can trace the path backward,
      either always going downhill or using an auxiliary image to
      give you the direction to go at each step.  This is implemented
      here in searchGrayMaze().

      Do we really have to use a sorted queue?  Can we solve this
      generalized maze with an unsorted queue of pixels?  (Or even
      an unsorted stack, doing a depth-first search (DFS)?)
      Consider a different algorithm for this generalized maze, where
      we travel again breadth first, but this time use a single,
      unsorted queue.  An auxiliary image is used as before to
      store the distances and to determine if pixels get pushed
      on the stack or dropped.  As before, we must allow pixels
      to be revisited, with relaxation of the distance if a shorter
      path arrives later.  As a result, we will in general have
      multiple instances of the same pixel on the stack with different
      distances.  However, because the queue is not ordered, some of
      these pixels will be popped when another instance with a lower
      distance is still on the stack.  Here, we're just popping them
      in the order they go on, rather than setting up a priority
      based on minimum distance.  Thus, unlike the priority queue,
      when a pixel is popped we have to check the distance map to
      see if a pixel with a lower distance has been put on the queue,
      and, if so, we discard the pixel we just popped.  So the
      "while" loop looks like this:
        - pop a pixel from the queue
        - check its distance against the distance stored in the
          distance map; if larger, discard
        - otherwise, for each of its neighbors:
            - compute its distance from the start pixel
            - compare this distance with that on the distance map:
                - if the distance map value higher, relax the distance
                  and push the pixel on the queue
                - if the distance map value is lower, discard the pixel

      How does this loop terminate?  Before, with an ordered queue,
      it terminates when you pop the end pixel.  But with an unordered
      queue (or stack), the first time you hit the end pixel, the
      distance is not guaranteed to be correct, because the pixels
      along the shortest path may not have yet been visited and relaxed.
      Because the shortest path can theoretically go anywhere,
      we must keep going.  How do we know when to stop?   Dijkstra
      uses an ordered queue to systematically remove nodes from
      further consideration.  (Each time a pixel is popped, we're
      done with it; it's "finalized" in the Dijkstra sense because
      we know the shortest path to it.)  However, with an unordered
      queue, the brute force answer is: stop when the queue
      (or stack) is empty, because then every pixel in the image
      has been assigned its minimum "distance" from the start pixel.

      This is similar to the situation when you use a stack for the
      simpler uniform-step problem: with breadth-first search (BFS)
      the pixels on the queue are automatically ordered, so you are
      done when you locate the end pixel as a neighbor of a popped pixel;
      whereas depth-first search (DFS), using a stack, requires,
      in general, a search of every accessible pixel.  Further, if
      a pixel is revisited with a smaller distance, that distance is
      recorded and the pixel is put on the stack again.

      But surely, you ask, can't we stop sooner?  What if the
      start and end pixels are very close to each other?
      OK, suppose they are, and you have very high walls and a
      long snaking level path that is actually the minimum cost.
      That long path can wind back and forth across the entire
      maze many times before ending up at the end point, which
      could be just over a wall from the start.  With the unordered
      queue, you very quickly get a high distance for the end
      pixel, which will be relaxed to the minimum distance only
      after all the pixels of the path have been visited and placed
      on the queue, multiple times for many of them.  So that's the
      price for not ordering the queue!


        """
        args = _convert_params(*args)
        
        return leptonica.pixSearchGrayMaze(*args)
    




class pixabasic(object):
    """   pixabasic.c

      Pixa creation, destruction, copying
           PIXA     *pixaCreate()
           PIXA     *pixaCreateFromPix()
           PIXA     *pixaCreateFromBoxa()
           PIXA     *pixaSplitPix()
           void      pixaDestroy()
           PIXA     *pixaCopy()

      Pixa addition
           l_int32   pixaAddPix()
           l_int32   pixaAddBox()
           static l_int32   pixaExtendArray()
           l_int32   pixaExtendArrayToSize()

      Pixa accessors
           l_int32   pixaGetCount()
           l_int32   pixaChangeRefcount()
           PIX      *pixaGetPix()
           l_int32   pixaGetPixDimensions()
           PIX      *pixaGetBoxa()
           l_int32   pixaGetBoxaCount()
           BOX      *pixaGetBox()
           l_int32   pixaGetBoxGeometry()
           l_int32   pixaSetBoxa()
           PIX     **pixaGetPixArray()
           l_int32   pixaVerifyDepth()
           l_int32   pixaIsFull()
           l_int32   pixaCountText()
           void   ***pixaGetLinePtrs()

      Pixa array modifiers
           l_int32   pixaReplacePix()
           l_int32   pixaInsertPix()
           l_int32   pixaRemovePix()
           l_int32   pixaRemovePixAndSave()
           l_int32   pixaInitFull()
           l_int32   pixaClear()

      Pixa and Pixaa combination
           l_int32   pixaJoin()
           l_int32   pixaaJoin()

      Pixaa creation, destruction
           PIXAA    *pixaaCreate()
           PIXAA    *pixaaCreateFromPixa()
           void      pixaaDestroy()

      Pixaa addition
           l_int32   pixaaAddPixa()
           l_int32   pixaaExtendArray()
           l_int32   pixaaAddPix()
           l_int32   pixaaAddBox()

      Pixaa accessors
           l_int32   pixaaGetCount()
           PIXA     *pixaaGetPixa()
           BOXA     *pixaaGetBoxa()
           PIX      *pixaaGetPix()
           l_int32   pixaaVerifyDepth()
           l_int32   pixaaIsFull()

      Pixaa array modifiers
           l_int32   pixaaInitFull()
           l_int32   pixaaReplacePixa()
           l_int32   pixaaClear()
           l_int32   pixaaTruncate()

      Pixa serialized I/O  (requires png support)
           PIXA     *pixaRead()
           PIXA     *pixaReadStream()
           l_int32   pixaWrite()
           l_int32   pixaWriteStream()

      Pixaa serialized I/O  (requires png support)
           PIXAA    *pixaaReadFromFiles()
           PIXAA    *pixaaRead()
           PIXAA    *pixaaReadStream()
           l_int32   pixaaWrite()
           l_int32   pixaaWriteStream()


   Important note on reference counting:
     Reference counting for the Pixa is analogous to that for the Boxa.
     See pix.h for details.   pixaCopy() provides three possible modes
     of copy.  The basic rule is that however a Pixa is obtained
     (e.g., from pixaCreate*(), pixaCopy(), or a Pixaa accessor),
     it is necessary to call pixaDestroy() on it.

"""
    
    try:
        leptonica.pixaGetBoxGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetBoxGeometry.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaGetBoxGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBoxGeometry(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  pixaGetBoxGeometry()

      Input:  pixa
              index  (to the index-th box)
              &x, &y, &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBoxGeometry(*args)
    
    

    try:
        leptonica.pixaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.pixaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetCount(*args):
        """
        ('PIXA', '*pixa')       
  pixaGetCount()

      Input:  pixa
      Return: count, or 0 if no pixa


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetCount(*args)
    
    

    try:
        leptonica.pixaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaChangeRefcount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaChangeRefcount(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'delta')       
  pixaChangeRefcount()

      Input:  pixa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaChangeRefcount(*args)
    
    

    try:
        leptonica.pixaVerifyDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaVerifyDepth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaVerifyDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaVerifyDepth(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pmaxdepth')       
  pixaVerifyDepth()

      Input:  pixa
              &maxdepth (<optional return> max depth of all pix)
      Return: depth (return 0 if they're not all the same, or on error)

  Notes:
      (1) It is considered to be an error if there are no pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaVerifyDepth(*args)
    
    

    try:
        leptonica.pixaRead.argtypes = [ctypes.c_void_p]
        leptonica.pixaRead.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRead(*args):
        """
        ('const char', '*filename')       
  pixaRead()

      Input:  filename
      Return: pixa, or null on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRead(*args)
    
    

    try:
        leptonica.pixaGetPixArray.argtypes = [ctypes.c_void_p]
        leptonica.pixaGetPixArray.restype = ctypes.c_void_p
    except AttributeError:
        os.stderr.write("Warning - function pixaGetPixArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetPixArray(*args):
        """
        ('PIXA', '*pixa')       
  pixaGetPixArray()

      Input:  pixa
      Return: pix array, or null on error

  Notes:
      (1) This returns a ptr to the actual array.  The array is
          owned by the pixa, so it must not be destroyed.
      (2) The caller should always check if the return value is NULL
          before accessing any of the pix ptrs in this array!


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetPixArray(*args)
    
    

    try:
        leptonica.pixaClear.argtypes = [ctypes.c_void_p]
        leptonica.pixaClear.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaClear(*args):
        """
        ('PIXA', '*pixa')       
  pixaClear()

      Input:  pixa
      Return: 0 if OK, 1 on error

  Notes:
      (1) This destroys all pix in the pixa, as well as
          all boxes in the boxa.  The ptrs in the pix ptr array
          are all null'd.  The number of allocated pix, n, is set to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaClear(*args)
    
    

    try:
        leptonica.pixaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixaaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDestroy(*args):
        """
        ('PIXAA', '**ppaa')       
  pixaaDestroy()

      Input:  &paa <to be nulled>
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDestroy(*args)
    
    

    try:
        leptonica.pixaaGetCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetCount(*args):
        """
        ('PIXAA', '*paa')       
('NUMA', '**pna')       
  pixaaGetCount()

      Input:  paa
              &na (<optional return> number of pix in each pixa)
      Return: count, or 0 if no pixaa

  Notes:
      (1) If paa is empty, a returned na will also be empty.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetCount(*args)
    
    

    try:
        leptonica.pixaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaAddBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddBox(*args):
        """
        ('PIXA', '*pixa')       
('BOX', '*box')       
('l_int32', 'copyflag')       
  pixaAddBox()

      Input:  pixa
              box
              copyflag (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddBox(*args)
    
    

    try:
        leptonica.pixaaCreateFromPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaCreateFromPixa.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaCreateFromPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaCreateFromPixa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'n')       
('l_int32', 'type')       
('l_int32', 'copyflag')       
  pixaaCreateFromPixa()

      Input:  pixa
              n (number specifying subdivision of pixa)
              type (L_CHOOSE_CONSECUTIVE, L_CHOOSE_SKIP_BY)
              copyflag (L_CLONE, L_COPY)
      Return: paa, or null on error

  Notes:
      (1) This subdivides a pixa into a set of smaller pixa that
          are accumulated into a pixaa.
      (2) If type == L_CHOOSE_CONSECUTIVE, the first 'n' pix are
          put in a pixa and added to pixaa, then the next 'n', etc.
          If type == L_CHOOSE_SKIP_BY, the first pixa is made by
          aggregating pix[0], pix[n], pix[2*n], etc.
      (3) The copyflag specifies if each new pix is a copy or a clone.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaCreateFromPixa(*args)
    
    

    try:
        leptonica.pixaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixaaReadStream.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReadStream(*args):
        """
        ('FILE', '*fp')       
  pixaaReadStream()

      Input:  stream
      Return: paa, or null on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReadStream(*args)
    
    

    try:
        leptonica.pixaaRead.argtypes = [ctypes.c_void_p]
        leptonica.pixaaRead.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaRead(*args):
        """
        ('const char', '*filename')       
  pixaaRead()

      Input:  filename
      Return: paa, or null on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaRead(*args)
    
    

    try:
        leptonica.pixaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.pixaaTruncate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaTruncate(*args):
        """
        ('PIXAA', '*paa')       
  pixaaTruncate()

      Input:  paa
      Return: 0 if OK, 1 on error

  Notes:
      (1) This identifies the largest index containing a pixa that
          has any pix within it, destroys all pixa above that index,
          and resets the count.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaTruncate(*args)
    
    

    try:
        leptonica.pixaaReplacePixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaaReplacePixa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaReplacePixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReplacePixa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('PIXA', '*pixa')       
  pixaaReplacePixa()

      Input:  paa
              index  (to the index-th pixa)
              pixa (insert to replace existing one)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This allows random insertion of a pixa into a pixaa, with
          destruction of any existing pixa at that location.
          The input pixa is now owned by the pixaa.
      (2) No other pixa in the array are affected.
      (3) The index must be within the allowed set.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReplacePixa(*args)
    
    

    try:
        leptonica.pixaGetPixDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetPixDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaGetPixDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetPixDimensions(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
  pixaGetPixDimensions()

      Input:  pixa
              index  (to the index-th box)
              &w, &h, &d (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetPixDimensions(*args)
    
    

    try:
        leptonica.pixaaReadFromFiles.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaReadFromFiles.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaReadFromFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReadFromFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'first')       
('l_int32', 'nfiles')       
  pixaaReadFromFiles()

      Input:  dirname (directory)
              substr (<optional> substring filter on filenames; can be NULL)
              first (0-based)
              nfiles (use 0 for everything from @first to the end)
      Return: paa, or null on error or if no pixa files are found.

  Notes:
      (1) The files must be serialized pixa files (e.g., *.pa)
          If some files cannot be read, warnings are issued.
      (2) Use @substr to filter filenames in the directory.  If
          @substr == NULL, this takes all files.
      (3) After filtering, use @first and @nfiles to select
          a contiguous set of files, that have been lexically
          sorted in increasing order.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReadFromFiles(*args)
    
    

    try:
        leptonica.pixaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDestroy(*args):
        """
        ('PIXA', '**ppixa')       
  pixaDestroy()

      Input:  &pixa (<can be nulled>)
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the pixa.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDestroy(*args)
    
    

    try:
        leptonica.pixaCreate.argtypes = [ctypes.c_int32]
        leptonica.pixaCreate.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreate(*args):
        """
        ('l_int32', 'n')       
  pixaCreate()

      Input:  n  (initial number of ptrs)
      Return: pixa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreate(*args)
    
    

    try:
        leptonica.pixaRemovePixAndSave.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaRemovePixAndSave.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaRemovePixAndSave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemovePixAndSave(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('PIX', '**ppix')       
('BOX', '**pbox')       
  pixaRemovePixAndSave()

      Input:  pixa
              index (of pix to be removed)
              &pix (<optional return> removed pix)
              &box (<optional return> removed box)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts pixa[i] --> pixa[i - 1] for all i > index.
      (2) It should not be used repeatedly on large arrays,
          because the function is O(n).
      (3) The corresponding box is removed as well, if it exists.
      (4) The removed pix and box can either be retained or destroyed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemovePixAndSave(*args)
    
    

    try:
        leptonica.pixaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXAA', '*paa')       
  pixaaWriteStream()

      Input:  stream (opened for "wb")
              paa
      Return: 0 if OK, 1 on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaWriteStream(*args)
    
    

    try:
        leptonica.pixaaIsFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaIsFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaIsFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaIsFull(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*pfull')       
  pixaaIsFull()

      Input:  paa
              &full (<return> 1 if all pixa in the paa have full pix arrays)
      Return: return 0 if OK, 1 on error

  Notes:
      (1) Does not require boxa associated with each pixa to be full.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaIsFull(*args)
    
    

    try:
        leptonica.pixaaClear.argtypes = [ctypes.c_void_p]
        leptonica.pixaaClear.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaClear(*args):
        """
        ('PIXAA', '*paa')       
  pixaaClear()

      Input:  paa
      Return: 0 if OK, 1 on error

  Notes:
      (1) This destroys all pixa in the pixaa, and nulls the ptrs
          in the pixa ptr array.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaClear(*args)
    
    

    try:
        leptonica.pixaaGetPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaGetPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetPix(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('l_int32', 'ipix')       
('l_int32', 'accessflag')       
  pixaaGetPix()

      Input:  paa
              index  (index into the pixa array in the pixaa)
              ipix  (index into the pix array in the pixa)
              accessflag  (L_COPY or L_CLONE)
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetPix(*args)
    
    

    try:
        leptonica.pixaGetBoxaCount.argtypes = [ctypes.c_void_p]
        leptonica.pixaGetBoxaCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaGetBoxaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBoxaCount(*args):
        """
        ('PIXA', '*pixa')       
  pixaGetBoxaCount()

      Input:  pixa
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBoxaCount(*args)
    
    

    try:
        leptonica.pixaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixaReadStream.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadStream(*args):
        """
        ('FILE', '*fp')       
  pixaReadStream()

      Input:  stream
      Return: pixa, or null on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadStream(*args)
    
    

    try:
        leptonica.pixaRemovePix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaRemovePix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaRemovePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemovePix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
  pixaRemovePix()

      Input:  pixa
              index (of pix to be removed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts pixa[i] --> pixa[i - 1] for all i > index.
      (2) It should not be used repeatedly on large arrays,
          because the function is O(n).
      (3) The corresponding box is removed as well, if it exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemovePix(*args)
    
    

    try:
        leptonica.pixaaGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaGetBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetBoxa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'accesstype')       
  pixaaGetBoxa()

      Input:  paa
              accesstype  (L_COPY, L_CLONE)
      Return: boxa, or null on error

  Notes:
      (1) L_COPY returns a copy; L_CLONE returns a new reference to the boxa.
      (2) In both cases, invoke boxaDestroy() on the returned boxa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetBoxa(*args)
    
    

    try:
        leptonica.pixaGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaGetBox.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBox(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       
  pixaGetBox()

      Input:  pixa
              index  (to the index-th pix)
              accesstype  (L_COPY or L_CLONE)
      Return: box (if null, not automatically an error), or null on error

  Notes:
      (1) There is always a boxa with a pixa, and it is initialized so
          that each box ptr is NULL.
      (2) In general, we expect that there is either a box associated
          with each pix, or no boxes at all in the boxa.
      (3) Having no boxes is thus not an automatic error.  Whether it
          is an actual error is determined by the calling program.
          If the caller expects to get a box, it is an error; see, e.g.,
          pixaGetBoxGeometry().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBox(*args)
    
    

    try:
        leptonica.pixaGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaGetBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBoxa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'accesstype')       
  pixaGetBoxa()

      Input:  pixa
              accesstype  (L_COPY, L_CLONE, L_COPY_CLONE)
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBoxa(*args)
    
    

    try:
        leptonica.pixaaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaInitFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaInitFull(*args):
        """
        ('PIXAA', '*paa')       
('PIXA', '*pixa')       
  pixaaInitFull()

      Input:  paa (typically empty)
              pixa (to be replicated into the entire pixa ptr array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This initializes a pixaa by filling up the entire pixa ptr array
          with copies of @pixa.  Any existing pixa are destroyed.
      (2) Example usage.  This function is useful to prepare for a
          random insertion (or replacement) of pixa into a pixaa.
          To randomly insert pixa into a pixaa, up to some index "max":
             Pixaa *paa = pixaaCreate(max);
             Pixa *pixa = pixaCreate(1);  // if you want little memory
             pixaaInitFull(paa, pixa);  // copy it to entire array
             pixaDestroy(&pixa);  // no longer needed
          The initialization allows the pixaa to always be properly filled.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaInitFull(*args)
    
    

    try:
        leptonica.pixaaAddPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaAddPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaAddPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaAddPix(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'copyflag')       
  pixaaAddPix()

      Input:  paa  (input paa)
              index (index of pixa in paa)
              pix (to be added)
              box (<optional> to be added)
              copyflag (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaAddPix(*args)
    
    

    try:
        leptonica.pixaGetPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaGetPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetPix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       
  pixaGetPix()

      Input:  pixa
              index  (to the index-th pix)
              accesstype  (L_COPY or L_CLONE)
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetPix(*args)
    
    

    try:
        leptonica.pixaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaJoin(*args):
        """
        ('PIXA', '*pixad')       
('PIXA', '*pixas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  pixaJoin()

      Input:  pixad  (dest pixa; add to this one)
              pixas  (<optional> source pixa; add from this one)
              istart  (starting index in pixas)
              iend  (ending index in pixas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This appends a clone of each indicated pix in pixas to pixad
      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (3) iend < 0 means 'read to the end'
      (4) If pixas is NULL or contains no pix, this is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaJoin(*args)
    
    

    try:
        leptonica.pixaaCreate.argtypes = [ctypes.c_int32]
        leptonica.pixaaCreate.restype = lambda address: PIXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaCreate(*args):
        """
        ('l_int32', 'n')       
  pixaaCreate()

      Input:  n  (initial number of pixa ptrs)
      Return: paa, or null on error

  Notes:
      (1) A pixaa provides a 2-level hierarchy of images.
          A common use is for segmentation masks, which are
          inexpensive to store in png format.
      (2) For example, suppose you want a mask for each textline
          in a two-column page.  The textline masks for each column
          can be represented by a pixa, of which there are 2 in the pixaa.
          The boxes for the textline mask components within a column
          can have their origin referred to the column rather than the page.
          Then the boxa field can be used to represent the two box (regions)
          for the columns, and the (x,y) components of each box can
          be used to get the absolute position of the textlines on
          the page.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaCreate(*args)
    
    

    try:
        leptonica.pixaAddPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaAddPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaAddPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddPix(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pix')       
('l_int32', 'copyflag')       
  pixaAddPix()

      Input:  pixa
              pix  (to be added)
              copyflag (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddPix(*args)
    
    

    try:
        leptonica.pixaSetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSetBoxa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaSetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSetBoxa(*args):
        """
        ('PIXA', '*pixa')       
('BOXA', '*boxa')       
('l_int32', 'accesstype')       
  pixaSetBoxa()

      Input:  pixa
              boxa
              accesstype  (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This destroys the existing boxa in the pixa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSetBoxa(*args)
    
    

    try:
        leptonica.pixaGetLinePtrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetLinePtrs.restype = ctypes.POINTER(ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p)))
    except AttributeError:
        os.stderr.write("Warning - function pixaGetLinePtrs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetLinePtrs(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*psize')       
  pixaGetLinePtrs()

      Input:  pixa (of pix that all have the same depth)
              &size (<optional return> number of pix in the pixa)
      Return: array of array of line ptrs, or null on error

  Notes:
      (1) See pixGetLinePtrs() for details.
      (2) It is best if all pix in the pixa are the same size.
          The size of each line ptr array is equal to the height
          of the pix that it refers to.
      (3) This is an array of arrays.  To destroy it:
            for (i = 0; i < size; i++)
                FREE(lineset[i]);
            FREE(lineset);


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetLinePtrs(*args)
    
    

    try:
        leptonica.pixaReplacePix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaReplacePix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaReplacePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReplacePix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('PIX', '*pix')       
('BOX', '*box')       
  pixaReplacePix()

      Input:  pixa
              index  (to the index-th pix)
              pix (insert to replace existing one)
              box (<optional> insert to replace existing)
      Return: 0 if OK, 1 on error

  Notes:
      (1) In-place replacement of one pix.
      (2) The previous pix at that location is destroyed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReplacePix(*args)
    
    

    try:
        leptonica.pixaaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaWrite(*args):
        """
        ('const char', '*filename')       
('PIXAA', '*paa')       
  pixaaWrite()

      Input:  filename
              paa
      Return: 0 if OK, 1 on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaWrite(*args)
    
    

    try:
        leptonica.pixaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWrite(*args):
        """
        ('const char', '*filename')       
('PIXA', '*pixa')       
  pixaWrite()

      Input:  filename
              pixa
      Return: 0 if OK, 1 on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWrite(*args)
    
    

    try:
        leptonica.pixaaExtendArray.argtypes = [ctypes.c_void_p]
        leptonica.pixaaExtendArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaExtendArray(*args):
        """
        ('PIXAA', '*paa')       
  pixaaExtendArray()

      Input:  paa
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaExtendArray(*args)
    
    

    try:
        leptonica.pixaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaInitFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaInitFull(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pix')       
('BOX', '*box')       
  pixaInitFull()

      Input:  pixa (typically empty)
              pix (<optional> to be replicated into the entire pixa ptr array)
              box (<optional> to be replicated into the entire boxa ptr array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This initializes a pixa by filling up the entire pix ptr array
          with copies of @pix.  If @pix == NULL, we use a tiny placeholder
          pix (w = h = d = 1).  Any existing pix are destroyed.
          It also optionally fills the boxa with copies of @box.
          After this operation, the numbers of pix and (optionally)
          boxes are equal to the number of allocated ptrs.
      (2) Note that we use pixaReplacePix() instead of pixaInsertPix().
          They both have the same effect when inserting into a NULL ptr
          in the pixa ptr array:
      (3) If the boxa is not initialized (i.e., filled with boxes),
          later insertion of boxes will cause an error, because the
          'n' field is 0.
      (4) Example usage.  This function is useful to prepare for a
          random insertion (or replacement) of pix into a pixa.
          To randomly insert pix into a pixa, without boxes, up to
          some index "max":
             Pixa *pixa = pixaCreate(max);
             pixaInitFull(pixa, NULL, NULL);
          An existing pixa with a smaller ptr array can also be reused:
             pixaExtendArrayToSize(pixa, max);
             pixaInitFull(pixa, NULL, NULL);
          The initialization allows the pixa to always be properly
          filled, even if all pix (and boxes) are not later replaced.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaInitFull(*args)
    
    

    try:
        leptonica.pixaaAddPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaAddPixa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaAddPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaAddPixa(*args):
        """
        ('PIXAA', '*paa')       
('PIXA', '*pixa')       
('l_int32', 'copyflag')       
  pixaaAddPixa()

      Input:  paa
              pixa  (to be added)
              copyflag:
                L_INSERT inserts the pixa directly
                L_COPY makes a new pixa and copies each pix and each box
                L_CLONE gives a new handle to the input pixa
                L_COPY_CLONE makes a new pixa and inserts clones of
                    all pix and boxes
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaAddPixa(*args)
    
    

    try:
        leptonica.pixaIsFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaIsFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaIsFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaIsFull(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pfullpa')       
('l_int32', '*pfullba')       
  pixaIsFull()

      Input:  pixa
              &fullpa (<optional return> 1 if pixa is full)
              &fullba (<optional return> 1 if boxa is full)
      Return: 0 if OK, 1 on error

  Notes:
      (1) A pixa is "full" if the array of pix is fully
          occupied from index 0 to index (pixa->n - 1).


        """
        args = _convert_params(*args)
        
        return leptonica.pixaIsFull(*args)
    
    

    try:
        leptonica.pixaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaJoin(*args):
        """
        ('PIXAA', '*paad')       
('PIXAA', '*paas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  pixaaJoin()

      Input:  paad  (dest pixaa; add to this one)
              paas  (<optional> source pixaa; add from this one)
              istart  (starting index in pixaas)
              iend  (ending index in pixaas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This appends a clone of each indicated pixa in paas to pixaad
      (2) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (3) iend < 0 means 'read to the end'


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaJoin(*args)
    
    

    try:
        leptonica.pixaaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaAddBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaAddBox(*args):
        """
        ('PIXAA', '*paa')       
('BOX', '*box')       
('l_int32', 'copyflag')       
  pixaaAddBox()

      Input:  paa
              box
              copyflag (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The box can be used, for example, to hold the support region
          of a pixa that is being added to the pixaa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaAddBox(*args)
    
    

    try:
        leptonica.pixaaGetPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaGetPixa.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaaGetPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetPixa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       
  pixaaGetPixa()

      Input:  paa
              index  (to the index-th pixa)
              accesstype  (L_COPY, L_CLONE, L_COPY_CLONE)
      Return: pixa, or null on error

  Notes:
      (1) L_COPY makes a new pixa with a copy of every pix
      (2) L_CLONE just makes a new reference to the pixa,
          and bumps the counter.  You would use this, for example,
          when you need to extract some data from a pix within a
          pixa within a pixaa.
      (3) L_COPY_CLONE makes a new pixa with a clone of every pix
          and box
      (4) In all cases, you must invoke pixaDestroy() on the returned pixa


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetPixa(*args)
    
    

    try:
        leptonica.pixaaVerifyDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaVerifyDepth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaaVerifyDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaVerifyDepth(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*pmaxdepth')       
  pixaaVerifyDepth()

      Input:  paa
              &maxdepth (<optional return> max depth of all pix in pixaa)
      Return: depth (return 0 if they're not all the same, or on error)


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaVerifyDepth(*args)
    
    

    try:
        leptonica.pixaCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaCreateFromPix.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreateFromPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'n')       
('l_int32', 'cellw')       
('l_int32', 'cellh')       
  pixaCreateFromPix()

      Input:  pixs  (with individual components on a lattice)
              n   (number of components)
              cellw   (width of each cell)
              cellh   (height of each cell)
      Return: pixa, or null on error

  Notes:
      (1) For bpp = 1, we truncate each retrieved pix to the ON
          pixels, which we assume for now start at (0,0)


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreateFromPix(*args)
    
    

    try:
        leptonica.pixaSplitPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaSplitPix.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaSplitPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSplitPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'borderwidth')       
('l_uint32', 'bordercolor')       
  pixaSplitPix()

      Input:  pixs  (with individual components on a lattice)
              nx   (number of mosaic cells horizontally)
              ny   (number of mosaic cells vertically)
              borderwidth  (of added border on all sides)
              bordercolor  (in our RGBA format: 0xrrggbbaa)
      Return: pixa, or null on error

  Notes:
      (1) This is a variant on pixaCreateFromPix(), where we
          simply divide the image up into (approximately) equal
          subunits.  If you want the subimages to have essentially
          the same aspect ratio as the input pix, use nx = ny.
      (2) If borderwidth is 0, we ignore the input bordercolor and
          redefine it to white.
      (3) The bordercolor is always used to initialize each tiled pix,
          so that if the src is clipped, the unblitted part will
          be this color.  This avoids 1 pixel wide black stripes at the
          left and lower edges.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSplitPix(*args)
    
    

    try:
        leptonica.pixaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXA', '*pixa')       
  pixaWriteStream()

      Input:  stream (opened for "wb")
              pixa
      Return: 0 if OK, 1 on error

  Notes:
      (1) The pix are stored in the file as png.
          If the png library is not linked, this will fail.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteStream(*args)
    
    

    try:
        leptonica.pixaExtendArrayToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaExtendArrayToSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaExtendArrayToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaExtendArrayToSize(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'size')       
  pixaExtendArrayToSize()

      Input:  pixa
      Return: 0 if OK; 1 on error

  Notes:
      (1) If necessary, reallocs new pixa and boxa ptrs arrays to @size.
          The pixa and boxa ptr arrays must always be equal in size.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaExtendArrayToSize(*args)
    
    

    try:
        leptonica.pixaInsertPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaInsertPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaInsertPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaInsertPix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('PIX', '*pixs')       
('BOX', '*box')       
  pixaInsertPix()

      Input:  pixa
              index (at which pix is to be inserted)
              pixs (new pix to be inserted)
              box (<optional> new box to be inserted)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts pixa[i] --> pixa[i + 1] for all i >= index,
          and then inserts at pixa[index].
      (2) To insert at the beginning of the array, set index = 0.
      (3) It should not be used repeatedly on large arrays,
          because the function is O(n).
      (4) To append a pix to a pixa, it's easier to use pixaAddPix().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaInsertPix(*args)
    
    

    try:
        leptonica.pixaCountText.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaCountText.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaCountText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCountText(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pntext')       
  pixaCountText()

      Input:  pixa
              &ntext (<return> number of pix with non-empty text strings)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) All pix have non-empty text strings if the returned value @ntext
          equals the pixa count.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCountText(*args)
    
    

    try:
        leptonica.pixaCreateFromBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaCreateFromBoxa.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCreateFromBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreateFromBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', '*pcropwarn')       
  pixaCreateFromBoxa()

      Input:  pixs
              boxa
              &cropwarn (<optional return> TRUE if the boxa extent
                         is larger than pixs.
      Return: pixad, or null on error

  Notes:
      (1) This simply extracts from pixs the region corresponding to each
          box in the boxa.
      (2) The 3rd arg is optional.  If the extent of the boxa exceeds the
          size of the pixa, so that some boxes are either clipped
          or entirely outside the pix, a warning is returned as TRUE.
      (3) pixad will have only the properly clipped elements, and
          the internal boxa will be correct.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreateFromBoxa(*args)
    
    

    try:
        leptonica.pixaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaCopy.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCopy(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'copyflag')       
  pixaCopy()

      Input:  pixas
              copyflag (see pix.h for details):
                L_COPY makes a new pixa and copies each pix and each box
                L_CLONE gives a new ref-counted handle to the input pixa
                L_COPY_CLONE makes a new pixa and inserts clones of
                    all pix and boxes
      Return: new pixa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCopy(*args)
    




class bmf(object):
    """  bmf.c

   Acquisition and generation of bitmap fonts.

       L_BMF           *bmfCreate()
       L_BMF           *bmfDestroy()

       PIX             *bmfGetPix()
       l_int32          bmfGetWidth()
       l_int32          bmfGetBaseline()

       PIXA            *pixaGetFont()
       l_int32          pixaSaveFont()
       PIXA            *pixaGenerateFont()
       static l_int32   pixGetTextBaseline()
       static l_int32   bmfMakeAsciiTables()

   This is not a very general utility, because it only uses bitmap
   representations of a single font, Palatino-Roman, with the
   normal style.  It uses bitmaps generated for nine sizes, from
   4 to 20 pts, rendered at 300 ppi.  Generalization to different
   fonts, styles and sizes is straightforward.

   I chose Palatino-Roman is because I like it.
   The input font images were generated from a set of small
   PostScript files, such as chars-12.ps, which were rendered
   into the inputfont[] bitmap files using GhostScript.  See, for
   example, the bash script prog/ps2tiff, which will "rip" a
   PostScript file into a set of ccitt-g4 compressed tiff files.

   The set of ascii characters from 32 through 126 are the 95
   printable ascii chars.  Palatino-Roman is missing char 92, '\'.
   I have substituted '/', char 47, for 92, so that there will be
   no missing printable chars in this set.  The space is char 32,
   and I have given it a width equal to twice the width of '!'.

"""
    
    try:
        leptonica.pixaGetFont.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetFont.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaGetFont not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetFont(*args):
        """
        ('const char', '*dir')       
('l_int32', 'size')       
('l_int32', '*pbl0')       
('l_int32', '*pbl1')       
('l_int32', '*pbl2')       
  pixaGetFont()

      Input:  dir (directory holding pixa of character set)
              size (4, 6, 8, ... , 20)
              &bl1 (<return> baseline of row 1)
              &bl2 (<return> baseline of row 2)
              &bl3 (<return> baseline of row 3)
      Return: pixa of font bitmaps for 95 characters, or null on error

  Notes:
      (1) This reads a pre-computed pixa file with the 95 ascii chars.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetFont(*args)
    
    

    try:
        leptonica.bmfCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.bmfCreate.restype = lambda address: L_BMF(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function bmfCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfCreate(*args):
        """
        ('const char', '*dir')       
('l_int32', 'size')       
  bmfCreate()

      Input:  dir (directory holding pixa of character set)
              size (4, 6, 8, ... , 20)
      Return: bmf (holding the bitmap font and associated information)

  Notes:
      (1) This first tries to read a pre-computed pixa file with the
          95 ascii chars in it.  If the file is not found, it
          creates the pixa from the raw image.  It then generates all
          associated data required to use the bmf.


        """
        args = _convert_params(*args)
        
        return leptonica.bmfCreate(*args)
    
    

    try:
        leptonica.bmfGetWidth.argtypes = [ctypes.c_void_p, ctypes.c_char, ctypes.c_void_p]
        leptonica.bmfGetWidth.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bmfGetWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetWidth(*args):
        """
        ('L_BMF', '*bmf')       
('char', 'chr')       
('l_int32', '*pw')       
  bmfGetWidth()

      Input:  bmf
              chr (should be one of the 95 supported bitmaps)
              &w (<return> character width; -1 if not printable)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetWidth(*args)
    
    

    try:
        leptonica.pixaGenerateFont.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGenerateFont.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaGenerateFont not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGenerateFont(*args):
        """
        ('const char', '*dir')       
('l_int32', 'size')       
('l_int32', '*pbl0')       
('l_int32', '*pbl1')       
('l_int32', '*pbl2')       
  pixaGenerateFont()

      Input:  dir (directory holding image of character set)
              size (4, 6, 8, ... , 20, in pts at 300 ppi)
              &bl1 (<return> baseline of row 1)
              &bl2 (<return> baseline of row 2)
              &bl3 (<return> baseline of row 3)
      Return: pixa of font bitmaps for 95 characters, or null on error

  These font generation functions use 9 sets, each with bitmaps
  of 94 ascii characters, all in Palatino-Roman font.
  Each input bitmap has 3 rows of characters.  The range of
  ascii values in each row is as follows:
    row 0:  32-57   (32 is a space)
    row 1:  58-91   (92, '\', is not represented in this font)
    row 2:  93-126
  We LR flip the '/' char to generate a bitmap for the missing
  '\' character, so that we have representations of all 95
  printable chars.

  Computation of the bitmaps and baselines for a single
  font takes from 40 to 200 msec on a 2 GHz processor,
  depending on the size.  Use pixaGetFont() to read the
  generated character set directly from files that were
  produced in prog/genfonts.c using this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGenerateFont(*args)
    
    

    try:
        leptonica.pixaSaveFont.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSaveFont.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaSaveFont not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSaveFont(*args):
        """
        ('const char', '*indir')       
('const char', '*outdir')       
('l_int32', 'size')       
  pixaSaveFont()

      Input:  indir (directory holding image of character set)
              outdir (directory into which the output pixa file
                      will be written)
              size (in pts, at 300 ppi)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This saves a font of a particular size.
      (2) prog/genfonts calls this function for each of the
          nine font sizes, to generate all the font pixa files.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSaveFont(*args)
    
    

    try:
        leptonica.bmfGetPix.argtypes = [ctypes.c_void_p, ctypes.c_char]
        leptonica.bmfGetPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function bmfGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetPix(*args):
        """
        ('L_BMF', '*bmf')       
('char', 'chr')       
  bmfGetPix()

      Input:  bmf
              chr (should be one of the 95 supported printable bitmaps)
      Return: pix (clone of pix in bmf), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetPix(*args)
    
    

    try:
        leptonica.bmfGetBaseline.argtypes = [ctypes.c_void_p, ctypes.c_char, ctypes.c_void_p]
        leptonica.bmfGetBaseline.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function bmfGetBaseline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetBaseline(*args):
        """
        ('L_BMF', '*bmf')       
('char', 'chr')       
('l_int32', '*pbaseline')       
  bmfGetBaseline()

      Input:  bmf
              chr (should be one of the 95 supported bitmaps)
              &baseline (<return>; distance below UL corner of bitmap char)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetBaseline(*args)
    
    

    try:
        leptonica.bmfDestroy.argtypes = [ctypes.c_void_p]
        leptonica.bmfDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function bmfDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfDestroy(*args):
        """
        ('L_BMF', '**pbmf')       
  bmfDestroy()

      Input:  &bmf (<set to null>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.bmfDestroy(*args)
    




class pix5(object):
    """  pix5.c

    This file has these operations:

      (1) Measurement of 1 bpp image properties
      (2) Extract rectangular regions
      (3) Clip to foreground
      (4) Extract pixel averages, reversals and variance along lines
      (5) Rank row and column transforms

    Measurement of properties
           l_int32     pixaFindDimensions()
           l_int32     pixFindAreaPerimRatio()
           NUMA       *pixaFindPerimToAreaRatio()
           l_int32     pixFindPerimToAreaRatio()
           NUMA       *pixaFindPerimSizeRatio()
           l_int32     pixFindPerimSizeRatio()
           NUMA       *pixaFindAreaFraction()
           l_int32     pixFindAreaFraction()
           NUMA       *pixaFindAreaFractionMasked()
           l_int32     pixFindAreaFractionMasked()
           NUMA       *pixaFindWidthHeightRatio()
           NUMA       *pixaFindWidthHeightProduct()
           l_int32     pixFindOverlapFraction()
           BOXA       *pixFindRectangleComps()
           l_int32     pixConformsToRectangle()

    Extract rectangular region
           PIXA       *pixClipRectangles()
           PIX        *pixClipRectangle()
           PIX        *pixClipMasked()
           l_int32     pixCropToMatch()
           PIX        *pixCropToSize()
           PIX        *pixResizeToMatch()

    Clip to foreground
           PIX        *pixClipToForeground()
           l_int32     pixTestClipToForeground()
           l_int32     pixClipBoxToForeground()
           l_int32     pixScanForForeground()
           l_int32     pixClipBoxToEdges()
           l_int32     pixScanForEdge()

    Extract pixel averages and reversals along lines
           NUMA       *pixExtractOnLine()
           l_float32   pixAverageOnLine()
           NUMA       *pixAverageIntensityProfile()
           NUMA       *pixReversalProfile()

    Extract windowed variance along a line
           NUMA       *pixWindowedVarianceOnLine()

    Extract min/max of pixel values near lines
           l_int32     pixMinMaxNearLine()

    Rank row and column transforms
           PIX        *pixRankRowTransform()
           PIX        *pixRankColumnTransform()

"""
    
    try:
        leptonica.pixScanForForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixScanForForeground.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixScanForForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScanForForeground(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'scanflag')       
('l_int32', '*ploc')       
  pixScanForForeground()

      Input:  pixs (1 bpp)
              box  (<optional> within which the search is conducted)
              scanflag (direction of scan; e.g., L_FROM_LEFT)
              &loc (location in scan direction of first black pixel)
      Return: 0 if OK; 1 on error or if no fg pixels are found

  Notes:
      (1) If there are no fg pixels, the position is set to 0.
          Caller must check the return value!
      (2) Use @box == NULL to scan from edge of pixs


        """
        args = _convert_params(*args)
        
        return leptonica.pixScanForForeground(*args)
    
    

    try:
        leptonica.pixaFindWidthHeightRatio.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindWidthHeightRatio.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaFindWidthHeightRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindWidthHeightRatio(*args):
        """
        ('PIXA', '*pixa')       
  pixaFindWidthHeightRatio()

      Input:  pixa (of 1 bpp pix)
      Return: na (of width/height ratios for each pix), or null on error

  Notes:
      (1) This is typically used for a pixa consisting of
          1 bpp connected components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindWidthHeightRatio(*args)
    
    

    try:
        leptonica.pixRankRowTransform.argtypes = [ctypes.c_void_p]
        leptonica.pixRankRowTransform.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankRowTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankRowTransform(*args):
        """
        ('PIX', '*pixs')       
  pixRankRowTransform()

      Input:  pixs (8 bpp; no colormap)
      Return: pixd (with pixels sorted in each row, from
                    min to max value)

 Notes:
     (1) The time is O(n) in the number of pixels and runs about
         100 Mpixels/sec on a 3 GHz machine.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankRowTransform(*args)
    
    

    try:
        leptonica.pixFindRectangleComps.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFindRectangleComps.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindRectangleComps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindRectangleComps(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dist')       
('l_int32', 'minw')       
('l_int32', 'minh')       
  pixFindRectangleComps()

      Input:  pixs (1 bpp)
              dist (max distance allowed between bounding box and nearest
                    foreground pixel within it)
              minw, minh (minimum size in each direction as a requirement
                          for a conforming rectangle)
      Return: boxa (of components that conform), or null on error

  Notes:
      (1) This applies the function pixConformsToRectangle() to
          each 8-c.c. in pixs, and returns a boxa containing the
          regions of all components that are conforming.
      (2) Conforming components must satisfy both the size constraint
          given by @minsize and the slop in conforming to a rectangle
          determined by @dist.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindRectangleComps(*args)
    
    

    try:
        leptonica.pixClipMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixClipMasked.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixClipMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', 'outval')       
  pixClipMasked()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp; colormap ok)
              pixm  (clipping mask, 1 bpp)
              x, y (origin of clipping mask relative to pixs)
              outval (val to use for pixels that are outside the mask)
      Return: pixd, (clipped pix) or null on error or if pixm doesn't
              intersect pixs

  Notes:
      (1) If pixs has a colormap, it is preserved in pixd.
      (2) The depth of pixd is the same as that of pixs.
      (3) If the depth of pixs is 1, use @outval = 0 for white background
          and 1 for black; otherwise, use the max value for white
          and 0 for black.  If pixs has a colormap, the max value for
          @outval is 0xffffffff; otherwise, it is 2^d - 1.
      (4) When using 1 bpp pixs, this is a simple clip and
          blend operation.  For example, if both pix1 and pix2 are
          black text on white background, and you want to OR the
          fg on the two images, let pixm be the inverse of pix2.
          Then the operation takes all of pix1 that's in the bg of
          pix2, and for the remainder (which are the pixels
          corresponding to the fg of the pix2), paint them black
          (1) in pix1.  The function call looks like
             pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1);


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipMasked(*args)
    
    

    try:
        leptonica.pixaFindWidthHeightProduct.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindWidthHeightProduct.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaFindWidthHeightProduct not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindWidthHeightProduct(*args):
        """
        ('PIXA', '*pixa')       
  pixaFindWidthHeightProduct()

      Input:  pixa (of 1 bpp pix)
      Return: na (of width*height products for each pix), or null on error

  Notes:
      (1) This is typically used for a pixa consisting of
          1 bpp connected components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindWidthHeightProduct(*args)
    
    

    try:
        leptonica.pixClipBoxToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipBoxToForeground.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixClipBoxToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipBoxToForeground(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*boxs')       
('PIX', '**ppixd')       
('BOX', '**pboxd')       
  pixClipBoxToForeground()

      Input:  pixs (1 bpp)
              boxs  (<optional> ; use full image if null)
              &pixd  (<optional return> clipped pix returned)
              &boxd  (<optional return> bounding box)
      Return: 0 if OK; 1 on error or if there are no fg pixels

  Notes:
      (1) At least one of {&pixd, &boxd} must be specified.
      (2) If there are no fg pixels, the returned ptrs are null.
      (3) Do not use &pixs for the 3rd arg or &boxs for the 4th arg;
          this will leak memory.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipBoxToForeground(*args)
    
    

    try:
        leptonica.pixRankColumnTransform.argtypes = [ctypes.c_void_p]
        leptonica.pixRankColumnTransform.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankColumnTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankColumnTransform(*args):
        """
        ('PIX', '*pixs')       
  pixRankColumnTransform()

      Input:  pixs (8 bpp; no colormap)
      Return: pixd (with pixels sorted in each column, from
                    min to max value)

 Notes:
     (1) The time is O(n) in the number of pixels and runs about
         50 Mpixels/sec on a 3 GHz machine.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankColumnTransform(*args)
    
    

    try:
        leptonica.pixaFindAreaFractionMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaFindAreaFractionMasked.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaFindAreaFractionMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindAreaFractionMasked(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pixm')       
('l_int32', 'debug')       
  pixaFindAreaFractionMasked()

      Input:  pixa (of 1 bpp pix)
              pixm (mask image)
              debug (1 for output, 0 to suppress)
      Return: na (of ratio masked/total fractions for each pix),
                  or null on error

  Notes:
      (1) This is typically used for a pixa consisting of
          1 bpp connected components, which has an associated
          boxa giving the location of the components relative
          to the mask origin.
      (2) The debug flag displays in green and red the masked and
          unmasked parts of the image from which pixa was derived.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindAreaFractionMasked(*args)
    
    

    try:
        leptonica.pixAverageIntensityProfile.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAverageIntensityProfile.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAverageIntensityProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageIntensityProfile(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'dir')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'factor1')       
('l_int32', 'factor2')       
  pixAverageIntensityProfile()

      Input:  pixs (any depth; colormap OK)
              fract (fraction of image width or height to be used)
              dir (averaging direction: L_HORIZONTAL_LINE or L_VERTICAL_LINE)
              first, last (span of rows or columns to measure)
              factor1 (sampling along fast scan direction; >= 1)
              factor2 (sampling along slow scan direction; >= 1)
      Return: na (of reversal profile), or null on error.

  Notes:
      (1) If d != 1 bpp, colormaps are removed and the result
          is converted to 8 bpp.
      (2) If @dir == L_HORIZONTAL_LINE, the intensity is averaged
          along each horizontal raster line (sampled by @factor1),
          and the profile is the array of these averages in the
          vertical direction between @first and @last raster lines,
          and sampled by @factor2.
      (3) If @dir == L_VERTICAL_LINE, the intensity is averaged
          along each vertical line (sampled by @factor1),
          and the profile is the array of these averages in the
          horizontal direction between @first and @last columns,
          and sampled by @factor2.
      (4) The averages are measured over the central @fract of the image.
          Use @fract == 1.0 to average across the entire width or height.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageIntensityProfile(*args)
    
    

    try:
        leptonica.pixFindAreaFractionMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindAreaFractionMasked.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindAreaFractionMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindAreaFractionMasked(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('PIX', '*pixm')       
('l_int32', '*tab')       
('l_float32', '*pfract')       
  pixFindAreaFractionMasked()

      Input:  pixs (1 bpp, typically a single component)
              box (<optional> for pixs relative to pixm)
              pixm (1 bpp mask, typically over the entire image from
                    which the component pixs was extracted)
              tab (<optional> pixel sum table, can be NULL)
              &fract (<return> fg area/size ratio)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This finds the ratio of the number of masked fg pixels
          in pixs to the total number of fg pixels in pixs.
          It is typically used for a single connected component.
          If there are no fg pixels, this returns a ratio of 0.0.
      (2) The box gives the location of the pix relative to that
          of the UL corner of the mask.  Therefore, the rasterop
          is performed with the pix translated to its location
          (x, y) in the mask before ANDing.
          If box == NULL, the UL corners of pixs and pixm are aligned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindAreaFractionMasked(*args)
    
    

    try:
        leptonica.pixaFindPerimToAreaRatio.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindPerimToAreaRatio.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaFindPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindPerimToAreaRatio(*args):
        """
        ('PIXA', '*pixa')       
  pixaFindPerimToAreaRatio()

      Input:  pixa (of 1 bpp pix)
      Return: na (of perimeter/arear ratio for each pix), or null on error

  Notes:
      (1) This is typically used for a pixa consisting of
          1 bpp connected components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixFindPerimSizeRatio.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindPerimSizeRatio.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindPerimSizeRatio(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pratio')       
  pixFindPerimSizeRatio()

      Input:  pixs (1 bpp)
              tab (<optional> pixel sum table, can be NULL)
              &ratio (<return> perimeter/size ratio)
      Return: 0 if OK, 1 on error

  Notes:
      (1) We take the 'size' as twice the sum of the width and
          height of pixs, and the perimeter is the number of fg
          boundary pixels.  We use the fg pixels of the boundary
          because the pix may be clipped to the boundary, so an
          erosion is required to count all boundary pixels.
      (2) This has a large value for dendritic, fractal-like components
          with highly irregular boundaries.
      (3) This is typically used for a single connected component.
          It has a value of about 1.0 for rectangular components with
          relatively smooth boundaries.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixaFindAreaFraction.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindAreaFraction.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaFindAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindAreaFraction(*args):
        """
        ('PIXA', '*pixa')       
  pixaFindAreaFraction()

      Input:  pixa (of 1 bpp pix)
      Return: na (of area fractions for each pix), or null on error

  Notes:
      (1) This is typically used for a pixa consisting of
          1 bpp connected components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindAreaFraction(*args)
    
    

    try:
        leptonica.pixFindOverlapFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindOverlapFraction.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindOverlapFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindOverlapFraction(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', '*tab')       
('l_float32', '*pratio')       
('l_int32', '*pnoverlap')       
  pixFindOverlapFraction()

      Input:  pixs1, pixs2 (1 bpp)
              x2, y2 (location in pixs1 of UL corner of pixs2)
              tab (<optional> pixel sum table, can be null)
              &ratio (<return> ratio fg intersection to fg union)
              &noverlap (<optional return> number of overlapping pixels)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.
      (2) This measure is similar to the correlation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindOverlapFraction(*args)
    
    

    try:
        leptonica.pixaFindPerimSizeRatio.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindPerimSizeRatio.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaFindPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindPerimSizeRatio(*args):
        """
        ('PIXA', '*pixa')       
  pixaFindPerimSizeRatio()

      Input:  pixa (of 1 bpp pix)
      Return: na (of fg perimeter/(2*(w+h)) ratio for each pix),
                  or null on error

  Notes:
      (1) This is typically used for a pixa consisting of
          1 bpp connected components.
      (2) This has a minimum value for a circle of pi/4; a value for
          a rectangle component of approx. 1.0; and a value much larger
          than 1.0 for a component with a highly irregular boundary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixClipToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipToForeground.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixClipToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipToForeground(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixd')       
('BOX', '**pbox')       
  pixClipToForeground()

      Input:  pixs (1 bpp)
              &pixd  (<optional return> clipped pix returned)
              &box   (<optional return> bounding box)
      Return: 0 if OK; 1 on error or if there are no fg pixels

  Notes:
      (1) At least one of {&pixd, &box} must be specified.
      (2) If there are no fg pixels, the returned ptrs are null.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipToForeground(*args)
    
    

    try:
        leptonica.pixCropToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCropToSize.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCropToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCropToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixCropToSize()

      Input:  pixs (any depth, colormap OK)
              w, h (max dimensions of cropped image)
      Return: pixd (cropped if necessary) or null on error.

  Notes:
      (1) If either w or h is smaller than the corresponding dimension
          of pixs, this returns a cropped image; otherwise it returns
          a clone of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCropToSize(*args)
    
    

    try:
        leptonica.pixMinMaxNearLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMinMaxNearLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMinMaxNearLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMinMaxNearLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'dist')       
('l_int32', 'direction')       
('NUMA', '**pnamin')       
('NUMA', '**pnamax')       
('l_float32', '*pminave')       
('l_float32', '*pmaxave')       
  pixMinMaxNearLine()

      Input:  pixs (8 bpp; no colormap)
              x1, y1 (starting pt for line)
              x2, y2 (end pt for line)
              dist (distance to search from line in each direction)
              direction (L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH)
              &namin (<optional return> minimum values)
              &namax (<optional return> maximum values)
              &minave (<optional return> average of minimum values)
              &maxave (<optional return> average of maximum values)
      Return: 0 if OK; 1 on error or if there are no sampled points
              within the image.

  Notes:
      (1) If the line is more horizontal than vertical, the values
          are computed for [x1, x2], and the pixels are taken
          below and/or above the local y-value.  Otherwise, the
          values are computed for [y1, y2] and the pixels are taken
          to the left and/or right of the local x value.
      (2) @direction specifies which side (or both sides) of the
          line are scanned for min and max values.
      (3) There are two ways to tell if the returned values of min
          and max averages are valid: the returned values cannot be
          negative and the function must return 0.
      (4) All accessed pixels are clipped to the pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMinMaxNearLine(*args)
    
    

    try:
        leptonica.pixTestClipToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTestClipToForeground.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTestClipToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTestClipToForeground(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pcanclip')       
  pixTestClipToForeground()

      Input:  pixs (1 bpp)
              &canclip (<return> 1 if fg does not extend to all four edges)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is a lightweight test to determine if a 1 bpp image
          can be further cropped without loss of fg pixels.
          If it cannot, canclip is set to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTestClipToForeground(*args)
    
    

    try:
        leptonica.pixCropToMatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCropToMatch.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCropToMatch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCropToMatch(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('PIX', '**ppixd1')       
('PIX', '**ppixd2')       
  pixCropToMatch()

      Input:  pixs1 (any depth, colormap OK)
              pixs2 (any depth, colormap OK)
              &pixd1 (<return> may be a clone)
              &pixd2 (<return> may be a clone)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This resizes pixs1 and/or pixs2 by cropping at the right
          and bottom, so that they're the same size.
      (2) If a pix doesn't need to be cropped, a clone is returned.
      (3) Note: the images are implicitly aligned to the UL corner.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCropToMatch(*args)
    
    

    try:
        leptonica.pixFindPerimToAreaRatio.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindPerimToAreaRatio.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindPerimToAreaRatio(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pfract')       
  pixFindPerimToAreaRatio()

      Input:  pixs (1 bpp)
              tab (<optional> pixel sum table, can be NULL)
              &fract (<return> perimeter/area ratio)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The perimeter is the number of fg boundary pixels, and the
          area is the number of fg pixels.  This returns 0.0 if
          there are no fg pixels.
      (2) Unlike pixFindAreaPerimRatio(), this uses the full set of
          fg pixels for the area, and the ratio is taken in the opposite
          order.
      (3) This is typically used for a single connected component.
          This always has a value <= 1.0, and if the average distance
          of a fg pixel from the nearest bg pixel is d, this has
          a value ~1/d.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixReversalProfile.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReversalProfile.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReversalProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReversalProfile(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'dir')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'minreversal')       
('l_int32', 'factor1')       
('l_int32', 'factor2')       
  pixReversalProfile()

      Input:  pixs (any depth; colormap OK)
              fract (fraction of image width or height to be used)
              dir (profile direction: L_HORIZONTAL_LINE or L_VERTICAL_LINE)
              first, last (span of rows or columns to measure)
              minreversal (minimum change in intensity to trigger a reversal)
              factor1 (sampling along raster line (fast scan); >= 1)
              factor2 (sampling of raster lines (slow scan); >= 1)
      Return: na (of reversal profile), or null on error.

  Notes:
      (1) If d != 1 bpp, colormaps are removed and the result
          is converted to 8 bpp.
      (2) If @dir == L_HORIZONTAL_LINE, the the reversals are counted
          along each horizontal raster line (sampled by @factor1),
          and the profile is the array of these sums in the
          vertical direction between @first and @last raster lines,
          and sampled by @factor2.
      (3) If @dir == L_VERTICAL_LINE, the the reversals are counted
          along each vertical column (sampled by @factor1),
          and the profile is the array of these sums in the
          horizontal direction between @first and @last columns,
          and sampled by @factor2.
      (4) For each row or column, the reversals are summed over the
          central @fract of the image.  Use @fract == 1.0 to sum
          across the entire width (of row) or height (of column).
      (5) @minreversal is the relative change in intensity that is
          required to resolve peaks and valleys.  A typical number for
          locating text in 8 bpp might be 50.  For 1 bpp, minreversal
          must be 1.
      (6) The reversal profile is simply the number of reversals
          in a row or column, vs the row or column index.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReversalProfile(*args)
    
    

    try:
        leptonica.pixClipBoxToEdges.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipBoxToEdges.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixClipBoxToEdges not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipBoxToEdges(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*boxs')       
('l_int32', 'lowthresh')       
('l_int32', 'highthresh')       
('l_int32', 'maxwidth')       
('l_int32', 'factor')       
('PIX', '**ppixd')       
('BOX', '**pboxd')       
  pixClipBoxToEdges()

      Input:  pixs (1 bpp)
              boxs  (<optional> ; use full image if null)
              lowthresh (threshold to choose clipping location)
              highthresh (threshold required to find an edge)
              maxwidth (max allowed width between low and high thresh locs)
              factor (sampling factor along pixel counting direction)
              &pixd  (<optional return> clipped pix returned)
              &boxd  (<optional return> bounding box)
      Return: 0 if OK; 1 on error or if a fg edge is not found from
              all four sides.

  Notes:
      (1) At least one of {&pixd, &boxd} must be specified.
      (2) If there are no fg pixels, the returned ptrs are null.
      (3) This function attempts to locate rectangular "image" regions
          of high-density fg pixels, that have well-defined edges
          on the four sides.
      (4) Edges are searched for on each side, iterating in order
          from left, right, top and bottom.  As each new edge is
          found, the search box is resized to use that location.
          Once an edge is found, it is held.  If no more edges
          are found in one iteration, the search fails.
      (5) See pixScanForEdge() for usage of the thresholds and @maxwidth.
      (6) The thresholds must be at least 1, and the low threshold
          cannot be larger than the high threshold.
      (7) If the low and high thresholds are both 1, this is equivalent
          to pixClipBoxToForeground().


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipBoxToEdges(*args)
    
    

    try:
        leptonica.pixResizeToMatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixResizeToMatch.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixResizeToMatch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixResizeToMatch(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixt')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixResizeToMatch()

      Input:  pixs (1, 2, 4, 8, 16, 32 bpp; colormap ok)
              pixt  (can be null; we use only the size)
              w, h (ignored if pixt is defined)
      Return: pixd (resized to match) or null on error

  Notes:
      (1) This resizes pixs to make pixd, without scaling, by either
          cropping or extending separately in both width and height.
          Extension is done by replicating the last row or column.
          This is useful in a situation where, due to scaling
          operations, two images that are expected to be the
          same size can differ slightly in each dimension.
      (2) You can use either an existing pixt or specify
          both @w and @h.  If pixt is defined, the values
          in @w and @h are ignored.
      (3) If pixt is larger than pixs (or if w and/or d is larger
          than the dimension of pixs, replicate the outer row and
          column of pixels in pixs into pixd.


        """
        args = _convert_params(*args)
        
        return leptonica.pixResizeToMatch(*args)
    
    

    try:
        leptonica.pixFindAreaPerimRatio.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindAreaPerimRatio.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindAreaPerimRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindAreaPerimRatio(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pfract')       
  pixFindAreaPerimRatio()

      Input:  pixs (1 bpp)
              tab (<optional> pixel sum table, can be NULL)
              &fract (<return> area/perimeter ratio)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The area is the number of fg pixels that are not on the
          boundary (i.e., are not 8-connected to a bg pixel), and the
          perimeter is the number of fg boundary pixels.  Returns
          0.0 if there are no fg pixels.
      (2) This function is retained because clients are using it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindAreaPerimRatio(*args)
    
    

    try:
        leptonica.pixScanForEdge.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixScanForEdge.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixScanForEdge not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScanForEdge(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'lowthresh')       
('l_int32', 'highthresh')       
('l_int32', 'maxwidth')       
('l_int32', 'factor')       
('l_int32', 'scanflag')       
('l_int32', '*ploc')       
  pixScanForEdge()

      Input:  pixs (1 bpp)
              box  (<optional> within which the search is conducted)
              lowthresh (threshold to choose clipping location)
              highthresh (threshold required to find an edge)
              maxwidth (max allowed width between low and high thresh locs)
              factor (sampling factor along pixel counting direction)
              scanflag (direction of scan; e.g., L_FROM_LEFT)
              &loc (location in scan direction of first black pixel)
      Return: 0 if OK; 1 on error or if the edge is not found

  Notes:
      (1) If there are no fg pixels, the position is set to 0.
          Caller must check the return value!
      (2) Use @box == NULL to scan from edge of pixs
      (3) As the scan progresses, the location where the sum of
          pixels equals or excees @lowthresh is noted (loc).  The
          scan is stopped when the sum of pixels equals or exceeds
          @highthresh.  If the scan distance between loc and that
          point does not exceed @maxwidth, an edge is found and
          its position is taken to be loc.  @maxwidth implicitly
          sets a minimum on the required gradient of the edge.
      (4) The thresholds must be at least 1, and the low threshold
          cannot be larger than the high threshold.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScanForEdge(*args)
    
    

    try:
        leptonica.pixAverageOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAverageOnLine.restype = ctypes.c_float
    except AttributeError:
        os.stderr.write("Warning - function pixAverageOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'factor')       
  pixAverageOnLine()

      Input:  pixs (1 bpp or 8 bpp; no colormap)
              x1, y1 (starting pt for line)
              x2, y2 (end pt for line)
              factor (sampling; >= 1)
      Return: average of pixel values along line, or null on error.

  Notes:
      (1) The line must be either horizontal or vertical, so either
          y1 == y2 (horizontal) or x1 == x2 (vertical).
      (2) If horizontal, x1 must be <= x2.
          If vertical, y1 must be <= y2.
          characterize the intensity smoothness along a line.
      (3) Input end points are clipped to the pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageOnLine(*args)
    
    

    try:
        leptonica.pixClipRectangles.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipRectangles.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixClipRectangles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipRectangles(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
  pixClipRectangles()

      Input:  pixs
              boxa (requested clipping regions)
      Return: pixa (consisting of requested regions), or null on error

  Notes:
     (1) The returned pixa includes the actual regions clipped out from
         the input pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipRectangles(*args)
    
    

    try:
        leptonica.pixFindAreaFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindAreaFraction.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindAreaFraction(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pfract')       
  pixFindAreaFraction()

      Input:  pixs (1 bpp)
              tab (<optional> pixel sum table, can be NULL)
              &fract (<return> fg area/size ratio)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This finds the ratio of the number of fg pixels to the
          size of the pix (w * h).  It is typically used for a
          single connected component.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindAreaFraction(*args)
    
    

    try:
        leptonica.pixExtractOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixExtractOnLine.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'factor')       
  pixExtractOnLine()

      Input:  pixs (1 bpp or 8 bpp; no colormap)
              x1, y1 (one end point for line)
              x2, y2 (another end pt for line)
              factor (sampling; >= 1)
      Return: na (of pixel values along line), or null on error.

  Notes:
      (1) Input end points are clipped to the pix.
      (2) If the line is either horizontal, or closer to horizontal
          than to vertical, the points will be extracted from left
          to right in the pix.  Likewise, if the line is vertical,
          or closer to vertical than to horizontal, the points will
          be extracted from top to bottom.
      (3) Can be used with numaCountReverals(), for example, to
          characterize the intensity smoothness along a line.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractOnLine(*args)
    
    

    try:
        leptonica.pixConformsToRectangle.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixConformsToRectangle.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixConformsToRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConformsToRectangle(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'dist')       
('l_int32', '*pconforms')       
  pixConformsToRectangle()

      Input:  pixs (1 bpp)
              box (<optional> if null, use the entire pixs)
              dist (max distance allowed between bounding box and nearest
                    foreground pixel within it)
              &conforms (<return> 0 (false) if not conforming;
                        1 (true) if conforming)
      Return: 0 if OK, 1 on error

  Notes:
      (1) There are several ways to test if a connected component has
          an essentially rectangular boundary, such as:
           a. Fraction of fill into the bounding box
           b. Max-min distance of fg pixel from periphery of bounding box
           c. Max depth of bg intrusions into component within bounding box
          The weakness of (a) is that it is highly sensitive to holes
          within the c.c.  The weakness of (b) is that it can have
          arbitrarily large intrusions into the c.c.  Method (c) tests
          the integrity of the outer boundary of the c.c., with respect
          to the enclosing bounding box, so we use it.
      (2) This tests if the connected component within the box conforms
          to the box at all points on the periphery within @dist.
          Inside, at a distance from the box boundary that is greater
          than @dist, we don't care about the pixels in the c.c.
      (3) We can think of the conforming condition as follows:
          No pixel inside a distance @dist from the boundary
          can connect to the boundary through a path through the bg.
          To implement this, we need to do a flood fill.  We can go
          either from inside toward the boundary, or the other direction.
          It's easiest to fill from the boundary, and then verify that
          there are no filled pixels farther than @dist from the boundary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConformsToRectangle(*args)
    
    

    try:
        leptonica.pixaFindDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaFindDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaFindDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindDimensions(*args):
        """
        ('PIXA', '*pixa')       
('NUMA', '**pnaw')       
('NUMA', '**pnah')       
  pixaFindDimensions()

      Input:  pixa
              &naw (<optional return> numa of pix widths)
              &nah (<optional return> numa of pix heights)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindDimensions(*args)
    
    

    try:
        leptonica.pixWindowedVarianceOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixWindowedVarianceOnLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWindowedVarianceOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedVarianceOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'loc')       
('l_int32', 'c1')       
('l_int32', 'c2')       
('l_int32', 'size')       
('NUMA', '**pnad')       
  pixWindowedVarianceOnLine()

      Input:  pixs (8 bpp; no colormap)
              dir (L_HORIZONTAL_LINE or L_VERTICAL_LINE)
              loc (location of the constant coordinate for the line)
              c1, c2 (end point coordinates for the line)
              size (window size; must be > 1)
              &nad (<return> windowed square root of variance)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The returned variance array traverses the line starting
          from the smallest coordinate, min(c1,c2).
      (2) Line end points are clipped to pixs.
      (3) The reference point for the variance calculation is the center of
          the window.  Therefore, the numa start parameter from
          pixExtractOnLine() is incremented by @size/2,
          to align the variance values with the pixel coordinate.
      (4) The square root of the variance is the RMS deviation from the mean.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedVarianceOnLine(*args)
    
    

    try:
        leptonica.pixClipRectangle.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipRectangle.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixClipRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipRectangle(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('BOX', '**pboxc')       
  pixClipRectangle()

      Input:  pixs
              box  (requested clipping region; const)
              &boxc (<optional return> actual box of clipped region)
      Return: clipped pix, or null on error or if rectangle
              doesn't intersect pixs

  Notes:

  This should be simple, but there are choices to be made.
  The box is defined relative to the pix coordinates.  However,
  if the box is not contained within the pix, we have two choices:

      (1) clip the box to the pix
      (2) make a new pix equal to the full box dimensions,
          but let rasterop do the clipping and positioning
          of the src with respect to the dest

  Choice (2) immediately brings up the problem of what pixel values
  to use that were not taken from the src.  For example, on a grayscale
  image, do you want the pixels not taken from the src to be black
  or white or something else?  To implement choice 2, one needs to
  specify the color of these extra pixels.

  So we adopt (1), and clip the box first, if necessary,
  before making the dest pix and doing the rasterop.  But there
  is another issue to consider.  If you want to paste the
  clipped pix back into pixs, it must be properly aligned, and
  it is necessary to use the clipped box for alignment.
  Accordingly, this function has a third (optional) argument, which is
  the input box clipped to the src pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipRectangle(*args)
    




class pix4(object):
    """  pix4.c

    This file has these operations:

      (1) Pixel histograms
      (2) Pixel row/column statistics
      (3) Foreground/background estimation

    Pixel histogram, rank val, averaging and min/max
           NUMA       *pixGetGrayHistogram()
           NUMA       *pixGetGrayHistogramMasked()
           NUMA       *pixGetGrayHistogramInRect()
           l_int32     pixGetColorHistogram()
           l_int32     pixGetColorHistogramMasked()
           NUMA       *pixGetCmapHistogram()
           NUMA       *pixGetCmapHistogramMasked()
           NUMA       *pixGetCmapHistogramInRect()
           l_int32     pixGetRankValue()
           l_int32     pixGetRankValueMaskedRGB()
           l_int32     pixGetRankValueMasked()
           l_int32     pixGetAverageValue()
           l_int32     pixGetAverageMaskedRGB()
           l_int32     pixGetAverageMasked()
           l_int32     pixGetAverageTiledRGB()
           PIX        *pixGetAverageTiled()
           NUMA       *pixRowStats()
           NUMA       *pixColumnStats()
           l_int32     pixGetComponentRange()
           l_int32     pixGetExtremeValue()
           l_int32     pixGetMaxValueInRect()
           l_int32     pixGetBinnedComponentRange()
           l_int32     pixGetRankColorArray()
           l_int32     pixGetBinnedColor()
           PIX        *pixDisplayColorArray()
           PIX        *pixRankBinByStrip()

    Pixelwise aligned statistics
           PIX        *pixaGetAlignedStats()
           l_int32     pixaExtractColumnFromEachPix()
           l_int32     pixGetRowStats()
           l_int32     pixGetColumnStats()
           l_int32     pixSetPixelColumn()

    Foreground/background estimation
           l_int32     pixThresholdForFgBg()
           l_int32     pixSplitDistributionFgBg()

"""
    
    try:
        leptonica.pixGetRankValueMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRankValueMasked.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRankValueMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankValueMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_float32', 'rank')       
('l_float32', '*pval')       
('NUMA', '**pna')       
  pixGetRankValueMasked()

      Input:  pixs (8 bpp, or colormapped)
              pixm (<optional> 1 bpp mask over which rank val is to be taken;
                    use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0; these values are ignored if pixm is null)
              factor (subsampling factor; integer >= 1)
              rank (between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest)
              &val (<return> pixel value corresponding to input rank)
              &na (<optional return> of histogram)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Computes the rank value of pixels in pixs that are under
          the fg of the optional mask.  If the mask is null, it
          computes the average of the pixels in pixs.
      (2) Set the subsampling @factor > 1 to reduce the amount of
          computation.
      (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
      (4) Input x,y are ignored unless pixm exists.
      (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
          has rank 1.0.  For the median pixel value, use 0.5.
      (6) The histogram can optionally be returned, so that other rank
          values can be extracted without recomputing the histogram.
          In that case, just use
              numaHistogramGetValFromRank(na, rank, &val);
          on the returned Numa for additional rank values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankValueMasked(*args)
    
    

    try:
        leptonica.pixGetColumnStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetColumnStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetColumnStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColumnStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'nbins')       
('l_int32', 'thresh')       
('l_float32', '*rowvect')       
  pixGetColumnStats()

      Input:  pixs (8 bpp; not cmapped)
              type (L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT)
              nbins (of histogram for median and mode; ignored for mean)
              thresh (on histogram for mode val; ignored for all other types)
              rowvect (vector of results gathered down the columns of pixs)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes a row vector of statistics using each
          column of a Pix.  The result is put in @rowvect.
      (2) The @thresh parameter works with L_MODE_VAL only, and
          sets a minimum occupancy of the mode bin.
          If the occupancy of the mode bin is less than @thresh, the
          mode value is returned as 0.  To always return the actual
          mode value, set @thresh = 0.
      (3) What is the meaning of this @thresh parameter?
          For each column, the total count in the histogram is h, the
          image height.  So @thresh, relative to h, gives a measure
          of the ratio of the bin width to the width of the distribution.
          The larger @thresh, the narrower the distribution must be
          for the mode value to be returned (instead of returning 0).


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColumnStats(*args)
    
    

    try:
        leptonica.pixColumnStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixColumnStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColumnStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColumnStats(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('NUMA', '**pnamean')       
('NUMA', '**pnamedian')       
('NUMA', '**pnamode')       
('NUMA', '**pnamodecount')       
('NUMA', '**pnavar')       
('NUMA', '**pnarootvar')       
  pixColumnStats()

      Input:  pixs (8 bpp; not cmapped)
              box (<optional> clipping box; can be null)
              &namean (<optional return> numa of mean values)
              &namedian (<optional return> numa of median values)
              &namode (<optional return> numa of mode intensity values)
              &namodecount (<optional return> numa of mode counts)
              &navar (<optional return> numa of variance)
              &narootvar (<optional return> numa of square root of variance)
      Return: na (numa of requested statistic for each column),
                  or null on error

  Notes:
      (1) This computes numas that represent row vectors of statistics,
          with each of its values derived from the corresponding col of a Pix.
      (2) Use NULL on input to prevent computation of any of the 5 numas.
      (3) Other functions that compute pixel column statistics are:
             pixCountPixelsByColumn()
             pixAverageByColumn()
             pixVarianceByColumn()
             pixGetColumnStats()


        """
        args = _convert_params(*args)
        
        return leptonica.pixColumnStats(*args)
    
    

    try:
        leptonica.pixaExtractColumnFromEachPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaExtractColumnFromEachPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaExtractColumnFromEachPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaExtractColumnFromEachPix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'col')       
('PIX', '*pixd')       
  pixaExtractColumnFromEachPix()

      Input:  pixa (of identically sized, 8 bpp; not cmapped)
              col (column index)
              pixd (pix into which each column is inserted)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaExtractColumnFromEachPix(*args)
    
    

    try:
        leptonica.pixDisplayColorArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixDisplayColorArray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayColorArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayColorArray(*args):
        """
        ('l_uint32', '*carray')       
('l_int32', 'ncolors')       
('l_int32', 'side')       
('l_int32', 'ncols')       
('const char', '*fontdir')       
  pixDisplayColorArray()

      Input:  carray (array of colors: 0xrrggbb00)
              ncolors (size of array)
              side (size of each color square; suggest 200)
              ncols (number of columns in output color matrix)
              fontdir (<optional> to label each square with text)
      Return: pixd (color array), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayColorArray(*args)
    
    

    try:
        leptonica.pixRowStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRowStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRowStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRowStats(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('NUMA', '**pnamean')       
('NUMA', '**pnamedian')       
('NUMA', '**pnamode')       
('NUMA', '**pnamodecount')       
('NUMA', '**pnavar')       
('NUMA', '**pnarootvar')       
  pixRowStats()

      Input:  pixs (8 bpp; not cmapped)
              box (<optional> clipping box; can be null)
              &namean (<optional return> numa of mean values)
              &namedian (<optional return> numa of median values)
              &namode (<optional return> numa of mode intensity values)
              &namodecount (<optional return> numa of mode counts)
              &navar (<optional return> numa of variance)
              &narootvar (<optional return> numa of square root of variance)
      Return: na (numa of requested statistic for each row), or null on error

  Notes:
      (1) This computes numas that represent column vectors of statistics,
          with each of its values derived from the corresponding row of a Pix.
      (2) Use NULL on input to prevent computation of any of the 5 numas.
      (3) Other functions that compute pixel row statistics are:
             pixCountPixelsByRow()
             pixAverageByRow()
             pixVarianceByRow()
             pixGetRowStats()


        """
        args = _convert_params(*args)
        
        return leptonica.pixRowStats(*args)
    
    

    try:
        leptonica.pixGetCmapHistogramMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetCmapHistogramMasked.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetCmapHistogramMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCmapHistogramMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
  pixGetCmapHistogramMasked()

      Input:  pixs (colormapped: d = 2, 4 or 8)
              pixm (<optional> 1 bpp mask over which histogram is
                    to be computed; use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0; these values are ignored if pixm is null)
              factor (subsampling factor; integer >= 1)
      Return: na (histogram), or null on error

  Notes:
      (1) This generates a histogram of colormap pixel indices,
          and is of size 2^d.
      (2) Set the subsampling @factor > 1 to reduce the amount of computation.
      (3) Clipping of pixm to pixs is done in the inner loop.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCmapHistogramMasked(*args)
    
    

    try:
        leptonica.pixaGetAlignedStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaGetAlignedStats.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaGetAlignedStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetAlignedStats(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'type')       
('l_int32', 'nbins')       
('l_int32', 'thresh')       
  pixaGetAlignedStats()

      Input:  pixa (of identically sized, 8 bpp pix; not cmapped)
              type (L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT)
              nbins (of histogram for median and mode; ignored for mean)
              thresh (on histogram for mode val; ignored for all other types)
      Return: pix (with pixelwise aligned stats), or null on error.

  Notes:
      (1) Each pixel in the returned pix represents an average
          (or median, or mode) over the corresponding pixels in each
          pix in the pixa.
      (2) The @thresh parameter works with L_MODE_VAL only, and
          sets a minimum occupancy of the mode bin.
          If the occupancy of the mode bin is less than @thresh, the
          mode value is returned as 0.  To always return the actual
          mode value, set @thresh = 0.  See pixGetRowStats().


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetAlignedStats(*args)
    
    

    try:
        leptonica.pixGetAverageMaskedRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetAverageMaskedRGB.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetAverageMaskedRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageMaskedRGB(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_float32', '*prval')       
('l_float32', '*pgval')       
('l_float32', '*pbval')       
  pixGetAverageMaskedRGB()

      Input:  pixs (32 bpp, or colormapped)
              pixm (<optional> 1 bpp mask over which average is to be taken;
                    use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0)
              factor (subsampling factor; >= 1)
              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,
                    L_STANDARD_DEVIATION, L_VARIANCE)
              &rval (<return optional> measured red value of given 'type')
              &gval (<return optional> measured green value of given 'type')
              &bval (<return optional> measured blue value of given 'type')
      Return: 0 if OK, 1 on error

  Notes:
      (1) For usage, see pixGetAverageMasked().
      (2) If there is a colormap, it is removed before the 8 bpp
          component images are extracted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageMaskedRGB(*args)
    
    

    try:
        leptonica.pixThresholdForFgBg.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdForFgBg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdForFgBg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdForFgBg(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'thresh')       
('l_int32', '*pfgval')       
('l_int32', '*pbgval')       
  pixThresholdForFgBg()

      Input:  pixs (any depth; cmapped ok)
              factor (subsampling factor; integer >= 1)
              thresh (threshold for generating foreground mask)
              &fgval (<optional return> average foreground value)
              &bgval (<optional return> average background value)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdForFgBg(*args)
    
    

    try:
        leptonica.pixGetAverageMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetAverageMasked.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetAverageMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_float32', '*pval')       
  pixGetAverageMasked()

      Input:  pixs (8 or 16 bpp, or colormapped)
              pixm (<optional> 1 bpp mask over which average is to be taken;
                    use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0)
              factor (subsampling factor; >= 1)
              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,
                    L_STANDARD_DEVIATION, L_VARIANCE)
              &val (<return> measured value of given 'type')
      Return: 0 if OK, 1 on error

  Notes:
      (1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs
          that are under the fg of the optional mask.  If the mask
          is null, it finds the average of the pixels in pixs.
      (2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of
          pixels in pixs, either masked or not; L_STANDARD_DEVIATION
          to get the standard deviation from the mean of the pixels;
          L_VARIANCE to get the average squared difference from the
          expected value.  The variance is the square of the stdev.
          For the standard deviation, we use
              sqrt(<(<x> - x)>^2) = sqrt(<x^2> - <x>^2)
      (3) Set the subsampling @factor > 1 to reduce the amount of
          computation.
      (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
      (5) Input x,y are ignored unless pixm exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageMasked(*args)
    
    

    try:
        leptonica.pixGetGrayHistogramMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetGrayHistogramMasked.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetGrayHistogramMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogramMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
  pixGetGrayHistogramMasked()

      Input:  pixs (8 bpp, or colormapped)
              pixm (<optional> 1 bpp mask over which histogram is
                    to be computed; use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0; these values are ignored if pixm is null)
              factor (subsampling factor; integer >= 1)
      Return: na (histogram), or null on error

  Notes:
      (1) If pixs is cmapped, it is converted to 8 bpp gray.
          If you want a histogram of the colormap indices, use
          pixGetCmapHistogramMasked().
      (2) This always returns a 256-value histogram of pixel values.
      (3) Set the subsampling factor > 1 to reduce the amount of computation.
      (4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
      (5) Input x,y are ignored unless pixm exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogramMasked(*args)
    
    

    try:
        leptonica.pixGetAverageTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetAverageTiled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetAverageTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageTiled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'type')       
  pixGetAverageTiled()

      Input:  pixs (8 bpp, or colormapped)
              sx, sy (tile size; must be at least 2 x 2)
              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION)
      Return: pixd (average values in each tile), or null on error

  Notes:
      (1) Only computes for tiles that are entirely contained in pixs.
      (2) Use L_MEAN_ABSVAL to get the average abs value within the tile;
          L_ROOT_MEAN_SQUARE to get the rms value within each tile;
          L_STANDARD_DEVIATION to get the standard dev. from the average
          within each tile.
      (3) If colormapped, converts to 8 bpp gray.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageTiled(*args)
    
    

    try:
        leptonica.pixGetColorHistogramMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetColorHistogramMasked.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetColorHistogramMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColorHistogramMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('NUMA', '**pnar')       
('NUMA', '**pnag')       
('NUMA', '**pnab')       
  pixGetColorHistogramMasked()

      Input:  pixs (32 bpp rgb, or colormapped)
              pixm (<optional> 1 bpp mask over which histogram is
                    to be computed; use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0; these values are ignored if pixm is null)
              factor (subsampling factor; integer >= 1)
              &nar (<return> red histogram)
              &nag (<return> green histogram)
              &nab (<return> blue histogram)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This generates a set of three 256 entry histograms,
      (2) Set the subsampling @factor > 1 to reduce the amount of computation.
      (3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
      (4) Input x,y are ignored unless pixm exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColorHistogramMasked(*args)
    
    

    try:
        leptonica.pixGetExtremeValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetExtremeValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetExtremeValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetExtremeValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
('l_int32', '*pgrayval')       
  pixGetExtremeValue()

      Input:  pixs (8 bpp grayscale, 32 bpp rgb, or colormapped)
              factor (subsampling factor; >= 1; ignored if colormapped)
              type (L_SELECT_MIN or L_SELECT_MAX)
              &rval (<optional return> red component)
              &gval (<optional return> green component)
              &bval (<optional return> blue component)
              &grayval (<optional return> min or max gray value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If pixs is grayscale, the result is returned in &grayval.
          Otherwise, if there is a colormap or d == 32,
          each requested color component is returned.  At least
          one color component (address) must be input.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetExtremeValue(*args)
    
    

    try:
        leptonica.pixGetComponentRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetComponentRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetComponentRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetComponentRange(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'color')       
('l_int32', '*pminval')       
('l_int32', '*pmaxval')       
  pixGetComponentRange()

      Input:  pixs (8 bpp grayscale, 32 bpp rgb, or colormapped)
              factor (subsampling factor; >= 1; ignored if colormapped)
              color (L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE)
              &minval (<optional return> minimum value of component)
              &maxval (<optional return> maximum value of component)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If pixs is 8 bpp grayscale, the color selection type is ignored.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetComponentRange(*args)
    
    

    try:
        leptonica.pixGetBinnedColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetBinnedColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBinnedColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBinnedColor(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       
('l_int32', 'factor')       
('l_int32', 'nbins')       
('NUMA', '*nalut')       
('l_uint32', '**pcarray')       
('l_int32', 'debugflag')       
  pixGetBinnedColor()

      Input:  pixs (32 bpp)
              pixg (8 bpp grayscale version of pixs)
              factor (sampling factor along pixel counting direction)
              nbins (number of intensity bins)
              nalut (LUT for mapping from intensity to bin number)
              &carray (<return> array of average color values in each bin)
              debugflag (1 to display output debug plots of color
                         components; 2 to write them as png to file)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This takes a color image, a grayscale (intensity) version,
          a LUT from intensity to bin number, and the number of bins.
          It computes the average color for pixels whose intensity
          is in each bin.  This is returned as an array of l_uint32
          colors in our standard RGBA ordering.
      (2) This function generates equal width intensity bins and
          finds the average color in each bin.  Compare this with
          pixGetRankColorArray(), which rank orders the pixels
          by the value of the selected component in each pixel,
          sets up bins with equal population (not intensity width!),
          and gets the average color in each bin.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBinnedColor(*args)
    
    

    try:
        leptonica.pixGetGrayHistogramInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetGrayHistogramInRect.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetGrayHistogramInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogramInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'factor')       
  pixGetGrayHistogramInRect()

      Input:  pixs (8 bpp, or colormapped)
              box (<optional>) over which histogram is to be computed;
                   use full image if null)
              factor (subsampling factor; integer >= 1)
      Return: na (histogram), or null on error

  Notes:
      (1) If pixs is cmapped, it is converted to 8 bpp gray.
          If you want a histogram of the colormap indices, use
          pixGetCmapHistogramInRect().
      (2) This always returns a 256-value histogram of pixel values.
      (3) Set the subsampling @factor > 1 to reduce the amount of computation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogramInRect(*args)
    
    

    try:
        leptonica.pixGetCmapHistogramInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetCmapHistogramInRect.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetCmapHistogramInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCmapHistogramInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'factor')       
  pixGetCmapHistogramInRect()

      Input:  pixs (colormapped: d = 2, 4 or 8)
              box (<optional>) over which histogram is to be computed;
                   use full image if null)
              factor (subsampling factor; integer >= 1)
      Return: na (histogram), or null on error

  Notes:
      (1) This generates a histogram of colormap pixel indices,
          and is of size 2^d.
      (2) Set the subsampling @factor > 1 to reduce the amount of computation.
      (3) Clipping to the box is done in the inner loop.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCmapHistogramInRect(*args)
    
    

    try:
        leptonica.pixGetAverageTiledRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetAverageTiledRGB.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetAverageTiledRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageTiledRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'type')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       
  pixGetAverageTiledRGB()

      Input:  pixs (32 bpp, or colormapped)
              sx, sy (tile size; must be at least 2 x 2)
              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION)
              &pixr (<optional return> tiled 'average' of red component)
              &pixg (<optional return> tiled 'average' of green component)
              &pixb (<optional return> tiled 'average' of blue component)
      Return: 0 if OK, 1 on error

  Notes:
      (1) For usage, see pixGetAverageTiled().
      (2) If there is a colormap, it is removed before the 8 bpp
          component images are extracted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageTiledRGB(*args)
    
    

    try:
        leptonica.pixGetBinnedComponentRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetBinnedComponentRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBinnedComponentRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBinnedComponentRange(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nbins')       
('l_int32', 'factor')       
('l_int32', 'color')       
('l_int32', '*pminval')       
('l_int32', '*pmaxval')       
('l_uint32', '**pcarray')       
('const char', '*fontdir')       
  pixGetBinnedComponentRange()

      Input:  pixs (32 bpp rgb)
              nbins (number of equal population bins; must be > 1)
              factor (subsampling factor; >= 1)
              color (L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE)
              &minval (<optional return> minimum value of component)
              &maxval (<optional return> maximum value of component)
              &carray (<optional return> color array of bins)
              fontdir (<optional> for debug output)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This returns the min and max average values of the
          selected color component in the set of rank bins,
          where the ranking is done using the specified component.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBinnedComponentRange(*args)
    
    

    try:
        leptonica.pixGetGrayHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetGrayHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetGrayHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixGetGrayHistogram()

      Input:  pixs (1, 2, 4, 8, 16 bpp; can be colormapped)
              factor (subsampling factor; integer >= 1)
      Return: na (histogram), or null on error

  Notes:
      (1) If pixs has a colormap, it is converted to 8 bpp gray.
          If you want a histogram of the colormap indices, use
          pixGetCmapHistogram().
      (2) If pixs does not have a colormap, the output histogram is
          of size 2^d, where d is the depth of pixs.
      (3) This always returns a 256-value histogram of pixel values.
      (4) Set the subsampling factor > 1 to reduce the amount of computation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogram(*args)
    
    

    try:
        leptonica.pixGetRankValueMaskedRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRankValueMaskedRGB.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRankValueMaskedRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankValueMaskedRGB(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_float32', 'rank')       
('l_float32', '*prval')       
('l_float32', '*pgval')       
('l_float32', '*pbval')       
  pixGetRankValueMaskedRGB()

      Input:  pixs (32 bpp)
              pixm (<optional> 1 bpp mask over which rank val is to be taken;
                    use all pixels if null)
              x, y (UL corner of pixm relative to the UL corner of pixs;
                    can be < 0; these values are ignored if pixm is null)
              factor (subsampling factor; integer >= 1)
              rank (between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest)
              &rval (<optional return> red component val for to input rank)
              &gval (<optional return> green component val for to input rank)
              &bval (<optional return> blue component val for to input rank)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Computes the rank component values of pixels in pixs that
          are under the fg of the optional mask.  If the mask is null, it
          computes the average of the pixels in pixs.
      (2) Set the subsampling @factor > 1 to reduce the amount of
          computation.
      (4) Input x,y are ignored unless pixm exists.
      (5) The rank must be in [0.0 ... 1.0], where the brightest pixel
          has rank 1.0.  For the median pixel value, use 0.5.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankValueMaskedRGB(*args)
    
    

    try:
        leptonica.pixGetRowStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetRowStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRowStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRowStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'nbins')       
('l_int32', 'thresh')       
('l_float32', '*colvect')       
  pixGetRowStats()

      Input:  pixs (8 bpp; not cmapped)
              type (L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT)
              nbins (of histogram for median and mode; ignored for mean)
              thresh (on histogram for mode; ignored for mean and median)
              colvect (vector of results gathered across the rows of pixs)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes a column vector of statistics using each
          row of a Pix.  The result is put in @colvect.
      (2) The @thresh parameter works with L_MODE_VAL only, and
          sets a minimum occupancy of the mode bin.
          If the occupancy of the mode bin is less than @thresh, the
          mode value is returned as 0.  To always return the actual
          mode value, set @thresh = 0.
      (3) What is the meaning of this @thresh parameter?
          For each row, the total count in the histogram is w, the
          image width.  So @thresh, relative to w, gives a measure
          of the ratio of the bin width to the width of the distribution.
          The larger @thresh, the narrower the distribution must be
          for the mode value to be returned (instead of returning 0).
      (4) If the Pix consists of a set of corresponding columns,
          one for each Pix in a Pixa, the width of the Pix is the
          number of Pix in the Pixa and the column vector can
          be stored as a column in a Pix of the same size as
          each Pix in the Pixa.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRowStats(*args)
    
    

    try:
        leptonica.pixGetMaxValueInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetMaxValueInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetMaxValueInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetMaxValueInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', '*pmaxval')       
('l_int32', '*pxmax')       
('l_int32', '*pymax')       
  pixGetMaxValueInRect()

      Input:  pixs (8 bpp or 32 bpp grayscale; no color space components)
              box (<optional> region; set box = NULL to use entire pixs)
              &maxval (<optional return> max value in region)
              &xmax (<optional return> x location of max value)
              &ymax (<optional return> y location of max value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This can be used to find the maximum and its location
          in a 2-dimensional histogram, where the x and y directions
          represent two color components (e.g., saturation and hue).
      (2) Note that here a 32 bpp pixs has pixel values that are simply
          numbers.  They are not 8 bpp components in a colorspace.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetMaxValueInRect(*args)
    
    

    try:
        leptonica.pixRankBinByStrip.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRankBinByStrip.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRankBinByStrip not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankBinByStrip(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'direction')       
('l_int32', 'size')       
('l_int32', 'nbins')       
('l_int32', 'type')       
  pixRankBinByStrip()

      Input:  pixs (32 bpp or cmapped)
              direction (L_SCAN_HORIZONTAL or L_SCAN_VERTICAL)
              size (of strips in scan direction)
              nbins (number of equal population bins; must be > 1)
              type (color selection flag)
      Return: pixd (result), or null on error

  Notes:
      (1) This generates a pix where each column represents a strip of
          the input image.  If @direction == L_SCAN_HORIZONTAL, the
          input impage is tiled into vertical strips of width @size,
          where @size is a compromise between getting better spatial
          columnwise resolution (small @size) and getting better
          columnwise statistical information (larger @size).  Likewise
          with rows of the image if @direction == L_SCAN_VERTICAL.
      (2) For L_HORIZONTAL_SCAN, the output pix contains rank binned
          median colors in each column that correspond to a vertical
          strip of width @size in the input image.
      (3) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
          L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
          It determines how the rank ordering is done.
      (4) Typical input values might be @size = 5, @nbins = 10.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankBinByStrip(*args)
    
    

    try:
        leptonica.pixGetRankValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixGetRankValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRankValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', 'rank')       
('l_uint32', '*pvalue')       
  pixGetRankValue()

      Input:  pixs (8 bpp, 32 bpp or colormapped)
              factor (subsampling factor; integer >= 1)
              rank (between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest)
              &value (<return> pixel value corresponding to input rank)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Simple function to get rank values of an image.
          For a color image, the median value (rank = 0.5) can be
          used to linearly remap the colors based on the median
          of a target image, using pixLinearMapToTargetColor().


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankValue(*args)
    
    

    try:
        leptonica.pixGetRankColorArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetRankColorArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRankColorArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankColorArray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nbins')       
('l_int32', 'type')       
('l_int32', 'factor')       
('l_uint32', '**pcarray')       
('l_int32', 'debugflag')       
('const char', '*fontdir')       
  pixGetRankColorArray()

      Input:  pixs (32 bpp or cmapped)
              nbins (number of equal population bins; must be > 1)
              type (color selection flag)
              factor (subsampling factor; integer >= 1)
              &carray (<return> array of colors, ranked by intensity)
              debugflag (1 to display color squares and plots of color
                         components; 2 to write them as png to file)
              fontdir (<optional> for text fonts; ignored if debugflag == 0)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
          L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
      (2) Then it finds the histogram of the selected component in each
          RGB pixel.  For each of the @nbins sets of pixels,
          ordered by this component value, find the average color,
          and return this as a "rank color" array.  The output array
          has @nbins colors.
      (3) Set the subsampling factor > 1 to reduce the amount of
          computation.  Typically you want at least 10,000 pixels
          for reasonable statistics.
      (4) The rank color as a function of rank can then be found from
             rankint = (l_int32)(rank * (nbins - 1) + 0.5);
             extractRGBValues(array[rankint], &rval, &gval, &bval);
          where the rank is in [0.0 ... 1.0].
          This function is meant to be simple and approximate.
      (5) Compare this with pixGetBinnedColor(), which generates equal
          width intensity bins and finds the average color in each bin.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankColorArray(*args)
    
    

    try:
        leptonica.pixSetPixelColumn.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSetPixelColumn.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetPixelColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPixelColumn(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'col')       
('l_float32', '*colvect')       
  pixSetPixelColumn()

      Input:  pix (8 bpp; not cmapped)
              col (column index)
              colvect (vector of floats)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPixelColumn(*args)
    
    

    try:
        leptonica.pixGetColorHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetColorHistogram.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetColorHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColorHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('NUMA', '**pnar')       
('NUMA', '**pnag')       
('NUMA', '**pnab')       
  pixGetColorHistogram()

      Input:  pixs (rgb or colormapped)
              factor (subsampling factor; integer >= 1)
              &nar (<return> red histogram)
              &nag (<return> green histogram)
              &nab (<return> blue histogram)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This generates a set of three 256 entry histograms,
          one for each color component (r,g,b).
      (2) Set the subsampling @factor > 1 to reduce the amount of computation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColorHistogram(*args)
    
    

    try:
        leptonica.pixGetCmapHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetCmapHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetCmapHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCmapHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixGetCmapHistogram()

      Input:  pixs (colormapped: d = 2, 4 or 8)
              factor (subsampling factor; integer >= 1)
      Return: na (histogram of cmap indices), or null on error

  Notes:
      (1) This generates a histogram of colormap pixel indices,
          and is of size 2^d.
      (2) Set the subsampling @factor > 1 to reduce the amount of computation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCmapHistogram(*args)
    
    

    try:
        leptonica.pixSplitDistributionFgBg.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSplitDistributionFgBg.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSplitDistributionFgBg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitDistributionFgBg(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scorefract')       
('l_int32', 'factor')       
('l_int32', '*pthresh')       
('l_int32', '*pfgval')       
('l_int32', '*pbgval')       
('l_int32', 'debugflag')       
  pixSplitDistributionFgBg()

      Input:  pixs (any depth; cmapped ok)
              scorefract (fraction of the max score, used to determine
                          the range over which the histogram min is searched)
              factor (subsampling factor; integer >= 1)
              &thresh (<optional return> best threshold for separating)
              &fgval (<optional return> average foreground value)
              &bgval (<optional return> average background value)
              debugflag (1 for plotting of distribution and split point)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See numaSplitDistribution() for details on the underlying
          method of choosing a threshold.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitDistributionFgBg(*args)
    
    

    try:
        leptonica.pixGetAverageValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetAverageValue.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetAverageValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_uint32', '*pvalue')       
  pixGetAverageValue()

      Input:  pixs (8 bpp, 32 bpp or colormapped)
              factor (subsampling factor; integer >= 1)
              type (L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,
                    L_STANDARD_DEVIATION, L_VARIANCE)
              &value (<return> pixel value corresponding to input rank)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Simple function to get average statistical values of an image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageValue(*args)
    




class pix1(object):
    """  pix1.c

    The pixN.c {N = 1,2,3,4,5} files are sorted by the type of operation.
    The primary functions in these files are:

        pix1.c: constructors, destructors and field accessors
        pix2.c: pixel poking of image, pad and border pixels
        pix3.c: masking and logical ops, counting, mirrored tiling
        pix4.c: histograms, statistics, fg/bg estimation
        pix5.c: property measurements, rectangle extraction


    This file has the basic constructors, destructors and field accessors

    Pix memory management (allows custom allocator and deallocator)
          static void  *pix_malloc()
          static void   pix_free()
          void          setPixMemoryManager()

    Pix creation
          PIX          *pixCreate()
          PIX          *pixCreateNoInit()
          PIX          *pixCreateTemplate()
          PIX          *pixCreateTemplateNoInit()
          PIX          *pixCreateHeader()
          PIX          *pixClone()

    Pix destruction
          void          pixDestroy()
          static void   pixFree()

    Pix copy
          PIX          *pixCopy()
          l_int32       pixResizeImageData()
          l_int32       pixCopyColormap()
          l_int32       pixSizesEqual()
          l_int32       pixTransferAllData()
          l_int32       pixSwapAndDestroy()

    Pix accessors
          l_int32       pixGetWidth()
          l_int32       pixSetWidth()
          l_int32       pixGetHeight()
          l_int32       pixSetHeight()
          l_int32       pixGetDepth()
          l_int32       pixSetDepth()
          l_int32       pixGetDimensions()
          l_int32       pixSetDimensions()
          l_int32       pixCopyDimensions()
          l_int32       pixGetSpp()
          l_int32       pixSetSpp()
          l_int32       pixCopySpp()
          l_int32       pixGetWpl()
          l_int32       pixSetWpl()
          l_int32       pixGetRefcount()
          l_int32       pixChangeRefcount()
          l_uint32      pixGetXRes()
          l_int32       pixSetXRes()
          l_uint32      pixGetYRes()
          l_int32       pixSetYRes()
          l_int32       pixGetResolution()
          l_int32       pixSetResolution()
          l_int32       pixCopyResolution()
          l_int32       pixScaleResolution()
          l_int32       pixGetInputFormat()
          l_int32       pixSetInputFormat()
          l_int32       pixCopyInputFormat()
          char         *pixGetText()
          l_int32       pixSetText()
          l_int32       pixAddText()
          l_int32       pixCopyText()
          PIXCMAP      *pixGetColormap()
          l_int32       pixSetColormap()
          l_int32       pixDestroyColormap()
          l_uint32     *pixGetData()
          l_int32       pixSetData()
          l_uint32     *pixExtractData()
          l_int32       pixFreeData()

    Pix line ptrs
          void        **pixGetLinePtrs()

    Pix debug
          l_int32       pixPrintStreamInfo()


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Important notes on direct management of pix image data
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  Custom allocator and deallocator
  --------------------------------

  At the lowest level, you can specify the function that does the
  allocation and deallocation of the data field in the pix.
  By default, this is malloc and free.  However, by calling
  setPixMemoryManager(), custom functions can be substituted.
  When using this, keep two things in mind:

   (1) Call setPixMemoryManager() before any pix have been allocated
   (2) Destroy all pix as usual, in order to prevent leaks.

  In pixalloc.c, we provide an example custom allocator and deallocator.
  To use it, you must call pmsCreate() before any pix have been allocated
  and pmsDestroy() at the end after all pix have been destroyed.


  Direct manipulation of the pix data field
  -----------------------------------------

  Memory management of the (image) data field in the pix is
  handled differently from that in the colormap or text fields.
  For colormap and text, the functions pixSetColormap() and
  pixSetText() remove the existing heap data and insert the
  new data.  For the image data, pixSetData() just reassigns the
  data field; any existing data will be lost if there isn't
  another handle for it.

  Why is pixSetData() limited in this way?  Because the image
  data can be very large, we need flexible ways to handle it,
  particularly when you want to re-use the data in a different
  context without making a copy.  Here are some different
  things you might want to do:

  (1) Use pixCopy(pixd, pixs) where pixd is not the same size
      as pixs.  This will remove the data in pixd, allocate a
      new data field in pixd, and copy the data from pixs, leaving
      pixs unchanged.

  (2) Use pixTransferAllData(pixd, &pixs, ...) to transfer the
      data from pixs to pixd without making a copy of it.  If
      pixs is not cloned, this will do the transfer and destroy pixs.
      But if the refcount of pixs is greater than 1, it just copies
      the data and decrements the ref count.

  (3) Use pixSwapAndDestroy(pixd, &pixs) to replace pixs by an
      existing pixd.  This is similar to pixTransferAllData(), but
      simpler, in that it never makes any copies and if pixs is
      cloned, the other references are not changed by this operation.

  (4) Use pixExtractData() to extract the image data from the pix
      without copying if possible.  This could be used, for example,
      to convert from a pix to some other data structure with minimal
      heap allocation.  After the data is extracated, the pixels can
      be munged and used in another context.  However, the danger
      here is that the pix might have a refcount > 1, in which case
      a copy of the data must be made and the input pix left unchanged.
      If there are no clones, the image data can be extracted without
      a copy, and the data ptr in the pix must be nulled before
      destroying it because the pix will no longer 'own' the data.

  We have provided accessors and functions here that should be
  sufficient so that you can do anything you want without
  explicitly referencing any of the pix member fields.

  However, to avoid memory smashes and leaks when doing special operations
  on the pix data field, look carefully at the behavior of the image
  data accessors and keep in mind that when you invoke pixDestroy(),
  the pix considers itself the owner of all its heap data.

"""
    
    try:
        leptonica.pixCopySpp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopySpp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCopySpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopySpp(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixCopySpp()

      Input:  pixd
              pixs
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopySpp(*args)
    
    

    try:
        leptonica.pixExtractData.argtypes = [ctypes.c_void_p]
        leptonica.pixExtractData.restype = ctypes.POINTER(ctypes.c_uint32)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractData(*args):
        """
        ('PIX', '*pixs')       
  pixExtractData()

  Notes:
      (1) This extracts the pix image data for use in another context.
          The caller still needs to use pixDestroy() on the input pix.
      (2) If refcount == 1, the data is extracted and the
          pix->data ptr is set to NULL.
      (3) If refcount > 1, this simply returns a copy of the data,
          using the pix allocator, and leaving the input pix unchanged.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractData(*args)
    
    

    try:
        leptonica.pixCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreate(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       
  pixCreate()

      Input:  width, height, depth
      Return: pixd (with data allocated and initialized to 0),
                    or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreate(*args)
    
    

    try:
        leptonica.pixGetResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetResolution.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetResolution(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       
  pixGetResolution()

      Input:  pix
              &xres, &yres (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetResolution(*args)
    
    

    try:
        leptonica.pixGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetDimensions(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
  pixGetDimensions()

      Input:  pix
              &w, &h, &d (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetDimensions(*args)
    
    

    try:
        leptonica.pixSwapAndDestroy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSwapAndDestroy.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSwapAndDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSwapAndDestroy(*args):
        """
        ('PIX', '**ppixd')       
('PIX', '**ppixs')       
  pixSwapAndDestroy()

      Input:  &pixd (<optional, return> input pixd can be null,
                     and it must be different from pixs)
              &pixs (will be nulled after the swap)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Simple operation to change the handle name safely.
          After this operation, the original image in pixd has
          been destroyed, pixd points to what was pixs, and
          the input pixs ptr has been nulled.
      (2) This works safely whether or not pixs and pixd are cloned.
          If pixs is cloned, the other handles still point to
          the original image, with the ref count reduced by 1.
      (3) Usage example:
            Pix *pix1 = pixRead("...");
            Pix *pix2 = function(pix1, ...);
            pixSwapAndDestroy(&pix1, &pix2);
            pixDestroy(&pix1);  // holds what was in pix2
          Example with clones ([] shows ref count of image generated
                               by the function):
            Pix *pixs = pixRead("...");
            Pix *pix1 = pixClone(pixs);
            Pix *pix2 = function(pix1, ...);   [1]
            Pix *pix3 = pixClone(pix2);   [1] --> [2]
            pixSwapAndDestroy(&pix1, &pix2);
            pixDestroy(&pixs);  // still holds read image
            pixDestroy(&pix1);  // holds what was in pix2  [2] --> [1]
            pixDestroy(&pix3);  // holds what was in pix2  [1] --> [0]


        """
        args = _convert_params(*args)
        
        return leptonica.pixSwapAndDestroy(*args)
    
    

    try:
        leptonica.pixCreateNoInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreateNoInit.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreateNoInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateNoInit(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       
  pixCreateNoInit()

      Input:  width, height, depth
      Return: pixd (with data allocated but not initialized),
                    or null on error

  Notes:
      (1) Must set pad bits to avoid reading unitialized data, because
          some optimized routines (e.g., pixConnComp()) read from pad bits.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateNoInit(*args)
    
    

    try:
        leptonica.pixFreeData.argtypes = [ctypes.c_void_p]
        leptonica.pixFreeData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFreeData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFreeData(*args):
        """
        ('PIX', '*pix')       
  pixFreeData()

  Notes:
      (1) This frees the data and sets the pix data ptr to null.
          It should be used before pixSetData() in the situation where
          you want to free any existing data before doing
          a subsequent assignment with pixSetData().


        """
        args = _convert_params(*args)
        
        return leptonica.pixFreeData(*args)
    
    

    try:
        leptonica.pixCreateTemplate.argtypes = [ctypes.c_void_p]
        leptonica.pixCreateTemplate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreateTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateTemplate(*args):
        """
        ('PIX', '*pixs')       
  pixCreateTemplate()

      Input:  pixs
      Return: pixd, or null on error

  Notes:
      (1) Makes a Pix of the same size as the input Pix, with the
          data array allocated and initialized to 0.
      (2) Copies the other fields, including colormap if it exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateTemplate(*args)
    
    

    try:
        leptonica.pixCreateTemplateNoInit.argtypes = [ctypes.c_void_p]
        leptonica.pixCreateTemplateNoInit.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreateTemplateNoInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateTemplateNoInit(*args):
        """
        ('PIX', '*pixs')       
  pixCreateTemplateNoInit()

      Input:  pixs
      Return: pixd, or null on error

  Notes:
      (1) Makes a Pix of the same size as the input Pix, with
          the data array allocated but not initialized to 0.
      (2) Copies the other fields, including colormap if it exists.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateTemplateNoInit(*args)
    
    

    try:
        leptonica.pixCreateHeader.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreateHeader.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreateHeader not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateHeader(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       
  pixCreateHeader()

      Input:  width, height, depth
      Return: pixd (with no data allocated), or null on error

  Notes:
      (1) It is assumed that all 32 bit pix have 3 spp.  If there is
          a valid alpha channel, this will be set to 4 spp later.
      (2) If the number of bytes to be allocated is larger than the
          maximum value in an int32, we can get overflow, resulting
          in a smaller amount of memory actually being allocated.
          Later, an attempt to access memory that wasn't allocated will
          cause a crash.  So to avoid crashing a program (or worse)
          with bad (or malicious) input, this is where we limit the
          requested allocation of image data in a typesafe way.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateHeader(*args)
    
    

    try:
        leptonica.pixDestroyColormap.argtypes = [ctypes.c_void_p]
        leptonica.pixDestroyColormap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixDestroyColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDestroyColormap(*args):
        """
        ('PIX', '*pix')       
  pixDestroyColormap()

      Input:  pix
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixDestroyColormap(*args)
    
    

    try:
        leptonica.pixSetResolution.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetResolution.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetResolution(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'xres')       
('l_int32', 'yres')       
  pixSetResolution()

      Input:  pix
              xres, yres (use 0 to skip the setting for either of these)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetResolution(*args)
    
    

    try:
        leptonica.pixSetText.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetText.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetText(*args):
        """
        ('PIX', '*pix')       
('const char', '*textstring')       
  pixSetText()

      Input:  pix
              textstring (can be null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This removes any existing textstring and puts a copy of
          the input textstring there.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetText(*args)
    
    

    try:
        leptonica.pixSetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetDimensions(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'd')       
  pixSetDimensions()

      Input:  pix
              w, h, d (use 0 to skip the setting for any of these)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetDimensions(*args)
    
    

    try:
        leptonica.pixGetText.argtypes = [ctypes.c_void_p]
        leptonica.pixGetText.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function pixGetText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetText(*args):
        """
        ('PIX', '*pix')       
  pixGetText()

      Input:  pix
      Return: ptr to existing text string

  Notes:
      (1) The text string belongs to the pix.  The caller must
          NOT free it!


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetText(*args)
    
    

    try:
        leptonica.pixDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDestroy(*args):
        """
        ('PIX', '**ppix')       
  pixDestroy()

      Input:  &pix <will be nulled>
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the pix.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDestroy(*args)
    
    

    try:
        leptonica.pixCopyColormap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopyColormap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCopyColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyColormap(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixCopyColormap()

      Input:  src and dest Pix
      Return: 0 if OK, 1 on error

  Notes:
      (1) This always destroys any colormap in pixd (except if
          the operation is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyColormap(*args)
    
    

    try:
        leptonica.pixSizesEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSizesEqual.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSizesEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSizesEqual(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
  pixSizesEqual()

      Input:  two pix
      Return: 1 if the two pix have same {h, w, d}; 0 otherwise.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSizesEqual(*args)
    
    

    try:
        leptonica.pixGetData.argtypes = [ctypes.c_void_p]
        leptonica.pixGetData.restype = ctypes.POINTER(ctypes.c_uint32)
    except AttributeError:
        os.stderr.write("Warning - function pixGetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetData(*args):
        """
        ('PIX', '*pix')       
  pixGetData()

  Notes:
      (1) This gives a new handle for the data.  The data is still
          owned by the pix, so do not call FREE() on it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetData(*args)
    
    

    try:
        leptonica.pixClone.argtypes = [ctypes.c_void_p]
        leptonica.pixClone.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClone(*args):
        """
        ('PIX', '*pixs')       
  pixClone()

      Input:  pix
      Return: same pix (ptr), or null on error

  Notes:
      (1) A "clone" is simply a handle (ptr) to an existing pix.
          It is implemented because (a) images can be large and
          hence expensive to copy, and (b) extra handles to a data
          structure need to be made with a simple policy to avoid
          both double frees and memory leaks.  Pix are reference
          counted.  The side effect of pixClone() is an increase
          by 1 in the ref count.
      (2) The protocol to be used is:
          (a) Whenever you want a new handle to an existing image,
              call pixClone(), which just bumps a ref count.
          (b) Always call pixDestroy() on all handles.  This
              decrements the ref count, nulls the handle, and
              only destroys the pix when pixDestroy() has been
              called on all handles.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClone(*args)
    
    

    try:
        leptonica.pixSetColormap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetColormap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetColormap(*args):
        """
        ('PIX', '*pix')       
('PIXCMAP', '*colormap')       
  pixSetColormap()

      Input:  pix
              colormap (to be assigned)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) Unlike with the pix data field, pixSetColormap() destroys
          any existing colormap before assigning the new one.
          Because colormaps are not ref counted, it is important that
          the new colormap does not belong to any other pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetColormap(*args)
    
    

    try:
        leptonica.pixSetData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetData(*args):
        """
        ('PIX', '*pix')       
('l_uint32', '*data')       
  pixSetData()

  Notes:
      (1) This does not free any existing data.  To free existing
          data, use pixFreeData() before pixSetData().


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetData(*args)
    
    

    try:
        leptonica.pixGetLinePtrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetLinePtrs.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))
    except AttributeError:
        os.stderr.write("Warning - function pixGetLinePtrs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetLinePtrs(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*psize')       
  pixGetLinePtrs()

      Input:  pix
              &size (<optional return> array size, which is the pix height)
      Return: array of line ptrs, or null on error

  Notes:
      (1) This is intended to be used for fast random pixel access.
          For example, for an 8 bpp image,
              val = GET_DATA_BYTE(lines8[i], j);
          is equivalent to, but much faster than,
              pixGetPixel(pix, j, i, &val);
      (2) How much faster?  For 1 bpp, it's from 6 to 10x faster.
          For 8 bpp, it's an amazing 30x faster.  So if you are
          doing random access over a substantial part of the image,
          use this line ptr array.
      (3) When random access is used in conjunction with a stack,
          queue or heap, the overall computation time depends on
          the operations performed on each struct that is popped
          or pushed, and whether we are using a priority queue (O(logn))
          or a queue or stack (O(1)).  For example, for maze search,
          the overall ratio of time for line ptrs vs. pixGet/Set* is
             Maze type     Type                   Time ratio
               binary      queue                     0.4
               gray        heap (priority queue)     0.6
      (4) Because this returns a void** and the accessors take void*,
          the compiler cannot check the pointer types.  It is
          strongly recommended that you adopt a naming scheme for
          the returned ptr arrays that indicates the pixel depth.
          (This follows the original intent of Simonyi's "Hungarian"
          application notation, where naming is used proactively
          to make errors visibly obvious.)  By doing this, you can
          tell by inspection if the correct accessor is used.
          For example, for an 8 bpp pixg:
              void **lineg8 = pixGetLinePtrs(pixg, NULL);
              val = GET_DATA_BYTE(lineg8[i], j);  // fast access; BYTE, 8
              ...
              FREE(lineg8);  // don't forget this
      (5) These are convenient for accessing bytes sequentially in an
          8 bpp grayscale image.  People who write image processing code
          on 8 bpp images are accustomed to grabbing pixels directly out
          of the raster array.  Note that for little endians, you first
          need to reverse the byte order in each 32-bit word.
          Here's a typical usage pattern:
              pixEndianByteSwap(pix);   // always safe; no-op on big-endians
              l_uint8 **lineptrs = (l_uint8 **)pixGetLinePtrs(pix, NULL);
              pixGetDimensions(pix, &w, &h, NULL);
              for (i = 0; i < h; i++) {
                  l_uint8 *line = lineptrs[i];
                  for (j = 0; j < w; j++) {
                      val = line[j];
                      ...
                  }
              }
              pixEndianByteSwap(pix);  // restore big-endian order
              FREE(lineptrs);
          This can be done even more simply as follows:
              l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);
              for (i = 0; i < h; i++) {
                  l_uint8 *line = lineptrs[i];
                  for (j = 0; j < w; j++) {
                      val = line[j];
                      ...
                  }
              }
              pixCleanupByteProcessing(pix, lineptrs);


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetLinePtrs(*args)
    
    

    try:
        leptonica.pixTransferAllData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTransferAllData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTransferAllData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTransferAllData(*args):
        """
        ('PIX', '*pixd')       
('PIX', '**ppixs')       
('l_int32', 'copytext')       
('l_int32', 'copyformat')       
  pixTransferAllData()

      Input:  pixd (must be different from pixs)
              &pixs (will be nulled if refcount goes to 0)
              copytext (1 to copy the text field; 0 to skip)
              copyformat (1 to copy the informat field; 0 to skip)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a complete data transfer from pixs to pixd,
          followed by the destruction of pixs (refcount permitting).
      (2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,
          the data in pixs is copied (rather than transferred) to pixd.
      (3) This operation, like all others with a pre-existing pixd,
          will side-effect any existing clones of pixd.  The pixd
          refcount does not change.
      (4) When might you use this?  Suppose you have an in-place Pix
          function (returning void) with the typical signature:
              void function-inplace(PIX *pix, ...)
          where "..." are non-pointer input parameters, and suppose
          further that you sometimes want to return an arbitrary Pix
          in place of the input Pix.  There are two ways you can do this:
          (a) The straightforward way is to change the function
              signature to take the address of the Pix ptr:
                  void function-inplace(PIX **ppix, ...) {
                      PIX *pixt = function-makenew(*ppix);
                      pixDestroy(ppix);
                      *ppix = pixt;
                      return;
                  }
              Here, the input and returned pix are different, as viewed
              by the calling function, and the inplace function is
              expected to destroy the input pix to avoid a memory leak.
          (b) Keep the signature the same and use pixTransferAllData()
              to return the new Pix in the input Pix struct:
                  void function-inplace(PIX *pix, ...) {
                      PIX *pixt = function-makenew(pix);
                      pixTransferAllData(pix, &pixt, 0, 0);
                               // pixDestroy() is called on pixt
                      return;
                  }
              Here, the input and returned pix are the same, as viewed
              by the calling function, and the inplace function must
              never destroy the input pix, because the calling function
              maintains an unchanged handle to it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTransferAllData(*args)
    
    

    try:
        leptonica.pixResizeImageData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixResizeImageData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixResizeImageData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixResizeImageData(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixResizeImageData()

      Input:  pixd (gets new uninitialized buffer for image data)
              pixs (determines the size of the buffer; not changed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This removes any existing image data from pixd and
          allocates an uninitialized buffer that will hold the
          amount of image data that is in pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixResizeImageData(*args)
    
    

    try:
        leptonica.pixCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopy.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopy(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixCopy()

      Input:  pixd (<optional>; can be null, or equal to pixs,
                    or different from pixs)
              pixs
      Return: pixd, or null on error

  Notes:
      (1) There are three cases:
            (a) pixd == null  (makes a new pix; refcount = 1)
            (b) pixd == pixs  (no-op)
            (c) pixd != pixs  (data copy; no change in refcount)
          If the refcount of pixd > 1, case (c) will side-effect
          these handles.
      (2) The general pattern of use is:
             pixd = pixCopy(pixd, pixs);
          This will work for all three cases.
          For clarity when the case is known, you can use:
            (a) pixd = pixCopy(NULL, pixs);
            (c) pixCopy(pixd, pixs);
      (3) For case (c), we check if pixs and pixd are the same
          size (w,h,d).  If so, the data is copied directly.
          Otherwise, the data is reallocated to the correct size
          and the copy proceeds.  The refcount of pixd is unchanged.
      (4) This operation, like all others that may involve a pre-existing
          pixd, will side-effect any existing clones of pixd.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopy(*args)
    
    

    try:
        leptonica.pixAddText.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddText.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAddText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddText(*args):
        """
        ('PIX', '*pix')       
('const char', '*textstring')       
  pixAddText()

      Input:  pix
              textstring
      Return: 0 if OK, 1 on error

  Notes:
      (1) This adds the new textstring to any existing text.
      (2) Either or both the existing text and the new text
          string can be null.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddText(*args)
    
    

    try:
        leptonica.pixPrintStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixPrintStreamInfo.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixPrintStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPrintStreamInfo(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('const char', '*text')       
  pixPrintStreamInfo()

      Input:  fp (file stream)
              pix
              text (<optional> identifying string; can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixPrintStreamInfo(*args)
    
    

    try:
        leptonica.pixCopyDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopyDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCopyDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyDimensions(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixCopyDimensions()

      Input:  pixd
              pixd
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyDimensions(*args)
    




class pix3(object):
    """  pix3.c

    This file has these operations:

      (1) Mask-directed operations
      (2) Full-image bit-logical operations
      (3) Foreground pixel counting operations on 1 bpp images
      (4) Average and variance of pixel values
      (5) Mirrored tiling of a smaller image


    Masked operations
           l_int32     pixSetMasked()
           l_int32     pixSetMaskedGeneral()
           l_int32     pixCombineMasked()
           l_int32     pixCombineMaskedGeneral()
           l_int32     pixPaintThroughMask()
           PIX        *pixPaintSelfThroughMask()
           PIX        *pixMakeMaskFromLUT()
           PIX        *pixSetUnderTransparency()

    One and two-image boolean operations on arbitrary depth images
           PIX        *pixInvert()
           PIX        *pixOr()
           PIX        *pixAnd()
           PIX        *pixXor()
           PIX        *pixSubtract()

    Foreground pixel counting in 1 bpp images
           l_int32     pixZero()
           l_int32     pixForegroundFraction()
           NUMA       *pixaCountPixels()
           l_int32     pixCountPixels()
           NUMA       *pixCountByRow()
           NUMA       *pixCountByColumn()
           NUMA       *pixCountPixelsByRow()
           NUMA       *pixCountPixelsByColumn()
           l_int32     pixCountPixelsInRow()
           NUMA       *pixGetMomentByColumn()
           l_int32     pixThresholdPixelSum()
           l_int32    *makePixelSumTab8()
           l_int32    *makePixelCentroidTab8()

    Average of pixel values in gray images
           NUMA       *pixAverageByRow()
           NUMA       *pixAverageByColumn()
           l_int32     pixAverageInRect()

    Variance of pixel values in gray images
           NUMA       *pixVarianceByRow()
           NUMA       *pixVarianceByColumn()
           l_int32     pixVarianceInRect()

    Average of absolute value of pixel differences in gray images
           NUMA       *pixAbsDiffByRow()
           NUMA       *pixAbsDiffByColumn()
           l_int32     pixAbsDiffInRect()
           l_int32     pixAbsDiffOnLine()

    Count of pixels with specific value            *
           l_int32     pixCountArbInRect()

    Mirrored tiling
           PIX        *pixMirroredTiling()

    Static helper function
           static l_int32  findTilePatchCenter()

"""
    
    try:
        leptonica.pixAbsDiffByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAbsDiffByColumn.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAbsDiffByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixAbsDiffByColumn()

      Input:  pix (8 bpp; no colormap)
              box (<optional> clipping box for region; can be null)
      Return: na of abs val pixel difference averages by column,
              or null on error

  Notes:
      (1) This is an average over differences of adjacent pixels along
          each column.
      (2) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffByColumn(*args)
    
    

    try:
        leptonica.pixSubtract.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSubtract.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSubtract not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSubtract(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixSubtract()

      Input:  pixd  (<optional>; this can be null, equal to pixs1,
                     equal to pixs2, or different from both pixs1 and pixs2)
              pixs1 (can be == pixd)
              pixs2 (can be == pixd)
      Return: pixd always

  Notes:
      (1) This gives the set subtraction of two images with equal depth,
          aligning them to the the UL corner.  pixs1 and pixs2
          need not have the same width and height.
      (2) Source pixs2 is always subtracted from source pixs1.
          The result is
                  pixs1 \ pixs2 = pixs1 & (~pixs2)
      (3) There are 4 cases:
            (a) pixd == null,   (src1 - src2) --> new pixd
            (b) pixd == pixs1,  (src1 - src2) --> src1  (in-place)
            (c) pixd == pixs2,  (src1 - src2) --> src2  (in-place)
            (d) pixd != pixs1 && pixd != pixs2),
                                 (src1 - src2) --> input pixd
      (4) For clarity, if the case is known, use these patterns:
            (a) pixd = pixSubtract(NULL, pixs1, pixs2);
            (b) pixSubtract(pixs1, pixs1, pixs2);
            (c) pixSubtract(pixs2, pixs1, pixs2);
            (d) pixSubtract(pixd, pixs1, pixs2);
      (5) The size of the result is determined by pixs1.
      (6) The depths of pixs1 and pixs2 must be equal.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSubtract(*args)
    
    

    try:
        leptonica.pixCountPixelsByColumn.argtypes = [ctypes.c_void_p]
        leptonica.pixCountPixelsByColumn.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCountPixelsByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsByColumn(*args):
        """
        ('PIX', '*pix')       
  pixCountPixelsByColumn()

      Input:  pix (1 bpp)
      Return: na of counts in each column, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsByColumn(*args)
    
    

    try:
        leptonica.pixVarianceInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixVarianceInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_float32', '*prootvar')       
  pixVarianceInRect()

      Input:  pix (1, 2, 4, 8 bpp; not cmapped)
              box (<optional> if null, use entire image)
              &rootvar (<return> sqrt variance of pixel values in region)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceInRect(*args)
    
    

    try:
        leptonica.pixAverageByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAverageByColumn.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAverageByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'type')       
  pixAverageByColumn()

      Input:  pix (8 or 16 bpp; no colormap)
              box (<optional> clipping box for sum; can be null)
              type (L_WHITE_IS_MAX, L_BLACK_IS_MAX)
      Return: na of pixel averages by column, or null on error

  Notes:
      (1) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.
      (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
          value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageByColumn(*args)
    
    

    try:
        leptonica.pixSetUnderTransparency.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSetUnderTransparency.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSetUnderTransparency not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetUnderTransparency(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'val')       
('l_int32', 'debug')       
  pixSetUnderTransparency()

      Input:  pixs (32 bpp rgba)
              val (32 bit unsigned color to use where alpha == 0)
              debug (displays layers of pixs)
      Return: pixd (32 bpp rgba), or null on error

  Notes:
      (1) This sets the r, g and b components under every fully
          transparent alpha component to @val.  The alpha components
          are unchanged.
      (2) Full transparency is denoted by alpha == 0.  Setting
          all pixels to a constant @val where alpha is transparent
          can improve compressibility by reducing the entropy.
      (3) The visual result depends on how the image is displayed.
          (a) For display devices that respect the use of the alpha
              layer, this will not affect the appearance.
          (b) For typical leptonica operations, alpha is ignored,
              so there will be a change in appearance because this
              resets the rgb values in the fully transparent region.
      (4) pixRead() and pixWrite() will, by default, read and write
          4-component (rgba) pix in png format.  To ignore the alpha
          component after reading, or omit it on writing, pixSetSpp(..., 3).
      (5) Here are some examples:
          * To convert all fully transparent pixels in a 4 component
            (rgba) png file to white:
              pixs = pixRead(<infile>);
              pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0);
          * To write pixd with the alpha component:
              pixWrite(<outfile>, pixd, IFF_PNG);
          * To write and rgba image without the alpha component, first do:
              pixSetSpp(pixd, 3);
            If you later want to use the alpha, spp must be reset to 4.
          * (fancier) To remove the alpha by blending the image over
            a white background:
              pixRemoveAlpha()
            This changes all pixel values where the alpha component is
            not opaque (255).
      (6) Caution.  rgb images in leptonica typically have value 0 in
          the alpha channel, which is fully transparent.  If spp for
          such an image were changed from 3 to 4, the image becomes
          fully transparent, and this function will set each pixel to @val.
          If you really want to set every pixel to the same value,
          use pixSetAllArbitrary().
      (7) This is useful for compressing an RGBA image where the part
          of the image that is fully transparent is random junk; compression
          is typically improved by setting that region to a constant.
          For rendering as a 3 component RGB image over a uniform
          background of arbitrary color, use pixAlphaBlendUniform().


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetUnderTransparency(*args)
    
    

    try:
        leptonica.pixThresholdPixelSum.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdPixelSum.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdPixelSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdPixelSum(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'thresh')       
('l_int32', '*pabove')       
('l_int32', '*tab8')       
  pixThresholdPixelSum()

      Input:  pix (1 bpp)
              threshold
              &above (<return> 1 if above threshold;
                               0 if equal to or less than threshold)
              tab8  (<optional> 8-bit pixel lookup table)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This sums the ON pixels and returns immediately if the count
          goes above threshold.  It is therefore more efficient
          for matching images (by running this function on the xor of
          the 2 images) than using pixCountPixels(), which counts all
          pixels before returning.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdPixelSum(*args)
    
    

    try:
        leptonica.pixCountPixelsInRow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixelsInRow.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCountPixelsInRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsInRow(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'row')       
('l_int32', '*pcount')       
('l_int32', '*tab8')       
  pixCountPixelsInRow()

      Input:  pix (1 bpp)
              row number
              &count (<return> sum of ON pixels in raster line)
              tab8  (<optional> 8-bit pixel lookup table)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsInRow(*args)
    
    

    try:
        leptonica.makePixelCentroidTab8.argtypes = []
        leptonica.makePixelCentroidTab8.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function makePixelCentroidTab8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePixelCentroidTab8(*args):
        """
               
  makePixelCentroidTab8()

      Input:  void
      Return: table of 256 l_int32, or null on error

  Notes:
      (1) This table of integers gives the centroid weight of the 1 bits
          in the 8 bit index.  In other words, if sumtab is obtained by
          makePixelSumTab8, and centroidtab is obtained by
          makePixelCentroidTab8, then, for 1 <= i <= 255,
          centroidtab[i] / (float)sumtab[i]
          is the centroid of the 1 bits in the 8-bit index i, where the
          MSB is considered to have position 0 and the LSB is considered
          to have position 7.


        """
        args = _convert_params(*args)
        
        return leptonica.makePixelCentroidTab8(*args)
    
    

    try:
        leptonica.pixCountPixelsByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixelsByRow.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCountPixelsByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsByRow(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*tab8')       
  pixCountPixelsByRow()

      Input:  pix (1 bpp)
              tab8  (<optional> 8-bit pixel lookup table)
      Return: na of counts, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsByRow(*args)
    
    

    try:
        leptonica.pixVarianceByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceByColumn.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVarianceByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixVarianceByColumn()

      Input:  pix (8 or 16 bpp; no colormap)
              box (<optional> clipping box for variance; can be null)
      Return: na of rmsdev by column, or null on error

  Notes:
      (1) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.
      (2) We are actually computing the RMS deviation in each row.
          This is the square root of the variance.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceByColumn(*args)
    
    

    try:
        leptonica.pixaCountPixels.argtypes = [ctypes.c_void_p]
        leptonica.pixaCountPixels.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixaCountPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCountPixels(*args):
        """
        ('PIXA', '*pixa')       
  pixaCountPixels()

      Input:  pixa (array of 1 bpp pix)
      Return: na of ON pixels in each pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCountPixels(*args)
    
    

    try:
        leptonica.pixSetMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixSetMasked.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_uint32', 'val')       
  pixSetMasked()

      Input:  pixd (1, 2, 4, 8, 16 or 32 bpp; or colormapped)
              pixm (<optional> 1 bpp mask; no operation if NULL)
              val (value to set at each masked pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) In-place operation.
      (2) NOTE: For cmapped images, this calls pixSetMaskedCmap().
          @val must be the 32-bit color representation of the RGB pixel.
          It is not the index into the colormap!
      (2) If pixm == NULL, a warning is given.
      (3) This is an implicitly aligned operation, where the UL
          corners of pixd and pixm coincide.  A warning is
          issued if the two image sizes differ significantly,
          but the operation proceeds.
      (4) Each pixel in pixd that co-locates with an ON pixel
          in pixm is set to the specified input value.
          Other pixels in pixd are not changed.
      (5) You can visualize this as painting the color through
          the mask, as a stencil.
      (6) If you do not want to have the UL corners aligned,
          use the function pixSetMaskedGeneral(), which requires
          you to input the UL corner of pixm relative to pixd.
      (7) Implementation details: see comments in pixPaintThroughMask()
          for when we use rasterop to do the painting.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMasked(*args)
    
    

    try:
        leptonica.pixVarianceByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceByRow.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixVarianceByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixVarianceByRow()

      Input:  pix (8 or 16 bpp; no colormap)
              box (<optional> clipping box for variance; can be null)
      Return: na of rmsdev by row, or null on error

  Notes:
      (1) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.
      (2) We are actually computing the RMS deviation in each row.
          This is the square root of the variance.


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceByRow(*args)
    
    

    try:
        leptonica.pixOr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOr.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOr(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixOr()

      Input:  pixd  (<optional>; this can be null, equal to pixs1,
                     different from pixs1)
              pixs1 (can be == pixd)
              pixs2 (must be != pixd)
      Return: pixd always

  Notes:
      (1) This gives the union of two images with equal depth,
          aligning them to the the UL corner.  pixs1 and pixs2
          need not have the same width and height.
      (2) There are 3 cases:
            (a) pixd == null,   (src1 | src2) --> new pixd
            (b) pixd == pixs1,  (src1 | src2) --> src1  (in-place)
            (c) pixd != pixs1,  (src1 | src2) --> input pixd
      (3) For clarity, if the case is known, use these patterns:
            (a) pixd = pixOr(NULL, pixs1, pixs2);
            (b) pixOr(pixs1, pixs1, pixs2);
            (c) pixOr(pixd, pixs1, pixs2);
      (4) The size of the result is determined by pixs1.
      (5) The depths of pixs1 and pixs2 must be equal.
      (6) Note carefully that the order of pixs1 and pixs2 only matters
          for the in-place case.  For in-place, you must have
          pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
          result: the copy puts pixs1 image data in pixs2, and
          the rasterop is then between pixs2 and pixs2 (a no-op).


        """
        args = _convert_params(*args)
        
        return leptonica.pixOr(*args)
    
    

    try:
        leptonica.pixZero.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixZero.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixZero not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixZero(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pempty')       
  pixZero()

      Input:  pix (all depths; colormap OK)
              &empty  (<return> 1 if all bits in image data field are 0;
                       0 otherwise)
      Return: 0 if OK; 1 on error

  Notes:
      (1) For a binary image, if there are no fg (black) pixels, empty = 1.
      (2) For a grayscale image, if all pixels are black (0), empty = 1.
      (3) For an RGB image, if all 4 components in every pixel is 0,
          empty = 1.
      (4) For a colormapped image, pixel values are 0.  The colormap
          is ignored.


        """
        args = _convert_params(*args)
        
        return leptonica.pixZero(*args)
    
    

    try:
        leptonica.pixPaintSelfThroughMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixPaintSelfThroughMask.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixPaintSelfThroughMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintSelfThroughMask(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'tilesize')       
('l_int32', 'searchdir')       
  pixPaintSelfThroughMask()

      Input:  pixd (8 bpp gray or 32 bpp rgb; not colormapped)
              pixm (1 bpp mask)
              x, y (origin of pixm relative to pixd; must not be negative)
              tilesize (requested size for tiling)
              searchdir (L_HORIZ, L_VERT)
      Return: 0 if OK; 1 on error

  Notes:
      (1) In-place operation; pixd is changed.
      (2) If pixm == NULL, it's a no-op.
      (3) The mask origin is placed at (x,y) on pixd, and the
          operation is clipped to the intersection of pixd and the
          fg of the mask.
      (4) The tilesize is the the requested size for tiling.  The
          actual size for each c.c. will be bounded by the minimum
          dimension of the c.c. and the distance at which the tile
          center is located.
      (5) searchdir is the direction with respect to the b.b. of each
          mask component, from which the square patch is chosen and
          tiled onto the image, clipped by the mask component.
      (6) Specifically, a mirrored tiling, generated from pixd,
          is used to construct the pixels that are painted onto
          pixd through pixm.


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintSelfThroughMask(*args)
    
    

    try:
        leptonica.pixAbsDiffOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAbsDiffOnLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAbsDiffOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffOnLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_float32', '*pabsdiff')       
  pixAbsDiffOnLine()

      Input:  pix (8 bpp; not cmapped)
              x1, y1 (first point; x1 <= x2, y1 <= y2)
              x2, y2 (first point)
              &absdiff (<return> average of abs diff pixel values on line)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This gives the average over the abs val of differences of
          adjacent pixels values, along a line that is either horizontal
          or vertical.
      (2) If horizontal, require x1 < x2; if vertical, require y1 < y2.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffOnLine(*args)
    
    

    try:
        leptonica.pixAnd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAnd.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAnd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAnd(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixAnd()

      Input:  pixd  (<optional>; this can be null, equal to pixs1,
                     different from pixs1)
              pixs1 (can be == pixd)
              pixs2 (must be != pixd)
      Return: pixd always

  Notes:
      (1) This gives the intersection of two images with equal depth,
          aligning them to the the UL corner.  pixs1 and pixs2
          need not have the same width and height.
      (2) There are 3 cases:
            (a) pixd == null,   (src1 & src2) --> new pixd
            (b) pixd == pixs1,  (src1 & src2) --> src1  (in-place)
            (c) pixd != pixs1,  (src1 & src2) --> input pixd
      (3) For clarity, if the case is known, use these patterns:
            (a) pixd = pixAnd(NULL, pixs1, pixs2);
            (b) pixAnd(pixs1, pixs1, pixs2);
            (c) pixAnd(pixd, pixs1, pixs2);
      (4) The size of the result is determined by pixs1.
      (5) The depths of pixs1 and pixs2 must be equal.
      (6) Note carefully that the order of pixs1 and pixs2 only matters
          for the in-place case.  For in-place, you must have
          pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
          result: the copy puts pixs1 image data in pixs2, and
          the rasterop is then between pixs2 and pixs2 (a no-op).


        """
        args = _convert_params(*args)
        
        return leptonica.pixAnd(*args)
    
    

    try:
        leptonica.pixAbsDiffInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAbsDiffInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAbsDiffInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'dir')       
('l_float32', '*pabsdiff')       
  pixAbsDiffInRect()

      Input:  pix (8 bpp; not cmapped)
              box (<optional> if null, use entire image)
              dir (differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE)
              &absdiff (<return> average of abs diff pixel values in region)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This gives the average over the abs val of differences of
          adjacent pixels values, along either each
             row:     dir == L_HORIZONTAL_LINE
             column:  dir == L_VERTICAL_LINE


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffInRect(*args)
    
    

    try:
        leptonica.pixAverageByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAverageByRow.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAverageByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'type')       
  pixAverageByRow()

      Input:  pix (8 or 16 bpp; no colormap)
              box (<optional> clipping box for sum; can be null)
              type (L_WHITE_IS_MAX, L_BLACK_IS_MAX)
      Return: na of pixel averages by row, or null on error

  Notes:
      (1) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.
      (2) If type == L_BLACK_IS_MAX, black pixels get the maximum
          value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageByRow(*args)
    
    

    try:
        leptonica.pixCountArbInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCountArbInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCountArbInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountArbInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'val')       
('l_int32', 'factor')       
('l_int32', '*pcount')       
  pixCountArbInRect()

      Input:  pixs (8 bpp, or colormapped)
              box (<optional>) over which count is made;
                   use entire image null)
              val (pixel value to count)
              factor (subsampling factor; integer >= 1)
              &count (<return> count; estimate it if factor > 1)
      Return: na (histogram), or null on error

  Notes:
      (1) If pixs is cmapped, @val is compared to the colormap index;
          otherwise, @val is compared to the grayscale value.
      (2) Set the subsampling @factor > 1 to reduce the amount of computation.
          If @factor > 1, multiply the count by @factor * @factor.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountArbInRect(*args)
    
    

    try:
        leptonica.pixMirroredTiling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMirroredTiling.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMirroredTiling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMirroredTiling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixMirroredTiling()

      Input:  pixs (8 or 32 bpp, small tile; to be replicated)
              w, h (dimensions of output pix)
      Return: pixd (usually larger pix, mirror-tiled with pixs),
              or null on error

  Notes:
      (1) This uses mirrored tiling, where each row alternates
          with LR flips and every column alternates with TB
          flips, such that the result is a tiling with identical
          2 x 2 tiles, each of which is composed of these transforms:
                  -----------------
                  | 1    |  LR    |
                  -----------------
                  | TB   |  LR/TB |
                  -----------------


        """
        args = _convert_params(*args)
        
        return leptonica.pixMirroredTiling(*args)
    
    

    try:
        leptonica.pixForegroundFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixForegroundFraction.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixForegroundFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixForegroundFraction(*args):
        """
        ('PIX', '*pix')       
('l_float32', '*pfract')       
  pixForegroundFraction()

      Input:  pix (1 bpp)
              &fract (<return> fraction of ON pixels)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixForegroundFraction(*args)
    
    

    try:
        leptonica.pixMakeMaskFromLUT.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMakeMaskFromLUT.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMakeMaskFromLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeMaskFromLUT(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
  pixMakeMaskFromLUT()

      Input:  pixs (2, 4 or 8 bpp; can be colormapped)
              tab (256-entry LUT; 1 means to write to mask)
      Return: pixd (1 bpp mask), or null on error

  Notes:
      (1) This generates a 1 bpp mask image, where a 1 is written in
          the mask for each pixel in pixs that has a value corresponding
          to a 1 in the LUT.
      (2) The LUT should be of size 256.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeMaskFromLUT(*args)
    
    

    try:
        leptonica.pixPaintThroughMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixPaintThroughMask.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixPaintThroughMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintThroughMask(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', 'val')       
  pixPaintThroughMask()

      Input:  pixd (1, 2, 4, 8, 16 or 32 bpp; or colormapped)
              pixm (<optional> 1 bpp mask)
              x, y (origin of pixm relative to pixd; can be negative)
              val (pixel value to set at each masked pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) In-place operation.  Calls pixSetMaskedCmap() for colormapped
          images.
      (2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate
          number of least significant bits of val.
      (3) If pixm == NULL, it's a no-op.
      (4) The mask origin is placed at (x,y) on pixd, and the
          operation is clipped to the intersection of rectangles.
      (5) For rgb, the components in val are in the canonical locations,
          with red in location COLOR_RED, etc.
      (6) Implementation detail 1:
          For painting with val == 0 or val == maxval, you can use rasterop.
          If val == 0, invert the mask so that it's 0 over the region
          into which you want to write, and use PIX_SRC & PIX_DST to
          clear those pixels.  To write with val = maxval (all 1's),
          use PIX_SRC | PIX_DST to set all bits under the mask.
      (7) Implementation detail 2:
          The rasterop trick can be used for depth > 1 as well.
          For val == 0, generate the mask for depth d from the binary
          mask using
              pixmd = pixUnpackBinary(pixm, d, 1);
          and use pixRasterop() with PIX_MASK.  For val == maxval,
              pixmd = pixUnpackBinary(pixm, d, 0);
          and use pixRasterop() with PIX_PAINT.
          But note that if d == 32 bpp, it is about 3x faster to use
          the general implementation (not pixRasterop()).
      (8) Implementation detail 3:
          It might be expected that the switch in the inner loop will
          cause large branching delays and should be avoided.
          This is not the case, because the entrance is always the
          same and the compiler can correctly predict the jump.


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintThroughMask(*args)
    
    

    try:
        leptonica.pixSetMaskedGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetMaskedGeneral.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetMaskedGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMaskedGeneral(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_uint32', 'val')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixSetMaskedGeneral()

      Input:  pixd (8, 16 or 32 bpp)
              pixm (<optional> 1 bpp mask; no operation if null)
              val (value to set at each masked pixel)
              x, y (location of UL corner of pixm relative to pixd;
                    can be negative)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) Alignment is explicit.  If you want the UL corners of
          the two images to be aligned, use pixSetMasked().
      (3) A typical use would be painting through the foreground
          of a small binary mask pixm, located somewhere on a
          larger pixd.  Other pixels in pixd are not changed.
      (4) You can visualize this as painting the color through
          the mask, as a stencil.
      (5) This uses rasterop to handle clipping and different depths of pixd.
      (6) If pixd has a colormap, you should call pixPaintThroughMask().
      (7) Why is this function here, if pixPaintThroughMask() does the
          same thing, and does it more generally?  I've retained it here
          to show how one can paint through a mask using only full
          image rasterops, rather than pixel peeking in pixm and poking
          in pixd.  It's somewhat baroque, but I found it amusing.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMaskedGeneral(*args)
    
    

    try:
        leptonica.makePixelSumTab8.argtypes = []
        leptonica.makePixelSumTab8.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function makePixelSumTab8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePixelSumTab8(*args):
        """
               
  makePixelSumTab8()

      Input:  void
      Return: table of 256 l_int32, or null on error

  Notes:
      (1) This table of integers gives the number of 1 bits
          in the 8 bit index.


        """
        args = _convert_params(*args)
        
        return leptonica.makePixelSumTab8(*args)
    
    

    try:
        leptonica.pixCombineMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCombineMasked.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCombineMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCombineMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
  pixCombineMasked()

      Input:  pixd (1 bpp, 8 bpp gray or 32 bpp rgb; no cmap)
              pixs (1 bpp, 8 bpp gray or 32 bpp rgb; no cmap)
              pixm (<optional> 1 bpp mask; no operation if NULL)
      Return: 0 if OK; 1 on error

  Notes:
      (1) In-place operation; pixd is changed.
      (2) This sets each pixel in pixd that co-locates with an ON
          pixel in pixm to the corresponding value of pixs.
      (3) pixs and pixd must be the same depth and not colormapped.
      (4) All three input pix are aligned at the UL corner, and the
          operation is clipped to the intersection of all three images.
      (5) If pixm == NULL, it's a no-op.
      (6) Implementation: see notes in pixCombineMaskedGeneral().
          For 8 bpp selective masking, you might guess that it
          would be faster to generate an 8 bpp version of pixm,
          using pixConvert1To8(pixm, 0, 255), and then use a
          general combine operation
               d = (d & ~m) | (s & m)
          on a word-by-word basis.  Not always.  The word-by-word
          combine takes a time that is independent of the mask data.
          If the mask is relatively sparse, the byte-check method
          is actually faster!


        """
        args = _convert_params(*args)
        
        return leptonica.pixCombineMasked(*args)
    
    

    try:
        leptonica.pixXor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixXor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixXor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixXor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
  pixXor()

      Input:  pixd  (<optional>; this can be null, equal to pixs1,
                     different from pixs1)
              pixs1 (can be == pixd)
              pixs2 (must be != pixd)
      Return: pixd always

  Notes:
      (1) This gives the XOR of two images with equal depth,
          aligning them to the the UL corner.  pixs1 and pixs2
          need not have the same width and height.
      (2) There are 3 cases:
            (a) pixd == null,   (src1 ^ src2) --> new pixd
            (b) pixd == pixs1,  (src1 ^ src2) --> src1  (in-place)
            (c) pixd != pixs1,  (src1 ^ src2) --> input pixd
      (3) For clarity, if the case is known, use these patterns:
            (a) pixd = pixXor(NULL, pixs1, pixs2);
            (b) pixXor(pixs1, pixs1, pixs2);
            (c) pixXor(pixd, pixs1, pixs2);
      (4) The size of the result is determined by pixs1.
      (5) The depths of pixs1 and pixs2 must be equal.
      (6) Note carefully that the order of pixs1 and pixs2 only matters
          for the in-place case.  For in-place, you must have
          pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
          result: the copy puts pixs1 image data in pixs2, and
          the rasterop is then between pixs2 and pixs2 (a no-op).


        """
        args = _convert_params(*args)
        
        return leptonica.pixXor(*args)
    
    

    try:
        leptonica.pixAbsDiffByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAbsDiffByRow.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAbsDiffByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixAbsDiffByRow()

      Input:  pix (8 bpp; no colormap)
              box (<optional> clipping box for region; can be null)
      Return: na of abs val pixel difference averages by row, or null on error

  Notes:
      (1) This is an average over differences of adjacent pixels along
          each row.
      (2) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffByRow(*args)
    
    

    try:
        leptonica.pixCountPixels.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixels.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCountPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixels(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pcount')       
('l_int32', '*tab8')       
  pixCountPixels()

      Input:  pix (1 bpp)
              &count (<return> count of ON pixels)
              tab8  (<optional> 8-bit pixel lookup table)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixels(*args)
    
    

    try:
        leptonica.pixCountByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountByRow.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCountByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixCountByRow()

      Input:  pix (1 bpp)
              box (<optional> clipping box for count; can be null)
      Return: na of number of ON pixels by row, or null on error

  Notes:
      (1) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountByRow(*args)
    
    

    try:
        leptonica.pixInvert.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixInvert.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixInvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixInvert(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
  pixInvert()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs
      Return: pixd, or null on error

  Notes:
      (1) This inverts pixs, for all pixel depths.
      (2) There are 3 cases:
           (a) pixd == null,   ~src --> new pixd
           (b) pixd == pixs,   ~src --> src  (in-place)
           (c) pixd != pixs,   ~src --> input pixd
      (3) For clarity, if the case is known, use these patterns:
           (a) pixd = pixInvert(NULL, pixs);
           (b) pixInvert(pixs, pixs);
           (c) pixInvert(pixd, pixs);


        """
        args = _convert_params(*args)
        
        return leptonica.pixInvert(*args)
    
    

    try:
        leptonica.pixAverageInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAverageInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAverageInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_float32', '*pave')       
  pixAverageInRect()

      Input:  pix (1, 2, 4, 8 bpp; not cmapped)
              box (<optional> if null, use entire image)
              &ave (<return> average of pixel values in region)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageInRect(*args)
    
    

    try:
        leptonica.pixGetMomentByColumn.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetMomentByColumn.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetMomentByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetMomentByColumn(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'order')       
  pixGetMomentByColumn()

      Input:  pix (1 bpp)
              order (of moment, either 1 or 2)
      Return: na of first moment of fg pixels, by column, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetMomentByColumn(*args)
    
    

    try:
        leptonica.pixCombineMaskedGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCombineMaskedGeneral.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCombineMaskedGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCombineMaskedGeneral(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixCombineMaskedGeneral()

      Input:  pixd (1 bpp, 8 bpp gray or 32 bpp rgb)
              pixs (1 bpp, 8 bpp gray or 32 bpp rgb)
              pixm (<optional> 1 bpp mask)
              x, y (origin of pixs and pixm relative to pixd; can be negative)
      Return: 0 if OK; 1 on error

  Notes:
      (1) In-place operation; pixd is changed.
      (2) This is a generalized version of pixCombinedMasked(), where
          the source and mask can be placed at the same (arbitrary)
          location relative to pixd.
      (3) pixs and pixd must be the same depth and not colormapped.
      (4) The UL corners of both pixs and pixm are aligned with
          the point (x, y) of pixd, and the operation is clipped to
          the intersection of all three images.
      (5) If pixm == NULL, it's a no-op.
      (6) Implementation.  There are two ways to do these.  In the first,
          we use rasterop, ORing the part of pixs under the mask
          with pixd (which has been appropriately cleared there first).
          In the second, the mask is used one pixel at a time to
          selectively replace pixels of pixd with those of pixs.
          Here, we use rasterop for 1 bpp and pixel-wise replacement
          for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,
          we must first generate an 8 bpp version of the mask.
          The code is simple:

             Pix *pixm8 = pixConvert1To8(NULL, pixm, 0, 255);
             Pix *pixt = pixAnd(NULL, pixs, pixm8);
             pixRasterop(pixd, x, y, wmin, hmin, PIX_DST & PIX_NOT(PIX_SRC),
                         pixm8, 0, 0);
             pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,
                         pixt, 0, 0);
             pixDestroy(&pixt);
             pixDestroy(&pixm8);


        """
        args = _convert_params(*args)
        
        return leptonica.pixCombineMaskedGeneral(*args)
    
    

    try:
        leptonica.pixCountByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountByColumn.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCountByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixCountByColumn()

      Input:  pix (1 bpp)
              box (<optional> clipping box for count; can be null)
      Return: na of number of ON pixels by column, or null on error

  Notes:
      (1) To resample for a bin size different from 1, use
          numaUniformSampling() on the result of this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountByColumn(*args)
    




class pix2(object):
    """  pix2.c

    This file has these basic operations:

      (1) Get and set: individual pixels, full image, rectangular region,
          pad pixels, border pixels, and color components for RGB
      (2) Add and remove border pixels
      (3) Endian byte swaps
      (4) Simple method for byte-processing images (instead of words)

      Pixel poking
           l_int32     pixGetPixel()
           l_int32     pixSetPixel()
           l_int32     pixGetRGBPixel()
           l_int32     pixSetRGBPixel()
           l_int32     pixGetRandomPixel()
           l_int32     pixClearPixel()
           l_int32     pixFlipPixel()
           void        setPixelLow()

      Find black or white value
           l_int32     pixGetBlackOrWhiteVal()

      Full image clear/set/set-to-arbitrary-value
           l_int32     pixClearAll()
           l_int32     pixSetAll()
           l_int32     pixSetAllGray()
           l_int32     pixSetAllArbitrary()
           l_int32     pixSetBlackOrWhite()
           l_int32     pixSetComponentArbitrary()

      Rectangular region clear/set/set-to-arbitrary-value/blend
           l_int32     pixClearInRect()
           l_int32     pixSetInRect()
           l_int32     pixSetInRectArbitrary()
           l_int32     pixBlendInRect()

      Set pad bits
           l_int32     pixSetPadBits()
           l_int32     pixSetPadBitsBand()

      Assign border pixels
           l_int32     pixSetOrClearBorder()
           l_int32     pixSetBorderVal()
           l_int32     pixSetBorderRingVal()
           l_int32     pixSetMirroredBorder()
           PIX        *pixCopyBorder()

      Add and remove border
           PIX        *pixAddBorder()
           PIX        *pixAddBlackOrWhiteBorder()
           PIX        *pixAddBorderGeneral()
           PIX        *pixRemoveBorder()
           PIX        *pixRemoveBorderGeneral()
           PIX        *pixRemoveBorderToSize()
           PIX        *pixAddMirroredBorder()
           PIX        *pixAddRepeatedBorder()
           PIX        *pixAddMixedBorder()
           PIX        *pixAddContinuedBorder()

      Helper functions using alpha
           l_int32     pixShiftAndTransferAlpha()
           PIX        *pixDisplayLayersRGBA()

      Color sample setting and extraction
           PIX        *pixCreateRGBImage()
           PIX        *pixGetRGBComponent()
           l_int32     pixSetRGBComponent()
           PIX        *pixGetRGBComponentCmap()
           l_int32     pixCopyRGBComponent()
           l_int32     composeRGBPixel()
           l_int32     composeRGBAPixel()
           void        extractRGBValues()
           void        extractRGBAValues()
           l_int32     extractMinMaxComponent()
           l_int32     pixGetRGBLine()

      Conversion between big and little endians
           PIX        *pixEndianByteSwapNew()
           l_int32     pixEndianByteSwap()
           l_int32     lineEndianByteSwap()
           PIX        *pixEndianTwoByteSwapNew()
           l_int32     pixEndianTwoByteSwap()

      Extract raster data as binary string
           l_int32     pixGetRasterData()

      Test alpha component opaqueness
           l_int32     pixAlphaIsOpaque

      Setup helpers for 8 bpp byte processing
           l_uint8   **pixSetupByteProcessing()
           l_int32     pixCleanupByteProcessing()

      Setting parameters for antialias masking with alpha transforms
           void        l_setAlphaMaskBorder()

      *** indicates implicit assumption about RGB component ordering

"""
    
    try:
        leptonica.l_setAlphaMaskBorder.argtypes = [ctypes.c_float, ctypes.c_float]
        leptonica.l_setAlphaMaskBorder.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setAlphaMaskBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setAlphaMaskBorder(*args):
        """
        ('l_float32', 'val1')       
('l_float32', 'val2')       
  l_setAlphaMaskBorder()

      Input:  val1, val2 (in [0.0 ... 1.0])
      Return: void

  Notes:
      (1) This sets the opacity values used to generate the two outer
          boundary rings in the alpha mask associated with geometric
          transforms such as pixRotateWithAlpha().
      (2) The default values are val1 = 0.0 (completely transparent
          in the outermost ring) and val2 = 0.5 (half transparent
          in the second ring).  When the image is blended, this
          completely removes the outer ring (shrinking the image by
          2 in each direction), and alpha-blends with 0.5 the second ring.
          Using val1 = 0.25 and val2 = 0.75 gives a slightly more
          blurred border, with no perceptual difference at screen resolution.
      (3) The actual mask values are found by multiplying these
          normalized opacity values by 255.


        """
        args = _convert_params(*args)
        
        return leptonica.l_setAlphaMaskBorder(*args)
    
    

    try:
        leptonica.pixSetMirroredBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetMirroredBorder.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetMirroredBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMirroredBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixSetMirroredBorder()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot (number of pixels to set)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This applies what is effectively mirror boundary conditions
          to a border region in the image.  It is in-place.
      (2) This is useful for setting pixels near the border to a
          value representative of the near pixels to the interior.
      (3) The general pixRasterop() is used for an in-place operation here
          because there is no overlap between the src and dest rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMirroredBorder(*args)
    
    

    try:
        leptonica.pixSetPadBits.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetPadBits.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetPadBits not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPadBits(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'val')       
  pixSetPadBits()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              val  (0 or 1)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The pad bits are the bits that expand each scanline to a
          multiple of 32 bits.  They are usually not used in
          image processing operations.  When boundary conditions
          are important, as in seedfill, they must be set properly.
      (2) This sets the value of the pad bits (if any) in the last
          32-bit word in each scanline.
      (3) For 32 bpp pix, there are no pad bits, so this is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPadBits(*args)
    
    

    try:
        leptonica.pixGetRGBComponentCmap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetRGBComponentCmap.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetRGBComponentCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBComponentCmap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'comp')       
  pixGetRGBComponentCmap()

      Input:  pixs  (colormapped)
              comp  (one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE})
      Return: pixd  (the selected 8 bpp component image of the
                     input cmapped image), or null on error

  Notes:
      (1) In leptonica, we do not support alpha in colormaps.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBComponentCmap(*args)
    
    

    try:
        leptonica.pixGetBlackOrWhiteVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetBlackOrWhiteVal.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetBlackOrWhiteVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBlackOrWhiteVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'op')       
('l_uint32', '*pval')       
  pixGetBlackOrWhiteVal()

      Input:  pixs (all depths; cmap ok)
              op (L_GET_BLACK_VAL, L_GET_WHITE_VAL)
              &val (<return> pixel value)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Side effect.  For a colormapped image, if the requested
          color is not present and there is room to add it in the cmap,
          it is added and the new index is returned.  If there is no room,
          the index of the closest color in intensity is returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBlackOrWhiteVal(*args)
    
    

    try:
        leptonica.pixRemoveBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRemoveBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'npix')       
  pixRemoveBorder()

      Input:  pixs (all depths; colormap ok)
              npix (number to be removed from each of the 4 sides)
      Return: pixd (with pixels removed around border), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorder(*args)
    
    

    try:
        leptonica.pixBlendInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_float]
        leptonica.pixBlendInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBlendInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', 'val')       
('l_float32', 'fract')       
  pixBlendInRect()

      Input:  pixs (32 bpp rgb)
              box (<optional> in which all pixels will be blended)
              val  (blend value; 0xrrggbb00)
              fract (fraction of color to be blended with each pixel in pixs)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This is an in-place function.  It blends the input color @val
          with the pixels in pixs in the specified rectangle.
          If no rectangle is specified, it blends over the entire image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendInRect(*args)
    
    

    try:
        leptonica.pixClearAll.argtypes = [ctypes.c_void_p]
        leptonica.pixClearAll.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixClearAll not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClearAll(*args):
        """
        ('PIX', '*pix')       
  pixClearAll()

      Input:  pix (all depths; use cmapped with caution)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Clears all data to 0.  For 1 bpp, this is white; for grayscale
          or color, this is black.
      (2) Caution: for colormapped pix, this sets the color to the first
          one in the colormap.  Be sure that this is the intended color!


        """
        args = _convert_params(*args)
        
        return leptonica.pixClearAll(*args)
    
    

    try:
        leptonica.setPixelLow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.setPixelLow.restype = None
    except AttributeError:
        os.stderr.write("Warning - function setPixelLow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def setPixelLow(*args):
        """
        ('l_uint32', '*line')       
('l_int32', 'x')       
('l_int32', 'depth')       
('l_uint32', 'val')       
  setPixelLow()

      Input:  line (ptr to beginning of line),
              x (pixel location in line)
              depth (bpp)
              val (to be inserted)
      Return: void

  Notes:
      (1) Caution: input variables are not checked!


        """
        args = _convert_params(*args)
        
        return leptonica.setPixelLow(*args)
    
    

    try:
        leptonica.pixGetRasterData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRasterData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRasterData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRasterData(*args):
        """
        ('PIX', '*pixs')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
  pixGetRasterData()

      Input:  pixs (1, 8, 32 bpp)
              &data (<return> raster data in memory)
              &nbytes (<return> number of bytes in data string)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This returns the raster data as a byte string, padded to the
          byte.  For 1 bpp, the first pixel is the MSbit in the first byte.
          For rgb, the bytes are in (rgb) order.  This is the format
          required for flate encoding of pixels in a PostScript file.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRasterData(*args)
    
    

    try:
        leptonica.pixCopyBorder.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCopyBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCopyBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyBorder(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixCopyBorder()

      Input:  pixd (all depths; colormap ok; can be NULL)
              pixs (same depth and size as pixd)
              left, right, top, bot (number of pixels to copy)
      Return: pixd, or null on error if pixd is not defined

  Notes:
      (1) pixd can be null, but otherwise it must be the same size
          and depth as pixs.  Always returns pixd.
      (1) This is useful in situations where by setting a few border
          pixels we can avoid having to copy all pixels in pixs into
          pixd as an initialization step for some operation.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyBorder(*args)
    
    

    try:
        leptonica.pixCopyRGBComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCopyRGBComponent.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCopyRGBComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyRGBComponent(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'comp')       
  pixCopyRGBComponent()

      Input:  pixd (32 bpp)
              pixs (32 bpp)
              comp (one of the set: {COLOR_RED, COLOR_GREEN,
                                     COLOR_BLUE, L_ALPHA_CHANNEL})
      Return: 0 if OK; 1 on error

  Notes:
      (1) The two images are registered to the UL corner.  The sizes
          are usually the same, and a warning is issued if they differ.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyRGBComponent(*args)
    
    

    try:
        leptonica.pixSetAllArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixSetAllArbitrary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetAllArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAllArbitrary(*args):
        """
        ('PIX', '*pix')       
('l_uint32', 'val')       
  pixSetAllArbitrary()

      Input:  pix (all depths; use cmapped with caution)
              val  (value to set all pixels)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Caution!  For colormapped pix, @val is used as an index
          into a colormap.  Be sure that index refers to the intended color.
          If the color is not in the colormap, you should first add it
          and then call this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAllArbitrary(*args)
    
    

    try:
        leptonica.pixSetPadBitsBand.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetPadBitsBand.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetPadBitsBand not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPadBitsBand(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'by')       
('l_int32', 'bh')       
('l_int32', 'val')       
  pixSetPadBitsBand()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              by  (starting y value of band)
              bh  (height of band)
              val  (0 or 1)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The pad bits are the bits that expand each scanline to a
          multiple of 32 bits.  They are usually not used in
          image processing operations.  When boundary conditions
          are important, as in seedfill, they must be set properly.
      (2) This sets the value of the pad bits (if any) in the last
          32-bit word in each scanline, within the specified
          band of raster lines.
      (3) For 32 bpp pix, there are no pad bits, so this is a no-op.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPadBitsBand(*args)
    
    

    try:
        leptonica.pixSetAllGray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetAllGray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetAllGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAllGray(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'grayval')       
  pixSetAllGray()

      Input:  pix (all depths, cmap ok)
              grayval (in range 0 ... 255)
      Return: 0 if OK; 1 on error

  Notes:
      (1) N.B.  For all images, @grayval == 0 represents black and
          @grayval == 255 represents white.
      (2) For depth < 8, we do our best to approximate the gray level.
          For 1 bpp images, any @grayval < 128 is black; >= 128 is white.
          For 32 bpp images, each r,g,b component is set to @grayval,
          and the alpha component is preserved.
      (3) If pix is colormapped, it adds the gray value, replicated in
          all components, to the colormap if it's not there and there
          is room.  If the colormap is full, it finds the closest color in
          L2 distance of components.  This index is written to all pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAllGray(*args)
    
    

    try:
        leptonica.pixEndianTwoByteSwapNew.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianTwoByteSwapNew.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixEndianTwoByteSwapNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianTwoByteSwapNew(*args):
        """
        ('PIX', '*pixs')       
  pixEndianTwoByteSwapNew()

      Input:  pixs
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is used on little-endian platforms to swap the
          2-byte entities within a 32-bit word.
      (2) This is equivalent to a full byte swap, as performed
          by pixEndianByteSwap(), followed by byte swaps in
          each of the 16-bit entities separately.
      (3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,
          this returns a new pix (or a clone).  We provide this
          to avoid having to swap twice in situations where the input
          pix must be restored to canonical little-endian order.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianTwoByteSwapNew(*args)
    
    

    try:
        leptonica.pixSetBorderRingVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixSetBorderRingVal.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetBorderRingVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBorderRingVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dist')       
('l_uint32', 'val')       
  pixSetBorderRingVal()

      Input:  pixs (any depth; cmap OK)
              dist (distance from outside; must be > 0; first ring is 1)
              val (value to set at each border pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The rings are single-pixel-wide rectangular sets of
          pixels at a given distance from the edge of the pix.
          This sets all pixels in a given ring to a value.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBorderRingVal(*args)
    
    

    try:
        leptonica.lineEndianByteSwap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.lineEndianByteSwap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lineEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lineEndianByteSwap(*args):
        """
        ('l_uint32', '*datad')       
('l_uint32', '*datas')       
('l_int32', 'wpl')       
  lineEndianByteSwap()

      Input   datad (dest byte array data, reordered on little-endians)
              datas (a src line of pix data)
              wpl (number of 32 bit words in the line)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is used on little-endian platforms to swap
          the bytes within each word in the line of image data.
          Bytes 0 <==> 3 and 1 <==> 2 are swapped in the dest
          byte array data8d, relative to the pix data in datas.
      (2) The bytes represent 8 bit pixel values.  They are swapped
          for little endians so that when the dest array (char *)datad
          is addressed by bytes, the pixels are chosen sequentially
          from left to right in the image.


        """
        args = _convert_params(*args)
        
        return leptonica.lineEndianByteSwap(*args)
    
    

    try:
        leptonica.pixClearPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixClearPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixClearPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClearPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixClearPixel()

      Input:  pix
              (x,y) pixel coords
      Return: 0 if OK; 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClearPixel(*args)
    
    

    try:
        leptonica.pixGetRandomPixel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRandomPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRandomPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRandomPixel(*args):
        """
        ('PIX', '*pix')       
('l_uint32', '*pval')       
('l_int32', '*px')       
('l_int32', '*py')       
  pixGetRandomPixel()

      Input:  pix (any depth; can be colormapped)
              &val (<return> pixel value)
              &x (<optional return> x coordinate chosen; can be null)
              &y (<optional return> y coordinate chosen; can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) If the pix is colormapped, it returns the rgb value.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRandomPixel(*args)
    
    

    try:
        leptonica.pixGetRGBPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRGBPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRGBPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
  pixGetRGBPixel()

      Input:  pix (32 bpp rgb, not colormapped)
              (x,y) pixel coords
              &rval (<optional return> red component)
              &gval (<optional return> green component)
              &bval (<optional return> blue component)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBPixel(*args)
    
    

    try:
        leptonica.pixSetInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixSetInRect()

      Input:  pix (all depths, can be cmapped)
              box (in which all pixels will be set)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Sets all data in rect to 1.  For 1 bpp, this is black;
          for grayscale or color, this is white.
      (2) Caution: for colormapped pix, this sets the pixel value to the
          maximum value supported by the colormap: 2^d - 1.  However, this
          color may not be defined, because the colormap may not be full.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetInRect(*args)
    
    

    try:
        leptonica.pixAddBlackOrWhiteBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddBlackOrWhiteBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddBlackOrWhiteBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddBlackOrWhiteBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_int32', 'op')       
  pixAddBlackOrWhiteBorder()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot  (number of pixels added)
              op (L_GET_BLACK_VAL, L_GET_WHITE_VAL)
      Return: pixd (with the added exterior pixels), or null on error

  Notes:
      (1) See pixGetBlackOrWhiteVal() for possible side effect (adding
          a color to a colormap).
      (2) The only complication is that pixs may have a colormap.
          There are two ways to add the black or white border:
          (a) As done here (simplest, most efficient)
          (b) l_int32 ws, hs, d;
              pixGetDimensions(pixs, &ws, &hs, &d);
              Pix *pixd = pixCreate(ws + left + right, hs + top + bot, d);
              PixColormap *cmap = pixGetColormap(pixs);
              if (cmap != NULL)
                  pixSetColormap(pixd, pixcmapCopy(cmap));
              pixSetBlackOrWhite(pixd, L_SET_WHITE);  // uses cmap
              pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0);


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddBlackOrWhiteBorder(*args)
    
    

    try:
        leptonica.composeRGBPixel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.composeRGBPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function composeRGBPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def composeRGBPixel(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_uint32', '*ppixel')       
  composeRGBPixel()

      Input:  rval, gval, bval
              &pixel  (<return> 32-bit pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) All channels are 8 bits: the input values must be between
          0 and 255.  For speed, this is not enforced by masking
          with 0xff before shifting.
      (2) A slower implementation uses macros:
            SET_DATA_BYTE(ppixel, COLOR_RED, rval);
            SET_DATA_BYTE(ppixel, COLOR_GREEN, gval);
            SET_DATA_BYTE(ppixel, COLOR_BLUE, bval);


        """
        args = _convert_params(*args)
        
        return leptonica.composeRGBPixel(*args)
    
    

    try:
        leptonica.pixSetInRectArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixSetInRectArbitrary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetInRectArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetInRectArbitrary(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_uint32', 'val')       
  pixSetInRectArbitrary()

      Input:  pix (all depths; can be cmapped)
              box (in which all pixels will be set to val)
              val  (value to set all pixels)
      Return: 0 if OK; 1 on error

  Notes:
      (1) For colormapped pix, be sure the value is the intended
          one in the colormap.
      (2) Caution: for colormapped pix, this sets each pixel in the
          rect to the color at the index equal to val.  Be sure that
          this index exists in the colormap and that it is the intended one!


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetInRectArbitrary(*args)
    
    

    try:
        leptonica.pixSetOrClearBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetOrClearBorder.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetOrClearBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetOrClearBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_int32', 'op')       
  pixSetOrClearBorder()

      Input:  pixs (all depths)
              left, right, top, bot (amount to set or clear)
              operation (PIX_SET or PIX_CLR)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The border region is defined to be the region in the
          image within a specific distance of each edge.  Here, we
          allow the pixels within a specified distance of each
          edge to be set independently.  This either sets or
          clears all pixels in the border region.
      (2) For binary images, use PIX_SET for black and PIX_CLR for white.
      (3) For grayscale or color images, use PIX_SET for white
          and PIX_CLR for black.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetOrClearBorder(*args)
    
    

    try:
        leptonica.pixEndianByteSwapNew.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianByteSwapNew.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixEndianByteSwapNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianByteSwapNew(*args):
        """
        ('PIX', '*pixs')       
  pixEndianByteSwapNew()

      Input:  pixs
      Return: pixd, or null on error

  Notes:
      (1) This is used to convert the data in a pix to a
          serialized byte buffer in raster order, and, for RGB,
          in order RGBA.  This requires flipping bytes within
          each 32-bit word for little-endian platforms, because the
          words have a MSB-to-the-left rule, whereas byte raster-order
          requires the left-most byte in each word to be byte 0.
          For big-endians, no swap is necessary, so this returns a clone.
      (2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,
          this returns a new pix (or a clone).  We provide this
          because often when serialization is done, the source
          pix needs to be restored to canonical little-endian order,
          and this requires a second byte swap.  In such a situation,
          it is twice as fast to make a new pix in big-endian order,
          use it, and destroy it.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianByteSwapNew(*args)
    
    

    try:
        leptonica.extractRGBValues.argtypes = [ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.extractRGBValues.restype = None
    except AttributeError:
        os.stderr.write("Warning - function extractRGBValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractRGBValues(*args):
        """
        ('l_uint32', 'pixel')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
  extractRGBValues()

      Input:  pixel (32 bit)
              &rval (<optional return> red component)
              &gval (<optional return> green component)
              &bval (<optional return> blue component)
      Return: void

  Notes:
      (1) A slower implementation uses macros:
             *prval = GET_DATA_BYTE(&pixel, COLOR_RED);
             *pgval = GET_DATA_BYTE(&pixel, COLOR_GREEN);
             *pbval = GET_DATA_BYTE(&pixel, COLOR_BLUE);


        """
        args = _convert_params(*args)
        
        return leptonica.extractRGBValues(*args)
    
    

    try:
        leptonica.pixShiftAndTransferAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixShiftAndTransferAlpha.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixShiftAndTransferAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixShiftAndTransferAlpha(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'shiftx')       
('l_float32', 'shifty')       
  pixShiftAndTransferAlpha()

      Input:  pixd  (32 bpp)
              pixs  (32 bpp)
              shiftx, shifty
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixShiftAndTransferAlpha(*args)
    
    

    try:
        leptonica.pixAddMirroredBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddMirroredBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddMirroredBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddMirroredBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixAddMirroredBorder()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot (number of pixels added)
      Return: pixd, or null on error

  Notes:
      (1) This applies what is effectively mirror boundary conditions.
          For the added border pixels in pixd, the pixels in pixs
          near the border are mirror-copied into the border region.
      (2) This is useful for avoiding special operations near
          boundaries when doing image processing operations
          such as rank filters and convolution.  In use, one first
          adds mirrored pixels to each side of the image.  The number
          of pixels added on each side is half the filter dimension.
          Then the image processing operations proceed over a
          region equal to the size of the original image, and
          write directly into a dest pix of the same size as pixs.
      (3) The general pixRasterop() is used for an in-place operation here
          because there is no overlap between the src and dest rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddMirroredBorder(*args)
    
    

    try:
        leptonica.pixGetRGBLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRGBLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetRGBLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'row')       
('l_uint8', '*bufr')       
('l_uint8', '*bufg')       
('l_uint8', '*bufb')       
  pixGetRGBLine()

      Input:  pixs  (32 bpp)
              row
              bufr  (array of red samples; size w bytes)
              bufg  (array of green samples; size w bytes)
              bufb  (array of blue samples; size w bytes)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This puts rgb components from the input line in pixs
          into the given buffers.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBLine(*args)
    
    

    try:
        leptonica.pixCreateRGBImage.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCreateRGBImage.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCreateRGBImage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateRGBImage(*args):
        """
        ('PIX', '*pixr')       
('PIX', '*pixg')       
('PIX', '*pixb')       
  pixCreateRGBImage()

      Input:  8 bpp red pix
              8 bpp green pix
              8 bpp blue pix
      Return: 32 bpp pix, interleaved with 4 samples/pixel,
              or null on error

  Notes:
      (1) the 4th byte, sometimes called the "alpha channel",
          and which is often used for blending between different
          images, is left with 0 value.
      (2) see Note (4) in pix.h for details on storage of
          8-bit samples within each 32-bit word.
      (3) This implementation, setting the r, g and b components
          sequentially, is much faster than setting them in parallel
          by constructing an RGB dest pixel and writing it to dest.
          The reason is there are many more cache misses when reading
          from 3 input images simultaneously.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateRGBImage(*args)
    
    

    try:
        leptonica.pixClearInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClearInRect.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixClearInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClearInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
  pixClearInRect()

      Input:  pix (all depths; can be cmapped)
              box (in which all pixels will be cleared)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Clears all data in rect to 0.  For 1 bpp, this is white;
          for grayscale or color, this is black.
      (2) Caution: for colormapped pix, this sets the color to the first
          one in the colormap.  Be sure that this is the intended color!


        """
        args = _convert_params(*args)
        
        return leptonica.pixClearInRect(*args)
    
    

    try:
        leptonica.pixAddBorderGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixAddBorderGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddBorderGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddBorderGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_uint32', 'val')       
  pixAddBorderGeneral()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot  (number of pixels added)
              val   (value of added border pixels)
      Return: pixd (with the added exterior pixels), or null on error

  Notes:
      (1) For binary images:
             white:  val = 0
             black:  val = 1
          For grayscale images:
             white:  val = 2 ** d - 1
             black:  val = 0
          For rgb color images:
             white:  val = 0xffffff00
             black:  val = 0
          For colormapped images, set val to the appropriate colormap index.
      (2) If the added border is either black or white, you can use
             pixAddBlackOrWhiteBorder()
          The black and white values for all images can be found with
             pixGetBlackOrWhiteVal()
          which, if pixs is cmapped, may add an entry to the colormap.
          Alternatively, if pixs has a colormap, you can find the index
          of the pixel whose intensity is closest to white or black:
             white: pixcmapGetRankIntensity(cmap, 1.0, &index);
             black: pixcmapGetRankIntensity(cmap, 0.0, &index);
          and use that for val.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddBorderGeneral(*args)
    
    

    try:
        leptonica.pixRemoveBorderGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveBorderGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveBorderGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorderGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixRemoveBorderGeneral()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot  (number of pixels removed)
      Return: pixd (with pixels removed around border), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorderGeneral(*args)
    
    

    try:
        leptonica.pixEndianTwoByteSwap.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianTwoByteSwap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixEndianTwoByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianTwoByteSwap(*args):
        """
        ('PIX', '*pixs')       
  pixEndianTwoByteSwap()

      Input:  pixs
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is used on little-endian platforms to swap the
          2-byte entities within a 32-bit word.
      (2) This is equivalent to a full byte swap, as performed
          by pixEndianByteSwap(), followed by byte swaps in
          each of the 16-bit entities separately.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianTwoByteSwap(*args)
    
    

    try:
        leptonica.pixGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', '*pval')       
  pixGetPixel()

      Input:  pix
              (x,y) pixel coords
              &val (<return> pixel value)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This returns the value in the data array.  If the pix is
          colormapped, it returns the colormap index, not the rgb value.
      (2) Because of the function overhead and the parameter checking,
          this is much slower than using the GET_DATA_*() macros directly.
          Speed on a 1 Mpixel RGB image, using a 3 GHz machine:
            * pixGet/pixSet: ~25 Mpix/sec
            * GET_DATA/SET_DATA: ~350 MPix/sec
          If speed is important and you're doing random access into
          the pix, use pixGetLinePtrs() and the array access macros.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPixel(*args)
    
    

    try:
        leptonica.pixAddContinuedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddContinuedBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddContinuedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddContinuedBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixAddContinuedBorder()

      Input:  pixs
              left, right, top, bot (pixels on each side to be added)
      Return: pixd, or null on error

  Notes:
      (1) This adds pixels on each side whose values are equal to
          the value on the closest boundary pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddContinuedBorder(*args)
    
    

    try:
        leptonica.extractMinMaxComponent.argtypes = [ctypes.c_uint32, ctypes.c_int32]
        leptonica.extractMinMaxComponent.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function extractMinMaxComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractMinMaxComponent(*args):
        """
        ('l_uint32', 'pixel')       
('l_int32', 'type')       
  extractMinMaxComponent()

      Input:  pixel (32 bpp RGB)
              type (L_CHOOSE_MIN or L_CHOOSE_MAX)
      Return: component (in range [0 ... 255], or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.extractMinMaxComponent(*args)
    
    

    try:
        leptonica.pixCleanupByteProcessing.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCleanupByteProcessing.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCleanupByteProcessing not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCleanupByteProcessing(*args):
        """
        ('PIX', '*pix')       
('l_uint8', '**lineptrs')       
  pixCleanupByteProcessing()

      Input:  pix (8 bpp, no colormap)
              lineptrs (ptrs to the beginning of each raster line of data)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This must be called after processing that was initiated
          by pixSetupByteProcessing() has finished.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCleanupByteProcessing(*args)
    
    

    try:
        leptonica.pixSetBlackOrWhite.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetBlackOrWhite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetBlackOrWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBlackOrWhite(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'op')       
  pixSetBlackOrWhite()

      Input:  pixs (all depths; cmap ok)
              op (L_SET_BLACK, L_SET_WHITE)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Function for setting all pixels in an image to either black
          or white.
      (2) If pixs is colormapped, it adds black or white to the
          colormap if it's not there and there is room.  If the colormap
          is full, it finds the closest color in intensity.
          This index is written to all pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBlackOrWhite(*args)
    
    

    try:
        leptonica.pixAddRepeatedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddRepeatedBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddRepeatedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddRepeatedBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixAddRepeatedBorder()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot (number of pixels added)
      Return: pixd, or null on error

  Notes:
      (1) This applies a repeated border, as if the central part of
          the image is tiled over the plane.  So, for example, the
          pixels in the left border come from the right side of the image.
      (2) The general pixRasterop() is used for an in-place operation here
          because there is no overlap between the src and dest rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddRepeatedBorder(*args)
    
    

    try:
        leptonica.pixSetRGBPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetRGBPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetRGBPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetRGBPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
  pixSetRGBPixel()

      Input:  pix (32 bpp rgb)
              (x,y) pixel coords
              rval (red component)
              gval (green component)
              bval (blue component)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetRGBPixel(*args)
    
    

    try:
        leptonica.pixSetupByteProcessing.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetupByteProcessing.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_ubyte))
    except AttributeError:
        os.stderr.write("Warning - function pixSetupByteProcessing not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetupByteProcessing(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  pixSetupByteProcessing()

      Input:  pix (8 bpp, no colormap)
              &w (<optional return> width)
              &h (<optional return> height)
      Return: line ptr array, or null on error

  Notes:
      (1) This is a simple helper for processing 8 bpp images with
          direct byte access.  It can swap byte order within each word.
      (2) After processing, you must call pixCleanupByteProcessing(),
          which frees the lineptr array and restores byte order.
      (3) Usage:
              l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);
              for (i = 0; i < h; i++) {
                  l_uint8 *line = lineptrs[i];
                  for (j = 0; j < w; j++) {
                      val = line[j];
                      ...
                  }
              }
              pixCleanupByteProcessing(pix, lineptrs);


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetupByteProcessing(*args)
    
    

    try:
        leptonica.composeRGBAPixel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.composeRGBAPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function composeRGBAPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def composeRGBAPixel(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'aval')       
('l_uint32', '*ppixel')       
  composeRGBAPixel()

      Input:  rval, gval, bval, aval
              &pixel  (<return> 32-bit pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) All channels are 8 bits: the input values must be between
          0 and 255.  For speed, this is not enforced by masking
          with 0xff before shifting.


        """
        args = _convert_params(*args)
        
        return leptonica.composeRGBAPixel(*args)
    
    

    try:
        leptonica.pixFlipPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFlipPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFlipPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFlipPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixFlipPixel()

      Input:  pix
              (x,y) pixel coords
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixFlipPixel(*args)
    
    

    try:
        leptonica.pixSetAll.argtypes = [ctypes.c_void_p]
        leptonica.pixSetAll.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetAll not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAll(*args):
        """
        ('PIX', '*pix')       
  pixSetAll()

      Input:  pix (all depths; use cmapped with caution)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Sets all data to 1.  For 1 bpp, this is black; for grayscale
          or color, this is white.
      (2) Caution: for colormapped pix, this sets the pixel value to the
          maximum value supported by the colormap: 2^d - 1.  However, this
          color may not be defined, because the colormap may not be full.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAll(*args)
    
    

    try:
        leptonica.pixSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixSetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', 'val')       
  pixSetPixel()

      Input:  pix
              (x,y) pixel coords
              val (value to be inserted)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Warning: the input value is not checked for overflow with respect
          the the depth of @pix, and the sign bit (if any) is ignored.
          * For d == 1, @val > 0 sets the bit on.
          * For d == 2, 4, 8 and 16, @val is masked to the maximum allowable
            pixel value, and any (invalid) higher order bits are discarded.
      (2) See pixGetPixel() for information on performance.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPixel(*args)
    
    

    try:
        leptonica.pixSetRGBComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetRGBComponent.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetRGBComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetRGBComponent(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'comp')       
  pixSetRGBComponent()

      Input:  pixd  (32 bpp)
              pixs  (8 bpp)
              comp  (one of the set: {COLOR_RED, COLOR_GREEN,
                                      COLOR_BLUE, L_ALPHA_CHANNEL})
      Return: 0 if OK; 1 on error

  Notes:
      (1) This places the 8 bpp pixel in pixs into the
          specified component (properly interleaved) in pixd,
      (2) The two images are registered to the UL corner; the sizes
          need not be the same, but a warning is issued if they differ.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetRGBComponent(*args)
    
    

    try:
        leptonica.pixRemoveBorderToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveBorderToSize.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRemoveBorderToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorderToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       
  pixRemoveBorderToSize()

      Input:  pixs (all depths; colormap ok)
              wd  (target width; use 0 if only removing from height)
              hd  (target height; use 0 if only removing from width)
      Return: pixd (with pixels removed around border), or null on error

  Notes:
      (1) Removes pixels as evenly as possible from the sides of the
          image, leaving the central part.
      (2) Returns clone if no pixels requested removed, or the target
          sizes are larger than the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorderToSize(*args)
    
    

    try:
        leptonica.pixAlphaIsOpaque.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAlphaIsOpaque.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixAlphaIsOpaque not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAlphaIsOpaque(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*popaque')       
  pixAlphaIsOpaque()

      Input:  pix (32 bpp, spp == 4)
              &opaque (<return> 1 if spp == 4 and all alpha component
                       values are 255 (opaque); 0 otherwise)
      Return: 0 if OK, 1 on error
      Notes:
          (1) On error, opaque is returned as 0 (FALSE).


        """
        args = _convert_params(*args)
        
        return leptonica.pixAlphaIsOpaque(*args)
    
    

    try:
        leptonica.pixSetBorderVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixSetBorderVal.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetBorderVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBorderVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_uint32', 'val')       
  pixSetBorderVal()

      Input:  pixs (8, 16 or 32 bpp)
              left, right, top, bot (amount to set)
              val (value to set at each border pixel)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The border region is defined to be the region in the
          image within a specific distance of each edge.  Here, we
          allow the pixels within a specified distance of each
          edge to be set independently.  This sets the pixels
          in the border region to the given input value.
      (2) For efficiency, use pixSetOrClearBorder() if
          you're setting the border to either black or white.
      (3) If d != 32, the input value should be masked off
          to the appropriate number of least significant bits.
      (4) The code is easily generalized for 2 or 4 bpp.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBorderVal(*args)
    
    

    try:
        leptonica.extractRGBAValues.argtypes = [ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.extractRGBAValues.restype = None
    except AttributeError:
        os.stderr.write("Warning - function extractRGBAValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractRGBAValues(*args):
        """
        ('l_uint32', 'pixel')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
('l_int32', '*paval')       
  extractRGBAValues()

      Input:  pixel (32 bit)
              &rval (<optional return> red component)
              &gval (<optional return> green component)
              &bval (<optional return> blue component)
              &aval (<optional return> alpha component)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.extractRGBAValues(*args)
    
    

    try:
        leptonica.pixSetComponentArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetComponentArbitrary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetComponentArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetComponentArbitrary(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'comp')       
('l_int32', 'val')       
  pixSetComponentArbitrary()

      Input:  pix (32 bpp)
              comp (COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL)
              val  (value to set this component)
      Return: 0 if OK; 1 on error

  Notes:
      (1) For example, this can be used to set the alpha component to opaque:
              pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetComponentArbitrary(*args)
    
    

    try:
        leptonica.pixAddBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixAddBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'npix')       
('l_uint32', 'val')       
  pixAddBorder()

      Input:  pixs (all depths; colormap ok)
              npix (number of pixels to be added to each side)
              val  (value of added border pixels)
      Return: pixd (with the added exterior pixels), or null on error

  Notes:
      (1) See pixGetBlackOrWhiteVal() for values of black and white pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddBorder(*args)
    
    

    try:
        leptonica.pixDisplayLayersRGBA.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixDisplayLayersRGBA.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayLayersRGBA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayLayersRGBA(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'val')       
('l_int32', 'maxw')       
  pixDisplayLayersRGBA()

      Input:  pixs (cmap or 32 bpp rgba)
              val (32 bit unsigned color to use as background)
              maxw (max output image width; 0 for no scaling)
      Return: pixd (showing various image views), or null on error

  Notes:
      (1) Use @val == 0xffffff00 for white background.
      (2) Three views are given:
           - the image with a fully opaque alpha
           - the alpha layer
           - the image as it would appear with a white background.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayLayersRGBA(*args)
    
    

    try:
        leptonica.pixEndianByteSwap.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianByteSwap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianByteSwap(*args):
        """
        ('PIX', '*pixs')       
  pixEndianByteSwap()

      Input:  pixs
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is used on little-endian platforms to swap
          the bytes within a word; bytes 0 and 3 are swapped,
          and bytes 1 and 2 are swapped.
      (2) This is required for little-endians in situations
          where we convert from a serialized byte order that is
          in raster order, as one typically has in file formats,
          to one with MSB-to-the-left in each 32-bit word, or v.v.
          See pix.h for a description of the canonical format
          (MSB-to-the left) that is used for both little-endian
          and big-endian platforms.   For big-endians, the
          MSB-to-the-left word order has the bytes in raster
          order when serialized, so no byte flipping is required.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianByteSwap(*args)
    
    

    try:
        leptonica.pixGetRGBComponent.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetRGBComponent.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetRGBComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBComponent(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'comp')       
  pixGetRGBComponent()

      Input:  pixs (32 bpp, or colormapped)
              comp (one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE,
                    L_ALPHA_CHANNEL})
      Return: pixd (the selected 8 bpp component image of the
                    input 32 bpp image) or null on error

  Notes:
      (1) Three calls to this function generate the r, g and b 8 bpp
          component images.  This is much faster than generating the
          three images in parallel, by extracting a src pixel and setting
          the pixels of each component image from it.  The reason is
          there are many more cache misses when writing to three
          output images simultaneously.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBComponent(*args)
    
    

    try:
        leptonica.pixAddMixedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddMixedBorder.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddMixedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddMixedBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  pixAddMixedBorder()

      Input:  pixs (all depths; colormap ok)
              left, right, top, bot (number of pixels added)
      Return: pixd, or null on error

  Notes:
      (1) This applies mirrored boundary conditions horizontally
          and repeated b.c. vertically.
      (2) It is specifically used for avoiding special operations
          near boundaries when convolving a hue-saturation histogram
          with a given window size.  The repeated b.c. are used
          vertically for hue, and the mirrored b.c. are used
          horizontally for saturation.  The number of pixels added
          on each side is approximately (but not quite) half the
          filter dimension.  The image processing operations can
          then proceed over a region equal to the size of the original
          image, and write directly into a dest pix of the same
          size as pixs.
      (3) The general pixRasterop() can be used for an in-place
          operation here because there is no overlap between the
          src and dest rectangles.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddMixedBorder(*args)
    




class pngio(object):
    """  pngio.c

    Read png from file
          PIX        *pixReadStreamPng()
          l_int32     readHeaderPng()
          l_int32     freadHeaderPng()
          l_int32     readHeaderMemPng()
          l_int32     fgetPngResolution()
          l_int32     isPngInterlaced()

    Write png to file
          l_int32     pixWritePng()  [ special top level ]
          l_int32     pixWriteStreamPng()
          l_int32     pixSetZlibCompression()

    Setting flag for special read mode
          void        l_pngSetReadStrip16To8()

    Read/write to memory
          PIX        *pixReadMemPng()
          l_int32     pixWriteMemPng()

    Documentation: libpng.txt and example.c

    On input (decompression from file), palette color images
    are read into an 8 bpp Pix with a colormap, and 24 bpp
    3 component color images are read into a 32 bpp Pix with
    rgb samples.  On output (compression to file), palette color
    images are written as 8 bpp with the colormap, and 32 bpp
    full color images are written compressed as a 24 bpp,
    3 component color image.

    In the following, we use these abbreviations:
       bps == bit/sample
       spp == samples/pixel
       bpp == bits/pixel of image in Pix (memory)
    where each component is referred to as a "sample".

    For reading and writing rgb and rgba images, we read and write
    alpha if it exists (spp == 4) and do not read or write if
    it doesn't (spp == 3).  The alpha component can be 'removed'
    simply by setting spp to 3.  In leptonica, we make relatively
    little explicit use of the alpha sample.  Note that the alpha
    sample in the image is also called "alpha transparency",
    "alpha component" and "alpha layer."

    To change the zlib compression level, use pixSetZlibCompression()
    before writing the file.  The default is for standard png compression.
    The zlib compression value can be set [0 ... 9], with
         0     no compression (huge files)
         1     fastest compression
         -1    default compression  (equivalent to 6 in latest version)
         9     best compression
    Note that if you are using the defined constants in zlib instead
    of the compression integers given above, you must include zlib.h.

    There is global for determining the size of retained samples:
             var_PNG_STRIP_16_to_8
    and a function l_pngSetReadStrip16To8() for setting it.
    The default is TRUE, which causes pixRead() to strip each 16 bit
    sample down to 8 bps:
     - For 16 bps rgb (16 bps, 3 spp) --> 32 bpp rgb Pix
     - For 16 bps gray (16 bps, 1 spp) --> 8 bpp grayscale Pix
    If the variable is set to FALSE, the 16 bit gray samples
    are saved when read; the 16 bit rgb samples return an error.
    Note: results can be non-deterministic if used with
    multi-threaded applications.

    On systems like windows without fmemopen() and open_memstream(),
    we write data to a temp file and read it back for operations
    between pix and compressed-data, such as pixReadMemPng() and
    pixWriteMemPng().

"""
    
    try:
        leptonica.pixReadMemPng.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemPng.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemPng(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
  pixReadMemPng()

      Input:  cdata (const; png-encoded)
              size (of data)
      Return: pix, or null on error

  Notes:
      (1) The @size byte of @data must be a null character.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemPng(*args)
    
    

    try:
        leptonica.readHeaderMemPng.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemPng.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderMemPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemPng(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  readHeaderMemPng()

      Input:  data
              size (40 bytes is sufficient)
              &w (<optional return>)
              &h (<optional return>)
              &bps (<optional return>, bits/sample)
              &spp (<optional return>, samples/pixel)
              &iscmap (<optional return>; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See readHeaderPng().
      (2) png colortypes (see png.h: PNG_COLOR_TYPE_*):
          0:  gray; fully transparent (with tRNS) (1 spp)
          2:  RGB (3 spp)
          3:  colormap; colormap+alpha (with tRNS) (1 spp)
          4:  gray + alpha (2 spp)
          6:  RGBA (4 spp)
          Note:
            0 and 3 have the alpha information in a tRNS chunk
            4 and 6 have separate alpha samples with each pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemPng(*args)
    
    

    try:
        leptonica.pixWriteStreamPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixWriteStreamPng.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPng(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_float32', 'gamma')       
  pixWriteStreamPng()

      Input:  stream
              pix
              gamma (use 0.0 if gamma is not defined)
      Return: 0 if OK; 1 on error

  Notes:
      (1) If called from pixWriteStream(), the stream is positioned
          at the beginning of the file.
      (2) To do sequential writes of png format images to a stream,
          use pixWriteStreamPng() directly.
      (3) gamma is an optional png chunk.  If no gamma value is to be
          placed into the file, use gamma = 0.0.  Otherwise, if
          gamma > 0.0, its value is written into the header.
      (4) The use of gamma in png is highly problematic.  For an illuminating
          discussion, see:  http://hsivonen.iki.fi/png-gamma/
      (5) What is the effect/meaning of gamma in the png file?  This
          gamma, which we can call the 'source' gamma, is the
          inverse of the gamma that was used in enhance.c to brighten
          or darken images.  The 'source' gamma is supposed to indicate
          the intensity mapping that was done at the time the
          image was captured.  Display programs typically apply a
          'display' gamma of 2.2 to the output, which is intended
          to linearize the intensity based on the response of
          thermionic tubes (CRTs).  Flat panel LCDs have typically
          been designed to give a similar response as CRTs (call it
          "backward compatibility").  The 'display' gamma is
          in some sense the inverse of the 'source' gamma.
          jpeg encoders attached to scanners and cameras will lighten
          the pixels, applying a gamma corresponding to approximately
          a square-root relation of output vs input:
                output = input^(gamma)
          where gamma is often set near 0.4545  (1/gamma is 2.2).
          This is stored in the image file.  Then if the display
          program reads the gamma, it will apply a display gamma,
          typically about 2.2; the product is 1.0, and the
          display program produces a linear output.  This works because
          the dark colors were appropriately boosted by the scanner,
          as described by the 'source' gamma, so they should not
          be further boosted by the display program.
      (6) As an example, with xv and display, if no gamma is stored,
          the program acts as if gamma were 0.4545, multiplies this by 2.2,
          and does a linear rendering.  Taking this as a baseline
          brightness, if the stored gamma is:
              > 0.4545, the image is rendered lighter than baseline
              < 0.4545, the image is rendered darker than baseline
          In contrast, gqview seems to ignore the gamma chunk in png.
      (7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
          and 32.  However, it is possible, and in some cases desirable,
          to write out a png file using an rgb pix that has 24 bpp.
          For example, the open source xpdf SplashBitmap class generates
          24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.
          To generate such a pix, you can make a 24 bpp pix without data
          and assign the data array to the pix; e.g.,
              pix = pixCreateHeader(w, h, 24);
              pixSetData(pix, rgbdata);
          See pixConvert32To24() for an example, where we get rgbdata
          from the 32 bpp pix.  Caution: do not call pixSetPadBits(),
          because the alignment is wrong and you may erase part of the
          last pixel on each line.
      (8) If the pix has a colormap, it is written to file.  In most
          situations, the alpha component is 255 for each colormap entry,
          which is opaque and indicates that it should be ignored.
          However, if any alpha component is not 255, it is assumed that
          the alpha values are valid, and they are written to the png
          file in a tRNS segment.  On readback, the tRNS segment is
          identified, and the colormapped image with alpha is converted
          to a 4 spp rgba image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPng(*args)
    
    

    try:
        leptonica.l_pngSetReadStrip16To8.argtypes = [ctypes.c_int32]
        leptonica.l_pngSetReadStrip16To8.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_pngSetReadStrip16To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_pngSetReadStrip16To8(*args):
        """
        ('l_int32', 'flag')       
  l_pngSetReadStrip16To8()

      Input:  flag (1 for stripping 16 bpp to 8 bpp on reading;
                    0 for leaving 16 bpp)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_pngSetReadStrip16To8(*args)
    
    

    try:
        leptonica.freadHeaderPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderPng.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function freadHeaderPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderPng(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  freadHeaderPng()

      Input:  stream
              &w (<optional return>)
              &h (<optional return>)
              &bps (<optional return>, bits/sample)
              &spp (<optional return>, samples/pixel)
              &iscmap (<optional return>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See readHeaderPng().  We only need the first 40 bytes in the file.


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderPng(*args)
    
    

    try:
        leptonica.readHeaderPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderPng.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderPng(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  readHeaderPng()

      Input:  filename
              &w (<optional return>)
              &h (<optional return>)
              &bps (<optional return>, bits/sample)
              &spp (<optional return>, samples/pixel)
              &iscmap (<optional return>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If there is a colormap, iscmap is returned as 1; else 0.
      (2) For gray+alpha, although the png records bps = 16, we
          consider this as two 8 bpp samples (gray and alpha).
          When a gray+alpha is read, it is converted to 32 bpp RGBA.


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderPng(*args)
    
    

    try:
        leptonica.pixReadStreamPng.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamPng.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamPng(*args):
        """
        ('FILE', '*fp')       
  pixReadStreamPng()

      Input:  stream
      Return: pix, or null on error

  Notes:
      (1) If called from pixReadStream(), the stream is positioned
          at the beginning of the file.
      (2) To do sequential reads of png format images from a stream,
          use pixReadStreamPng()
      (3) Any image with alpha is converted to RGBA (spp = 4, with
          equal red, green and blue channels) on reading.
          There are three important cases with alpha:
          (a) grayscale-with-alpha (spp = 2), where bpp = 8, and each
              pixel has an associated alpha (transparency) value
              in the second component of the image data.
          (b) spp = 1, d = 1 with colormap and alpha in the trans array.
              Transparency is usually associated with the white background.
          (c) spp = 1, d = 8 with colormap and alpha in the trans array.
              Each color in the colormap has a separate transparency value.
      (4) We use the high level png interface, where the transforms are set
          up in advance and the header and image are read with a single
          call.  The more complicated interface, where the header is
          read first and the buffers for the raster image are user-
          allocated before reading the image, works for single images,
          but I could not get it to work properly for the successive
          png reads that are required by pixaReadStream().


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamPng(*args)
    
    

    try:
        leptonica.pixSetZlibCompression.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetZlibCompression.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSetZlibCompression not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetZlibCompression(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'compval')       
  pixSetZlibCompression()

      Input:  pix
              compval (zlib compression value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Valid zlib compression values are in the interval [0 ... 9],
          where, as defined in zlib.h:
            0         Z_NO_COMPRESSION
            1         Z_BEST_SPEED    (poorest compression)
            9         Z_BEST_COMPRESSION
          For the default value, use either of these:
            6         Z_DEFAULT_COMPRESSION
           -1         (resolves to Z_DEFAULT_COMPRESSION)
      (2) If you use the defined constants in zlib.h instead of the
          compression integers given above, you must include zlib.h.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetZlibCompression(*args)
    
    

    try:
        leptonica.pixWritePng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixWritePng.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWritePng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWritePng(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_float32', 'gamma')       
  pixWritePng()

      Input:  filename
              pix
              gamma
      Return: 0 if OK; 1 on error

  Notes:
      (1) Special version for writing png with a specified gamma.
          When using pixWrite(), no field is given for gamma.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWritePng(*args)
    
    

    try:
        leptonica.pixWriteMemPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixWriteMemPng.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPng(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_float32', 'gamma')       
  pixWriteMemPng()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
              gamma (use 0.0 if gamma is not defined)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixWriteStreamPng() for usage.  This version writes to
          memory instead of to a file stream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPng(*args)
    
    

    try:
        leptonica.isPngInterlaced.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.isPngInterlaced.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function isPngInterlaced not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def isPngInterlaced(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pinterlaced')       
  isPngInterlaced()

      Input:  filename
              &interlaced (<return> 1 if interlaced png; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.isPngInterlaced(*args)
    




class heap(object):
    """   heap.c

      Create/Destroy L_Heap
          L_HEAP         *lheapCreate()
          void           *lheapDestroy()

      Operations to add/remove to/from the heap
          l_int32         lheapAdd()
          static l_int32  lheapExtendArray()
          void           *lheapRemove()

      Heap operations
          l_int32         lheapSwapUp()
          l_int32         lheapSwapDown()
          l_int32         lheapSort()
          l_int32         lheapSortStrictOrder()

      Accessors
          l_int32         lheapGetCount()

      Debug output
          l_int32         lheapPrint()

    The L_Heap is useful to implement a priority queue, that is sorted
    on a key in each element of the heap.  The heap is an array
    of nearly arbitrary structs, with a l_float32 the first field.
    This field is the key on which the heap is sorted.

    Internally, we keep track of the heap size, n.  The item at the
    root of the heap is at the head of the array.  Items are removed
    from the head of the array and added to the end of the array.
    When an item is removed from the head, the item at the end
    of the array is moved to the head.  When items are either
    added or removed, it is usually necesary to swap array items
    to restore the heap order.  It is guaranteed that the number
    of swaps does not exceed log(n).

    --------------------------  N.B.  ------------------------------
    The items on the heap (or, equivalently, in the array) are cast
    to void*.  Their key is a l_float32, and it is REQUIRED that the
    key be the first field in the struct.  That allows us to get the
    key by simply dereferencing the struct.  Alternatively, we could
    choose (but don't) to pass an application-specific comparison
    function into the heap operation functions.
    --------------------------  N.B.  ------------------------------

"""
    
    try:
        leptonica.lheapSwapUp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lheapSwapUp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapSwapUp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapSwapUp(*args):
        """
        ('L_HEAP', '*lh')       
('l_int32', 'index')       
  lheapSwapUp()

      Input:  lh (heap)
              index (of array corresponding to node to be swapped up)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is called after a new item is put on the heap, at the
          bottom of a complete tree.
      (2) To regain the heap order, we let it bubble up,
          iteratively swapping with its parent, until it either
          reaches the root of the heap or it finds a parent that
          is in the correct position already vis-a-vis the child.


        """
        args = _convert_params(*args)
        
        return leptonica.lheapSwapUp(*args)
    
    

    try:
        leptonica.lheapDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lheapDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function lheapDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapDestroy(*args):
        """
        ('L_HEAP', '**plh')       
('l_int32', 'freeflag')       
  lheapDestroy()

      Input:  &lheap  (<to be nulled>)
              freeflag (TRUE to free each remaining struct in the array)
      Return: void

  Notes:
      (1) Use freeflag == TRUE when the items in the array can be
          simply destroyed using free.  If those items require their
          own destroy function, they must be destroyed before
          calling this function, and then this function is called
          with freeflag == FALSE.
      (2) To destroy the lheap, we destroy the ptr array, then
          the lheap, and then null the contents of the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.lheapDestroy(*args)
    
    

    try:
        leptonica.lheapAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lheapAdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapAdd(*args):
        """
        ('L_HEAP', '*lh')       
('void', '*item')       
  lheapAdd()

      Input:  lheap
              item to be added to the tail of the heap
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapAdd(*args)
    
    

    try:
        leptonica.lheapSort.argtypes = [ctypes.c_void_p]
        leptonica.lheapSort.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapSort(*args):
        """
        ('L_HEAP', '*lh')       
  lheapSort()

      Input:  lh (heap, with internal array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This sorts an array into heap order.  If the heap is already
          in heap order for the direction given, this has no effect.


        """
        args = _convert_params(*args)
        
        return leptonica.lheapSort(*args)
    
    

    try:
        leptonica.lheapGetCount.argtypes = [ctypes.c_void_p]
        leptonica.lheapGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapGetCount(*args):
        """
        ('L_HEAP', '*lh')       
  lheapGetCount()

      Input:  lheap
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapGetCount(*args)
    
    

    try:
        leptonica.lheapSortStrictOrder.argtypes = [ctypes.c_void_p]
        leptonica.lheapSortStrictOrder.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapSortStrictOrder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapSortStrictOrder(*args):
        """
        ('L_HEAP', '*lh')       
  lheapSortStrictOrder()

      Input:  lh (heap, with internal array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This sorts a heap into strict order.
      (2) For each element, starting at the end of the array and
          working forward, the element is swapped with the head
          element and then allowed to swap down onto a heap of
          size reduced by one.  The result is that the heap is
          reversed but in strict order.  The array elements are
          then reversed to put it in the original order.


        """
        args = _convert_params(*args)
        
        return leptonica.lheapSortStrictOrder(*args)
    
    

    try:
        leptonica.lheapRemove.argtypes = [ctypes.c_void_p]
        leptonica.lheapRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function lheapRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapRemove(*args):
        """
        ('L_HEAP', '*lh')       
  lheapRemove()

      Input:  lheap
      Return: ptr to item popped from the root of the heap,
              or null if the heap is empty or on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapRemove(*args)
    
    

    try:
        leptonica.lheapCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.lheapCreate.restype = lambda address: L_HEAP(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function lheapCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapCreate(*args):
        """
        ('l_int32', 'nalloc')       
('l_int32', 'direction')       
  lheapCreate()

      Input:  size of ptr array to be alloc'd (0 for default)
              direction (L_SORT_INCREASING, L_SORT_DECREASING)
      Return: lheap, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapCreate(*args)
    
    

    try:
        leptonica.lheapSwapDown.argtypes = [ctypes.c_void_p]
        leptonica.lheapSwapDown.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapSwapDown not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapSwapDown(*args):
        """
        ('L_HEAP', '*lh')       
  lheapSwapDown()

      Input:  lh (heap)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is called after an item has been popped off the
          root of the heap, and the last item in the heap has
          been placed at the root.
      (2) To regain the heap order, we let it bubble down,
          iteratively swapping with one of its children.  For a
          decreasing sort, it swaps with the largest child; for
          an increasing sort, the smallest.  This continues until
          it either reaches the lowest level in the heap, or the
          parent finds that neither child should swap with it
          (e.g., for a decreasing heap, the parent is larger
          than or equal to both children).


        """
        args = _convert_params(*args)
        
        return leptonica.lheapSwapDown(*args)
    
    

    try:
        leptonica.lheapPrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lheapPrint.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lheapPrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapPrint(*args):
        """
        ('FILE', '*fp')       
('L_HEAP', '*lh')       
  lheapPrint()

      Input:  stream
              lheap
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapPrint(*args)
    




class gifio(object):
    """  gifio.c

    Read gif from file
          PIX        *pixReadStreamGif()
          static PIX *pixInterlaceGIF()

    Write gif to file
          l_int32     pixWriteStreamGif()

    Read/write from/to memory (see warning)
          PIX        *pixReadMemGif()
          l_int32     pixWriteMemGif()

    The initial version of this module was generously contribued by
    Antony Dovgal.  He can be contacted at:  tony *AT* daylessday.org

    Important version information:

    (1) This uses the gif library, version 4.1.6 or later.
        Do not use 4.1.4.  It has serious problems handling 1 bpp images.

    (2) There are some issues with version 5.0:
        - valgrind detects uninitialized values used used for writing
          and conditionally jumping in EGifPutScreenDesc().
        - DGifSlurp() crashes on some images, apparently triggered by
          by some GIF extension records.  The latter problem has been
          reported but not resolved as of October 2013.

    (3) E. Raymond has been changing the high-level interface with 5.0
        and 5.1, and to keep up we have used macros determined by the
        major and minor version numbers.

"""
    
    try:
        leptonica.pixReadMemGif.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemGif.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemGif(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
  pixReadMemGif()

      Input:  data (const; gif-encoded)
              size (of data)
      Return: pix, or null on error

  Notes:
      (1) Of course, we are cheating here -- writing the data to file
          in gif format and reading it back in.  We can't use the
          GNU runtime extension fmemopen() to avoid writing to a file
          because libgif doesn't have a file stream interface!
      (2) This should not be assumed to be safe from a sophisticated
          attack, even though we have attempted to make the filename
          difficult to guess by embedding the process number and the
          current time in microseconds.  The best way to handle
          temporary files is to use file descriptors (capabilities)
          or file handles.  However, I know of no way to do this
          for gif files because of the way that libgif handles the
          file descriptors.  The canonical approach would be to do this:
              char templ[] = "hiddenfilenameXXXXXX";
              l_int32 fd = mkstemp(templ);
              FILE *fp = fdopen(fd, "w+b");
              fwrite(data, 1, size, fp);
              rewind(fp);
              Pix *pix = pixReadStreamGif(fp);
          but this fails because fp is in a bad state after writing.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemGif(*args)
    
    

    try:
        leptonica.pixWriteMemGif.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemGif.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemGif(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
  pixWriteMemGif()

      Input:  &data (<return> data of gif compressed image)
              &size (<return> size of returned data)
              pix
      Return: 0 if OK, 1 on error

  Notes:
      (1) See comments in pixReadMemGif()


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemGif(*args)
    
    

    try:
        leptonica.pixWriteStreamGif.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamGif.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamGif(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
  pixWriteStreamGif()

      Input:  stream
              pix (1, 2, 4, 8, 16 or 32 bpp)
      Return: 0 if OK, 1 on error

  Notes:
      (1) All output gif have colormaps.  If the pix is 32 bpp rgb,
          this quantizes the colors and writes out 8 bpp.
          If the pix is 16 bpp grayscale, it converts to 8 bpp first.
      (2) We can't write to memory using open_memstream() because
          the gif functions write through a file descriptor, not a
          file stream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamGif(*args)
    
    

    try:
        leptonica.pixReadStreamGif.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamGif.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamGif(*args):
        """
        ('FILE', '*fp')       
  pixReadStreamGif()

      Input:  stream
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamGif(*args)
    




class projective(object):
    """  projective.c

      Projective (4 pt) image transformation using a sampled
      (to nearest integer) transform on each dest point
           PIX      *pixProjectiveSampledPta()
           PIX      *pixProjectiveSampled()

      Projective (4 pt) image transformation using interpolation
      (or area mapping) for anti-aliasing images that are
      2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
           PIX      *pixProjectivePta()
           PIX      *pixProjective()
           PIX      *pixProjectivePtaColor()
           PIX      *pixProjectiveColor()
           PIX      *pixProjectivePtaGray()
           PIX      *pixProjectiveGray()

      Projective transform including alpha (blend) component
           PIX      *pixProjectivePtaWithAlpha()

      Projective coordinate transformation
           l_int32   getProjectiveXformCoeffs()
           l_int32   projectiveXformSampledPt()
           l_int32   projectiveXformPt()

      A projective transform can be specified as a specific functional
      mapping between 4 points in the source and 4 points in the dest.
      It preserves straight lines, but is less stable than a bilinear
      transform, because it contains a division by a quantity that
      can get arbitrarily small.)

      We give both a projective coordinate transformation and
      two projective image transformations.

      For the former, we ask for the coordinate value (x',y')
      in the transformed space for any point (x,y) in the original
      space.  The coefficients of the transformation are found by
      solving 8 simultaneous equations for the 8 coordinates of
      the 4 points in src and dest.  The transformation can then
      be used to compute the associated image transform, by
      computing, for each dest pixel, the relevant pixel(s) in
      the source.  This can be done either by taking the closest
      src pixel to each transformed dest pixel ("sampling") or
      by doing an interpolation and averaging over 4 source
      pixels with appropriate weightings ("interpolated").

      A typical application would be to remove keystoning
      due to a projective transform in the imaging system.

      The projective transform is given by specifying two equations:

          x' = (ax + by + c) / (gx + hy + 1)
          y' = (dx + ey + f) / (gx + hy + 1)

      where the eight coefficients have been computed from four
      sets of these equations, each for two corresponding data pts.
      In practice, once the coefficients are known, we use the
      equations "backwards": for each point (x,y) in the dest image,
      these two equations are used to compute the corresponding point
      (x',y') in the src.  That computed point in the src is then used
      to determine the corresponding dest pixel value in one of two ways:

       - sampling: simply take the value of the src pixel in which this
                   point falls
       - interpolation: take appropriate linear combinations of the
                        four src pixels that this dest pixel would
                        overlap, with the coefficients proportional
                        to the amount of overlap

      For small warp where there is little scale change, (e.g.,
      for rotation) area mapping is nearly equivalent to interpolation.

      Typical relative timing of pointwise transforms (sampled = 1.0):
      8 bpp:   sampled        1.0
               interpolated   1.5
      32 bpp:  sampled        1.0
               interpolated   1.6
      Additionally, the computation time/pixel is nearly the same
      for 8 bpp and 32 bpp, for both sampled and interpolated.

"""
    
    try:
        leptonica.pixProjectiveSampledPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjectiveSampledPta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectiveSampledPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveSampledPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       
  pixProjectiveSampledPta()

      Input:  pixs (all depths)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary.
      (2) Retains colormap, which you can do for a sampled transform..
      (3) No 3 of the 4 points may be collinear.
      (4) For 8 and 32 bpp pix, better quality is obtained by the
          somewhat slower pixProjectivePta().  See that
          function for relative timings between sampled and interpolated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveSampledPta(*args)
    
    

    try:
        leptonica.pixProjectivePtaWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixProjectivePtaWithAlpha.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectivePtaWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePtaWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('PIX', '*pixg')       
('l_float32', 'fract')       
('l_int32', 'border')       
  pixProjectivePtaWithAlpha()

      Input:  pixs (32 bpp rgb)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              pixg (<optional> 8 bpp, for alpha channel, can be null)
              fract (between 0.0 and 1.0, with 0.0 fully transparent
                     and 1.0 fully opaque)
              border (of pixels added to capture transformed source pixels)
      Return: pixd, or null on error

  Notes:
      (1) The alpha channel is transformed separately from pixs,
          and aligns with it, being fully transparent outside the
          boundary of the transformed pixs.  For pixels that are fully
          transparent, a blending function like pixBlendWithGrayMask()
          will give zero weight to corresponding pixels in pixs.
      (2) If pixg is NULL, it is generated as an alpha layer that is
          partially opaque, using @fract.  Otherwise, it is cropped
          to pixs if required and @fract is ignored.  The alpha channel
          in pixs is never used.
      (3) Colormaps are removed.
      (4) When pixs is transformed, it doesn't matter what color is brought
          in because the alpha channel will be transparent (0) there.
      (5) To avoid losing source pixels in the destination, it may be
          necessary to add a border to the source pix before doing
          the projective transformation.  This can be any non-negative
          number.
      (6) The input @ptad and @ptas are in a coordinate space before
          the border is added.  Internally, we compensate for this
          before doing the projective transform on the image after
          the border is added.
      (7) The default setting for the border values in the alpha channel
          is 0 (transparent) for the outermost ring of pixels and
          (0.5 * fract * 255) for the second ring.  When blended over
          a second image, this
          (a) shrinks the visible image to make a clean overlap edge
              with an image below, and
          (b) softens the edges by weakening the aliasing there.
          Use l_setAlphaMaskBorder() to change these values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePtaWithAlpha(*args)
    
    

    try:
        leptonica.projectiveXformPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.projectiveXformPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function projectiveXformPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def projectiveXformPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pxp')       
('l_float32', '*pyp')       
  projectiveXformPt()

      Input:  vc (vector of 8 coefficients)
              (x, y)  (initial point)
              (&xp, &yp)   (<return> transformed point)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This computes the floating point location of the transformed point.
      (2) It does not check ptrs for returned data!


        """
        args = _convert_params(*args)
        
        return leptonica.projectiveXformPt(*args)
    
    

    try:
        leptonica.pixProjectivePtaColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixProjectivePtaColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectivePtaColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePtaColor(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint32', 'colorval')       
  pixProjectivePtaColor()

      Input:  pixs (32 bpp)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePtaColor(*args)
    
    

    try:
        leptonica.pixProjectivePtaGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixProjectivePtaGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectivePtaGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePtaGray(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint8', 'grayval')       
  pixProjectivePtaGray()

      Input:  pixs (8 bpp)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePtaGray(*args)
    
    

    try:
        leptonica.getProjectiveXformCoeffs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getProjectiveXformCoeffs.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getProjectiveXformCoeffs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getProjectiveXformCoeffs(*args):
        """
        ('PTA', '*ptas')       
('PTA', '*ptad')       
('l_float32', '**pvc')       
  getProjectiveXformCoeffs()

      Input:  ptas  (source 4 points; unprimed)
              ptad  (transformed 4 points; primed)
              &vc   (<return> vector of coefficients of transform)
      Return: 0 if OK; 1 on error

  We have a set of 8 equations, describing the projective
  transformation that takes 4 points (ptas) into 4 other
  points (ptad).  These equations are:

          x1' = (c[0]*x1 + c[1]*y1 + c[2]) / (c[6]*x1 + c[7]*y1 + 1)
          y1' = (c[3]*x1 + c[4]*y1 + c[5]) / (c[6]*x1 + c[7]*y1 + 1)
          x2' = (c[0]*x2 + c[1]*y2 + c[2]) / (c[6]*x2 + c[7]*y2 + 1)
          y2' = (c[3]*x2 + c[4]*y2 + c[5]) / (c[6]*x2 + c[7]*y2 + 1)
          x3' = (c[0]*x3 + c[1]*y3 + c[2]) / (c[6]*x3 + c[7]*y3 + 1)
          y3' = (c[3]*x3 + c[4]*y3 + c[5]) / (c[6]*x3 + c[7]*y3 + 1)
          x4' = (c[0]*x4 + c[1]*y4 + c[2]) / (c[6]*x4 + c[7]*y4 + 1)
          y4' = (c[3]*x4 + c[4]*y4 + c[5]) / (c[6]*x4 + c[7]*y4 + 1)

  Multiplying both sides of each eqn by the denominator, we get

           AC = B

  where B and C are column vectors

         B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
         C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]

  and A is the 8x8 matrix

             x1   y1     1     0   0    0   -x1*x1'  -y1*x1'
              0    0     0    x1   y1   1   -x1*y1'  -y1*y1'
             x2   y2     1     0   0    0   -x2*x2'  -y2*x2'
              0    0     0    x2   y2   1   -x2*y2'  -y2*y2'
             x3   y3     1     0   0    0   -x3*x3'  -y3*x3'
              0    0     0    x3   y3   1   -x3*y3'  -y3*y3'
             x4   y4     1     0   0    0   -x4*x4'  -y4*x4'
              0    0     0    x4   y4   1   -x4*y4'  -y4*y4'

  These eight equations are solved here for the coefficients C.

  These eight coefficients can then be used to find the mapping
  (x,y) --> (x',y'):

           x' = (c[0]x + c[1]y + c[2]) / (c[6]x + c[7]y + 1)
           y' = (c[3]x + c[4]y + c[5]) / (c[6]x + c[7]y + 1)

  that is implemented in projectiveXformSampled() and
  projectiveXFormInterpolated().


        """
        args = _convert_params(*args)
        
        return leptonica.getProjectiveXformCoeffs(*args)
    
    

    try:
        leptonica.projectiveXformSampledPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.projectiveXformSampledPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function projectiveXformSampledPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def projectiveXformSampledPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       
  projectiveXformSampledPt()

      Input:  vc (vector of 8 coefficients)
              (x, y)  (initial point)
              (&xp, &yp)   (<return> transformed point)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds the nearest pixel coordinates of the transformed point.
      (2) It does not check ptrs for returned data!


        """
        args = _convert_params(*args)
        
        return leptonica.projectiveXformSampledPt(*args)
    
    

    try:
        leptonica.pixProjective.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjective.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjective not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjective(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       
  pixProjective()

      Input:  pixs (all depths; colormap ok)
              vc  (vector of 8 coefficients for projective transformation)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary
      (2) Removes any existing colormap, if necessary, before transforming


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjective(*args)
    
    

    try:
        leptonica.pixProjectiveSampled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjectiveSampled.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectiveSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveSampled(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       
  pixProjectiveSampled()

      Input:  pixs (all depths)
              vc  (vector of 8 coefficients for projective transformation)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary.
      (2) Retains colormap, which you can do for a sampled transform..
      (3) For 8 or 32 bpp, much better quality is obtained by the
          somewhat slower pixProjective().  See that function
          for relative timings between sampled and interpolated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveSampled(*args)
    
    

    try:
        leptonica.pixProjectiveGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixProjectiveGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectiveGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint8', 'grayval')       
  pixProjectiveGray()

      Input:  pixs (8 bpp)
              vc  (vector of 8 coefficients for projective transformation)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveGray(*args)
    
    

    try:
        leptonica.pixProjectivePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjectivePta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectivePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       
  pixProjectivePta()

      Input:  pixs (all depths; colormap ok)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Brings in either black or white pixels from the boundary
      (2) Removes any existing colormap, if necessary, before transforming


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePta(*args)
    
    

    try:
        leptonica.pixProjectiveColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixProjectiveColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProjectiveColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint32', 'colorval')       
  pixProjectiveColor()

      Input:  pixs (32 bpp)
              vc  (vector of 8 coefficients for projective transformation)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveColor(*args)
    




class arrayaccess(object):
    """  arrayaccess.c

     Access within an array of 32-bit words

           l_int32     l_getDataBit()
           void        l_setDataBit()
           void        l_clearDataBit()
           void        l_setDataBitVal()
           l_int32     l_getDataDibit()
           void        l_setDataDibit()
           void        l_clearDataDibit()
           l_int32     l_getDataQbit()
           void        l_setDataQbit()
           void        l_clearDataQbit()
           l_int32     l_getDataByte()
           void        l_setDataByte()
           l_int32     l_getDataTwoBytes()
           void        l_setDataTwoBytes()
           l_int32     l_getDataFourBytes()
           void        l_setDataFourBytes()

     Note that these all require 32-bit alignment, and hence an input
     ptr to l_uint32.  However, this is not enforced by the compiler.
     Instead, we allow the use of a void* ptr, because the line ptrs
     are an efficient way to get random access (see pixGetLinePtrs()).
     It is then necessary to cast internally within each function
     because ptr arithmetic requires knowing the size of the units
     being referenced.

"""
    
    try:
        leptonica.l_setDataBit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_setDataBit.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataBit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataBit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_setDataBit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: void

  Action: sets the pixel to 1


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataBit(*args)
    
    

    try:
        leptonica.l_clearDataBit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_clearDataBit.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_clearDataBit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_clearDataBit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_clearDataBit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: void

  Action: sets the (1-bit) pixel to 0


        """
        args = _convert_params(*args)
        
        return leptonica.l_clearDataBit(*args)
    
    

    try:
        leptonica.l_getDataFourBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataFourBytes.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_getDataFourBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataFourBytes(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_getDataFourBytes()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: value of the n-th (4-byte) pixel


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataFourBytes(*args)
    
    

    try:
        leptonica.l_setDataQbit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataQbit.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataQbit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataQbit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       
  l_setDataQbit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
              val   (val to be inserted: 0 - 0xf)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataQbit(*args)
    
    

    try:
        leptonica.l_setDataTwoBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataTwoBytes.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataTwoBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataTwoBytes(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       
  l_setDataTwoBytes()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
              val   (val to be inserted: 0 - 0xffff)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataTwoBytes(*args)
    
    

    try:
        leptonica.l_getDataBit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataBit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_getDataBit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataBit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_getDataBit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: val of the nth (1-bit) pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataBit(*args)
    
    

    try:
        leptonica.l_setDataFourBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataFourBytes.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataFourBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataFourBytes(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       
  l_setDataFourBytes()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
              val   (val to be inserted: 0 - 0xffffffff)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataFourBytes(*args)
    
    

    try:
        leptonica.l_setDataByte.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataByte.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataByte not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataByte(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       
  l_setDataByte()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
              val   (val to be inserted: 0 - 0xff)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataByte(*args)
    
    

    try:
        leptonica.l_getDataDibit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataDibit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_getDataDibit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataDibit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_getDataDibit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: val of the nth (2-bit) pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataDibit(*args)
    
    

    try:
        leptonica.l_getDataByte.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataByte.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_getDataByte not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataByte(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_getDataByte()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: value of the n-th (byte) pixel


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataByte(*args)
    
    

    try:
        leptonica.l_getDataTwoBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataTwoBytes.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_getDataTwoBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataTwoBytes(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_getDataTwoBytes()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: value of the n-th (2-byte) pixel


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataTwoBytes(*args)
    
    

    try:
        leptonica.l_clearDataDibit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_clearDataDibit.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_clearDataDibit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_clearDataDibit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_clearDataDibit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: void

  Action: sets the (2-bit) pixel to 0


        """
        args = _convert_params(*args)
        
        return leptonica.l_clearDataDibit(*args)
    
    

    try:
        leptonica.l_clearDataQbit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_clearDataQbit.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_clearDataQbit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_clearDataQbit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_clearDataQbit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: void

  Action: sets the (4-bit) pixel to 0


        """
        args = _convert_params(*args)
        
        return leptonica.l_clearDataQbit(*args)
    
    

    try:
        leptonica.l_setDataBitVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataBitVal.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataBitVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataBitVal(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       
  l_setDataBitVal()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
              val   (val to be inserted: 0 or 1)
      Return: void

  Notes:
      (1) This is an accessor for a 1 bpp pix.
      (2) It is actually a little slower than using:
            if (val == 0)
                l_ClearDataBit(line, n);
            else
                l_SetDataBit(line, n);


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataBitVal(*args)
    
    

    try:
        leptonica.l_getDataQbit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataQbit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_getDataQbit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataQbit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
  l_getDataQbit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
      Return: val of the nth (4-bit) pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataQbit(*args)
    
    

    try:
        leptonica.l_setDataDibit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataDibit.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_setDataDibit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataDibit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       
  l_setDataDibit()

      Input:  line  (ptr to beginning of data line)
              n     (pixel index)
              val   (val to be inserted: 0 - 3)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataDibit(*args)
    




class morphdwa(object):
    """  morphdwa.c

    Binary morphological (dwa) ops with brick Sels
         PIX     *pixDilateBrickDwa()
         PIX     *pixErodeBrickDwa()
         PIX     *pixOpenBrickDwa()
         PIX     *pixCloseBrickDwa()

    Binary composite morphological (dwa) ops with brick Sels
         PIX     *pixDilateCompBrickDwa()
         PIX     *pixErodeCompBrickDwa()
         PIX     *pixOpenCompBrickDwa()
         PIX     *pixCloseCompBrickDwa()

    Binary extended composite morphological (dwa) ops with brick Sels
         PIX     *pixDilateCompBrickExtendDwa()
         PIX     *pixErodeCompBrickExtendDwa()
         PIX     *pixOpenCompBrickExtendDwa()
         PIX     *pixCloseCompBrickExtendDwa()
         l_int32  getExtendedCompositeParameters()

    These are higher-level interfaces for dwa morphology with brick Sels.
    Because many morphological operations are performed using
    separable brick Sels, it is useful to have a simple interface
    for this.

    We have included all 58 of the brick Sels that are generated
    by selaAddBasic().  These are sufficient for all the decomposable
    bricks up to size 63, which is the limit for dwa Sels with
    origins at the center of the Sel.

    All three sets can be used as the basic interface for general
    brick operations.  Here are the internal calling sequences:

      (1) If you try to apply a non-decomposable operation, such as
          pixErodeBrickDwa(), with a Sel size that doesn't exist,
          this calls a decomposable operation, pixErodeCompBrickDwa(),
          instead.  This can differ in linear Sel size by up to
          2 pixels from the request.

      (2) If either Sel brick dimension is greater than 63, the extended
          composite function is called.

      (3) The extended composite function calls the composite function
          a number of times with size 63, and once with size < 63.
          Because each operation with a size of 63 is done compositely
          with 7 x 9 (exactly 63), the net result is correct in
          length to within 2 pixels.

    For composite operations, both using a comb and extended (beyond 63),
    horizontal and vertical operations are composed separately
    and sequentially.

    We have also included use of all the 76 comb Sels that are generated
    by selaAddDwaCombs().  The generated code is in dwacomb.2.c
    and dwacomblow.2.c.  These are used for the composite dwa
    brick operations.

    The non-composite brick operations, such as pixDilateBrickDwa(),
    will call the associated composite operation in situations where
    the requisite brick Sel has not been compiled into fmorphgen*.1.c.

    If you want to use brick Sels that are not represented in the
    basic set of 58, you must generate the dwa code to implement them.
    You have three choices for how to use these:

    (1) Add both the new Sels and the dwa code to the library:
        - For simplicity, add your new brick Sels to those defined
          in selaAddBasic().
        - Recompile the library.
        - Make prog/fmorphautogen.
        - Run prog/fmorphautogen, to generate new versions of the
          dwa code in fmorphgen.1.c and fmorphgenlow.1.c.
        - Copy these two files to src.
        - Recompile the library again.
        - Use the new brick Sels in your program and compile it.

    (2) Make both the new Sels and dwa code outside the library,
        and link it directly to an executable:
        - Write a function to generate the new Sels in a Sela, and call
          fmorphautogen(sela, <N>, filename) to generate the code.
        - Compile your program that uses the newly generated function
          pixMorphDwa_<N>(), and link to the two new C files.

    (3) Make the new Sels in the library and use the dwa code outside it:
        - Add code in the library to generate your new brick Sels.
          (It is suggested that you NOT add these Sels to the
          selaAddBasic() function; write a new function that generates
          a new Sela.)
        - Recompile the library.
        - Write a small program that generates the Sela and calls
          fmorphautogen(sela, <N>, filename) to generate the code.
        - Compile your program that uses the newly generated function
          pixMorphDwa_<N>(), and link to the two new C files.
       As an example of this approach, see prog/dwamorph*_reg.c:
        - added selaAddDwaLinear() to sel2.c
        - wrote dwamorph1_reg.c, to generate the dwa code.
        - compiled and linked the generated code with the application,
          dwamorph2_reg.c.  (Note: because this was a regression test,
          dwamorph1_reg also builds and runs the application program.)

"""
    
    try:
        leptonica.pixDilateBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) These implement 2D brick Sels, using linear Sels generated
          with selaAddBasic().
      (2) A brick Sel has hits for all elements.
      (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (4) Do separably if both hsize and vsize are > 1.
      (5) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (6) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (7) For clarity, if the case is known, use these patterns:
          (a) pixd = pixDilateBrickDwa(NULL, pixs, ...);
          (b) pixDilateBrickDwa(pixs, pixs, ...);
          (c) pixDilateBrickDwa(pixd, pixs, ...);
      (8) The size of pixd is determined by pixs.
      (9) If either linear Sel is not found, this calls
          the appropriate decomposible function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateBrickDwa(*args)
    
    

    try:
        leptonica.pixCloseCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseCompBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseCompBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) This implements a separable composite safe closing with 2D
          brick Sels.
      (2) For efficiency, it may decompose each linear morphological
          operation into two (brick + comb).
      (3) A brick Sel has hits for all elements.
      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (5) Do separably if both hsize and vsize are > 1.
      (6) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (7) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (8) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...);
          (b) pixCloseCompBrickDwa(pixs, pixs, ...);
          (c) pixCloseCompBrickDwa(pixd, pixs, ...);
      (9) The size of pixd is determined by pixs.
      (10) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
           but not necessarily equal to it.  It attempts to optimize:
              (a) for consistency with the input values: the product
                  of terms is close to the input size
              (b) for efficiency of the operation: the sum of the
                  terms is small; ideally about twice the square
                   root of the input size.
           So, for example, if the input hsize = 37, which is
           a prime number, the decomposer will break this into two
           terms, 6 and 6, so that the net result is a dilation
           with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseCompBrickDwa(*args)
    
    

    try:
        leptonica.pixCloseCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseCompBrickExtendDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseCompBrickExtendDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

      (1) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (2) There is no need to call this directly:  pixCloseCompBrickDwa()
          calls this function if either brick dimension exceeds 63.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.pixOpenCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenCompBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenCompBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) These implement a separable composite opening with 2D brick Sels.
      (2) For efficiency, it may decompose each linear morphological
          operation into two (brick + comb).
      (3) A brick Sel has hits for all elements.
      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (5) Do separably if both hsize and vsize are > 1.
      (6) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (7) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (8) For clarity, if the case is known, use these patterns:
          (a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...);
          (b) pixOpenCompBrickDwa(pixs, pixs, ...);
          (c) pixOpenCompBrickDwa(pixd, pixs, ...);
      (9) The size of pixd is determined by pixs.
      (10) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
           but not necessarily equal to it.  It attempts to optimize:
              (a) for consistency with the input values: the product
                  of terms is close to the input size
              (b) for efficiency of the operation: the sum of the
                  terms is small; ideally about twice the square
                   root of the input size.
           So, for example, if the input hsize = 37, which is
           a prime number, the decomposer will break this into two
           terms, 6 and 6, so that the net result is a dilation
           with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenCompBrickDwa(*args)
    
    

    try:
        leptonica.pixCloseBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) This is a 'safe' closing; we add an extra border of 32 OFF
          pixels for the standard asymmetric b.c.
      (2) These implement 2D brick Sels, using linear Sels generated
          with selaAddBasic().
      (3) A brick Sel has hits for all elements.
      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (5) Do separably if both hsize and vsize are > 1.
      (6) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (7) Note that we must always set or clear the border pixels
          before each operation, depending on the the b.c.
          (symmetric or asymmetric).
      (8) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (9) For clarity, if the case is known, use these patterns:
          (a) pixd = pixCloseBrickDwa(NULL, pixs, ...);
          (b) pixCloseBrickDwa(pixs, pixs, ...);
          (c) pixCloseBrickDwa(pixd, pixs, ...);
      (10) The size of the result is determined by pixs.
      (11) If either linear Sel is not found, this calls
           the appropriate decomposible function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseBrickDwa(*args)
    
    

    try:
        leptonica.pixErodeBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) These implement 2D brick Sels, using linear Sels generated
          with selaAddBasic().
      (2) A brick Sel has hits for all elements.
      (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (4) Do separably if both hsize and vsize are > 1.
      (5) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (6) Note that we must always set or clear the border pixels
          before each operation, depending on the the b.c.
          (symmetric or asymmetric).
      (7) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (8) For clarity, if the case is known, use these patterns:
          (a) pixd = pixErodeBrickDwa(NULL, pixs, ...);
          (b) pixErodeBrickDwa(pixs, pixs, ...);
          (c) pixErodeBrickDwa(pixd, pixs, ...);
      (9) The size of the result is determined by pixs.
      (10) If either linear Sel is not found, this calls
           the appropriate decomposible function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeBrickDwa(*args)
    
    

    try:
        leptonica.pixDilateCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateCompBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateCompBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) These implement a separable composite dilation with 2D brick Sels.
      (2) For efficiency, it may decompose each linear morphological
          operation into two (brick + comb).
      (3) A brick Sel has hits for all elements.
      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (5) Do separably if both hsize and vsize are > 1.
      (6) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (7) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (8) For clarity, if the case is known, use these patterns:
          (a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...);
          (b) pixDilateCompBrickDwa(pixs, pixs, ...);
          (c) pixDilateCompBrickDwa(pixd, pixs, ...);
      (9) The size of pixd is determined by pixs.
      (10) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
           but not necessarily equal to it.  It attempts to optimize:
              (a) for consistency with the input values: the product
                  of terms is close to the input size
              (b) for efficiency of the operation: the sum of the
                  terms is small; ideally about twice the square
                   root of the input size.
           So, for example, if the input hsize = 37, which is
           a prime number, the decomposer will break this into two
           terms, 6 and 6, so that the net result is a dilation
           with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateCompBrickDwa(*args)
    
    

    try:
        leptonica.pixOpenCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenCompBrickExtendDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenCompBrickExtendDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

      (1) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (2) There is no need to call this directly:  pixOpenCompBrickDwa()
          calls this function if either brick dimension exceeds 63.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.getExtendedCompositeParameters.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getExtendedCompositeParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getExtendedCompositeParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getExtendedCompositeParameters(*args):
        """
        ('l_int32', 'size')       
('l_int32', '*pn')       
('l_int32', '*pextra')       
('l_int32', '*pactualsize')       
  getExtendedCompositeParameters()

      Input:  size (of linear Sel)
              &pn (<return> number of 63 wide convolutions)
              &pextra (<return> size of extra Sel)
              &actualsize (<optional return> actual size used in operation)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The DWA implementation allows Sels to be used with hits
          up to 31 pixels from the origin, either horizontally or
          vertically.  Larger Sels can be used if decomposed into
          a set of operations with Sels not exceeding 63 pixels
          in either width or height (and with the origin as close
          to the center of the Sel as possible).
      (2) This returns the decomposition of a linear Sel of length
          @size into a set of @n Sels of length 63 plus an extra
          Sel of length @extra.
      (3) For notation, let w == @size, n == @n, and e == @extra.
          We have 1 < e < 63.

          Then if w < 64, we have n = 0 and e = w.
          The general formula for w > 63 is:
             w = 63 + (n - 1) * 62 + (e - 1)

          Where did this come from?  Each successive convolution with
          a Sel of length L adds a total length (L - 1) to w.
          This accounts for using 62 for each additional Sel of size 63,
          and using (e - 1) for the additional Sel of size e.

          Solving for n and e for w > 63:
             n = 1 + Int((w - 63) / 62)
             e = w - 63 - (n - 1) * 62 + 1

          The extra part is decomposed into two factors f1 and f2,
          and the actual size of the extra part is
             e' = f1 * f2
          Then the actual width is:
             w' = 63 + (n - 1) * 62 + f1 * f2 - 1


        """
        args = _convert_params(*args)
        
        return leptonica.getExtendedCompositeParameters(*args)
    
    

    try:
        leptonica.pixDilateCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateCompBrickExtendDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateCompBrickExtendDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) Ankur Jain suggested and implemented extending the composite
          DWA operations beyond the 63 pixel limit.  This is a
          simplified and approximate implementation of the extension.
          This allows arbitrary Dwa morph operations using brick Sels,
          by decomposing the horizontal and vertical dilations into
          a sequence of 63-element dilations plus a dilation of size
          between 3 and 62.
      (2) The 63-element dilations are exact, whereas the extra dilation
          is approximate, because the underlying decomposition is
          in pixDilateCompBrickDwa().  See there for further details.
      (3) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (4) There is no need to call this directly:  pixDilateCompBrickDwa()
          calls this function if either brick dimension exceeds 63.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.pixErodeCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeCompBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeCompBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) These implement a separable composite erosion with 2D brick Sels.
      (2) For efficiency, it may decompose each linear morphological
          operation into two (brick + comb).
      (3) A brick Sel has hits for all elements.
      (4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (5) Do separably if both hsize and vsize are > 1.
      (6) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (7) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (8) For clarity, if the case is known, use these patterns:
          (a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...);
          (b) pixErodeCompBrickDwa(pixs, pixs, ...);
          (c) pixErodeCompBrickDwa(pixd, pixs, ...);
      (9) The size of pixd is determined by pixs.
      (10) CAUTION: both hsize and vsize are being decomposed.
          The decomposer chooses a product of sizes (call them
          'terms') for each that is close to the input size,
           but not necessarily equal to it.  It attempts to optimize:
              (a) for consistency with the input values: the product
                  of terms is close to the input size
              (b) for efficiency of the operation: the sum of the
                  terms is small; ideally about twice the square
                   root of the input size.
           So, for example, if the input hsize = 37, which is
           a prime number, the decomposer will break this into two
           terms, 6 and 6, so that the net result is a dilation
           with hsize = 36.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeCompBrickDwa(*args)
    
    

    try:
        leptonica.pixOpenBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenBrickDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenBrickDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) These implement 2D brick Sels, using linear Sels generated
          with selaAddBasic().
      (2) A brick Sel has hits for all elements.
      (3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
      (4) Do separably if both hsize and vsize are > 1.
      (5) It is necessary that both horizontal and vertical Sels
          of the input size are defined in the basic sela.
      (6) Note that we must always set or clear the border pixels
          before each operation, depending on the the b.c.
          (symmetric or asymmetric).
      (7) There are three cases:
          (a) pixd == null   (result into new pixd)
          (b) pixd == pixs   (in-place; writes result back to pixs)
          (c) pixd != pixs   (puts result into existing pixd)
      (8) For clarity, if the case is known, use these patterns:
          (a) pixd = pixOpenBrickDwa(NULL, pixs, ...);
          (b) pixOpenBrickDwa(pixs, pixs, ...);
          (c) pixOpenBrickDwa(pixd, pixs, ...);
      (9) The size of the result is determined by pixs.
      (10) If either linear Sel is not found, this calls
           the appropriate decomposible function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenBrickDwa(*args)
    
    

    try:
        leptonica.pixErodeCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeCompBrickExtendDwa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeCompBrickExtendDwa()

      Input:  pixd  (<optional>; this can be null, equal to pixs,
                     or different from pixs)
              pixs (1 bpp)
              hsize (width of brick Sel)
              vsize (height of brick Sel)
      Return: pixd

  Notes:
      (1) See pixDilateCompBrickExtendDwa() for usage.
      (2) There is no need to call this directly:  pixErodeCompBrickDwa()
          calls this function if either brick dimension exceeds 63.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeCompBrickExtendDwa(*args)
    




class leptwin(object):
    """  leptwin.c

    This file contains Leptonica routines needed only on Microsoft Windows

    Currently it only contains one public function
    (based on dibsectn.c by jmh, 03-30-98):

      HBITMAP    pixGetWindowsHBITMAP(PIX *pix)

"""
    



class zlibmem(object):
    """   zlibmem.c

      zlib operations in memory, using bbuffer
          l_uint8   *zlibCompress()
          l_uint8   *zlibUncompress()


    This provides an example use of the byte buffer utility
    (see bbuffer.c for details of how the bbuffer works internally).
    We use zlib to compress and decompress a byte array from
    one memory buffer to another.  The standard method uses streams,
    but here we use the bbuffer as an expandable queue of pixels
    for both the reading and writing sides of each operation.

    With memory mapping, one should be able to compress between
    memory buffers by using the file system to buffer everything in
    the background, but the bbuffer implementation is more portable.

"""
    
    try:
        leptonica.zlibUncompress.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.zlibUncompress.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function zlibUncompress not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def zlibUncompress(*args):
        """
        ('l_uint8', '*datain')       
('size_t', 'nin')       
('size_t', '*pnout')       
  zlibUncompress()

      Input:  datain (byte buffer with compressed input data)
              nin    (number of bytes of input data)
              &nout  (<return> number of bytes of output data)
      Return: dataout (uncompressed data), or null on error

  Notes:
      (1) See zlibCompress().


        """
        args = _convert_params(*args)
        
        return leptonica.zlibUncompress(*args)
    
    

    try:
        leptonica.zlibCompress.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.zlibCompress.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function zlibCompress not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def zlibCompress(*args):
        """
        ('l_uint8', '*datain')       
('size_t', 'nin')       
('size_t', '*pnout')       
  zlibCompress()

      Input:  datain (byte buffer with input data)
              nin    (number of bytes of input data)
              &nout  (<return> number of bytes of output data)
      Return: dataout (compressed data), or null on error

  Notes:
      (1) We repeatedly read in and fill up an input buffer,
          compress the data, and read it back out.  zlib
          uses two byte buffers internally in the z_stream
          data structure.  We use the bbuffers to feed data
          into the fixed bufferin, and feed it out of bufferout,
          in the same way that a pair of streams would normally
          be used if the data were being read from one file
          and written to another.  This is done iteratively,
          compressing L_BUF_SIZE bytes of input data at a time.


        """
        args = _convert_params(*args)
        
        return leptonica.zlibCompress(*args)
    




class pixalloc(object):
    """  pixalloc.c

      Custom memory storage with allocator and deallocator

          l_int32       pmsCreate()
          void          pmsDestroy()
          void         *pmsCustomAlloc()
          void          pmsCustomDealloc()
          void         *pmsGetAlloc()
          l_int32       pmsGetLevelForAlloc()
          l_int32       pmsGetLevelForDealloc()
          void          pmsLogInfo()

"""
    
    try:
        leptonica.pmsCreate.argtypes = [ctypes.c_size_t, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pmsCreate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pmsCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsCreate(*args):
        """
        ('size_t', 'minsize')       
('size_t', 'smallest')       
('NUMA', '*numalloc')       
('const char', '*logfile')       
  pmsCreate()

      Input:  minsize (of data chunk that can be supplied by pms)
              smallest (bytes of the smallest pre-allocated data chunk.
              numalloc (array with the number of data chunks for each
                        size that are in the memory store)
              logfile (use for debugging; null otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes the size of the block of memory required
          and allocates it.  Each chunk starts on a 32-bit word boundary.
          The chunk sizes are in powers of 2, starting at @smallest,
          and the number of levels and chunks at each level is
          specified by @numalloc.
      (2) This is intended to manage the image data for a small number
          of relatively large pix.  The system malloc is expected to
          handle very large numbers of small chunks efficiently.
      (3) Important: set the allocators and call this function
          before any pix have been allocated.  Destroy all the pix
          in the normal way before calling pmsDestroy().
      (4) The pms struct is stored in a static global, so this function
          is not thread-safe.  When used, there must be only one thread
          per process.


        """
        args = _convert_params(*args)
        
        return leptonica.pmsCreate(*args)
    
    

    try:
        leptonica.pmsGetLevelForDealloc.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pmsGetLevelForDealloc.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pmsGetLevelForDealloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsGetLevelForDealloc(*args):
        """
        ('void', '*data')       
('l_int32', '*plevel')       
  pmsGetLevelForDealloc()

      Input: data (ptr to memory chunk)
             &level (<return> level in memory store; -1 if allocated
                     outside the store)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pmsGetLevelForDealloc(*args)
    
    

    try:
        leptonica.pmsGetLevelForAlloc.argtypes = [ctypes.c_size_t, ctypes.c_void_p]
        leptonica.pmsGetLevelForAlloc.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pmsGetLevelForAlloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsGetLevelForAlloc(*args):
        """
        ('size_t', 'nbytes')       
('l_int32', '*plevel')       
  pmsGetLevelForAlloc()

      Input: nbytes (min number of bytes in the chunk to be retrieved)
             &level (<return>; -1 if either too small or too large)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pmsGetLevelForAlloc(*args)
    
    

    try:
        leptonica.pmsCustomAlloc.argtypes = [ctypes.c_size_t]
        leptonica.pmsCustomAlloc.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function pmsCustomAlloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsCustomAlloc(*args):
        """
        ('size_t', 'nbytes')       
  pmsCustomAlloc()

      Input: nbytes (min number of bytes in the chunk to be retrieved)
      Return: data (ptr to chunk)

  Notes:
      (1) This attempts to find a suitable pre-allocated chunk.
          If not found, it dynamically allocates the chunk.
      (2) If logging is turned on, the allocations that are not taken
          from the memory store, and are at least as large as the
          minimum size the store can handle, are logged to file.


        """
        args = _convert_params(*args)
        
        return leptonica.pmsCustomAlloc(*args)
    
    

    try:
        leptonica.pmsDestroy.argtypes = []
        leptonica.pmsDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pmsDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsDestroy(*args):
        """
               
  pmsDestroy()

      Input:  (none)
      Return: void

  Notes:
      (1) Important: call this function at the end of the program, after
          the last pix has been destroyed.


        """
        args = _convert_params(*args)
        
        return leptonica.pmsDestroy(*args)
    
    

    try:
        leptonica.pmsCustomDealloc.argtypes = [ctypes.c_void_p]
        leptonica.pmsCustomDealloc.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pmsCustomDealloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsCustomDealloc(*args):
        """
        ('void', '*data')       
  pmsCustomDealloc()

      Input: data (to be freed or returned to the storage)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.pmsCustomDealloc(*args)
    
    

    try:
        leptonica.pmsGetAlloc.argtypes = [ctypes.c_size_t]
        leptonica.pmsGetAlloc.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function pmsGetAlloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsGetAlloc(*args):
        """
        ('size_t', 'nbytes')       
  pmsGetAlloc()

      Input:  nbytes
      Return: data

  Notes:
      (1) This is called when a request for pix data cannot be
          obtained from the preallocated memory store.  After use it
          is freed like normal memory.
      (2) If logging is on, only write out allocs that are as large as
          the minimum size handled by the memory store.
      (3) size_t is %lu on 64 bit platforms and %u on 32 bit platforms.
          The C99 platform-independent format specifier for size_t is %zu,
          but windows hasn't conformed, so we are forced to go back to
          C89, use %lu, and cast to get platform-independence.  Ugh.


        """
        args = _convert_params(*args)
        
        return leptonica.pmsGetAlloc(*args)
    
    

    try:
        leptonica.pmsLogInfo.argtypes = []
        leptonica.pmsLogInfo.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pmsLogInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsLogInfo(*args):
        """
               
  pmsLogInfo()

      Input:  (none)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.pmsLogInfo(*args)
    




class gifiostub(object):
    """  gifiostub.c

     Stubs for gifio.c functions

"""
    



class fpix2(object):
    """  fpix2.c

    This file has these FPix utilities:
       - interconversions with pix, fpix, dpix
       - min and max values
       - integer scaling
       - arithmetic operations
       - set all
       - border functions
       - simple rasterop (source --> dest)
       - geometric transforms

    Interconversions between Pix, FPix and DPix
          FPIX          *pixConvertToFPix()
          DPIX          *pixConvertToDPix()
          PIX           *fpixConvertToPix()
          PIX           *fpixDisplayMaxDynamicRange()  [useful for debugging]
          DPIX          *fpixConvertToDPix()
          PIX           *dpixConvertToPix()
          FPIX          *dpixConvertToFPix()

    Min/max value
          l_int32        fpixGetMin()
          l_int32        fpixGetMax()
          l_int32        dpixGetMin()
          l_int32        dpixGetMax()

    Integer scaling
          FPIX          *fpixScaleByInteger()
          DPIX          *dpixScaleByInteger()

    Arithmetic operations
          FPIX          *fpixLinearCombination()
          l_int32        fpixAddMultConstant()
          DPIX          *dpixLinearCombination()
          l_int32        dpixAddMultConstant()

    Set all
          l_int32        fpixSetAllArbitrary()
          l_int32        dpixSetAllArbitrary()

    FPix border functions
          FPIX          *fpixAddBorder()
          FPIX          *fpixRemoveBorder()
          FPIX          *fpixAddMirroredBorder()
          FPIX          *fpixAddContinuedBorder()
          FPIX          *fpixAddSlopeBorder()

    FPix simple rasterop
          l_int32        fpixRasterop()

    FPix rotation by multiples of 90 degrees
          FPIX          *fpixRotateOrth()
          FPIX          *fpixRotate180()
          FPIX          *fpixRotate90()
          FPIX          *fpixFlipLR()
          FPIX          *fpixFlipTB()

    FPix affine and projective interpolated transforms
          FPIX          *fpixAffinePta()
          FPIX          *fpixAffine()
          FPIX          *fpixProjectivePta()
          FPIX          *fpixProjective()
          l_int32        linearInterpolatePixelFloat()

    Thresholding to 1 bpp Pix
          PIX           *fpixThresholdToPix()

    Generate function from components
          FPIX          *pixComponentFunction()

"""
    
    try:
        leptonica.fpixRotate180.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixRotate180.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixRotate180 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRotate180(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       
  fpixRotate180()

      Input:  fpixd  (<optional>; can be null, equal to fpixs,
                      or different from fpixs)
              fpixs
      Return: fpixd, or null on error

  Notes:
      (1) This does a 180 rotation of the image about the center,
          which is equivalent to a left-right flip about a vertical
          line through the image center, followed by a top-bottom
          flip about a horizontal line through the image center.
      (2) There are 3 cases for input:
          (a) fpixd == null (creates a new fpixd)
          (b) fpixd == fpixs (in-place operation)
          (c) fpixd != fpixs (existing fpixd)
      (3) For clarity, use these three patterns, respectively:
          (a) fpixd = fpixRotate180(NULL, fpixs);
          (b) fpixRotate180(fpixs, fpixs);
          (c) fpixRotate180(fpixd, fpixs);


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRotate180(*args)
    
    

    try:
        leptonica.fpixAddSlopeBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddSlopeBorder.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAddSlopeBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddSlopeBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  fpixAddSlopeBorder()

      Input:  fpixs
              left, right, top, bot (pixels on each side to be added)
      Return: fpixd, or null on error

  Notes:
      (1) This adds pixels on each side whose values have a normal
          derivative equal to the normal derivative at the boundary
          of fpixs.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddSlopeBorder(*args)
    
    

    try:
        leptonica.fpixDisplayMaxDynamicRange.argtypes = [ctypes.c_void_p]
        leptonica.fpixDisplayMaxDynamicRange.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixDisplayMaxDynamicRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixDisplayMaxDynamicRange(*args):
        """
        ('FPIX', '*fpixs')       
  fpixDisplayMaxDynamicRange()

      Input:  fpixs
      Return: pixd (8 bpp), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixDisplayMaxDynamicRange(*args)
    
    

    try:
        leptonica.dpixAddMultConstant.argtypes = [ctypes.c_void_p, ctypes.c_double, ctypes.c_double]
        leptonica.dpixAddMultConstant.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixAddMultConstant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixAddMultConstant(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', 'addc')       
('l_float64', 'multc')       
  dpixAddMultConstant()

      Input:  dpix
              addc  (use 0.0 to skip the operation)
              multc (use 1.0 to skip the operation)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) It can be used to multiply each pixel by a constant,
          and also to add a constant to each pixel.  Multiplication
          is done first.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixAddMultConstant(*args)
    
    

    try:
        leptonica.fpixLinearCombination.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.fpixLinearCombination.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixLinearCombination not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixLinearCombination(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs1')       
('FPIX', '*fpixs2')       
('l_float32', 'a')       
('l_float32', 'b')       
  fpixLinearCombination()

      Input:  fpixd (<optional>; this can be null, equal to fpixs1, or
                     different from fpixs1)
              fpixs1 (can be == to fpixd)
              fpixs2
              a, b (multiplication factors on fpixs1 and fpixs2, rsp.)
      Return: fpixd always

  Notes:
      (1) Computes pixelwise linear combination: a * src1 + b * src2
      (2) Alignment is to UL corner.
      (3) There are 3 cases.  The result can go to a new dest,
          in-place to fpixs1, or to an existing input dest:
          * fpixd == null:   (src1 + src2) --> new fpixd
          * fpixd == fpixs1:  (src1 + src2) --> src1  (in-place)
          * fpixd != fpixs1: (src1 + src2) --> input fpixd
      (4) fpixs2 must be different from both fpixd and fpixs1.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixLinearCombination(*args)
    
    

    try:
        leptonica.fpixRotate90.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixRotate90.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixRotate90 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRotate90(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'direction')       
  fpixRotate90()

      Input:  fpixs
              direction (1 = clockwise,  -1 = counter-clockwise)
      Return: fpixd, or null on error

  Notes:
      (1) This does a 90 degree rotation of the image about the center,
          either cw or ccw, returning a new pix.
      (2) The direction must be either 1 (cw) or -1 (ccw).


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRotate90(*args)
    
    

    try:
        leptonica.dpixSetAllArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_double]
        leptonica.dpixSetAllArbitrary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixSetAllArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetAllArbitrary(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', 'inval')       
  dpixSetAllArbitrary()

      Input:  dpix
              val (to set at each pixel)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetAllArbitrary(*args)
    
    

    try:
        leptonica.dpixLinearCombination.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.dpixLinearCombination.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixLinearCombination not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixLinearCombination(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs1')       
('DPIX', '*dpixs2')       
('l_float32', 'a')       
('l_float32', 'b')       
  dpixLinearCombination()

      Input:  dpixd (<optional>; this can be null, equal to dpixs1, or
                     different from dpixs1)
              dpixs1 (can be == to dpixd)
              dpixs2
              a, b (multiplication factors on dpixs1 and dpixs2, rsp.)
      Return: dpixd always

  Notes:
      (1) Computes pixelwise linear combination: a * src1 + b * src2
      (2) Alignment is to UL corner.
      (3) There are 3 cases.  The result can go to a new dest,
          in-place to dpixs1, or to an existing input dest:
          * dpixd == null:   (src1 + src2) --> new dpixd
          * dpixd == dpixs1:  (src1 + src2) --> src1  (in-place)
          * dpixd != dpixs1: (src1 + src2) --> input dpixd
      (4) dpixs2 must be different from both dpixd and dpixs1.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixLinearCombination(*args)
    
    

    try:
        leptonica.fpixGetMin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetMin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixGetMin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetMin(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', '*pminval')       
('l_int32', '*pxminloc')       
('l_int32', '*pyminloc')       
  fpixGetMin()

      Input:  fpix
              &minval (<optional return> min value)
              &xminloc (<optional return> x location of min)
              &yminloc (<optional return> y location of min)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetMin(*args)
    
    

    try:
        leptonica.fpixAffinePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixAffinePta.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAffinePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAffinePta(*args):
        """
        ('FPIX', '*fpixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'border')       
('l_float32', 'inval')       
  fpixAffinePta()

      Input:  fpixs (8 bpp)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              border (size of extension with constant normal derivative)
              inval (value brought in; typ. 0)
      Return: fpixd, or null on error

  Notes:
      (1) If @border > 0, all four sides are extended by that distance,
          and removed after the transformation is finished.  Pixels
          that would be brought in to the trimmed result from outside
          the extended region are assigned @inval.  The purpose of
          extending the image is to avoid such assignments.
      (2) On the other hand, you may want to give all pixels that
          are brought in from outside fpixs a specific value.  In that
          case, set @border == 0.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAffinePta(*args)
    
    

    try:
        leptonica.fpixGetMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetMax.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixGetMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetMax(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', '*pmaxval')       
('l_int32', '*pxmaxloc')       
('l_int32', '*pymaxloc')       
  fpixGetMax()

      Input:  fpix
              &maxval (<optional return> max value)
              &xmaxloc (<optional return> x location of max)
              &ymaxloc (<optional return> y location of max)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetMax(*args)
    
    

    try:
        leptonica.fpixAddContinuedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddContinuedBorder.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAddContinuedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddContinuedBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  fpixAddContinuedBorder()

      Input:  fpixs
              left, right, top, bot (pixels on each side to be added)
      Return: fpixd, or null on error

  Notes:
      (1) This adds pixels on each side whose values are equal to
          the value on the closest boundary pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddContinuedBorder(*args)
    
    

    try:
        leptonica.fpixScaleByInteger.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixScaleByInteger.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixScaleByInteger not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixScaleByInteger(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'factor')       
  fpixScaleByInteger()

      Input:  fpixs (low resolution, subsampled)
              factor (scaling factor)
      Return: fpixd (interpolated result), or null on error

  Notes:
      (1) The width wd of fpixd is related to ws of fpixs by:
              wd = factor * (ws - 1) + 1   (and ditto for the height)
          We avoid special-casing boundary pixels in the interpolation
          by constructing fpixd by inserting (factor - 1) interpolated
          pixels between each pixel in fpixs.  Then
               wd = ws + (ws - 1) * (factor - 1)    (same as above)
          This also has the advantage that if we subsample by @factor,
          throwing out all the interpolated pixels, we regain the
          original low resolution fpix.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixScaleByInteger(*args)
    
    

    try:
        leptonica.fpixRemoveBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixRemoveBorder.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixRemoveBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRemoveBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  fpixRemoveBorder()

      Input:  fpixs
              left, right, top, bot (pixels on each side to be removed)
      Return: fpixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRemoveBorder(*args)
    
    

    try:
        leptonica.fpixFlipLR.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixFlipLR.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixFlipLR not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixFlipLR(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       
  pixFlipLR()

      Input:  fpixd (<optional>; can be null, equal to fpixs,
                     or different from fpixs)
              fpixs
      Return: fpixd, or null on error

  Notes:
      (1) This does a left-right flip of the image, which is
          equivalent to a rotation out of the plane about a
          vertical line through the image center.
      (2) There are 3 cases for input:
          (a) fpixd == null (creates a new fpixd)
          (b) fpixd == fpixs (in-place operation)
          (c) fpixd != fpixs (existing fpixd)
      (3) For clarity, use these three patterns, respectively:
          (a) fpixd = fpixFlipLR(NULL, fpixs);
          (b) fpixFlipLR(fpixs, fpixs);
          (c) fpixFlipLR(fpixd, fpixs);
      (4) If an existing fpixd is not the same size as fpixs, the
          image data will be reallocated.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixFlipLR(*args)
    
    

    try:
        leptonica.fpixRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixRotateOrth.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRotateOrth(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'quads')       
  fpixRotateOrth()

      Input:  fpixs
              quads (0-3; number of 90 degree cw rotations)
      Return: fpixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRotateOrth(*args)
    
    

    try:
        leptonica.pixConvertToFPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertToFPix.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertToFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToFPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncomps')       
  pixConvertToFPix()

      Input:  pix (1, 2, 4, 8, 16 or 32 bpp)
              ncomps (number of components: 3 for RGB, 1 otherwise)
      Return: fpix, or null on error

  Notes:
      (1) If colormapped, remove to grayscale.
      (2) If 32 bpp and @ncomps == 3, this is RGB; convert to luminance.
          In all other cases the src image is treated as having a single
          component of pixel values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToFPix(*args)
    
    

    try:
        leptonica.pixComponentFunction.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixComponentFunction.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixComponentFunction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixComponentFunction(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'rnum')       
('l_float32', 'gnum')       
('l_float32', 'bnum')       
('l_float32', 'rdenom')       
('l_float32', 'gdenom')       
('l_float32', 'bdenom')       
  pixComponentFunction()

      Input:  pix (32 bpp rgb)
              rnum, gnum, bnum (coefficients for numerator)
              rdenom, gdenom, bdenom (coefficients for denominator)
      Return: fpixd, or null on error

  Notes:
      (1) This stores a function of the component values of each
          input pixel in @fpixd.
      (2) The function is a ratio of linear combinations of component values.
          There are two special cases for denominator coefficients:
          (a) The denominator is 1.0: input 0 for all denominator coefficients
          (b) Only one component is used in the denominator: input 1.0
              for that denominator component and 0.0 for the other two.
      (3) If the denominator is 0, multiply by an arbitrary number that
          is much larger than 1.  Choose 256 "arbitrarily".



        """
        args = _convert_params(*args)
        
        return leptonica.pixComponentFunction(*args)
    
    

    try:
        leptonica.fpixProjective.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixProjective.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixProjective not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixProjective(*args):
        """
        ('FPIX', '*fpixs')       
('l_float32', '*vc')       
('l_float32', 'inval')       
  fpixProjective()

      Input:  fpixs (8 bpp)
              vc  (vector of 8 coefficients for projective transformation)
              inval (value brought in; typ. 0)
      Return: fpixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixProjective(*args)
    
    

    try:
        leptonica.dpixConvertToFPix.argtypes = [ctypes.c_void_p]
        leptonica.dpixConvertToFPix.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixConvertToFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixConvertToFPix(*args):
        """
        ('DPIX', '*dpix')       
  dpixConvertToFPix()

      Input:  dpix
      Return: fpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixConvertToFPix(*args)
    
    

    try:
        leptonica.pixConvertToDPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertToDPix.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConvertToDPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToDPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncomps')       
  pixConvertToDPix()

      Input:  pix (1, 2, 4, 8, 16 or 32 bpp)
              ncomps (number of components: 3 for RGB, 1 otherwise)
      Return: dpix, or null on error

  Notes:
      (1) If colormapped, remove to grayscale.
      (2) If 32 bpp and @ncomps == 3, this is RGB; convert to luminance.
          In all other cases the src image is treated as having a single
          component of pixel values.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToDPix(*args)
    
    

    try:
        leptonica.dpixGetMin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetMin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixGetMin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetMin(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', '*pminval')       
('l_int32', '*pxminloc')       
('l_int32', '*pyminloc')       
  dpixGetMin()

      Input:  dpix
              &minval (<optional return> min value)
              &xminloc (<optional return> x location of min)
              &yminloc (<optional return> y location of min)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetMin(*args)
    
    

    try:
        leptonica.fpixConvertToDPix.argtypes = [ctypes.c_void_p]
        leptonica.fpixConvertToDPix.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixConvertToDPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvertToDPix(*args):
        """
        ('FPIX', '*fpix')       
  fpixConvertToDPix()

      Input:  fpix
      Return: dpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvertToDPix(*args)
    
    

    try:
        leptonica.dpixScaleByInteger.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dpixScaleByInteger.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixScaleByInteger not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixScaleByInteger(*args):
        """
        ('DPIX', '*dpixs')       
('l_int32', 'factor')       
  dpixScaleByInteger()

      Input:  dpixs (low resolution, subsampled)
              factor (scaling factor)
      Return: dpixd (interpolated result), or null on error

  Notes:
      (1) The width wd of dpixd is related to ws of dpixs by:
              wd = factor * (ws - 1) + 1   (and ditto for the height)
          We avoid special-casing boundary pixels in the interpolation
          by constructing fpixd by inserting (factor - 1) interpolated
          pixels between each pixel in fpixs.  Then
               wd = ws + (ws - 1) * (factor - 1)    (same as above)
          This also has the advantage that if we subsample by @factor,
          throwing out all the interpolated pixels, we regain the
          original low resolution dpix.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixScaleByInteger(*args)
    
    

    try:
        leptonica.fpixAddMirroredBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddMirroredBorder.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAddMirroredBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddMirroredBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  fpixAddMirroredBorder()

      Input:  fpixs
              left, right, top, bot (pixels on each side to be added)
      Return: fpixd, or null on error

  Notes:
      (1) See pixAddMirroredBorder() for situations of usage.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddMirroredBorder(*args)
    
    

    try:
        leptonica.fpixAddBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddBorder.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAddBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
  fpixAddBorder()

      Input:  fpixs
              left, right, top, bot (pixels on each side to be added)
      Return: fpixd, or null on error

  Notes:
      (1) Adds border of '0' 32-bit pixels


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddBorder(*args)
    
    

    try:
        leptonica.fpixProjectivePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixProjectivePta.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixProjectivePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixProjectivePta(*args):
        """
        ('FPIX', '*fpixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'border')       
('l_float32', 'inval')       
  fpixProjectivePta()

      Input:  fpixs (8 bpp)
              ptad  (4 pts of final coordinate space)
              ptas  (4 pts of initial coordinate space)
              border (size of extension with constant normal derivative)
              inval (value brought in; typ. 0)
      Return: fpixd, or null on error

  Notes:
      (1) If @border > 0, all four sides are extended by that distance,
          and removed after the transformation is finished.  Pixels
          that would be brought in to the trimmed result from outside
          the extended region are assigned @inval.  The purpose of
          extending the image is to avoid such assignments.
      (2) On the other hand, you may want to give all pixels that
          are brought in from outside fpixs a specific value.  In that
          case, set @border == 0.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixProjectivePta(*args)
    
    

    try:
        leptonica.fpixFlipTB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixFlipTB.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixFlipTB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixFlipTB(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       
  fpixFlipTB()

      Input:  fpixd (<optional>; can be null, equal to fpixs,
                     or different from fpixs)
              fpixs
      Return: fpixd, or null on error

  Notes:
      (1) This does a top-bottom flip of the image, which is
          equivalent to a rotation out of the plane about a
          horizontal line through the image center.
      (2) There are 3 cases for input:
          (a) fpixd == null (creates a new fpixd)
          (b) fpixd == fpixs (in-place operation)
          (c) fpixd != fpixs (existing fpixd)
      (3) For clarity, use these three patterns, respectively:
          (a) fpixd = fpixFlipTB(NULL, fpixs);
          (b) fpixFlipTB(fpixs, fpixs);
          (c) fpixFlipTB(fpixd, fpixs);
      (4) If an existing fpixd is not the same size as fpixs, the
          image data will be reallocated.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixFlipTB(*args)
    
    

    try:
        leptonica.fpixConvertToPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixConvertToPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixConvertToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvertToPix(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'outdepth')       
('l_int32', 'negvals')       
('l_int32', 'errorflag')       
  fpixConvertToPix()

      Input:  fpixs
              outdepth (0, 8, 16 or 32 bpp)
              negvals (L_CLIP_TO_ZERO, L_TAKE_ABSVAL)
              errorflag (1 to output error stats; 0 otherwise)
      Return: pixd, or null on error

  Notes:
      (1) Use @outdepth = 0 to programmatically determine the
          output depth.  If no values are greater than 255,
          it will set outdepth = 8; otherwise to 16 or 32.
      (2) Because we are converting a float to an unsigned int
          with a specified dynamic range (8, 16 or 32 bits), errors
          can occur.  If errorflag == TRUE, output the number
          of values out of range, both negative and positive.
      (3) If a pixel value is positive and out of range, clip to
          the maximum value represented at the outdepth of 8, 16
          or 32 bits.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvertToPix(*args)
    
    

    try:
        leptonica.fpixThresholdToPix.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixThresholdToPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixThresholdToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixThresholdToPix(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', 'thresh')       
  fpixThresholdToPix()

      Input:  fpix
              thresh
      Return: pixd (1 bpp), or null on error

  Notes:
      (1) For all values of fpix that are <= thresh, sets the pixel
          in pixd to 1.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixThresholdToPix(*args)
    
    

    try:
        leptonica.dpixGetMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetMax.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixGetMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetMax(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', '*pmaxval')       
('l_int32', '*pxmaxloc')       
('l_int32', '*pymaxloc')       
  dpixGetMax()

      Input:  dpix
              &maxval (<optional return> max value)
              &xmaxloc (<optional return> x location of max)
              &ymaxloc (<optional return> y location of max)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetMax(*args)
    
    

    try:
        leptonica.fpixSetAllArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixSetAllArbitrary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixSetAllArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetAllArbitrary(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', 'inval')       
  fpixSetAllArbitrary()

      Input:  fpix
              val (to set at each pixel)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetAllArbitrary(*args)
    
    

    try:
        leptonica.dpixConvertToPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixConvertToPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixConvertToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixConvertToPix(*args):
        """
        ('DPIX', '*dpixs')       
('l_int32', 'outdepth')       
('l_int32', 'negvals')       
('l_int32', 'errorflag')       
  dpixConvertToPix()

      Input:  dpixs
              outdepth (0, 8, 16 or 32 bpp)
              negvals (L_CLIP_TO_ZERO, L_TAKE_ABSVAL)
              errorflag (1 to output error stats; 0 otherwise)
      Return: pixd, or null on error

  Notes:
      (1) Use @outdepth = 0 to programmatically determine the
          output depth.  If no values are greater than 255,
          it will set outdepth = 8; otherwise to 16 or 32.
      (2) Because we are converting a float to an unsigned int
          with a specified dynamic range (8, 16 or 32 bits), errors
          can occur.  If errorflag == TRUE, output the number
          of values out of range, both negative and positive.
      (3) If a pixel value is positive and out of range, clip to
          the maximum value represented at the outdepth of 8, 16
          or 32 bits.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixConvertToPix(*args)
    
    

    try:
        leptonica.fpixAffine.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixAffine.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixAffine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAffine(*args):
        """
        ('FPIX', '*fpixs')       
('l_float32', '*vc')       
('l_float32', 'inval')       
  fpixAffine()

      Input:  fpixs (8 bpp)
              vc  (vector of 8 coefficients for projective transformation)
              inval (value brought in; typ. 0)
      Return: fpixd, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAffine(*args)
    
    

    try:
        leptonica.fpixRasterop.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixRasterop.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixRasterop not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRasterop(*args):
        """
        ('FPIX', '*fpixd')       
('l_int32', 'dx')       
('l_int32', 'dy')       
('l_int32', 'dw')       
('l_int32', 'dh')       
('FPIX', '*fpixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
  fpixRasterop()

      Input:  fpixd  (dest fpix)
              dx     (x val of UL corner of dest rectangle)
              dy     (y val of UL corner of dest rectangle)
              dw     (width of dest rectangle)
              dh     (height of dest rectangle)
              fpixs  (src fpix)
              sx     (x val of UL corner of src rectangle)
              sy     (y val of UL corner of src rectangle)
      Return: 0 if OK; 1 on error.

  Notes:
      (1) This is similiar in structure to pixRasterop(), except
          it only allows copying from the source into the destination.
          For that reason, no op code is necessary.  Additionally,
          all pixels are 32 bit words (float values), which makes
          the copy very simple.
      (2) Clipping of both src and dest fpix are done automatically.
      (3) This allows in-place copying, without checking to see if
          the result is valid:  use for in-place with caution!


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRasterop(*args)
    
    

    try:
        leptonica.linearInterpolatePixelFloat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.linearInterpolatePixelFloat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function linearInterpolatePixelFloat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearInterpolatePixelFloat(*args):
        """
        ('l_float32', '*datas')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_float32', 'inval')       
('l_float32', '*pval')       
  linearInterpolatePixelFloat()

      Input:  datas (ptr to beginning of float image data)
              wpls (32-bit word/line for this data array)
              w, h (of image)
              x, y (floating pt location for evaluation)
              inval (float value brought in from the outside when the
                     input x,y location is outside the image)
              &val (<return> interpolated float value)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a standard linear interpolation function.  It is
          equivalent to area weighting on each component, and
          avoids "jaggies" when rendering sharp edges.


        """
        args = _convert_params(*args)
        
        return leptonica.linearInterpolatePixelFloat(*args)
    
    

    try:
        leptonica.fpixAddMultConstant.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.fpixAddMultConstant.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixAddMultConstant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddMultConstant(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', 'addc')       
('l_float32', 'multc')       
  fpixAddMultConstant()

      Input:  fpix
              addc  (use 0.0 to skip the operation)
              multc (use 1.0 to skip the operation)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is an in-place operation.
      (2) It can be used to multiply each pixel by a constant,
          and also to add a constant to each pixel.  Multiplication
          is done first.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddMultConstant(*args)
    




class psio1stub(object):
    """  psio1stub.c

     Stubs for psio1.c functions

"""
    



class fpix1(object):
    """  fpix1.c

    This file has basic constructors, destructors and field accessors
    for FPix, FPixa and DPix.  It also has uncompressed read/write.

    FPix Create/copy/destroy
          FPIX          *fpixCreate()
          FPIX          *fpixCreateTemplate()
          FPIX          *fpixClone()
          FPIX          *fpixCopy()
          l_int32        fpixResizeImageData()
          void           fpixDestroy()

    FPix accessors
          l_int32        fpixGetDimensions()
          l_int32        fpixSetDimensions()
          l_int32        fpixGetWpl()
          l_int32        fpixSetWpl()
          l_int32        fpixGetRefcount()
          l_int32        fpixChangeRefcount()
          l_int32        fpixGetResolution()
          l_int32        fpixSetResolution()
          l_int32        fpixCopyResolution()
          l_float32     *fpixGetData()
          l_int32        fpixSetData()
          l_int32        fpixGetPixel()
          l_int32        fpixSetPixel()

    FPixa Create/copy/destroy
          FPIXA         *fpixaCreate()
          FPIXA         *fpixaCopy()
          void           fpixaDestroy()

    FPixa addition
          l_int32        fpixaAddFPix()
          static l_int32 fpixaExtendArray()
          static l_int32 fpixaExtendArrayToSize()

    FPixa accessors
          l_int32        fpixaGetCount()
          l_int32        fpixaChangeRefcount()
          FPIX          *fpixaGetFPix()
          l_int32        fpixaGetFPixDimensions()
          l_int32        fpixaGetPixel()
          l_int32        fpixaSetPixel()

    DPix Create/copy/destroy
          DPIX          *dpixCreate()
          DPIX          *dpixCreateTemplate()
          DPIX          *dpixClone()
          DPIX          *dpixCopy()
          l_int32        dpixResizeImageData()
          void           dpixDestroy()

    DPix accessors
          l_int32        dpixGetDimensions()
          l_int32        dpixSetDimensions()
          l_int32        dpixGetWpl()
          l_int32        dpixSetWpl()
          l_int32        dpixGetRefcount()
          l_int32        dpixChangeRefcount()
          l_int32        dpixGetResolution()
          l_int32        dpixSetResolution()
          l_int32        dpixCopyResolution()
          l_float64     *dpixGetData()
          l_int32        dpixSetData()
          l_int32        dpixGetPixel()
          l_int32        dpixSetPixel()

    FPix serialized I/O
          FPIX          *fpixRead()
          FPIX          *fpixReadStream()
          l_int32        fpixWrite()
          l_int32        fpixWriteStream()
          FPIX          *fpixEndianByteSwap()

    DPix serialized I/O
          DPIX          *dpixRead()
          DPIX          *dpixReadStream()
          l_int32        dpixWrite()
          l_int32        dpixWriteStream()
          DPIX          *dpixEndianByteSwap()

    Print FPix (subsampled, for debugging)
          l_int32        fpixPrintStream()

"""
    
    try:
        leptonica.dpixReadStream.argtypes = [ctypes.c_void_p]
        leptonica.dpixReadStream.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixReadStream(*args):
        """
        ('FILE', '*fp')       
  dpixReadStream()

      Input:  stream
      Return: dpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixReadStream(*args)
    
    

    try:
        leptonica.fpixaGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fpixaGetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixaGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetPixel(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pval')       
  fpixaGetPixel()

      Input:  fpixa
              index (into fpixa array)
              (x,y) pixel coords
              &val (<return> pixel value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetPixel(*args)
    
    

    try:
        leptonica.dpixSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_double]
        leptonica.dpixSetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetPixel(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float64', 'val')       
  dpixSetPixel()

      Input:  dpix
              (x,y) pixel coords
              val (pixel value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetPixel(*args)
    
    

    try:
        leptonica.fpixaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.fpixaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function fpixaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaDestroy(*args):
        """
        ('FPIXA', '**pfpixa')       
  fpixaDestroy()

      Input:  &fpixa (<can be nulled>)
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the fpixa.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaDestroy(*args)
    
    

    try:
        leptonica.fpixaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaChangeRefcount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaChangeRefcount(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'delta')       
  fpixaChangeRefcount()

      Input:  fpixa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaChangeRefcount(*args)
    
    

    try:
        leptonica.dpixRead.argtypes = [ctypes.c_void_p]
        leptonica.dpixRead.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixRead(*args):
        """
        ('const char', '*filename')       
  dpixRead()

      Input:  filename
      Return: dpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixRead(*args)
    
    

    try:
        leptonica.fpixRead.argtypes = [ctypes.c_void_p]
        leptonica.fpixRead.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRead(*args):
        """
        ('const char', '*filename')       
  fpixRead()

      Input:  filename
      Return: fpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRead(*args)
    
    

    try:
        leptonica.dpixGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.dpixGetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetPixel(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float64', '*pval')       
  dpixGetPixel()

      Input:  dpix
              (x,y) pixel coords
              &val (<return> pixel value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetPixel(*args)
    
    

    try:
        leptonica.dpixCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixCreate.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCreate(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
  dpixCreate()

      Input:  width, height
      Return: dpix (with data allocated and initialized to 0),
                     or null on error

  Notes:
      (1) Makes a DPix of specified size, with the data array
          allocated and initialized to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCreate(*args)
    
    

    try:
        leptonica.fpixSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixSetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetPixel(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'val')       
  fpixSetPixel()

      Input:  fpix
              (x,y) pixel coords
              val (pixel value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetPixel(*args)
    
    

    try:
        leptonica.dpixWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixWrite(*args):
        """
        ('const char', '*filename')       
('DPIX', '*dpix')       
  dpixWrite()

      Input:  filename
              dpix
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixWrite(*args)
    
    

    try:
        leptonica.fpixWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixWriteStream(*args):
        """
        ('FILE', '*fp')       
('FPIX', '*fpix')       
  fpixWriteStream()

      Input:  stream (opened for "wb")
              fpix
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixWriteStream(*args)
    
    

    try:
        leptonica.fpixReadStream.argtypes = [ctypes.c_void_p]
        leptonica.fpixReadStream.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixReadStream(*args):
        """
        ('FILE', '*fp')       
  fpixReadStream()

      Input:  stream
      Return: fpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixReadStream(*args)
    
    

    try:
        leptonica.dpixCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixCopy.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCopy(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       
  dpixCopy()

      Input:  dpixd (<optional>; can be null, or equal to dpixs,
                    or different from dpixs)
              dpixs
      Return: dpixd, or null on error

  Notes:
      (1) There are three cases:
            (a) dpixd == null  (makes a new dpix; refcount = 1)
            (b) dpixd == dpixs  (no-op)
            (c) dpixd != dpixs  (data copy; no change in refcount)
          If the refcount of dpixd > 1, case (c) will side-effect
          these handles.
      (2) The general pattern of use is:
             dpixd = dpixCopy(dpixd, dpixs);
          This will work for all three cases.
          For clarity when the case is known, you can use:
            (a) dpixd = dpixCopy(NULL, dpixs);
            (c) dpixCopy(dpixd, dpixs);
      (3) For case (c), we check if dpixs and dpixd are the same size.
          If so, the data is copied directly.
          Otherwise, the data is reallocated to the correct size
          and the copy proceeds.  The refcount of dpixd is unchanged.
      (4) This operation, like all others that may involve a pre-existing
          dpixd, will side-effect any existing clones of dpixd.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCopy(*args)
    
    

    try:
        leptonica.fpixGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fpixGetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetPixel(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pval')       
  fpixGetPixel()

      Input:  fpix
              (x,y) pixel coords
              &val (<return> pixel value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetPixel(*args)
    
    

    try:
        leptonica.fpixPrintStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixPrintStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixPrintStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixPrintStream(*args):
        """
        ('FILE', '*fp')       
('FPIX', '*fpix')       
('l_int32', 'factor')       
  fpixPrintStream()

      Input:  stream
              fpix
              factor (subsampled)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Subsampled printout of fpix for debugging.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixPrintStream(*args)
    
    

    try:
        leptonica.fpixSetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixSetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixSetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetDimensions(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'w')       
('l_int32', 'h')       
  fpixSetDimensions()

      Input:  fpix
              w, h
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetDimensions(*args)
    
    

    try:
        leptonica.fpixCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixCopy.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCopy(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       
  fpixCopy()

      Input:  fpixd (<optional>; can be null, or equal to fpixs,
                    or different from fpixs)
              fpixs
      Return: fpixd, or null on error

  Notes:
      (1) There are three cases:
            (a) fpixd == null  (makes a new fpix; refcount = 1)
            (b) fpixd == fpixs  (no-op)
            (c) fpixd != fpixs  (data copy; no change in refcount)
          If the refcount of fpixd > 1, case (c) will side-effect
          these handles.
      (2) The general pattern of use is:
             fpixd = fpixCopy(fpixd, fpixs);
          This will work for all three cases.
          For clarity when the case is known, you can use:
            (a) fpixd = fpixCopy(NULL, fpixs);
            (c) fpixCopy(fpixd, fpixs);
      (3) For case (c), we check if fpixs and fpixd are the same size.
          If so, the data is copied directly.
          Otherwise, the data is reallocated to the correct size
          and the copy proceeds.  The refcount of fpixd is unchanged.
      (4) This operation, like all others that may involve a pre-existing
          fpixd, will side-effect any existing clones of fpixd.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCopy(*args)
    
    

    try:
        leptonica.dpixEndianByteSwap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixEndianByteSwap.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixEndianByteSwap(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       
  dpixEndianByteSwap()

      Input:  dpixd (can be equal to dpixs or NULL)
              dpixs
      Return: dpixd always

  Notes:
      (1) On big-endian hardware, this does byte-swapping on each of
          the 4-byte words in the dpix data.  On little-endians,
          the data is unchanged.  This is used for serialization
          of dpix; the data is serialized in little-endian byte
          order because most hardware is little-endian.
      (2) The operation can be either in-place or, if dpixd == NULL,
          a new dpix is made.  If not in-place, caller must catch
          the returned pointer.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixEndianByteSwap(*args)
    
    

    try:
        leptonica.dpixWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixWriteStream(*args):
        """
        ('FILE', '*fp')       
('DPIX', '*dpix')       
  dpixWriteStream()

      Input:  stream (opened for "wb")
              dpix
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixWriteStream(*args)
    
    

    try:
        leptonica.fpixaGetFPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixaGetFPix.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixaGetFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetFPix(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       
  fpixaGetFPix()

      Input:  fpixa
              index  (to the index-th fpix)
              accesstype  (L_COPY or L_CLONE)
      Return: fpix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetFPix(*args)
    
    

    try:
        leptonica.fpixaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaCopy.restype = lambda address: FPIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaCopy(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'copyflag')       
  fpixaCopy()

      Input:  fpixas
              copyflag:
                L_COPY makes a new fpixa and copies each fpix
                L_CLONE gives a new ref-counted handle to the input fpixa
                L_COPY_CLONE makes a new fpixa with clones of all fpix
      Return: new fpixa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaCopy(*args)
    
    

    try:
        leptonica.dpixClone.argtypes = [ctypes.c_void_p]
        leptonica.dpixClone.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixClone(*args):
        """
        ('DPIX', '*dpix')       
  dpixClone()

      Input:  dpix
      Return: same dpix (ptr), or null on error

  Notes:
      (1) See pixClone() for definition and usage.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixClone(*args)
    
    

    try:
        leptonica.fpixEndianByteSwap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixEndianByteSwap.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixEndianByteSwap(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       
  fpixEndianByteSwap()

      Input:  fpixd (can be equal to fpixs or NULL)
              fpixs
      Return: fpixd always

  Notes:
      (1) On big-endian hardware, this does byte-swapping on each of
          the 4-byte floats in the fpix data.  On little-endians,
          the data is unchanged.  This is used for serialization
          of fpix; the data is serialized in little-endian byte
          order because most hardware is little-endian.
      (2) The operation can be either in-place or, if fpixd == NULL,
          a new fpix is made.  If not in-place, caller must catch
          the returned pointer.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixEndianByteSwap(*args)
    
    

    try:
        leptonica.fpixaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.fpixaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetCount(*args):
        """
        ('FPIXA', '*fpixa')       
  fpixaGetCount()

      Input:  fpixa
      Return: count, or 0 if no pixa


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetCount(*args)
    
    

    try:
        leptonica.dpixSetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixSetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixSetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetDimensions(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'w')       
('l_int32', 'h')       
  dpixSetDimensions()

      Input:  dpix
              w, h
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetDimensions(*args)
    
    

    try:
        leptonica.fpixCreateTemplate.argtypes = [ctypes.c_void_p]
        leptonica.fpixCreateTemplate.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixCreateTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCreateTemplate(*args):
        """
        ('FPIX', '*fpixs')       
  fpixCreateTemplate()

      Input:  fpixs
      Return: fpixd, or null on error

  Notes:
      (1) Makes a FPix of the same size as the input FPix, with the
          data array allocated and initialized to 0.
      (2) Copies the resolution.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCreateTemplate(*args)
    
    

    try:
        leptonica.dpixCreateTemplate.argtypes = [ctypes.c_void_p]
        leptonica.dpixCreateTemplate.restype = lambda address: DPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function dpixCreateTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCreateTemplate(*args):
        """
        ('DPIX', '*dpixs')       
  dpixCreateTemplate()

      Input:  dpixs
      Return: dpixd, or null on error

  Notes:
      (1) Makes a DPix of the same size as the input DPix, with the
          data array allocated and initialized to 0.
      (2) Copies the resolution.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCreateTemplate(*args)
    
    

    try:
        leptonica.fpixClone.argtypes = [ctypes.c_void_p]
        leptonica.fpixClone.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixClone(*args):
        """
        ('FPIX', '*fpix')       
  fpixClone()

      Input:  fpix
      Return: same fpix (ptr), or null on error

  Notes:
      (1) See pixClone() for definition and usage.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixClone(*args)
    
    

    try:
        leptonica.fpixDestroy.argtypes = [ctypes.c_void_p]
        leptonica.fpixDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function fpixDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixDestroy(*args):
        """
        ('FPIX', '**pfpix')       
  fpixDestroy()

      Input:  &fpix <will be nulled>
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the fpix.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixDestroy(*args)
    
    

    try:
        leptonica.dpixGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetDimensions(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  dpixGetDimensions()

      Input:  dpix
              &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetDimensions(*args)
    
    

    try:
        leptonica.dpixDestroy.argtypes = [ctypes.c_void_p]
        leptonica.dpixDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function dpixDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixDestroy(*args):
        """
        ('DPIX', '**pdpix')       
  dpixDestroy()

      Input:  &dpix <will be nulled>
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the dpix.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixDestroy(*args)
    
    

    try:
        leptonica.fpixaSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixaSetPixel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixaSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaSetPixel(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'val')       
  fpixaSetPixel()

      Input:  fpixa
              index (into fpixa array)
              (x,y) pixel coords
              val (pixel value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaSetPixel(*args)
    
    

    try:
        leptonica.fpixCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixCreate.restype = lambda address: FPIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCreate(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
  fpixCreate()

      Input:  width, height
      Return: fpixd (with data allocated and initialized to 0),
                     or null on error

  Notes:
      (1) Makes a FPix of specified size, with the data array
          allocated and initialized to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCreate(*args)
    
    

    try:
        leptonica.fpixWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixWrite(*args):
        """
        ('const char', '*filename')       
('FPIX', '*fpix')       
  fpixWrite()

      Input:  filename
              fpix
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixWrite(*args)
    
    

    try:
        leptonica.fpixaCreate.argtypes = [ctypes.c_int32]
        leptonica.fpixaCreate.restype = lambda address: FPIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function fpixaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaCreate(*args):
        """
        ('l_int32', 'n')       
  fpixaCreate()

      Input:  n  (initial number of ptrs)
      Return: fpixa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaCreate(*args)
    
    

    try:
        leptonica.fpixaAddFPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaAddFPix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixaAddFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaAddFPix(*args):
        """
        ('FPIXA', '*fpixa')       
('FPIX', '*fpix')       
('l_int32', 'copyflag')       
  fpixaAddFPix()

      Input:  fpixa
              fpix  (to be added)
              copyflag (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaAddFPix(*args)
    
    

    try:
        leptonica.dpixResizeImageData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixResizeImageData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function dpixResizeImageData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixResizeImageData(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       
  dpixResizeImageData()

      Input:  dpixd, dpixs
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixResizeImageData(*args)
    
    

    try:
        leptonica.fpixaGetFPixDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixaGetFPixDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixaGetFPixDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetFPixDimensions(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  fpixaGetFPixDimensions()

      Input:  fpixa
              index  (to the index-th box)
              &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetFPixDimensions(*args)
    
    

    try:
        leptonica.fpixResizeImageData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixResizeImageData.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixResizeImageData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixResizeImageData(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       
  fpixResizeImageData()

      Input:  fpixd, fpixs
      Return: 0 if OK, 1 on error

  Notes:
      (1) If the data sizes differ, this destroys the existing
          data in fpixd and allocates a new, uninitialized, data array
          of the same size as the data in fpixs.  Otherwise, this
          doesn't do anything.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixResizeImageData(*args)
    
    

    try:
        leptonica.fpixGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetDimensions.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fpixGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetDimensions(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  fpixGetDimensions()

      Input:  fpix
              &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetDimensions(*args)
    




class ptafunc1(object):
    """   ptafunc1.c

      Pta and Ptaa rearrangements
           PTA      *ptaSubsample()
           l_int32   ptaJoin()
           l_int32   ptaaJoin()
           PTA      *ptaReverse()
           PTA      *ptaTranspose()
           PTA      *ptaCyclicPerm()
           PTA      *ptaSort()
           l_int32   ptaGetSortIndex()
           PTA      *ptaSortByIndex()
           PTA      *ptaRemoveDuplicates()
           PTAA     *ptaaSortByIndex()

      Geometric
           BOX      *ptaGetBoundingRegion()
           l_int32  *ptaGetRange()
           PTA      *ptaGetInsideBox()
           PTA      *pixFindCornerPixels()
           l_int32   ptaContainsPt()
           l_int32   ptaTestIntersection()
           PTA      *ptaTransform()
           l_int32   ptaPtInsidePolygon()
           l_float32 l_angleBetweenVectors()

      Least Squares Fit
           l_int32   ptaGetLinearLSF()
           l_int32   ptaGetQuadraticLSF()
           l_int32   ptaGetCubicLSF()
           l_int32   ptaGetQuarticLSF()
           l_int32   ptaNoisyLinearLSF()
           l_int32   ptaNoisyQuadraticLSF()
           l_int32   applyLinearFit()
           l_int32   applyQuadraticFit()
           l_int32   applyCubicFit()
           l_int32   applyQuarticFit()

      Interconversions with Pix
           l_int32   pixPlotAlongPta()
           PTA      *ptaGetPixelsFromPix()
           PIX      *pixGenerateFromPta()
           PTA      *ptaGetBoundaryPixels()
           PTAA     *ptaaGetBoundaryPixels()

      Display Pta and Ptaa
           PIX      *pixDisplayPta()
           PIX      *pixDisplayPtaaPattern()
           PIX      *pixDisplayPtaPattern()
           PTA      *ptaReplicatePattern()
           PIX      *pixDisplayPtaa()

"""
    
    try:
        leptonica.ptaaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaSortByIndex.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaSortByIndex(*args):
        """
        ('PTAA', '*ptaas')       
('NUMA', '*naindex')       
  ptaaSortByIndex()

      Input:  ptaas
              naindex (na that maps from the new ptaa to the input ptaa)
      Return: ptaad (sorted), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaSortByIndex(*args)
    
    

    try:
        leptonica.pixDisplayPtaaPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDisplayPtaaPattern.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayPtaaPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPtaaPattern(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PTAA', '*ptaa')       
('PIX', '*pixp')       
('l_int32', 'cx')       
('l_int32', 'cy')       
  pixDisplayPtaaPattern()

      Input:  pixd (32 bpp)
              pixs (1, 2, 4, 8, 16 or 32 bpp; 32 bpp if in place)
              ptaa (giving locations at which the pattern is displayed)
              pixp (1 bpp pattern to be placed such that its reference
                    point co-locates with each point in pta)
              cx, cy (reference point in pattern)
      Return: pixd (32 bpp RGB version of pixs).

  Notes:
      (1) To write on an existing pixs, pixs must be 32 bpp and
          call with pixd == pixs:
             pixDisplayPtaPattern(pixs, pixs, pta, ...);
          To write to a new pix, use pixd == NULL and call:
             pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
      (2) Puts a random color on each pattern associated with a pta.
      (3) On error, returns pixd to avoid losing pixs if called as
             pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
      (4) A typical pattern to be used is a circle, generated with
             generatePtaFilledCircle()


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPtaaPattern(*args)
    
    

    try:
        leptonica.applyLinearFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyLinearFit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function applyLinearFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyLinearFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'x')       
('l_float32', '*py')       
  applyLinearFit()

      Input: a, b (linear fit coefficients)
             x
             &y (<return> y = a * x + b)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyLinearFit(*args)
    
    

    try:
        leptonica.ptaGetPixelsFromPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetPixelsFromPix.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaGetPixelsFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetPixelsFromPix(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
  ptaGetPixelsFromPix()

      Input:  pixs (1 bpp)
              box (<optional> can be null)
      Return: pta, or null on error

  Notes:
      (1) Generates a pta of fg pixels in the pix, within the box.
          If box == NULL, it uses the entire pix.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetPixelsFromPix(*args)
    
    

    try:
        leptonica.ptaNoisyLinearLSF.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaNoisyLinearLSF.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaNoisyLinearLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaNoisyLinearLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'factor')       
('PTA', '**pptad')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pmederr')       
('NUMA', '**pnafit')       
  ptaNoisyLinearLSF()

      Input:  pta
              factor (reject outliers with error greater than this
                      number of medians; typically ~ 3)
              &ptad (<optional return> with outliers removed)
              &a  (<optional return> slope a of least square fit: y = ax + b)
              &b  (<optional return> intercept b of least square fit)
              &mederr (<optional return> median error)
              &nafit (<optional return> numa of least square fit to ptad)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a linear least square fit to the set of points
          in @pta.  It then evaluates the errors and removes points
          whose error is >= factor * median_error.  It then re-runs
          the linear LSF on the resulting points.
      (2) Either or both &a and &b must be input.  They determine the
          type of line that is fit.
      (3) The median error can give an indication of how good the fit
          is likely to be.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaNoisyLinearLSF(*args)
    
    

    try:
        leptonica.ptaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaJoin(*args):
        """
        ('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  ptaJoin()

      Input:  ptad  (dest pta; add to this one)
              ptas  (source pta; add from this one)
              istart  (starting index in ptas)
              iend  (ending index in ptas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (2) iend < 0 means 'read to the end'
      (3) if ptas == NULL, this is a no-op


        """
        args = _convert_params(*args)
        
        return leptonica.ptaJoin(*args)
    
    

    try:
        leptonica.ptaGetBoundingRegion.argtypes = [ctypes.c_void_p]
        leptonica.ptaGetBoundingRegion.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaGetBoundingRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetBoundingRegion(*args):
        """
        ('PTA', '*pta')       
  ptaGetBoundingRegion()

      Input:  pta
      Return: box, or null on error

  Notes:
      (1) This is used when the pta represents a set of points in
          a two-dimensional image.  It returns the box of minimum
          size containing the pts in the pta.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetBoundingRegion(*args)
    
    

    try:
        leptonica.ptaaGetBoundaryPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaGetBoundaryPixels.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaaGetBoundaryPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetBoundaryPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('BOXA', '**pboxa')       
('PIXA', '**ppixa')       
  ptaaGetBoundaryPixels()

      Input:  pixs (1 bpp)
              type (L_BOUNDARY_FG, L_BOUNDARY_BG)
              connectivity (4 or 8)
              &boxa (<optional return> bounding boxes of the c.c.)
              &pixa (<optional return> pixa of the c.c.)
      Return: ptaa, or null on error

  Notes:
      (1) This generates a ptaa of either fg or bg boundary pixels,
          where each pta has the boundary pixels for a connected
          component.
      (2) We can't simply find all the boundary pixels and then select
          those within the bounding box of each component, because
          bounding boxes can overlap.  It is necessary to extract and
          dilate or erode each component separately.  Note also that
          special handling is required for bg pixels when the
          component touches the pix boundary.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetBoundaryPixels(*args)
    
    

    try:
        leptonica.l_angleBetweenVectors.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.l_angleBetweenVectors.restype = ctypes.c_float
    except AttributeError:
        os.stderr.write("Warning - function l_angleBetweenVectors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_angleBetweenVectors(*args):
        """
        ('l_float32', 'x1')       
('l_float32', 'y1')       
('l_float32', 'x2')       
('l_float32', 'y2')       
  l_angleBetweenVectors()

      Input:  x1, y1 (end point of first vector)
              x2, y2 (end point of second vector)
      Return: angle (radians), or 0.0 on error

  Notes:
      (1) This gives the angle between two vectors, going between
          vector1 (x1,y1) and vector2 (x2,y2).  The angle is swept
          out from 1 --> 2.  If this is clockwise, the angle is
          positive, but the result is folded into the interval [-pi, pi].


        """
        args = _convert_params(*args)
        
        return leptonica.l_angleBetweenVectors(*args)
    
    

    try:
        leptonica.ptaGetBoundaryPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaGetBoundaryPixels.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaGetBoundaryPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetBoundaryPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
  ptaGetBoundaryPixels()

      Input:  pixs (1 bpp)
              type (L_BOUNDARY_FG, L_BOUNDARY_BG)
      Return: pta, or null on error

  Notes:
      (1) This generates a pta of either fg or bg boundary pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetBoundaryPixels(*args)
    
    

    try:
        leptonica.ptaCyclicPerm.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaCyclicPerm.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaCyclicPerm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCyclicPerm(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'xs')       
('l_int32', 'ys')       
  ptaCyclicPerm()

      Input:  ptas
              xs, ys  (start point; must be in ptas)
      Return: ptad (cyclic permutation, starting and ending at (xs, ys),
              or null on error

  Notes:
      (1) Check to insure that (a) ptas is a closed path where
          the first and last points are identical, and (b) the
          resulting pta also starts and ends on the same point
          (which in this case is (xs, ys).


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCyclicPerm(*args)
    
    

    try:
        leptonica.ptaGetLinearLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetLinearLSF.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetLinearLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetLinearLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('NUMA', '**pnafit')       
  ptaGetLinearLSF()

      Input:  pta
              &a  (<optional return> slope a of least square fit: y = ax + b)
              &b  (<optional return> intercept b of least square fit)
              &nafit (<optional return> numa of least square fit)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Either or both &a and &b must be input.  They determine the
          type of line that is fit.
      (2) If both &a and &b are defined, this returns a and b that minimize:

              sum (yi - axi -b)^2
               i

          The method is simple: differentiate this expression w/rt a and b,
          and solve the resulting two equations for a and b in terms of
          various sums over the input data (xi, yi).
      (3) We also allow two special cases, where either a = 0 or b = 0:
           (a) If &a is given and &b = null, find the linear LSF that
               goes through the origin (b = 0).
           (b) If &b is given and &a = null, find the linear LSF with
               zero slope (a = 0).
      (4) If @nafit is defined, this returns an array of fitted values,
          corresponding to the two implicit Numa arrays (nax and nay) in pta.
          Thus, just as you can plot the data in pta as nay vs. nax,
          you can plot the linear least square fit as nafit vs. nax.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetLinearLSF(*args)
    
    

    try:
        leptonica.applyQuadraticFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyQuadraticFit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function applyQuadraticFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyQuadraticFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'c')       
('l_float32', 'x')       
('l_float32', '*py')       
  applyQuadraticFit()

      Input: a, b, c (quadratic fit coefficients)
             x
             &y (<return> y = a * x^2 + b * x + c)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyQuadraticFit(*args)
    
    

    try:
        leptonica.ptaReverse.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaReverse.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReverse(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'type')       
  ptaReverse()

      Input:  ptas
              type  (0 for float values; 1 for integer values)
      Return: ptad (reversed pta), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaReverse(*args)
    
    

    try:
        leptonica.pixPlotAlongPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixPlotAlongPta.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixPlotAlongPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPlotAlongPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*pta')       
('l_int32', 'outformat')       
('const char', '*title')       
  pixPlotAlongPta()

      Input: pixs (any depth)
             pta (set of points on which to plot)
             outformat (GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_X11,
                        GPLOT_LATEX)
             title (<optional> for plot; can be null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) We remove any existing colormap and clip the pta to the input pixs.
      (2) This is a debugging function, and does not remove temporary
          plotting files that it generates.
      (3) If the image is RGB, three separate plots are generated.


        """
        args = _convert_params(*args)
        
        return leptonica.pixPlotAlongPta(*args)
    
    

    try:
        leptonica.ptaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaaJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaJoin(*args):
        """
        ('PTAA', '*ptaad')       
('PTAA', '*ptaas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  ptaaJoin()

      Input:  ptaad  (dest ptaa; add to this one)
              ptaas  (source ptaa; add from this one)
              istart  (starting index in ptaas)
              iend  (ending index in ptaas; use -1 to cat all)
      Return: 0 if OK, 1 on error

  Notes:
      (1) istart < 0 is taken to mean 'read from the start' (istart = 0)
      (2) iend < 0 means 'read to the end'
      (3) if ptas == NULL, this is a no-op


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaJoin(*args)
    
    

    try:
        leptonica.ptaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaSortByIndex.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSortByIndex(*args):
        """
        ('PTA', '*ptas')       
('NUMA', '*naindex')       
  ptaSortByIndex()

      Input:  ptas
              naindex (na that maps from the new pta to the input pta)
      Return: ptad (sorted), or null on  error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSortByIndex(*args)
    
    

    try:
        leptonica.pixDisplayPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDisplayPta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPta(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PTA', '*pta')       
  pixDisplayPta()

      Input:  pixd (can be same as pixs or null; 32 bpp if in-place)
              pixs (1, 2, 4, 8, 16 or 32 bpp)
              pta (of path to be plotted)
      Return: pixd (32 bpp RGB version of pixs, with path in green).

  Notes:
      (1) To write on an existing pixs, pixs must be 32 bpp and
          call with pixd == pixs:
             pixDisplayPta(pixs, pixs, pta);
          To write to a new pix, use pixd == NULL and call:
             pixd = pixDisplayPta(NULL, pixs, pta);
      (2) On error, returns pixd to avoid losing pixs if called as
             pixs = pixDisplayPta(pixs, pixs, pta);


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPta(*args)
    
    

    try:
        leptonica.ptaGetSortIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaGetSortIndex.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetSortIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetSortIndex(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
  ptaGetSortIndex()

      Input:  ptas
              sorttype (L_SORT_BY_X, L_SORT_BY_Y)
              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)
              &naindex (<return> index of sorted order into
                        original array)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetSortIndex(*args)
    
    

    try:
        leptonica.ptaContainsPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaContainsPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaContainsPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaContainsPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'x')       
('l_int32', 'y')       
  ptaContainsPt()

      Input:  pta
              x, y  (point)
      Return: 1 if contained, 0 otherwise or on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaContainsPt(*args)
    
    

    try:
        leptonica.pixFindCornerPixels.argtypes = [ctypes.c_void_p]
        leptonica.pixFindCornerPixels.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindCornerPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindCornerPixels(*args):
        """
        ('PIX', '*pixs')       
  pixFindCornerPixels()

      Input:  pixs (1 bpp)
      Return: pta, or null on error

  Notes:
      (1) Finds the 4 corner-most pixels, as defined by a search
          inward from each corner, using a 45 degree line.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindCornerPixels(*args)
    
    

    try:
        leptonica.pixGenerateFromPta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGenerateFromPta.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateFromPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateFromPta(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'w')       
('l_int32', 'h')       
  pixGenerateFromPta()

      Input:  pta
              w, h (of pix)
      Return: pix (1 bpp), or null on error

  Notes:
      (1) Points are rounded to nearest ints.
      (2) Any points outside (w,h) are silently discarded.
      (3) Output 1 bpp pix has values 1 for each point in the pta.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateFromPta(*args)
    
    

    try:
        leptonica.ptaReplicatePattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaReplicatePattern.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaReplicatePattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReplicatePattern(*args):
        """
        ('PTA', '*ptas')       
('PIX', '*pixp')       
('PTA', '*ptap')       
('l_int32', 'cx')       
('l_int32', 'cy')       
('l_int32', 'w')       
('l_int32', 'h')       
  ptaReplicatePattern()

      Input:  ptas ("sparse" input pta)
              pixp (<optional> 1 bpp pattern, to be replicated in output pta)
              ptap (<optional> set of pts, to be replicated in output pta)
              cx, cy (reference point in pattern)
              w, h (clipping sizes for output pta)
      Return: ptad (with all points of replicated pattern), or null on error

  Notes:
      (1) You can use either the image @pixp or the set of pts @ptap.
      (2) The pattern is placed with its reference point at each point
          in ptas, and all the fg pixels are colleced into ptad.
          For @pixp, this is equivalent to blitting pixp at each point
          in ptas, and then converting the resulting pix to a pta.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaReplicatePattern(*args)
    
    

    try:
        leptonica.ptaRemoveDuplicates.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.ptaRemoveDuplicates.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaRemoveDuplicates not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRemoveDuplicates(*args):
        """
        ('PTA', '*ptas')       
('l_uint32', 'factor')       
  ptaRemoveDuplicates()

      Input:  ptas (assumed to be integer values)
              factor (should be larger than the largest point value;
                      use 0 for default)
      Return: ptad (with duplicates removed), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRemoveDuplicates(*args)
    
    

    try:
        leptonica.applyCubicFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyCubicFit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function applyCubicFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyCubicFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'c')       
('l_float32', 'd')       
('l_float32', 'x')       
('l_float32', '*py')       
  applyCubicFit()

      Input: a, b, c, d (cubic fit coefficients)
             x
             &y (<return> y = a * x^3 + b * x^2  + c * x + d)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyCubicFit(*args)
    
    

    try:
        leptonica.ptaTranspose.argtypes = [ctypes.c_void_p]
        leptonica.ptaTranspose.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaTranspose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTranspose(*args):
        """
        ('PTA', '*ptas')       
  ptaTranspose()

      Input:  ptas
      Return: ptad (with x and y values swapped), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTranspose(*args)
    
    

    try:
        leptonica.ptaGetQuadraticLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetQuadraticLSF.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetQuadraticLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetQuadraticLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('NUMA', '**pnafit')       
  ptaGetQuadraticLSF()

      Input:  pta
              &a  (<optional return> coeff a of LSF: y = ax^2 + bx + c)
              &b  (<optional return> coeff b of LSF: y = ax^2 + bx + c)
              &c  (<optional return> coeff c of LSF: y = ax^2 + bx + c)
              &nafit (<optional return> numa of least square fit)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a quadratic least square fit to the set of points
          in @pta.  That is, it finds coefficients a, b and c that minimize:

              sum (yi - a*xi*xi -b*xi -c)^2
               i

          The method is simple: differentiate this expression w/rt
          a, b and c, and solve the resulting three equations for these
          coefficients in terms of various sums over the input data (xi, yi).
          The three equations are in the form:
             f[0][0]a + f[0][1]b + f[0][2]c = g[0]
             f[1][0]a + f[1][1]b + f[1][2]c = g[1]
             f[2][0]a + f[2][1]b + f[2][2]c = g[2]
      (2) If @nafit is defined, this returns an array of fitted values,
          corresponding to the two implicit Numa arrays (nax and nay) in pta.
          Thus, just as you can plot the data in pta as nay vs. nax,
          you can plot the linear least square fit as nafit vs. nax.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetQuadraticLSF(*args)
    
    

    try:
        leptonica.ptaPtInsidePolygon.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.ptaPtInsidePolygon.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaPtInsidePolygon not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaPtInsidePolygon(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', '*pinside')       
  ptaPtInsidePolygon()

      Input:  pta (vertices of a polygon)
              x, y (point to be tested)
              &inside (<return> 1 if inside; 0 if outside or on boundary)
      Return: 1 if OK, 0 on error

  The abs value of the sum of the angles subtended from a point by
  the sides of a polygon, when taken in order traversing the polygon,
  is 0 if the point is outside the polygon and 2*pi if inside.
  The sign will be positive if traversed cw and negative if ccw.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaPtInsidePolygon(*args)
    
    

    try:
        leptonica.ptaNoisyQuadraticLSF.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaNoisyQuadraticLSF.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaNoisyQuadraticLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaNoisyQuadraticLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'factor')       
('PTA', '**pptad')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('l_float32', '*pmederr')       
('NUMA', '**pnafit')       
  ptaNoisyQuadraticLSF()

      Input:  pta
              factor (reject outliers with error greater than this
                      number of medians; typically ~ 3)
              &ptad (<optional return> with outliers removed)
              &a  (<optional return> coeff a of LSF: y = ax^2 + bx + c)
              &b  (<optional return> coeff b of LSF: y = ax^2 + bx + c)
              &c  (<optional return> coeff c of LSF: y = ax^2 + bx + c)
              &mederr (<optional return> median error)
              &nafit (<optional return> numa of least square fit to ptad)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a quadratic least square fit to the set of points
          in @pta.  It then evaluates the errors and removes points
          whose error is >= factor * median_error.  It then re-runs
          a quadratic LSF on the resulting points.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaNoisyQuadraticLSF(*args)
    
    

    try:
        leptonica.pixDisplayPtaPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixDisplayPtaPattern.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayPtaPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPtaPattern(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PTA', '*pta')       
('PIX', '*pixp')       
('l_int32', 'cx')       
('l_int32', 'cy')       
('l_uint32', 'color')       
  pixDisplayPtaPattern()

      Input:  pixd (can be same as pixs or null; 32 bpp if in-place)
              pixs (1, 2, 4, 8, 16 or 32 bpp)
              pta (giving locations at which the pattern is displayed)
              pixp (1 bpp pattern to be placed such that its reference
                    point co-locates with each point in pta)
              cx, cy (reference point in pattern)
              color (in 0xrrggbb00 format)
      Return: pixd (32 bpp RGB version of pixs).

  Notes:
      (1) To write on an existing pixs, pixs must be 32 bpp and
          call with pixd == pixs:
             pixDisplayPtaPattern(pixs, pixs, pta, ...);
          To write to a new pix, use pixd == NULL and call:
             pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
      (2) On error, returns pixd to avoid losing pixs if called as
             pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
      (3) A typical pattern to be used is a circle, generated with
             generatePtaFilledCircle()


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPtaPattern(*args)
    
    

    try:
        leptonica.ptaGetRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetRange(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pminx')       
('l_float32', '*pmaxx')       
('l_float32', '*pminy')       
('l_float32', '*pmaxy')       
  ptaGetRange()

      Input:  pta
              &minx (<optional return> min value of x)
              &maxx (<optional return> max value of x)
              &miny (<optional return> min value of y)
              &maxy (<optional return> max value of y)
      Return: 0 if OK, 1 on error

  Notes:
      (1) We can use pts to represent pairs of floating values, that
          are not necessarily tied to a two-dimension region.  For
          example, the pts can represent a general function y(x).


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetRange(*args)
    
    

    try:
        leptonica.ptaGetCubicLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetCubicLSF.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetCubicLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetCubicLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('l_float32', '*pd')       
('NUMA', '**pnafit')       
  ptaGetCubicLSF()

      Input:  pta
              &a  (<optional return> coeff a of LSF: y = ax^3 + bx^2 + cx + d)
              &b  (<optional return> coeff b of LSF)
              &c  (<optional return> coeff c of LSF)
              &d  (<optional return> coeff d of LSF)
              &nafit (<optional return> numa of least square fit)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a cubic least square fit to the set of points
          in @pta.  That is, it finds coefficients a, b, c and d
          that minimize:

              sum (yi - a*xi*xi*xi -b*xi*xi -c*xi - d)^2
               i

          Differentiate this expression w/rt a, b, c and d, and solve
          the resulting four equations for these coefficients in
          terms of various sums over the input data (xi, yi).
          The four equations are in the form:
             f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]
             f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]
             f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]
             f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]
      (2) If @nafit is defined, this returns an array of fitted values,
          corresponding to the two implicit Numa arrays (nax and nay) in pta.
          Thus, just as you can plot the data in pta as nay vs. nax,
          you can plot the linear least square fit as nafit vs. nax.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetCubicLSF(*args)
    
    

    try:
        leptonica.ptaGetInsideBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetInsideBox.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaGetInsideBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetInsideBox(*args):
        """
        ('PTA', '*ptas')       
('BOX', '*box')       
  ptaGetInsideBox()

      Input:  ptas (input pts)
              box
      Return: ptad (of pts in ptas that are inside the box), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetInsideBox(*args)
    
    

    try:
        leptonica.ptaTestIntersection.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaTestIntersection.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaTestIntersection not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTestIntersection(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       
  ptaTestIntersection()

      Input:  pta1, pta2
      Return: bval which is 1 if they have any elements in common;
              0 otherwise or on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTestIntersection(*args)
    
    

    try:
        leptonica.ptaSubsample.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaSubsample.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaSubsample not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSubsample(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'subfactor')       
  ptaSubsample()

      Input:  ptas
              subfactor (subsample factor, >= 1)
      Return: ptad (evenly sampled pt values from ptas, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSubsample(*args)
    
    

    try:
        leptonica.ptaGetQuarticLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetQuarticLSF.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetQuarticLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetQuarticLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('l_float32', '*pd')       
('l_float32', '*pe')       
('NUMA', '**pnafit')       
  ptaGetQuarticLSF()

      Input:  pta
              &a  (<optional return> coeff a of LSF:
                        y = ax^4 + bx^3 + cx^2 + dx + e)
              &b  (<optional return> coeff b of LSF)
              &c  (<optional return> coeff c of LSF)
              &d  (<optional return> coeff d of LSF)
              &e  (<optional return> coeff e of LSF)
              &nafit (<optional return> numa of least square fit)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a quartic least square fit to the set of points
          in @pta.  That is, it finds coefficients a, b, c, d and 3
          that minimize:

              sum (yi - a*xi*xi*xi*xi -b*xi*xi*xi -c*xi*xi - d*xi - e)^2
               i

          Differentiate this expression w/rt a, b, c, d and e, and solve
          the resulting five equations for these coefficients in
          terms of various sums over the input data (xi, yi).
          The five equations are in the form:
             f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]
             f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]
             f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]
             f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]
             f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]
      (2) If @nafit is defined, this returns an array of fitted values,
          corresponding to the two implicit Numa arrays (nax and nay) in pta.
          Thus, just as you can plot the data in pta as nay vs. nax,
          you can plot the linear least square fit as nafit vs. nax.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetQuarticLSF(*args)
    
    

    try:
        leptonica.ptaSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaSort.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSort(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
  ptaSort()

      Input:  ptas
              sorttype (L_SORT_BY_X, L_SORT_BY_Y)
              sortorder  (L_SORT_INCREASING, L_SORT_DECREASING)
              &naindex (<optional return> index of sorted order into
                        original array)
      Return: ptad (sorted version of ptas), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSort(*args)
    
    

    try:
        leptonica.pixDisplayPtaa.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDisplayPtaa.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayPtaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPtaa(*args):
        """
        ('PIX', '*pixs')       
('PTAA', '*ptaa')       
  pixDisplayPtaa()

      Input:  pixs (1, 2, 4, 8, 16 or 32 bpp)
              ptaa (array of paths to be plotted)
      Return: pixd (32 bpp RGB version of pixs, with paths plotted
                    in different colors), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPtaa(*args)
    
    

    try:
        leptonica.applyQuarticFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyQuarticFit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function applyQuarticFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyQuarticFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'c')       
('l_float32', 'd')       
('l_float32', 'e')       
('l_float32', 'x')       
('l_float32', '*py')       
  applyQuarticFit()

      Input: a, b, c, d, e (quartic fit coefficients)
             x
             &y (<return> y = a * x^4 + b * x^3  + c * x^2 + d * x + e)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyQuarticFit(*args)
    
    

    try:
        leptonica.ptaTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.ptaTransform.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTransform(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
  ptaTransform()

      Input:  pta
              shiftx, shifty
              scalex, scaley
      Return: pta, or null on error

  Notes:
      (1) Shift first, then scale.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTransform(*args)
    




class runlength(object):
    """  runlength.c

     Label pixels by membership in runs
           PIX         *pixStrokeWidthTransform()
           static PIX  *pixFindMinRunsOrthogonal()
           PIX         *pixRunlengthTransform()

     Find runs along horizontal and vertical lines
           l_int32      pixFindHorizontalRuns()
           l_int32      pixFindVerticalRuns()

     Find max runs along horizontal and vertical lines
           l_int32      pixFindMaxRuns()
           l_int32      pixFindMaxHorizontalRunOnLine()
           l_int32      pixFindMaxVerticalRunOnLine()

     Compute runlength-to-membership transform on a line
           l_int32      runlengthMembershipOnLine()

     Make byte position LUT
           l_int32      makeMSBitLocTab()

  Here we're handling runs of either black or white pixels on 1 bpp
  images.  The directions of the runs in the stroke width transform
  are selectable from given sets of angles.  Most of the other runs
  are oriented either horizontally along the raster lines or
  vertically along pixel columns.

"""
    
    try:
        leptonica.runlengthMembershipOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.runlengthMembershipOnLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function runlengthMembershipOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def runlengthMembershipOnLine(*args):
        """
        ('l_int32', '*buffer')       
('l_int32', 'size')       
('l_int32', 'depth')       
('l_int32', '*start')       
('l_int32', '*end')       
('l_int32', 'n')       
  runlengthMembershipOnLine()

      Input:   buffer (into which full line of data is placed)
               size (full size of line; w or h)
               depth (8 or 16 bpp)
               start (array of start positions for fg runs)
               end (array of end positions for fg runs)
               n   (the number of runs)
      Return:  0 if OK; 1 on error

  Notes:
      (1) Converts a set of runlengths into a buffer of
          runlength membership values.
      (2) Initialization of the array gives pixels that are
          not within a run the value 0.


        """
        args = _convert_params(*args)
        
        return leptonica.runlengthMembershipOnLine(*args)
    
    

    try:
        leptonica.pixFindMaxVerticalRunOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindMaxVerticalRunOnLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindMaxVerticalRunOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindMaxVerticalRunOnLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', '*pystart')       
('l_int32', '*psize')       
  pixFindMaxVerticalRunOnLine()

      Input:  pix (1 bpp)
              x (column to traverse)
              &ystart (<optional return> start position)
              &size  (<return> the size of the run)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds the longest foreground vertical run on a scanline.
      (2) To find background runs, use pixInvert() before applying
          this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindMaxVerticalRunOnLine(*args)
    
    

    try:
        leptonica.pixStrokeWidthTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStrokeWidthTransform.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixStrokeWidthTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStrokeWidthTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'color')       
('l_int32', 'depth')       
('l_int32', 'nangles')       
  pixStrokeWidthTransform()

      Input:   pixs (1 bpp)
               color (0 for white runs, 1 for black runs)
               depth (of pixd: 8 or 16 bpp)
               nangles (2, 4, 6 or 8)
      Return:  pixd (8 or 16 bpp), or null on error

  Notes:
      (1) The dest Pix is 8 or 16 bpp, with the pixel values
          equal to the stroke width in which it is a member.
          The values are clipped to the max pixel value if necessary.
      (2) The color determines if we're labelling white or black strokes.
      (3) A pixel that is not a member of the chosen color gets
          value 0; it belongs to a width of length 0 of the
          chosen color.
      (4) This chooses, for each dest pixel, the minimum of sets
          of runlengths through each pixel.  Here are the sets:
            nangles    increment          set
            -------    ---------    --------------------------------
               2          90       {0, 90}
               4          45       {0, 45, 90, 135}
               6          30       {0, 30, 60, 90, 120, 150}
               8          22.5     {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}
      (5) Runtime scales linearly with (nangles - 2).


        """
        args = _convert_params(*args)
        
        return leptonica.pixStrokeWidthTransform(*args)
    
    

    try:
        leptonica.makeMSBitLocTab.argtypes = [ctypes.c_int32]
        leptonica.makeMSBitLocTab.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function makeMSBitLocTab not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeMSBitLocTab(*args):
        """
        ('l_int32', 'bitval')       
  makeMSBitLocTab()

      Input:  bitval (either 0 or 1)
      Return: table (giving, for an input byte, the MS bit location,
                     starting at 0 with the MSBit in the byte),
                     or null on error.

  Notes:
      (1) If bitval == 1, it finds the leftmost ON pixel in a byte;
          otherwise if bitval == 0, it finds the leftmost OFF pixel.
      (2) If there are no pixels of the indicated color in the byte,
          this returns 8.


        """
        args = _convert_params(*args)
        
        return leptonica.makeMSBitLocTab(*args)
    
    

    try:
        leptonica.pixFindMaxHorizontalRunOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindMaxHorizontalRunOnLine.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindMaxHorizontalRunOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindMaxHorizontalRunOnLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'y')       
('l_int32', '*pxstart')       
('l_int32', '*psize')       
  pixFindMaxHorizontalRunOnLine()

      Input:  pix (1 bpp)
              y (line to traverse)
              &xstart (<optional return> start position)
              &size  (<return> the size of the run)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds the longest foreground horizontal run on a scanline.
      (2) To find background runs, use pixInvert() before applying
          this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindMaxHorizontalRunOnLine(*args)
    
    

    try:
        leptonica.pixFindMaxRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFindMaxRuns.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindMaxRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindMaxRuns(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'direction')       
('NUMA', '**pnastart')       
  pixFindMaxRuns()

      Input:  pix (1 bpp)
              direction (L_HORIZONTAL_RUNS or L_VERTICAL_RUNS)
              &nastart (<optional return> start locations of longest runs)
      Return: na (of lengths of runs), or null on error

  Notes:
      (1) This finds the longest foreground runs by row or column
      (2) To find background runs, use pixInvert() before applying
          this function.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindMaxRuns(*args)
    
    

    try:
        leptonica.pixFindVerticalRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindVerticalRuns.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindVerticalRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindVerticalRuns(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', '*ystart')       
('l_int32', '*yend')       
('l_int32', '*pn')       
  pixFindVerticalRuns()

      Input:  pix (1 bpp)
              x (line to traverse)
              ystart (returns array of start positions for fg runs)
              yend (returns array of end positions for fg runs)
              &n   (<return> the number of runs found)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds foreground vertical runs on a single scanline.
      (2) To find background runs, use pixInvert() before applying
          this function.
      (3) The ystart and yend arrays are input.  They should be
          of size h/2 + 1 to insure that they can hold
          the maximum number of runs in the raster line.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindVerticalRuns(*args)
    
    

    try:
        leptonica.pixRunlengthTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRunlengthTransform.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRunlengthTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRunlengthTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'color')       
('l_int32', 'direction')       
('l_int32', 'depth')       
  pixRunlengthTransform()

      Input:   pixs (1 bpp)
               color (0 for white runs, 1 for black runs)
               direction (L_HORIZONTAL_RUNS, L_VERTICAL_RUNS)
               depth (8 or 16 bpp)
      Return:  pixd (8 or 16 bpp), or null on error

  Notes:
      (1) The dest Pix is 8 or 16 bpp, with the pixel values
          equal to the runlength in which it is a member.
          The length is clipped to the max pixel value if necessary.
      (2) The color determines if we're labelling white or black runs.
      (3) A pixel that is not a member of the chosen color gets
          value 0; it belongs to a run of length 0 of the
          chosen color.
      (4) To convert for maximum dynamic range, either linear or
          log, use pixMaxDynamicRange().


        """
        args = _convert_params(*args)
        
        return leptonica.pixRunlengthTransform(*args)
    
    

    try:
        leptonica.pixFindHorizontalRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindHorizontalRuns.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixFindHorizontalRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindHorizontalRuns(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'y')       
('l_int32', '*xstart')       
('l_int32', '*xend')       
('l_int32', '*pn')       
  pixFindHorizontalRuns()

      Input:  pix (1 bpp)
              y (line to traverse)
              xstart (returns array of start positions for fg runs)
              xend (returns array of end positions for fg runs)
              &n  (<return> the number of runs found)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This finds foreground horizontal runs on a single scanline.
      (2) To find background runs, use pixInvert() before applying
          this function.
      (3) The xstart and xend arrays are input.  They should be
          of size w/2 + 1 to insure that they can hold
          the maximum number of runs in the raster line.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindHorizontalRuns(*args)
    




class bmpiostub(object):
    """   bmpiostub.c

      Stubs for bmpio.c functions

"""
    



class compare(object):
    """  compare.c

      Test for pix equality
           l_int32     pixEqual()
           l_int32     pixEqualWithAlpha()
           l_int32     pixEqualWithCmap()
           l_int32     pixUsesCmapColor()

      Binary correlation
           l_int32     pixCorrelationBinary()

      Difference of two images of same size
           l_int32     pixDisplayDiffBinary()
           l_int32     pixCompareBinary()
           l_int32     pixCompareGrayOrRGB()
           l_int32     pixCompareGray()
           l_int32     pixCompareRGB()
           l_int32     pixCompareTiled()

      Other measures of the difference of two images of the same size
           NUMA       *pixCompareRankDifference()
           l_int32     pixTestForSimilarity()
           l_int32     pixGetDifferenceStats()
           NUMA       *pixGetDifferenceHistogram()
           l_int32     pixGetPerceptualDiff()
           l_int32     pixGetPSNR()

      Translated images at the same resolution
           l_int32     pixCompareWithTranslation()
           l_int32     pixBestCorrelation()

"""
    
    try:
        leptonica.pixGetDifferenceStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetDifferenceStats.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetDifferenceStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetDifferenceStats(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('l_int32', 'mindiff')       
('l_float32', '*pfractdiff')       
('l_float32', '*pavediff')       
('l_int32', 'printstats')       
  pixGetDifferenceStats()

      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)
              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)
              factor (subsampling factor; use 0 or 1 for no subsampling)
              mindiff (minimum pixel difference to be counted; > 0)
              &fractdiff (<return> fraction of pixels with diff greater
                          than or equal to mindiff)
              &avediff (<return> average difference of pixels with diff
                        greater than or equal to mindiff, less mindiff)
              printstats (use 1 to print normalized histogram to stderr)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This takes a threshold @mindiff and describes the difference
          between two images in terms of two numbers:
            (a) the fraction of pixels, @fractdiff, whose difference
                equals or exceeds the threshold @mindiff, and
            (b) the average value @avediff of the difference in pixel value
                for the pixels in the set given by (a), after you subtract
                @mindiff.  The reason for subtracting @mindiff is that
                you then get a useful measure for the rate of falloff
                of the distribution for larger differences.  For example,
                if @mindiff = 10 and you find that @avediff = 2.5, it
                says that of the pixels with diff > 10, the average of
                their diffs is just mindiff + 2.5 = 12.5.  This is a
                fast falloff in the histogram with increasing difference.
      (2) The two images are aligned at the UL corner, and do not
          need to be the same size.  If they are not the same size,
          the comparison will be made over overlapping pixels.
      (3) If there is a colormap, it is removed and the result
          is either gray or RGB depending on the colormap.
      (4) If RGB, the maximum difference between pixel components is
          saved in the histogram.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetDifferenceStats(*args)
    
    

    try:
        leptonica.pixCompareGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareGray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCompareGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareGray(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_int32', 'plottype')       
('l_int32', '*psame')       
('l_float32', '*pdiff')       
('l_float32', '*prmsdiff')       
('PIX', '**ppixdiff')       
  pixCompareGray()

      Input:  pix1 (8 or 16 bpp, not cmapped)
              pix2 (8 or 16 bpp, not cmapped)
              comptype (L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF)
              plottype (gplot plot output type, or 0 for no plot)
              &same (<optional return> 1 if pixel values are identical)
              &diff (<optional return> average difference)
              &rmsdiff (<optional return> rms of difference)
              &pixdiff (<optional return> pix of difference)
      Return: 0 if OK; 1 on error

  Notes:
      (1) See pixCompareGrayOrRGB() for details.
      (2) Use pixCompareGrayOrRGB() if the input pix are colormapped.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareGray(*args)
    
    

    try:
        leptonica.pixUsesCmapColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixUsesCmapColor.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixUsesCmapColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUsesCmapColor(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pcolor')       
  pixUsesCmapColor()

      Input:  pixs
              &color (<return>)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This returns color = TRUE if three things are obtained:
          (a) the pix has a colormap
          (b) the colormap has at least one color entry
          (c) a color entry is actually used
      (2) It is used in pixEqual() for comparing two images, in a
          situation where it is required to know if the colormap
          has color entries that are actually used in the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixUsesCmapColor(*args)
    
    

    try:
        leptonica.pixBestCorrelation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBestCorrelation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBestCorrelation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBestCorrelation(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_int32', 'etransx')       
('l_int32', 'etransy')       
('l_int32', 'maxshift')       
('l_int32', '*tab8')       
('l_int32', '*pdelx')       
('l_int32', '*pdely')       
('l_float32', '*pscore')       
('l_int32', 'debugflag')       
  pixBestCorrelation()

      Input:  pix1   (1 bpp)
              pix2   (1 bpp)
              area1  (number of on pixels in pix1)
              area2  (number of on pixels in pix2)
              etransx (estimated x translation of pix2 to align with pix1)
              etransy (estimated y translation of pix2 to align with pix1)
              maxshift  (max x and y shift of pix2, around the estimated
                          alignment location, relative to pix1)
              tab8 (<optional> sum tab for ON pixels in byte; can be NULL)
              &delx (<optional return> best x shift of pix2 relative to pix1
              &dely (<optional return> best y shift of pix2 relative to pix1
              &score (<optional return> maximum score found; can be NULL)
              debugflag (<= 0 to skip; positive to generate output.
                         The integer is used to label the debug image.)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This maximizes the correlation score between two 1 bpp images,
          by starting with an estimate of the alignment
          (@etransx, @etransy) and computing the correlation around this.
          It optionally returns the shift (@delx, @dely) that maximizes
          the correlation score when pix2 is shifted by this amount
          relative to pix1.
      (2) Get the centroids of pix1 and pix2, using pixCentroid(),
          to compute (@etransx, @etransy).  Get the areas using
          pixCountPixels().
      (3) The centroid of pix2 is shifted with respect to the centroid
          of pix1 by all values between -maxshiftx and maxshiftx,
          and likewise for the y shifts.  Therefore, the number of
          correlations computed is:
               (2 * maxshiftx + 1) * (2 * maxshifty + 1)
          Consequently, if pix1 and pix2 are large, you should do this
          in a coarse-to-fine sequence.  See the use of this function
          in pixCompareWithTranslation().


        """
        args = _convert_params(*args)
        
        return leptonica.pixBestCorrelation(*args)
    
    

    try:
        leptonica.pixEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixEqual.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqual(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', '*psame')       
  pixEqual()

      Input:  pix1
              pix2
              &same  (<return> 1 if same; 0 if different)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Equality is defined as having the same pixel values for
          each respective image pixel.
      (2) This works on two pix of any depth.  If one or both pix
          have a colormap, the depths can be different and the
          two pix can still be equal.
      (3) This ignores the alpha component for 32 bpp images.
      (4) If both pix have colormaps and the depths are equal,
          use the pixEqualWithCmap() function, which does a fast
          comparison if the colormaps are identical and a relatively
          slow comparison otherwise.
      (5) In all other cases, any existing colormaps must first be
          removed before doing pixel comparison.  After the colormaps
          are removed, the resulting two images must have the same depth.
          The "lowest common denominator" is RGB, but this is only
          chosen when necessary, or when both have colormaps but
          different depths.
      (6) For images without colormaps that are not 32 bpp, all bits
          in the image part of the data array must be identical.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqual(*args)
    
    

    try:
        leptonica.pixEqualWithCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixEqualWithCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixEqualWithCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqualWithCmap(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', '*psame')       
  pixEqualWithCmap()

      Input:  pix1
              pix2
              &same
      Return: 0 if OK, 1 on error

  Notes:
      (1) This returns same = TRUE if the images have identical content.
      (2) Both pix must have a colormap, and be of equal size and depth.
          If these conditions are not satisfied, it is not an error;
          the returned result is same = FALSE.
      (3) We then check whether the colormaps are the same; if so,
          the comparison proceeds 32 bits at a time.
      (4) If the colormaps are different, the comparison is done by
          slow brute force.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqualWithCmap(*args)
    
    

    try:
        leptonica.pixGetPSNR.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetPSNR.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetPSNR not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPSNR(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('l_float32', '*ppsnr')       
  pixGetPSNR()

      Input:  pix1, pix2 (8 or 32 bpp; no colormap)
              factor (sampling factor; >= 1)
              &psnr (<return> power signal/noise ratio difference)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes the power S/N ratio, in dB, for the difference
          between two images.  By convention, the power S/N
          for a grayscale image is ('log' == log base 10,
          and 'ln == log base e):
            PSNR = 10 * log((255/MSE)^2)
                 = 4.3429 * ln((255/MSE)^2)
                 = -4.3429 * ln((MSE/255)^2)
          where MSE is the mean squared error.
          Here are some examples:
             MSE             PSNR
             ---             ----
             10              28.1
             3               38.6
             1               48.1
             0.1             68.1
      (2) If pix1 and pix2 have the same pixel values, the MSE = 0.0
          and the PSNR is infinity.  For that case, this returns
          PSNR = 1000, which corresponds to the very small MSE of
          about 10^(-48).


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPSNR(*args)
    
    

    try:
        leptonica.pixEqualWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixEqualWithAlpha.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixEqualWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqualWithAlpha(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'use_alpha')       
('l_int32', '*psame')       
  pixEqualWithAlpha()

      Input:  pix1
              pix2
              use_alpha (1 to compare alpha in RGBA; 0 to ignore)
              &same  (<return> 1 if same; 0 if different)
      Return: 0 if OK; 1 on error

  Notes:
      (1) See notes in pixEqual().
      (2) This is more general than pixEqual(), in that for 32 bpp
          RGBA images, where spp = 4, you can optionally include
          the alpha component in the comparison.


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqualWithAlpha(*args)
    
    

    try:
        leptonica.pixTestForSimilarity.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixTestForSimilarity.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTestForSimilarity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTestForSimilarity(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('l_int32', 'mindiff')       
('l_float32', 'maxfract')       
('l_float32', 'maxave')       
('l_int32', '*psimilar')       
('l_int32', 'printstats')       
  pixTestForSimilarity()

      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)
              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)
              factor (subsampling factor; use 0 or 1 for no subsampling)
              mindiff (minimum pixel difference to be counted; > 0)
              maxfract (maximum fraction of pixels allowed to have
                        diff greater than or equal to mindiff)
              maxave (maximum average difference of pixels allowed for
                      pixels with diff greater than or equal to mindiff,
                      after subtracting mindiff)
              &similar (<return> 1 if similar, 0 otherwise)
              printstats (use 1 to print normalized histogram to stderr)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This takes 2 pix that are the same size and determines using
          3 input parameters if they are "similar".  The first parameter
          @mindiff establishes a criterion of pixel-to-pixel similarity:
          two pixels are not similar if their difference in value is
          at least mindiff.  Then @maxfract and @maxave are thresholds
          on the number and distribution of dissimilar pixels
          allowed for the two pix to be similar.   If the pix are
          to be similar, neither threshold can be exceeded.
      (2) In setting the @maxfract and @maxave thresholds, you have
          these options:
            (a) Base the comparison only on @maxfract.  Then set
                @maxave = 0.0 or 256.0.  (If 0, we always ignore it.)
            (b) Base the comparison only on @maxave.  Then set
                @maxfract = 1.0.
            (c) Base the comparison on both thresholds.
      (3) Example of values that can be expected at mindiff = 15 when
          comparing lossless png encoding with jpeg encoding, q=75:
             (smoothish bg)       fractdiff = 0.01, avediff = 2.5
             (natural scene)      fractdiff = 0.13, avediff = 3.5
          To identify these images as 'similar', select maxfract
          and maxave to be upper bounds of what you expect.
      (4) See pixGetDifferenceStats() for a discussion of why we subtract
          mindiff from the computed average diff of the nonsimilar pixels
          to get the 'avediff' returned by that function.
      (5) If there is a colormap, it is removed and the result
          is either gray or RGB depending on the colormap.
      (6) If RGB, the maximum difference between pixel components is
          saved in the histogram.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTestForSimilarity(*args)
    
    

    try:
        leptonica.pixCompareWithTranslation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCompareWithTranslation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCompareWithTranslation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareWithTranslation(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'thresh')       
('l_int32', '*pdelx')       
('l_int32', '*pdely')       
('l_float32', '*pscore')       
('l_int32', 'debugflag')       
  pixCompareWithTranslation()

      Input:  pix1, pix2 (any depth; colormap OK)
              thresh (threshold for converting to 1 bpp)
              &delx (<return> x translation on pix2 to align with pix1)
              &dely (<return> y translation on pix2 to align with pix1)
              &score (<return> correlation score at best alignment)
              debugflag (1 for debug output; 0 for no debugging)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a coarse-to-fine search for best translational
          alignment of two images, measured by a scoring function
          that is the correlation between the fg pixels.
      (2) The threshold is used if the images aren't 1 bpp.
      (3) With debug on, you get a pdf that shows, as a grayscale
          image, the score as a function of shift from the initial
          estimate, for each of the four levels.  The shift is 0 at
          the center of the image.
      (4) With debug on, you also get a pdf that shows the
          difference at the best alignment between the two images,
          at each of the four levels.  The red and green pixels
          show locations where one image has a fg pixel and the
          other doesn't.  The black pixels are where both images
          have fg pixels, and white pixels are where neither image
          has fg pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareWithTranslation(*args)
    
    

    try:
        leptonica.pixGetDifferenceHistogram.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetDifferenceHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetDifferenceHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetDifferenceHistogram(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
  pixGetDifferenceHistogram()

      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)
              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)
              factor (subsampling factor; use 0 or 1 for no subsampling)
      Return: na (Numa of histogram of differences), or null on error

  Notes:
      (1) The two images are aligned at the UL corner, and do not
          need to be the same size.  If they are not the same size,
          the comparison will be made over overlapping pixels.
      (2) If there is a colormap, it is removed and the result
          is either gray or RGB depending on the colormap.
      (3) If RGB, the maximum difference between pixel components is
          saved in the histogram.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetDifferenceHistogram(*args)
    
    

    try:
        leptonica.pixCompareRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareRGB.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCompareRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareRGB(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_int32', 'plottype')       
('l_int32', '*psame')       
('l_float32', '*pdiff')       
('l_float32', '*prmsdiff')       
('PIX', '**ppixdiff')       
  pixCompareRGB()

      Input:  pix1 (32 bpp rgb)
              pix2 (32 bpp rgb)
              comptype (L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF)
              plottype (gplot plot output type, or 0 for no plot)
              &same (<optional return> 1 if pixel values are identical)
              &diff (<optional return> average difference)
              &rmsdiff (<optional return> rms of difference)
              &pixdiff (<optional return> pix of difference)
      Return: 0 if OK; 1 on error

  Notes:
      (1) See pixCompareGrayOrRGB() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareRGB(*args)
    
    

    try:
        leptonica.pixGetPerceptualDiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetPerceptualDiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetPerceptualDiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPerceptualDiff(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'sampling')       
('l_int32', 'dilation')       
('l_int32', 'mindiff')       
('l_float32', '*pfract')       
('PIX', '**ppixdiff1')       
('PIX', '**ppixdiff2')       
  pixGetPerceptualDiff()

      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)
              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)
              sampling (subsampling factor; use 0 or 1 for no subsampling)
              dilation (size of grayscale or color Sel; odd)
              mindiff (minimum pixel difference to be counted; > 0)
              &fract (<return> fraction of pixels with diff greater than
                      mindiff)
              &pixdiff1 (<optional return> showing difference (gray or color))
              &pixdiff2 (<optional return> showing pixels of sufficient diff)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This takes 2 pix and determines, using 2 input parameters:
           * @dilation specifies the amount of grayscale or color
             dilation to apply to the images, to compensate for
             a small amount of misregistration.  A typical number might
             be 5, which uses a 5x5 Sel.  Grayscale dilation expands
             lighter pixels into darker pixel regions.
           * @mindiff determines the threshold on the difference in
             pixel values to be counted -- two pixels are not similar
             if their difference in value is at least @mindiff.  For
             color pixels, we use the maximum component difference.
      (2) The pixelwise comparison is always done with the UL corners
          aligned.  The sizes of pix1 and pix2 need not be the same,
          although in practice it can be useful to scale to the same size.
      (3) If there is a colormap, it is removed and the result
          is either gray or RGB depending on the colormap.
      (4) Two optional diff images can be retrieved (typ. for debugging):
           pixdiff1: the gray or color difference
           pixdiff2: thresholded to 1 bpp for pixels exceeding @mindiff
      (5) The returned value of fract can be compared to some threshold,
          which is application dependent.
      (6) This method is in analogy to the two-sided hausdorff transform,
          except here it is for d > 1.  For d == 1 (see pixRankHaustest()),
          we verify that when one pix1 is dilated, it covers at least a
          given fraction of the pixels in pix2, and v.v.; in that
          case, the two pix are sufficiently similar.  Here, we
          do an analogous thing: subtract the dilated pix1 from pix2 to
          get a 1-sided hausdorff-like transform.  Then do it the
          other way.  Take the component-wise max of the two results,
          and threshold to get the fraction of pixels with a difference
          below the threshold.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPerceptualDiff(*args)
    
    

    try:
        leptonica.pixCorrelationBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationBinary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCorrelationBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationBinary(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_float32', '*pval')       
  pixCorrelationBinary()

      Input:  pix1 (1 bpp)
              pix2 (1 bpp)
              &val (<return> correlation)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The correlation is a number between 0.0 and 1.0,
          based on foreground similarity:
                           (|1 AND 2|)**2
            correlation =  --------------
                             |1| * |2|
          where |x| is the count of foreground pixels in image x.
          If the images are identical, this is 1.0.
          If they have no fg pixels in common, this is 0.0.
          If one or both images have no fg pixels, the correlation is 0.0.
      (2) Typically the two images are of equal size, but this
          is not enforced.  Instead, the UL corners are aligned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationBinary(*args)
    
    

    try:
        leptonica.pixCompareTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCompareTiled.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCompareTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareTiled(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'type')       
('PIX', '**ppixdiff')       
  pixCompareTiled()

      Input:  pix1 (8 bpp or 32 bpp rgb)
              pix2 (8 bpp 32 bpp rgb)
              sx, sy (tile size; must be > 1)
              type (L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE)
              &pixdiff (<return> pix of difference)
      Return: 0 if OK; 1 on error

  Notes:
      (1) With L_MEAN_ABSVAL, we compute for each tile the
          average abs value of the pixel component difference between
          the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we
          compute instead the rms difference over all components.
      (2) The two input pix must be the same depth.  Comparison is made
          using UL corner alignment.
      (3) For 32 bpp, the distance between corresponding tiles
          is found by averaging the measured difference over all three
          components of each pixel in the tile.
      (4) The result, pixdiff, contains one pixel for each source tile.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareTiled(*args)
    
    

    try:
        leptonica.pixCompareGrayOrRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareGrayOrRGB.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCompareGrayOrRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareGrayOrRGB(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_int32', 'plottype')       
('l_int32', '*psame')       
('l_float32', '*pdiff')       
('l_float32', '*prmsdiff')       
('PIX', '**ppixdiff')       
  pixCompareGrayOrRGB()

      Input:  pix1 (8 or 16 bpp gray, 32 bpp rgb, or colormapped)
              pix2 (8 or 16 bpp gray, 32 bpp rgb, or colormapped)
              comptype (L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF)
              plottype (gplot plot output type, or 0 for no plot)
              &same (<optional return> 1 if pixel values are identical)
              &diff (<optional return> average difference)
              &rmsdiff (<optional return> rms of difference)
              &pixdiff (<optional return> pix of difference)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The two images are aligned at the UL corner, and do not
          need to be the same size.  If they are not the same size,
          the comparison will be made over overlapping pixels.
      (2) If there is a colormap, it is removed and the result
          is either gray or RGB depending on the colormap.
      (3) If RGB, each component is compared separately.
      (4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1
          and the absolute value is taken.
      (5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1
          and the result is clipped to 0.
      (6) The plot output types are specified in gplot.h.
          Use 0 if no difference plot is to be made.
      (7) If the images are pixelwise identical, no difference
          plot is made, even if requested.  The result (TRUE or FALSE)
          is optionally returned in the parameter 'same'.
      (8) The average difference (either subtracting or absolute value)
          is optionally returned in the parameter 'diff'.
      (9) The RMS difference is optionally returned in the
          parameter 'rmsdiff'.  For RGB, we return the average of
          the RMS differences for each of the components.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareGrayOrRGB(*args)
    
    

    try:
        leptonica.pixDisplayDiffBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDisplayDiffBinary.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayDiffBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayDiffBinary(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
  pixDisplayDiffBinary()

      Input:  pix1 (1 bpp)
              pix2 (1 bpp)
      Return: pixd (4 bpp cmapped), or null on error

  Notes:
      (1) This gives a color representation of the difference between
          pix1 and pix2.  The color difference depends on the order.
          The pixels in pixd have 4 colors:
           * unchanged:  black (on), white (off)
           * on in pix1, off in pix2: red
           * on in pix2, off in pix1: green
      (2) This aligns the UL corners of pix1 and pix2, and crops
          to the overlapping pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayDiffBinary(*args)
    
    

    try:
        leptonica.pixCompareRankDifference.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCompareRankDifference.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCompareRankDifference not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareRankDifference(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
  pixCompareRankDifference()

      Input:  pix1 (8 bpp gray or 32 bpp rgb, or colormapped)
              pix2 (8 bpp gray or 32 bpp rgb, or colormapped)
              factor (subsampling factor; use 0 or 1 for no subsampling)
      Return: narank (numa of rank difference), or null on error

  Notes:
      (1) This answers the question: if the pixel values in each
          component are compared by absolute difference, for
          any value of difference, what is the fraction of
          pixel pairs that have a difference of this magnitude
          or greater.  For a difference of 0, the fraction is 1.0.
          In this sense, it is a mapping from pixel difference to
          rank order of difference.
      (2) The two images are aligned at the UL corner, and do not
          need to be the same size.  If they are not the same size,
          the comparison will be made over overlapping pixels.
      (3) If there is a colormap, it is removed and the result
          is either gray or RGB depending on the colormap.
      (4) If RGB, pixel differences for each component are aggregated
          into a single histogram.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareRankDifference(*args)
    
    

    try:
        leptonica.pixCompareBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareBinary.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCompareBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareBinary(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_float32', '*pfract')       
('PIX', '**ppixdiff')       
  pixCompareBinary()

      Input:  pix1 (1 bpp)
              pix2 (1 bpp)
              comptype (L_COMPARE_XOR, L_COMPARE_SUBTRACT)
              &fract (<return> fraction of pixels that are different)
              &pixdiff (<optional return> pix of difference)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The two images are aligned at the UL corner, and do not
          need to be the same size.
      (2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.
      (3) The total number of pixels is determined by pix1.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareBinary(*args)
    




class conncomp(object):
    """  conncomp.c

    Connected component counting and extraction, using Heckbert's
    stack-based filling algorithm.

      4- and 8-connected components: counts, bounding boxes and images

      Top-level calls:
           BOXA     *pixConnComp()
           BOXA     *pixConnCompPixa()
           BOXA     *pixConnCompBB()
           l_int32   pixCountConnComp()

      Identify the next c.c. to be erased:
           l_int32   nextOnPixelInRaster()
           l_int32   nextOnPixelInRasterLow()

      Erase the c.c., saving the b.b.:
           BOX      *pixSeedfillBB()
           BOX      *pixSeedfill4BB()
           BOX      *pixSeedfill8BB()

      Just erase the c.c.:
           l_int32   pixSeedfill()
           l_int32   pixSeedfill4()
           l_int32   pixSeedfill8()

      Static stack helper functions for single raster line seedfill:
           static void    pushFillsegBB()
           static void    pushFillseg()
           static void    popFillseg()

  The basic method in pixConnCompBB() is very simple.  We scan the
  image in raster order, looking for the next ON pixel.  When it
  is found, we erase it and every pixel of the 4- or 8-connected
  component to which it belongs, using Heckbert's seedfill
  algorithm.  As pixels are erased, we keep track of the
  minimum rectangle that encloses all erased pixels; after
  the connected component has been erased, we save its
  bounding box in an array of boxes.  When all pixels in the
  image have been erased, we have an array that describes every
  4- or 8-connected component in terms of its bounding box.

  pixConnCompPixa() is a slight variation on pixConnCompBB(),
  where we additionally save an array of images (in a Pixa)
  of each of the 4- or 8-connected components.  This is done trivially
  by maintaining two temporary images.  We erase a component from one,
  and use the bounding box to extract the pixels within the b.b.
  from each of the two images.  An XOR between these subimages
  gives the erased component.  Then we erase the component from the
  second image using the XOR again, with the extracted component
  placed on the second image at the location of the bounding box.
  Rasterop does all the work.  At the end, we have an array
  of the 4- or 8-connected components, as well as an array of the
  bounding boxes that describe where they came from in the original image.

  If you just want the number of connected components, pixCountConnComp()
  is a bit faster than pixConnCompBB(), because it doesn't have to
  keep track of the bounding rectangles for each c.c.

"""
    
    try:
        leptonica.pixSeedfill4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill4.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfill4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill4(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixSeedfill4()

      Input:  pixs (1 bpp)
              stack (for holding fillsegs)
              x,y   (location of seed pixel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
      (2) This operates on the input 1 bpp pix to remove the fg seed
          pixel, at (x,y), and all pixels that are 4-connected to it.
          The seed pixel at (x,y) must initially be ON.
      (3) Reference: see pixSeedFill4BB()


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill4(*args)
    
    

    try:
        leptonica.pixSeedfill.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'connectivity')       
  pixSeedfill()

      Input:  pixs (1 bpp)
              stack (for holding fillsegs)
              x,y   (location of seed pixel)
              connectivity  (4 or 8)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This removes the component from pixs with a fg pixel at (x,y).
      (2) See pixSeedfill4() and pixSeedfill8() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill(*args)
    
    

    try:
        leptonica.nextOnPixelInRaster.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.nextOnPixelInRaster.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function nextOnPixelInRaster not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def nextOnPixelInRaster(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xstart')       
('l_int32', 'ystart')       
('l_int32', '*px')       
('l_int32', '*py')       
  nextOnPixelInRaster()

      Input:  pixs (1 bpp)
              xstart, ystart  (starting point for search)
              &x, &y  (<return> coord value of next ON pixel)
      Return: 1 if a pixel is found; 0 otherwise or on error


        """
        args = _convert_params(*args)
        
        return leptonica.nextOnPixelInRaster(*args)
    
    

    try:
        leptonica.pixSeedfillBB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillBB.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfillBB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillBB(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'connectivity')       
  pixSeedfillBB()

      Input:  pixs (1 bpp)
              stack (for holding fillsegs)
              x,y   (location of seed pixel)
              connectivity  (4 or 8)
      Return: box or null on error

  Notes:
      (1) This is the high-level interface to Paul Heckbert's
          stack-based seedfill algorithm.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillBB(*args)
    
    

    try:
        leptonica.pixCountConnComp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCountConnComp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixCountConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountConnComp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('l_int32', '*pcount')       
  pixCountConnComp()

      Input:  pixs (1 bpp)
              connectivity (4 or 8)
              &count (<return>
      Return: 0 if OK, 1 on error

 Notes:
     (1) This is the top-level call for getting the number of
         4- or 8-connected components in a 1 bpp image.
     (2) It works on a copy of the input pix.  The c.c. are located
         in raster order and erased one at a time.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountConnComp(*args)
    
    

    try:
        leptonica.pixConnCompBB.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnCompBB.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConnCompBB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompBB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
  pixConnCompBB()

      Input:  pixs (1 bpp)
              connectivity (4 or 8)
      Return: boxa, or null on error

 Notes:
     (1) Finds bounding boxes of 4- or 8-connected components
         in a binary image.
     (2) This works on a copy of the input pix.  The c.c. are located
         in raster order and erased one at a time.  In the process,
         the b.b. is computed and saved.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompBB(*args)
    
    

    try:
        leptonica.pixConnComp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnComp.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnComp(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '**ppixa')       
('l_int32', 'connectivity')       
  pixConnComp()

      Input:  pixs (1 bpp)
              &pixa   (<optional return> pixa of each c.c.)
              connectivity (4 or 8)
      Return: boxa, or null on error

  Notes:
      (1) This is the top-level call for getting bounding boxes or
          a pixa of the components, and it can be used instead
          of either pixConnCompBB() or pixConnCompPixa(), rsp.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnComp(*args)
    
    

    try:
        leptonica.pixSeedfill4BB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill4BB.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfill4BB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill4BB(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixSeedfill4BB()

      Input:  pixs (1 bpp)
              stack (for holding fillsegs)
              x,y   (location of seed pixel)
      Return: box or null on error.

  Notes:
      (1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
      (2) This operates on the input 1 bpp pix to remove the fg seed
          pixel, at (x,y), and all pixels that are 4-connected to it.
          The seed pixel at (x,y) must initially be ON.
      (3) Returns the bounding box of the erased 4-cc component.
      (4) Reference: see Paul Heckbert's stack-based seed fill algorithm
          in "Graphic Gems", ed. Andrew Glassner, Academic
          Press, 1990.  The algorithm description is given
          on pp. 275-277; working C code is on pp. 721-722.)
          The code here follows Heckbert's exactly, except
          we use function calls instead of macros for
          pushing data on and popping data off the stack.
          This makes sense to do because Heckbert's fixed-size
          stack with macros is dangerous: images exist that
          will overrun the stack and crash.   The stack utility
          here grows dynamically as needed, and the fillseg
          structures that are not in use are stored in another
          stack for reuse.  It should be noted that the
          overhead in the function calls (vs. macros) is negligible.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill4BB(*args)
    
    

    try:
        leptonica.pixSeedfill8BB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill8BB.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfill8BB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill8BB(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixSeedfill8BB()

      Input:  pixs (1 bpp)
              stack (for holding fillsegs)
              x,y   (location of seed pixel)
      Return: box or null on error.

  Notes:
      (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
      (2) This operates on the input 1 bpp pix to remove the fg seed
          pixel, at (x,y), and all pixels that are 8-connected to it.
          The seed pixel at (x,y) must initially be ON.
      (3) Returns the bounding box of the erased 8-cc component.
      (4) Reference: see Paul Heckbert's stack-based seed fill algorithm
          in "Graphic Gems", ed. Andrew Glassner, Academic
          Press, 1990.  The algorithm description is given
          on pp. 275-277; working C code is on pp. 721-722.)
          The code here follows Heckbert's closely, except
          the leak checks are changed for 8 connectivity.
          See comments on pixSeedfill4BB() for more details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill8BB(*args)
    
    

    try:
        leptonica.pixSeedfill8.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill8.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSeedfill8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill8(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixSeedfill8()

      Input:  pixs (1 bpp)
              stack (for holding fillsegs)
              x,y   (location of seed pixel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
      (2) This operates on the input 1 bpp pix to remove the fg seed
          pixel, at (x,y), and all pixels that are 8-connected to it.
          The seed pixel at (x,y) must initially be ON.
      (3) Reference: see pixSeedFill8BB()


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill8(*args)
    
    

    try:
        leptonica.pixConnCompPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnCompPixa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixConnCompPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompPixa(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '**ppixa')       
('l_int32', 'connectivity')       
  pixConnCompPixa()

      Input:  pixs (1 bpp)
              &pixa (<return> pixa of each c.c.)
              connectivity (4 or 8)
      Return: boxa, or null on error

  Notes:
      (1) This finds bounding boxes of 4- or 8-connected components
          in a binary image, and saves images of each c.c
          in a pixa array.
      (2) It sets up 2 temporary pix, and for each c.c. that is
          located in raster order, it erases the c.c. from one pix,
          then uses the b.b. to extract the c.c. from the two pix using
          an XOR, and finally erases the c.c. from the second pix.
      (3) A clone of the returned boxa (where all boxes in the array
          are clones) is inserted into the pixa.
      (4) If the input is valid, this always returns a boxa and a pixa.
          If pixs is empty, the boxa and pixa will be empty.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompPixa(*args)
    




class utils(object):
    """  utils.c

       Control of error, warning and info messages
           l_int32    setMsgSeverity()

       Error return functions, invoked by macros
           l_int32    returnErrorInt()
           l_float32  returnErrorFloat()
           void      *returnErrorPtr()

       Safe string procs
           char      *stringNew()
           l_int32    stringCopy()
           l_int32    stringReplace()
           l_int32    stringLength()
           l_int32    stringCat()
           char      *stringConcatNew()
           char      *stringJoin()
           char      *stringReverse()
           char      *strtokSafe()
           l_int32    stringSplitOnToken()

       Find and replace string and array procs
           char      *stringRemoveChars()
           l_int32    stringFindSubstr()
           char      *stringReplaceSubstr()
           char      *stringReplaceEachSubstr()
           L_DNA     *arrayFindEachSequence()
           l_int32    arrayFindSequence()

       Safe realloc
           void      *reallocNew()

       Read and write between file and memory
           l_uint8   *l_binaryRead()
           l_uint8   *l_binaryReadStream()
           l_uint8   *l_binaryReadSelect()
           l_uint8   *l_binaryReadSelectStream()
           l_int32    l_binaryWrite()
           l_int32    nbytesInFile()
           l_int32    fnbytesInFile()

       Copy in memory
           l_uint8   *l_binaryCopy()

       File copy operations
           l_int32    fileCopy()
           l_int32    fileConcatenate()
           l_int32    fileAppendString()

       Test files for equivalence
           l_int32    filesAreIdentical()

       Byte-swapping data conversion
           l_uint16   convertOnBigEnd16()
           l_uint32   convertOnBigEnd32()
           l_uint16   convertOnLittleEnd16()
           l_uint32   convertOnLittleEnd32()

       Cross-platform functions for opening file streams
           FILE      *fopenReadStream()
           FILE      *fopenWriteStream()

       Cross-platform functions that avoid C-runtime boundary crossing
       with Windows DLLs
           FILE      *lept_fopen()
           l_int32    lept_fclose()
           void       lept_calloc()
           void       lept_free()

       Cross-platform file system operations in temp directories
           l_int32    lept_mkdir()
           l_int32    lept_rmdir()
           l_int32    lept_direxists()
           l_int32    lept_mv()
           l_int32    lept_rm_match()
           l_int32    lept_rm()
           l_int32    lept_rmfile()
           l_int32    lept_cp()

       General file name operations
           l_int32    splitPathAtDirectory()
           l_int32    splitPathAtExtension()
           char      *pathJoin()
           char      *appendSubdirectory()

       Special file name operations
*          l_int32    convertSepCharsInPath()
           char      *genPathname()
           l_int32    makeTempDirname()
           l_int32    modifyTrailingSlash()
           char      *genTempFilename()
           l_int32    extractNumberFromFilename()

       File corruption operation
           l_int32    fileCorruptByDeletion()
           l_int32    fileCorruptByMutation()

       Generate random integer in given range
           l_int32    genRandomIntegerInRange()

       Simple math function
           l_int32    lept_roundftoi()

       Gray code conversion
           l_uint32   convertBinaryToGrayCode()
           l_uint32   convertGrayToBinaryCode()

       Leptonica version number
           char      *getLeptonicaVersion()

       Timing
           void       startTimer()
           l_float32  stopTimer()
           L_TIMER    startTimerNested()
           l_float32  stopTimerNested()
           void       l_getCurrentTime()
           void       l_getFormattedDate()

  Notes on cross-platform development
  -----------------------------------
  This is important:
  (1) With the exception of splitPathAtDirectory(), splitPathAtExtension()
*     and genPathname(), all input pathnames must have unix separators.
  (2) On Windows, when you specify a read or write to "/tmp/...",
      the filename is rewritten to use the Windows temp directory:
         /tmp  ==>    <Temp>...    (windows)
  (3) This filename rewrite, along with the conversion from unix
      to windows pathnames, happens in genPathname().
  (4) Use fopenReadStream() and fopenWriteStream() to open files,
      because these use genPathname() to find the platform-dependent
      filenames.  Likewise for l_binaryRead() and l_binaryWrite().
  (5) For moving, copying and removing files and directories that are in
      subdirectories of /tmp, use the lept_*() file system shell wrappers:
         lept_mkdir(), lept_rmdir(), lept_mv(), lept_rm() and lept_cp().
  (6) Use the lept_*() C library wrappers.  These work properly on
      Windows, where the same DLL must perform complementary operations
      on file streams (open/close) and heap memory (malloc/free):
         lept_fopen(), lept_fclose(), lept_calloc() and lept_free().

"""
    
    try:
        leptonica.stringCat.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.stringCat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringCat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCat(*args):
        """
        ('char', '*dest')       
('size_t', 'size')       
('const char', '*src')       
  stringCat()

      Input:  dest (null-terminated byte buffer)
              size (size of dest)
              src string (can be null or null-terminated string)
      Return: number of bytes added to dest; -1 on error

  Notes:
      (1) Alternative implementation of strncat, that checks the input,
          is easier to use (since the size of the dest buffer is specified
          rather than the number of bytes to copy), and does not complain
          if @src is null.
      (2) Never writes past end of dest.
      (3) If it can't append src (an error), it does nothing.
      (4) N.B. The order of 2nd and 3rd args is reversed from that in
          strncat, as in the Windows function strcat_s().


        """
        args = _convert_params(*args)
        
        return leptonica.stringCat(*args)
    
    

    try:
        leptonica.stringFindSubstr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringFindSubstr.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringFindSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringFindSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub')       
('l_int32', '*ploc')       
  stringFindSubstr()

      Input:  src (input string; can be of zero length)
              sub (substring to be searched for)
              &loc (<return optional> location of substring in src)
      Return: 1 if found; 0 if not found or on error

  Notes:
      (1) This is a wrapper around strstr().
      (2) Both @src and @sub must be defined, and @sub must have
          length of at least 1.
      (3) If the substring is not found and loc is returned, it has
          the value -1.


        """
        args = _convert_params(*args)
        
        return leptonica.stringFindSubstr(*args)
    
    

    try:
        leptonica.l_binaryCopy.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.l_binaryCopy.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function l_binaryCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryCopy(*args):
        """
        ('l_uint8', '*datas')       
('size_t', 'size')       
  l_binaryCopy()

      Input:  datas
              size (of data array)
      Return: datad (on heap), or null on error

  Notes:
      (1) We add 4 bytes to the zeroed output because in some cases
          (e.g., string handling) it is important to have the data
          be null terminated.  This guarantees that after the memcpy,
          the result is automatically null terminated.


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryCopy(*args)
    
    

    try:
        leptonica.stringReplaceSubstr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringReplaceSubstr.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function stringReplaceSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReplaceSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub1')       
('const char', '*sub2')       
('l_int32', '*pfound')       
('l_int32', '*ploc')       
  stringReplaceSubstr()

      Input:  src (input string; can be of zero length)
              sub1 (substring to be replaced)
              sub2 (substring to put in; can be "")
              &found (<return optional> 1 if sub1 is found; 0 otherwise)
              &loc (<return optional> location of ptr after replacement)
      Return: dest (string with substring replaced), or null if the
              substring not found or on error.

  Notes:
      (1) Replaces the first instance.
      (2) To only remove sub1, use "" for sub2
      (3) Returns a new string if sub1 and sub2 are the same.
      (4) The optional loc is input as the byte offset within the src
          from which the search starts, and after the search it is the
          char position in the string of the next character after
          the substituted string.
      (5) N.B. If ploc is not null, loc must always be initialized.
          To search the string from the beginning, set loc = 0.


        """
        args = _convert_params(*args)
        
        return leptonica.stringReplaceSubstr(*args)
    
    

    try:
        leptonica.appendSubdirectory.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.appendSubdirectory.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function appendSubdirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def appendSubdirectory(*args):
        """
        ('const char', '*dir')       
('const char', '*subdir')       
  appendSubdirectory()

      Input:  dir
              subdir
      Return: concatenated directory path without trailing slash,
              or null on error

  Notes:
      (1) Use unix pathname separators
      (2) Allocates a new string:  <dir>/<subdir>


        """
        args = _convert_params(*args)
        
        return leptonica.appendSubdirectory(*args)
    
    

    try:
        leptonica.fileAppendString.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fileAppendString.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fileAppendString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileAppendString(*args):
        """
        ('const char', '*filename')       
('const char', '*str')       
  fileAppendString()

      Input:  filename
              str (string to append to file)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileAppendString(*args)
    
    

    try:
        leptonica.fnbytesInFile.argtypes = [ctypes.c_void_p]
        leptonica.fnbytesInFile.restype = ctypes.c_size_t
    except AttributeError:
        os.stderr.write("Warning - function fnbytesInFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fnbytesInFile(*args):
        """
        ('FILE', '*fp')       
  fnbytesInFile()

      Input:  file stream
      Return: nbytes in file; 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fnbytesInFile(*args)
    
    

    try:
        leptonica.genPathname.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.genPathname.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function genPathname not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def genPathname(*args):
        """
        ('const char', '*dir')       
('const char', '*fname')       
  genPathname()

      Input:  dir (<optional> directory or full path name, with or without
                   trailing '/')
              fname (<optional> file name within a directory)
      Return: pathname (either a directory or full path), or null on error

  Notes:
      (1) This function generates actual paths in the following ways:
            * from two sub-parts (e.g., a directory and a file name).
            * from a single path full path, placed in @dir, with
              @fname == NULL.
            * from the name of a file in the local directory placed in
              @fname, with @dir == NULL.
            * if in a "/tmp" directory and on windows, the windows
              temp directory is used.
      (2) The name translation for "/tmp" on windows is:
               /tmp  -->   <Temp>   (windows)
      (3) There are four cases for the input:
          (a) @dir is a directory and @fname is defined: result is a full path
          (b) @dir is a directory and @fname is null: result is a directory
          (c) @dir is a full path and @fname is null: result is a full path
          (d) @dir is null or an empty string: start in the current dir;
              result is a full path
      (4) In all cases, the resulting pathname is not terminated with a slash
      (5) The caller is responsible for freeing the returned pathname.


        """
        args = _convert_params(*args)
        
        return leptonica.genPathname(*args)
    
    

    try:
        leptonica.lept_rmfile.argtypes = [ctypes.c_void_p]
        leptonica.lept_rmfile.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_rmfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rmfile(*args):
        """
        ('const char', '*filepath')       
  lept_rmfile()

      Input:  filepath (full path to file including the directory)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This removes the named file.
      (2) Use unix pathname separators.
      (3) Unlike the other lept_* functions in this section, this can remove
          any file. It is not restricted to files that are in /tmp or a
          subdirectory of it.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rmfile(*args)
    
    

    try:
        leptonica.l_binaryRead.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_binaryRead.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function l_binaryRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryRead(*args):
        """
        ('const char', '*filename')       
('size_t', '*pnbytes')       
  l_binaryRead()

      Input:  filename
              &nbytes (<return> number of bytes read)
      Return: data, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryRead(*args)
    
    

    try:
        leptonica.fileCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fileCopy.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fileCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileCopy(*args):
        """
        ('const char', '*srcfile')       
('const char', '*newfile')       
  fileCopy()

      Input:  srcfile (copy this file)
              newfile (to this file)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileCopy(*args)
    
    

    try:
        leptonica.lept_rmdir.argtypes = [ctypes.c_void_p]
        leptonica.lept_rmdir.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_rmdir not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rmdir(*args):
        """
        ('const char', '*subdir')       
  lept_rmdir()

      Input:  subdir (of /tmp or its equivalent on Windows)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This removes all files from the specified subdirectory of:
            /tmp      (unix)
            <Temp>    (windows)
          and then removes the directory.
      (2) The combination
            lept_rmdir(subdir);
            lept_mkdir(subdir);
          is guaranteed to give you an empty subdirectory.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rmdir(*args)
    
    

    try:
        leptonica.convertBinaryToGrayCode.argtypes = [ctypes.c_uint32]
        leptonica.convertBinaryToGrayCode.restype = ctypes.c_uint32
    except AttributeError:
        os.stderr.write("Warning - function convertBinaryToGrayCode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertBinaryToGrayCode(*args):
        """
        ('l_uint32', 'val')       
  convertBinaryToGrayCode()

      Input:  val
      Return: gray code value

  Notes:
      (1) Gray code values corresponding to integers differ by
          only one bit transition between successive integers.


        """
        args = _convert_params(*args)
        
        return leptonica.convertBinaryToGrayCode(*args)
    
    

    try:
        leptonica.l_binaryReadStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_binaryReadStream.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function l_binaryReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryReadStream(*args):
        """
        ('FILE', '*fp')       
('size_t', '*pnbytes')       
  l_binaryReadStream()

      Input:  fp (stream opened to read; can be stdin)
              &nbytes (<return> number of bytes read)
      Return: null-terminated array, or null on error
              (reading 0 bytes is not an error)

  Notes:
      (1) The returned array is terminated with a null byte so that it can
          be used to read ascii data from a file into a proper C string.
      (2) This can be used to capture data that is piped in via stdin,
          because it does not require seeking within the file.
      (3) For example, you can read an image from stdin into memory
          using shell redirection, with one of these shell commands:
             cat <imagefile> | readprog
             readprog < <imagefile>
          where readprog is:
             l_uint8 *data = l_binaryReadStream(stdin, &nbytes);
             Pix *pix = pixReadMem(data, nbytes);


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryReadStream(*args)
    
    

    try:
        leptonica.lept_rm_match.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_rm_match.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_rm_match not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rm_match(*args):
        """
        ('const char', '*subdir')       
('const char', '*substr')       
  lept_rm_match()

      Input:  subdir (<optional>  If NULL, the removed files are in /tmp)
              substr (<optional> pattern to match in filename)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This removes the matched files in /tmp or a subdirectory of /tmp.
          Use NULL for @subdir if the files are in /tmp.
      (2) If @substr == NULL, this removes all files in the directory.
          If @substr == "" (empty), this removes no files.
          If both @subdir == NULL and @substr == NULL, this removes
          all files in /tmp.
      (3) Use unix pathname separators.
      (4) On Windows, the file is in either <Temp>, or in a
          subdirectory, where <Temp> is the Windows temp dir.
          The name translation is: /tmp --> <Temp>.
      (5) Error conditions:
            * returns -1 if the directory is not found
            * returns the number of files (> 0) that it was unable to remove.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rm_match(*args)
    
    

    try:
        leptonica.splitPathAtDirectory.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.splitPathAtDirectory.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function splitPathAtDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def splitPathAtDirectory(*args):
        """
        ('const char', '*pathname')       
('char', '**pdir')       
('char', '**ptail')       
  splitPathAtDirectory()

      Input:  pathname  (full path; can be a directory)
              &dir  (<optional return> root directory name of
                     input path, including trailing '/')
              &tail (<optional return> path tail, which is either
                     the file name within the root directory or
                     the last sub-directory in the path)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If you only want the tail, input null for the root directory ptr.
      (2) If you only want the root directory name, input null for the
          tail ptr.
      (3) This function makes decisions based only on the lexical
          structure of the input.  Examples:
            /usr/tmp/abc  -->  dir: /usr/tmp/       tail: abc
            /usr/tmp/     -->  dir: /usr/tmp/       tail: [empty string]
            /usr/tmp      -->  dir: /usr/           tail: tmp
            abc           -->  dir: [empty string]  tail: abc
      (4) The input can have either forward (unix) or backward (win)
          slash separators.  The output has unix separators.
          Note that Win32 pathname functions generally accept both
          slash forms, but the windows command line interpreter
          only accepts backward slashes, because forward slashes are
          used to demarcate switches (vs. dashes in unix).


        """
        args = _convert_params(*args)
        
        return leptonica.splitPathAtDirectory(*args)
    
    

    try:
        leptonica.lept_roundftoi.argtypes = [ctypes.c_float]
        leptonica.lept_roundftoi.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_roundftoi not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_roundftoi(*args):
        """
        ('l_float32', 'fval')       
  lept_roundftoi()

      Input:  fval
      Return: value rounded to int

  Notes:
      (1) For fval >= 0, fval --> round(fval) == floor(fval + 0.5)
          For fval < 0, fval --> -round(-fval))
          This is symmetric around 0.
          e.g., for fval in (-0.5 ... 0.5), fval --> 0


        """
        args = _convert_params(*args)
        
        return leptonica.lept_roundftoi(*args)
    
    

    try:
        leptonica.convertSepCharsInPath.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.convertSepCharsInPath.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertSepCharsInPath not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertSepCharsInPath(*args):
        """
        ('char', '*path')       
('l_int32', 'type')       
  convertSepCharsInPath()

      Input:  path
              type (UNIX_PATH_SEPCHAR, WIN_PATH_SEPCHAR)
      Return: 0 if OK, 1 on error

  Notes:
      (1) In-place conversion.
      (2) Type is the resulting type:
            * UNIX_PATH_SEPCHAR:  '\\' ==> '/'
            * WIN_PATH_SEPCHAR:   '/' ==> '\\'
      (3) Virtually all path operations in leptonica use unix separators.


        """
        args = _convert_params(*args)
        
        return leptonica.convertSepCharsInPath(*args)
    
    

    try:
        leptonica.l_binaryReadSelectStream.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.l_binaryReadSelectStream.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function l_binaryReadSelectStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryReadSelectStream(*args):
        """
        ('FILE', '*fp')       
('size_t', 'start')       
('size_t', 'nbytes')       
('size_t', '*pnread')       
  l_binaryReadSelectStream()

      Input:  stream
              start (first byte to read)
              nbytes (number of bytes to read; use 0 to read to end of file)
              &nread (<return> number of bytes actually read)
      Return: null-terminated array, or null on error
              (reading 0 bytes is not an error)

  Notes:
      (1) The returned array is terminated with a null byte so that it can
          be used to read ascii data from a file into a proper C string.
          If the file to be read is empty and @start == 0, an array
          with a single null byte is returned.
      (2) Side effect: the stream pointer is re-positioned to the
          beginning of the file.


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryReadSelectStream(*args)
    
    

    try:
        leptonica.pathJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pathJoin.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function pathJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pathJoin(*args):
        """
        ('const char', '*dir')       
('const char', '*fname')       
  pathJoin()

      Input:  dir (<optional> can be null)
              fname (<optional> can be null)
      Return: specially concatenated path, or null on error

  Notes:
      (1) Use unix-style pathname separators ('/').
      (2) @fname can be the entire path, or part of the path containing
          at least one directory, or a tail without a directory, or null.
      (3) It produces a path that strips multiple slashes to a single
          slash, joins @dir and @fname by a slash, and has no trailing
          slashes (except in the cases where @dir == "/" and
          @fname == NULL, or v.v.).
      (4) If both @dir and @fname are null, produces an empty string.
      (5) Neither @dir nor @fname can begin with '.'.
      (6) The result is not canonicalized or tested for correctness:
          garbage in (e.g., /&%), garbage out.
      (7) Examples:
             //tmp// + //abc/  -->  /tmp/abc
             tmp/ + /abc/      -->  tmp/abc
             tmp/ + abc/       -->  tmp/abc
             /tmp/ + ///       -->  /tmp
             /tmp/ + NULL      -->  /tmp
             // + /abc//       -->  /abc
             // + NULL         -->  /
             NULL + /abc/def/  -->  /abc/def
             NULL + abc//      -->  abc
             NULL + //         -->  /
             NULL + NULL       -->  (empty string)
             "" + ""           -->  (empty string)
             "" + /            -->  /
             ".." + /etc/foo   -->  NULL
             /tmp + ".."       -->  NULL


        """
        args = _convert_params(*args)
        
        return leptonica.pathJoin(*args)
    
    

    try:
        leptonica.stringSplitOnToken.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringSplitOnToken.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringSplitOnToken not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringSplitOnToken(*args):
        """
        ('char', '*cstr')       
('const char', '*seps')       
('char', '**phead')       
('char', '**ptail')       
  stringSplitOnToken()

      Input:  cstr (input string to be split; not altered)
              seps (a string of character separators)
              &head (<return> ptr to copy of the input string, up to
                     the first separator token encountered)
              &tail (<return> ptr to copy of the part of the input string
                     starting with the first non-separator character
                     that occurs after the first separator is found)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The input string is not altered; all split parts are new strings.
      (2) The split occurs around the first consecutive sequence of
          tokens encountered.
      (3) The head goes from the beginning of the string up to
          but not including the first token found.
      (4) The tail contains the second part of the string, starting
          with the first char in that part that is NOT a token.
      (5) If no separator token is found, 'head' contains a copy
          of the input string and 'tail' is null.


        """
        args = _convert_params(*args)
        
        return leptonica.stringSplitOnToken(*args)
    
    

    try:
        leptonica.lept_fclose.argtypes = [ctypes.c_void_p]
        leptonica.lept_fclose.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_fclose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_fclose(*args):
        """
        ('FILE', '*fp')       
  lept_fclose()

      Input:  fp (stream handle)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This should be used by any application that accepts
          a file handle generated by a leptonica Windows DLL.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_fclose(*args)
    
    

    try:
        leptonica.fileConcatenate.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fileConcatenate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fileConcatenate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileConcatenate(*args):
        """
        ('const char', '*srcfile')       
('const char', '*destfile')       
  fileConcatenate()

      Input:  srcfile (file to append)
              destfile (file to add to)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileConcatenate(*args)
    
    

    try:
        leptonica.stringNew.argtypes = [ctypes.c_void_p]
        leptonica.stringNew.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function stringNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringNew(*args):
        """
        ('const char', '*src')       
  stringNew()

      Input:  src string
      Return: dest copy of src string, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.stringNew(*args)
    
    

    try:
        leptonica.l_getCurrentTime.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_getCurrentTime.restype = None
    except AttributeError:
        os.stderr.write("Warning - function l_getCurrentTime not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getCurrentTime(*args):
        """
        ('l_int32', '*sec')       
('l_int32', '*usec')       
  l_getCurrentTime()

      Input:  &sec (<optional return> in seconds since birth of Unix)
              &usec (<optional return> in microseconds since birth of Unix)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.l_getCurrentTime(*args)
    
    

    try:
        leptonica.strtokSafe.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.strtokSafe.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function strtokSafe not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def strtokSafe(*args):
        """
        ('char', '*cstr')       
('const char', '*seps')       
('char', '**psaveptr')       
  strtokSafe()

      Input:  cstr (input string to be sequentially parsed;
                    use NULL after the first call)
              seps (a string of character separators)
              &saveptr (<return> ptr to the next char after
                        the last encountered separator)
      Return: substr (a new string that is copied from the previous
                      saveptr up to but not including the next
                      separator character), or NULL if end of cstr.

  Notes:
      (1) This is a thread-safe implementation of strtok.
      (2) It has the same interface as strtok_r.
      (3) It differs from strtok_r in usage in two respects:
          (a) the input string is not altered
          (b) each returned substring is newly allocated and must
              be freed after use.
      (4) Let me repeat that.  This is "safe" because the input
          string is not altered and because each returned string
          is newly allocated on the heap.
      (5) It is here because, surprisingly, some C libraries don't
          include strtok_r.
      (6) Important usage points:
          - Input the string to be parsed on the first invocation.
          - Then input NULL after that; the value returned in saveptr
            is used in all subsequent calls.
      (7) This is only slightly slower than strtok_k.


        """
        args = _convert_params(*args)
        
        return leptonica.strtokSafe(*args)
    
    

    try:
        leptonica.stringRemoveChars.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringRemoveChars.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function stringRemoveChars not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringRemoveChars(*args):
        """
        ('const char', '*src')       
('const char', '*remchars')       
  stringRemoveChars()

      Input:  src (input string; can be of zero length)
              remchars  (string of chars to be removed from src)
      Return: dest (string with specified chars removed), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.stringRemoveChars(*args)
    
    

    try:
        leptonica.setMsgSeverity.argtypes = [ctypes.c_int32]
        leptonica.setMsgSeverity.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function setMsgSeverity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def setMsgSeverity(*args):
        """
        ('l_int32', 'newsev')       
  setMsgSeverity()

      Input:  newsev
      Return: oldsev

  Notes:
      (1) setMsgSeverity() allows the user to specify the desired
          message severity threshold.  Messages of equal or greater
          severity will be output.  The previous message severity is
          returned when the new severity is set.
      (2) If L_SEVERITY_EXTERNAL is passed, then the severity will be
          obtained from the LEPT_MSG_SEVERITY environment variable.
          If the environmental variable is not set, a warning is issued.


        """
        args = _convert_params(*args)
        
        return leptonica.setMsgSeverity(*args)
    
    

    try:
        leptonica.stringJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringJoin.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function stringJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringJoin(*args):
        """
        ('const char', '*src1')       
('const char', '*src2')       
  stringJoin()

      Input:  src1 string (<optional> can be null)
              src2 string (<optional> can be null)
      Return: concatenated string, or null on error

  Notes:
      (1) This is a safe version of strcat; it makes a new string.
      (2) It is not an error if either or both of the strings
          are empty, or if either or both of the pointers are null.


        """
        args = _convert_params(*args)
        
        return leptonica.stringJoin(*args)
    
    

    try:
        leptonica.genTempFilename.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.genTempFilename.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function genTempFilename not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def genTempFilename(*args):
        """
        ('const char', '*dir')       
('const char', '*tail')       
('l_int32', 'usetime')       
('l_int32', 'usepid')       
  genTempFilename()

      Input:  dir (directory name; use '.' for local dir;
                   no trailing '/' and @dir == "/" is invalid)
              tail (<optional>  tailname, including extension if any;
                    can be null or empty but can't contain '/')
              usetime (1 to include current time in microseconds in
                       the filename; 0 to omit.
              usepid (1 to include pid in filename; 0 to omit.
      Return: temp filename, or null on error

  Notes:
      (1) This makes a filename that is as unique as desired, and which
          can optionally include both the time and pid in the name.
      (2) Use unix-style pathname separators ('/').
      (3) Specifying the root directory (@dir == "/") is invalid.
      (4) Specifying a @tail containing '/' is invalid.
      (5) The most general form (@usetime = @usepid = 1) is:
              <dir>/<usec>_<pid>_<tail>
          When @usetime = 1, @usepid = 0, the output filename is:
              <dir>/<usec>_<tail>
          When @usepid = 0, @usepid = 1, the output filename is:
              <dir>/<pid>_<tail>
          When @usetime = @usepid = 0, the output filename is:
              <dir>/<tail>
          Note: It is not valid to have @tail = null or empty and have
          both @usetime = @usepid = 0.  That is, there must be
          some non-empty tail name.
      (6) N.B. The caller is responsible for freeing the returned filename.
          For windows, to avoid C-runtime boundary crossing problems
          when using DLLs, you must use lept_free() to free the name.
      (7) For windows, if the caller requests the directory '/tmp',
          this uses GetTempPath() to select the actual directory,
          avoiding platform-conditional code in use.  We represent
          the Windows temp directory by <Temp>.
      (8) Set @usetime = @usepid = 1 when
          (a) more than one process is writing and reading temp files, or
          (b) multiple threads from a single process call this function, or
          (c) there is the possiblity of an attack where the intruder
              is logged onto the server and might try to guess filenames.


        """
        args = _convert_params(*args)
        
        return leptonica.genTempFilename(*args)
    
    

    try:
        leptonica.l_getFormattedDate.argtypes = []
        leptonica.l_getFormattedDate.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function l_getFormattedDate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getFormattedDate(*args):
        """
               
  l_getFormattedDate()

      Input:  (none)
      Return: formatted date string, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_getFormattedDate(*args)
    
    

    try:
        leptonica.getLeptonicaVersion.argtypes = []
        leptonica.getLeptonicaVersion.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function getLeptonicaVersion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getLeptonicaVersion(*args):
        """
               
  getLeptonicaVersion()

      Return: string of version number (e.g., 'leptonica-1.68')

  Notes:
      (1) The caller has responsibility to free the memory.


        """
        args = _convert_params(*args)
        
        return leptonica.getLeptonicaVersion(*args)
    
    

    try:
        leptonica.lept_direxists.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_direxists.restype = None
    except AttributeError:
        os.stderr.write("Warning - function lept_direxists not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_direxists(*args):
        """
        ('const char', '*dir')       
('l_int32', '*pexists')       
  lept_direxists()

      Input:  dir
              &exists (<return> 1 if it exists; 0 otherwise)
      Return: void

  Notes:
      (1) Always use unix pathname separators.
      (2) For windows, does automatic translation to <temp> subdirectory
          if the pathname begins with '/tmp'.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_direxists(*args)
    
    

    try:
        leptonica.stringReplaceEachSubstr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringReplaceEachSubstr.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function stringReplaceEachSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReplaceEachSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub1')       
('const char', '*sub2')       
('l_int32', '*pcount')       
  stringReplaceEachSubstr()

      Input:  src (input string; can be of zero length)
              sub1 (substring to be replaced)
              sub2 (substring to put in; can be "")
              &count (<optional return > the number of times that sub1
                      is found in src; 0 if not found)
      Return: dest (string with substring replaced), or null if the
              substring not found or on error.

  Notes:
      (1) Replaces every instance.
      (2) To only remove each instance of sub1, use "" for sub2
      (3) Returns NULL if sub1 and sub2 are the same.


        """
        args = _convert_params(*args)
        
        return leptonica.stringReplaceEachSubstr(*args)
    
    

    try:
        leptonica.fopenReadStream.argtypes = [ctypes.c_void_p]
        leptonica.fopenReadStream.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function fopenReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fopenReadStream(*args):
        """
        ('const char', '*filename')       
  fopenReadStream()

      Input:  filename
      Return: stream, or null on error

  Notes:
      (1) This should be used whenever you want to run fopen() to
          read from a stream.  Never call fopen() directory.
      (2) This also handles pathname conversions for Windows; in
          particular the rewrite:
             /tmp --> <Temp>


        """
        args = _convert_params(*args)
        
        return leptonica.fopenReadStream(*args)
    
    

    try:
        leptonica.startTimerNested.argtypes = []
        leptonica.startTimerNested.restype = L_TIMER
    except AttributeError:
        os.stderr.write("Warning - function startTimerNested not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def startTimerNested(*args):
        """
               
  startTimerNested(), stopTimerNested()

  Example of usage:

      L_TIMER  t1 = startTimerNested();
      ....
      L_TIMER  t2 = startTimerNested();
      ....
      fprintf(stderr, "Elapsed time 2 = %7.3f sec\n", stopTimerNested(t2));
      ....
      fprintf(stderr, "Elapsed time 1 = %7.3f sec\n", stopTimerNested(t1));


        """
        args = _convert_params(*args)
        
        return leptonica.startTimerNested(*args)
    
    

    try:
        leptonica.arrayFindEachSequence.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.arrayFindEachSequence.restype = lambda address: L_DNA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function arrayFindEachSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def arrayFindEachSequence(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'datalen')       
('const l_uint8', '*sequence')       
('size_t', 'seqlen')       
  arrayFindEachSequence()

      Input:  data (byte array)
              datalen (length of data, in bytes)
              sequence (subarray of bytes to find in data)
              seqlen (length of sequence, in bytes)
      Return: dna of offsets where the sequence is found, or null if
              none are found or on error

  Notes:
      (1) The byte arrays @data and @sequence are not C strings,
          as they can contain null bytes.  Therefore, for each
          we must give the length of the array.
      (2) This finds every occurrence in @data of @sequence.


        """
        args = _convert_params(*args)
        
        return leptonica.arrayFindEachSequence(*args)
    
    

    try:
        leptonica.reallocNew.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.reallocNew.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function reallocNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def reallocNew(*args):
        """
        ('void', '**pindata')       
('l_int32', 'oldsize')       
('l_int32', 'newsize')       
  reallocNew()

      Input:  &indata (<optional>; nulls indata)
              oldsize (size of input data to be copied, in bytes)
              newsize (size of data to be reallocated in bytes)
      Return: ptr to new data, or null on error

  Action: !N.B. (3) and (4)!
      (1) Allocates memory, initialized to 0
      (2) Copies as much of the input data as possible
          to the new block, truncating the copy if necessary
      (3) Frees the input data
      (4) Zeroes the input data ptr

  Notes:
      (1) If newsize <=0, just frees input data and nulls ptr
      (2) If input ptr is null, just callocs new memory
      (3) This differs from realloc in that it always allocates
          new memory (if newsize > 0) and initializes it to 0,
          it requires the amount of old data to be copied,
          and it takes the address of the input ptr and
          nulls the handle.


        """
        args = _convert_params(*args)
        
        return leptonica.reallocNew(*args)
    
    

    try:
        leptonica.genRandomIntegerInRange.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.genRandomIntegerInRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function genRandomIntegerInRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def genRandomIntegerInRange(*args):
        """
        ('l_int32', 'range')       
('l_int32', 'seed')       
('l_int32', '*pval')       
  genRandomIntegerInRange()

      Input:  range (size of range; must be >= 2)
              seed (use 0 to skip; otherwise call srand)
              val (<return> random integer in range {0 ... range-1}
      Return: 0 if OK, 1 on error

  Notes:
      (1) For example, to choose a rand integer between 0 and 99,
          use @range = 100.


        """
        args = _convert_params(*args)
        
        return leptonica.genRandomIntegerInRange(*args)
    
    

    try:
        leptonica.stringReplace.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringReplace.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringReplace not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReplace(*args):
        """
        ('char', '**pdest')       
('const char', '*src')       
  stringReplace()

      Input:  &dest string (<return> copy)
              src string (<optional> can be null)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Frees any existing dest string
      (2) Puts a copy of src string in the dest
      (3) If either or both strings are null, does something reasonable.


        """
        args = _convert_params(*args)
        
        return leptonica.stringReplace(*args)
    
    

    try:
        leptonica.splitPathAtExtension.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.splitPathAtExtension.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function splitPathAtExtension not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def splitPathAtExtension(*args):
        """
        ('const char', '*pathname')       
('char', '**pbasename')       
('char', '**pextension')       
  splitPathAtExtension()

      Input:  pathname (full path; can be a directory)
              &basename (<optional return> pathname not including the
                        last dot and characters after that)
              &extension (<optional return> path extension, which is
                        the last dot and the characters after it.  If
                        there is no extension, it returns the empty string)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If you only want the extension, input null for the basename ptr.
      (2) If you only want the basename without extension, input null
          for the extension ptr.
      (3) This function makes decisions based only on the lexical
          structure of the input.  Examples:
            /usr/tmp/abc.jpg  -->  basename: /usr/tmp/abc    ext: .jpg
            /usr/tmp/.jpg     -->  basename: /usr/tmp/       ext: .jpg
            /usr/tmp.jpg/     -->  basename: /usr/tmp.jpg/   ext: [empty str]
            ./.jpg            -->  basename: ./              ext: .jpg
      (4) The input can have either forward (unix) or backward (win)
          slash separators.  The output has unix separators.


        """
        args = _convert_params(*args)
        
        return leptonica.splitPathAtExtension(*args)
    
    

    try:
        leptonica.l_binaryReadSelect.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.l_binaryReadSelect.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function l_binaryReadSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryReadSelect(*args):
        """
        ('const char', '*filename')       
('size_t', 'start')       
('size_t', 'nbytes')       
('size_t', '*pnread')       
  l_binaryReadSelect()

      Input:  filename
              start (first byte to read)
              nbytes (number of bytes to read; use 0 to read to end of file)
              &nread (<return> number of bytes actually read)
      Return: data, or null on error

  Notes:
      (1) The returned array is terminated with a null byte so that it can
          be used to read ascii data from a file into a proper C string.


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryReadSelect(*args)
    
    

    try:
        leptonica.fopenWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fopenWriteStream.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function fopenWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fopenWriteStream(*args):
        """
        ('const char', '*filename')       
('const char', '*modestring')       
  fopenWriteStream()

      Input:  filename
              modestring
      Return: stream, or null on error

  Notes:
      (1) This should be used whenever you want to run fopen() to
          write or append to a stream.  Never call fopen() directory.
      (2) This also handles pathname conversions for Windows; in
          particular the rewrite:
             /tmp --> <Temp>


        """
        args = _convert_params(*args)
        
        return leptonica.fopenWriteStream(*args)
    
    

    try:
        leptonica.arrayFindSequence.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.arrayFindSequence.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function arrayFindSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def arrayFindSequence(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'datalen')       
('const l_uint8', '*sequence')       
('size_t', 'seqlen')       
('l_int32', '*poffset')       
('l_int32', '*pfound')       
  arrayFindSequence()

      Input:  data (byte array)
              datalen (length of data, in bytes)
              sequence (subarray of bytes to find in data)
              seqlen (length of sequence, in bytes)
              &offset (return> offset from beginning of
                       data where the sequence begins)
              &found (<return> 1 if sequence is found; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The byte arrays 'data' and 'sequence' are not C strings,
          as they can contain null bytes.  Therefore, for each
          we must give the length of the array.
      (2) This searches for the first occurrence in @data of @sequence,
          which consists of @seqlen bytes.  The parameter @seqlen
          must not exceed the actual length of the @sequence byte array.
      (3) If the sequence is not found, the offset will be 0, so you
          must check @found.


        """
        args = _convert_params(*args)
        
        return leptonica.arrayFindSequence(*args)
    
    

    try:
        leptonica.lept_rm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_rm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_rm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rm(*args):
        """
        ('const char', '*subdir')       
('const char', '*tail')       
  lept_rm()

      Input:  subdir (<optional>  If NULL, the removed file is in /tmp)
              tail (filename without the directory)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This removes the named file in /tmp or a subdirectory of /tmp.
          Use NULL for @subdir if the file is in /tmp.
      (2) Use unix pathname separators.
      (3) On Windows, the file is in either <Temp>, or in a
          subdirectory, where <Temp> is the Windows temp dir.
          The name translation is: /tmp --> <Temp>.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rm(*args)
    
    

    try:
        leptonica.stringCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.stringCopy.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCopy(*args):
        """
        ('char', '*dest')       
('const char', '*src')       
('l_int32', 'n')       
  stringCopy()

      Input:  dest (existing byte buffer)
              src string (<optional> can be null)
              n (max number of characters to copy)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Relatively safe wrapper for strncpy, that checks the input,
          and does not complain if @src is null or @n < 1.
          If @n < 1, this is a no-op.
      (2) @dest needs to be at least @n bytes in size.
      (3) We don't call strncpy() because valgrind complains about
          use of uninitialized values.


        """
        args = _convert_params(*args)
        
        return leptonica.stringCopy(*args)
    
    

    try:
        leptonica.startTimer.argtypes = []
        leptonica.startTimer.restype = None
    except AttributeError:
        os.stderr.write("Warning - function startTimer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def startTimer(*args):
        """
               
  startTimer(), stopTimer()

  Example of usage:

      startTimer();
      ....
      fprintf(stderr, "Elapsed time = %7.3f sec\n", stopTimer());


        """
        args = _convert_params(*args)
        
        return leptonica.startTimer(*args)
    
    

    try:
        leptonica.fileCorruptByDeletion.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.fileCorruptByDeletion.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fileCorruptByDeletion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileCorruptByDeletion(*args):
        """
        ('const char', '*filein')       
('l_float32', 'loc')       
('l_float32', 'size')       
('const char', '*fileout')       
  fileCorruptByDeletion()

      Input:  filein
              loc (fractional location of start of deletion)
              size (fractional size of deletion)
              fileout (corrupted file)
      Return: 0 if OK, 1 on error

  Notes:
      (1) @loc and @size are expressed as a fraction of the file size.
      (2) This makes a copy of the data in @filein, where bytes in the
          specified region have deleted.
      (3) If (@loc + @size) >= 1.0, this deletes from the position
          represented by @loc to the end of the file.
      (4) It is useful for testing robustness of I/O wrappers when the
          data is corrupted, by simulating data corruption by deletion.


        """
        args = _convert_params(*args)
        
        return leptonica.fileCorruptByDeletion(*args)
    
    

    try:
        leptonica.filesAreIdentical.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.filesAreIdentical.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function filesAreIdentical not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def filesAreIdentical(*args):
        """
        ('const char', '*fname1')       
('const char', '*fname2')       
('l_int32', '*psame')       
  filesAreIdentical()

      Input:  fname1
              fname2
              &same (<return> 1 if identical; 0 if different)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.filesAreIdentical(*args)
    
    

    try:
        leptonica.returnErrorInt.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.returnErrorInt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function returnErrorInt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def returnErrorInt(*args):
        """
        ('const char', '*msg')       
('const char', '*procname')       
('l_int32', 'ival')       
  returnErrorInt()

      Input:  msg (error message)
              procname
              ival (return val)
      Return: ival (typically 1 for an error return)


        """
        args = _convert_params(*args)
        
        return leptonica.returnErrorInt(*args)
    
    

    try:
        leptonica.stringReverse.argtypes = [ctypes.c_void_p]
        leptonica.stringReverse.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function stringReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReverse(*args):
        """
        ('const char', '*src')       
  stringReverse()

      Input:  src (string)
      Return: dest (newly-allocated reversed string)


        """
        args = _convert_params(*args)
        
        return leptonica.stringReverse(*args)
    
    

    try:
        leptonica.l_binaryWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.l_binaryWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function l_binaryWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryWrite(*args):
        """
        ('const char', '*filename')       
('const char', '*operation')       
('void', '*data')       
('size_t', 'nbytes')       
  l_binaryWrite()

      Input:  filename (output)
              operation  ("w" for write; "a" for append)
              data  (binary data to be written)
              nbytes  (size of data array)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryWrite(*args)
    
    

    try:
        leptonica.extractNumberFromFilename.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.extractNumberFromFilename.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function extractNumberFromFilename not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractNumberFromFilename(*args):
        """
        ('const char', '*fname')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       
  extractNumberFromFilename()

      Input:  fname
              numpre (number of characters before the digits to be found)
              numpost (number of characters after the digits to be found)
      Return: num (number embedded in the filename); -1 on error or if
                   not found

  Notes:
      (1) The number is to be found in the basename, which is the
          filename without either the directory or the last extension.
      (2) When a number is found, it is non-negative.  If no number
          is found, this returns -1, without an error message.  The
          caller needs to check.


        """
        args = _convert_params(*args)
        
        return leptonica.extractNumberFromFilename(*args)
    
    

    try:
        leptonica.lept_free.argtypes = [ctypes.c_void_p]
        leptonica.lept_free.restype = None
    except AttributeError:
        os.stderr.write("Warning - function lept_free not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_free(*args):
        """
        ('void', '*ptr')       
  lept_free()

      Input:  void ptr
      Return: 0 if OK, 1 on error

  Notes:
      (1) This should be used by any application that accepts
          heap data allocated by a leptonica Windows DLL.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_free(*args)
    
    

    try:
        leptonica.lept_fopen.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_fopen.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function lept_fopen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_fopen(*args):
        """
        ('const char', '*filename')       
('const char', '*mode')       
  lept_fopen()

      Input:  filename
              mode (same as for fopen(); e.g., "rb")
      Return: stream or null on error

  Notes:
      (1) This must be used by any application that passes
          a file handle to a leptonica Windows DLL.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_fopen(*args)
    
    

    try:
        leptonica.lept_calloc.argtypes = [ctypes.c_size_t, ctypes.c_size_t]
        leptonica.lept_calloc.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function lept_calloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_calloc(*args):
        """
        ('size_t', 'nmemb')       
('size_t', 'size')       
  lept_calloc()

      Input:  nmemb (number of members)
              size (of each member)
      Return: void ptr, or null on error

  Notes:
      (1) For safety with windows DLLs, this can be used in conjunction
          with lept_free() to avoid C-runtime boundary problems.
          Just use these two functions throughout your application.


        """
        args = _convert_params(*args)
        
        return leptonica.lept_calloc(*args)
    
    

    try:
        leptonica.lept_cp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_cp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_cp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_cp(*args):
        """
        ('const char', '*srcfile')       
('const char', '*newdir')       
('const char', '*newtail')       
('char', '**pnewpath')       
  lept_cp()

      Input:  srcfile
              newdir (<optional>; can be NULL)
              newtail (<optional>; can be NULL)
              &newpath (<optional return> of actual path; can be NULL)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This copies @srcfile to /tmp or to a subdirectory of /tmp.
      (2) @srcfile can either be a full path or relative to the
          current directory.
      (3) @newdir can either specify an existing subdirectory of /tmp,
          or can be NULL.  In the latter case, the file will be written
          into /tmp.
      (4) @newtail can either specify a filename tail or, if NULL,
          the filename is taken from the tail of @srcfile.
      (5) For debugging, the computed newpath can be returned.  It must
          be freed by the caller.
      (6) Reminders:
            (a) use unix pathname separators
            (b) on windows, there is an additional name translation from
                /tmp  -->  <Temp>
      (7) Examples:
          * newdir = NULL, newtail = NULL   ==> /tmp/src-tail
          * newdir = NULL, newtail = abc    ==> /tmp/abc
          * newdir = def, newtail = NULL    ==> /tmp/def/src-tail
          * newdir = def, newtail = abc     ==> /tmp/def/abc



        """
        args = _convert_params(*args)
        
        return leptonica.lept_cp(*args)
    
    

    try:
        leptonica.returnErrorPtr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.returnErrorPtr.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function returnErrorPtr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def returnErrorPtr(*args):
        """
        ('const char', '*msg')       
('const char', '*procname')       
('void', '*pval')       
  returnErrorPtr()

      Input:  msg (error message)
              procname
              pval  (return val)
      Return: pval (typically null)


        """
        args = _convert_params(*args)
        
        return leptonica.returnErrorPtr(*args)
    
    

    try:
        leptonica.makeTempDirname.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.makeTempDirname.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeTempDirname not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeTempDirname(*args):
        """
        ('char', '*result')       
('size_t', 'nbytes')       
('const char', '*subdir')       
  makeTempDirname()

      Input:  result (preallocated on stack or heap and passed in)
              nbytes (size of @result array, in bytes)
              subdir (<optional>; can be NULL or an empty string)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This generates the directory path for output temp files,
          written into @result, with unix separators.
      (2) Caller allocates @result, large enough to hold
          <temp>/<subdir>, where <temp> is "/tmp" on unix
          and some other path on windows, determined by the windows
          function GenTempPath().
      (3) Usage example:
           char  result[256];
           makeTempDirname(result, 256, "golden");


        """
        args = _convert_params(*args)
        
        return leptonica.makeTempDirname(*args)
    
    

    try:
        leptonica.lept_mv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_mv.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_mv not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_mv(*args):
        """
        ('const char', '*srcfile')       
('const char', '*newdir')       
('const char', '*newtail')       
('char', '**pnewpath')       
  lept_mv()

      Input:  srcfile
              newdir (<optional>; can be NULL)
              newtail (<optional>; can be NULL)
              &newpath (<optional return> of actual path; can be NULL)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This moves @srcfile to /tmp or to a subdirectory of /tmp.
      (2) @srcfile can either be a full path or relative to the
          current directory.
      (3) @newdir can either specify an existing subdirectory of /tmp
          or can be NULL.  In the latter case, the file will be written
          into /tmp.
      (4) @newtail can either specify a filename tail or, if NULL,
          the filename is taken from the tail of @srcfile.
      (5) For debugging, the computed newpath can be returned.  It must
          be freed by the caller.
      (6) Reminders:
            (a) use unix pathname separators
            (b) on windows, there is a name translation from
                /tmp  -->  <Temp>
      (7) Examples:
          * newdir = NULL, newtail = NULL   ==> /tmp/src-tail
          * newdir = NULL, newtail = abc    ==> /tmp/abc
          * newdir = def, newtail = NULL    ==> /tmp/def/src-tail
          * newdir = def, newtail = abc     ==> /tmp/def/abc


        """
        args = _convert_params(*args)
        
        return leptonica.lept_mv(*args)
    
    

    try:
        leptonica.fileCorruptByMutation.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.fileCorruptByMutation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function fileCorruptByMutation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileCorruptByMutation(*args):
        """
        ('const char', '*filein')       
('l_float32', 'loc')       
('l_float32', 'size')       
('const char', '*fileout')       
  fileCorruptByMutation()

      Input:  filein
              loc (fractional location of start of randomization)
              size (fractional size of randomization)
              fileout (corrupted file)
      Return: 0 if OK, 1 on error

  Notes:
      (1) @loc and @size are expressed as a fraction of the file size.
      (2) This makes a copy of the data in @filein, where bytes in the
          specified region have been replaced by random data.
      (3) If (@loc + @size) >= 1.0, this modifies data from the position
          represented by @loc to the end of the file.
      (4) It is useful for testing robustness of I/O wrappers when the
          data is corrupted, by simulating data corruption.


        """
        args = _convert_params(*args)
        
        return leptonica.fileCorruptByMutation(*args)
    
    

    try:
        leptonica.stringLength.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.stringLength.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringLength not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringLength(*args):
        """
        ('const char', '*src')       
('size_t', 'size')       
  stringLength()

      Input:  src string (can be null or null-terminated string)
              size (size of src buffer)
      Return: length of src in bytes.

  Notes:
      (1) Safe implementation of strlen that only checks size bytes
          for trailing NUL.
      (2) Valid returned string lengths are between 0 and size - 1.
          If size bytes are checked without finding a NUL byte, then
          an error is indicated by returning size.


        """
        args = _convert_params(*args)
        
        return leptonica.stringLength(*args)
    
    

    try:
        leptonica.nbytesInFile.argtypes = [ctypes.c_void_p]
        leptonica.nbytesInFile.restype = ctypes.c_size_t
    except AttributeError:
        os.stderr.write("Warning - function nbytesInFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def nbytesInFile(*args):
        """
        ('const char', '*filename')       
  nbytesInFile()

      Input:  filename
      Return: nbytes in file; 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.nbytesInFile(*args)
    
    

    try:
        leptonica.convertGrayCodeToBinary.argtypes = [ctypes.c_uint32]
        leptonica.convertGrayCodeToBinary.restype = ctypes.c_uint32
    except AttributeError:
        os.stderr.write("Warning - function convertGrayCodeToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertGrayCodeToBinary(*args):
        """
        ('l_uint32', 'val')       
  convertGrayCodeToBinary()

      Input:  gray code value
      Return: binary value


        """
        args = _convert_params(*args)
        
        return leptonica.convertGrayCodeToBinary(*args)
    
    

    try:
        leptonica.modifyTrailingSlash.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.modifyTrailingSlash.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function modifyTrailingSlash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def modifyTrailingSlash(*args):
        """
        ('char', '*path')       
('size_t', 'nbytes')       
('l_int32', 'flag')       
  modifyTrailingSlash()

      Input:  path (preallocated on stack or heap and passed in)
              nbytes (size of @path array, in bytes)
              flag (L_ADD_TRAIL_SLASH or L_REMOVE_TRAIL_SLASH)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This carries out the requested action if necessary.


        """
        args = _convert_params(*args)
        
        return leptonica.modifyTrailingSlash(*args)
    
    

    try:
        leptonica.returnErrorFloat.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.returnErrorFloat.restype = ctypes.c_float
    except AttributeError:
        os.stderr.write("Warning - function returnErrorFloat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def returnErrorFloat(*args):
        """
        ('const char', '*msg')       
('const char', '*procname')       
('l_float32', 'fval')       
  returnErrorFloat()

      Input:  msg (error message)
              procname
              fval (return val)
      Return: fval


        """
        args = _convert_params(*args)
        
        return leptonica.returnErrorFloat(*args)
    
    

    try:
        leptonica.lept_mkdir.argtypes = [ctypes.c_void_p]
        leptonica.lept_mkdir.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lept_mkdir not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_mkdir(*args):
        """
        ('const char', '*subdir')       
  lept_mkdir()

      Input:  subdir (of /tmp or its equivalent on Windows)
      Return: 0 on success, non-zero on failure

  Notes:
      (1) This makes a subdirectory of the root temp directory.
          The root temp directory is:
            /tmp      (unix)
            <Temp>    (windows)


        """
        args = _convert_params(*args)
        
        return leptonica.lept_mkdir(*args)
    




class pnmio(object):
    """  pnmio.c

      Stream interface
          PIX             *pixReadStreamPnm()
          l_int32          readHeaderPnm()
          l_int32          freadHeaderPnm()
          l_int32          pixWriteStreamPnm()
          l_int32          pixWriteStreamAsciiPnm()

      Read/write to memory
          PIX             *pixReadMemPnm()
          l_int32          readHeaderMemPnm()
          l_int32          pixWriteMemPnm()

      Local helpers
          static l_int32   pnmReadNextAsciiValue();
          static l_int32   pnmSkipCommentLines();

      These are here by popular demand, with the help of Mattias
      Kregert (mattias@kregert.se), who provided the first implementation.

      The pnm formats are exceedingly simple, because they have
      no compression and no colormaps.  They support images that
      are 1 bpp; 2, 4, 8 and 16 bpp grayscale; and rgb.

      The original pnm formats ("ascii") are included for completeness,
      but their use is deprecated for all but tiny iconic images.
      They are extremely wasteful of memory; for example, the P1 binary
      ascii format is 16 times as big as the packed uncompressed
      format, because 2 characters are used to represent every bit
      (pixel) in the image.  Reading is slow because we check for extra
      white space and EOL at every sample value.

      The packed pnm formats ("raw") give file sizes similar to
      bmp files, which are uncompressed packed.  However, bmp
      are more flexible, because they can support colormaps.

      We don't differentiate between the different types ("pbm",
      "pgm", "ppm") at the interface level, because this is really a
      "distinction without a difference."  You read a file, you get
      the appropriate Pix.  You write a file from a Pix, you get the
      appropriate type of file.  If there is a colormap on the Pix,
      and the Pix is more than 1 bpp, you get either an 8 bpp pgm
      or a 24 bpp RGB pnm, depending on whether the colormap colors
      are gray or rgb, respectively.

      This follows the general policy that the I/O routines don't
      make decisions about the content of the image -- you do that
      with image processing before you write it out to file.
      The I/O routines just try to make the closest connection
      possible between the file and the Pix in memory.

      On systems like windows without fmemopen() and open_memstream(),
      we write data to a temp file and read it back for operations
      between pix and compressed-data, such as pixReadMemPnm() and
      pixWriteMemPnm().

"""
    
    try:
        leptonica.pixWriteStreamPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamPnm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPnm(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
  pixWriteStreamPnm()

      Input:  stream opened for write
              pix
      Return: 0 if OK; 1 on error

  Notes:
      (1) This writes "raw" packed format only:
          1 bpp --> pbm (P4)
          2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm (P5)
          2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm (P6)
      (2) 24 bpp rgb are not supported in leptonica, but this will
          write them out as a packed array of bytes (3 to a pixel).


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPnm(*args)
    
    

    try:
        leptonica.pixWriteStreamAsciiPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamAsciiPnm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamAsciiPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamAsciiPnm(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
  pixWriteStreamAsciiPnm()

      Input:  stream opened for write
              pix
      Return: 0 if OK; 1 on error

  Writes "ascii" format only:
      1 bpp --> pbm (P1)
      2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm (P2)
      2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm (P3)


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamAsciiPnm(*args)
    
    

    try:
        leptonica.readHeaderPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderPnm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderPnm(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
('l_int32', '*ptype')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
  readHeaderPnm()

      Input:  filename
              &w (<optional return>)
              &h (<optional return>)
              &d (<optional return>)
              &type (<optional return> pnm type)
              &bps (<optional return>, bits/sample)
              &spp (<optional return>, samples/pixel)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderPnm(*args)
    
    

    try:
        leptonica.pixReadMemPnm.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemPnm.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemPnm(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
  pixReadMemPnm()

      Input:  cdata (const; pnm-encoded)
              size (of data)
      Return: pix, or null on error

  Notes:
      (1) The @size byte of @data must be a null character.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemPnm(*args)
    
    

    try:
        leptonica.readHeaderMemPnm.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemPnm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderMemPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemPnm(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
('l_int32', '*ptype')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
  readHeaderMemPnm()

      Input:  cdata (const; pnm-encoded)
              size (of data)
              &w (<optional return>)
              &h (<optional return>)
              &d (<optional return>)
              &type (<optional return> pnm type)
              &bps (<optional return>, bits/sample)
              &spp (<optional return>, samples/pixel)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemPnm(*args)
    
    

    try:
        leptonica.pixWriteMemPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemPnm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPnm(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
  pixWriteMemPnm()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixWriteStreamPnm() for usage.  This version writes to
          memory instead of to a file stream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPnm(*args)
    
    

    try:
        leptonica.pixReadStreamPnm.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamPnm.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamPnm(*args):
        """
        ('FILE', '*fp')       
  pixReadStreamPnm()

      Input:  stream opened for read
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamPnm(*args)
    
    

    try:
        leptonica.freadHeaderPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderPnm.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function freadHeaderPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderPnm(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
('l_int32', '*ptype')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
  freadHeaderPnm()

      Input:  stream opened for read
              &w (<optional return>)
              &h (<optional return>)
              &d (<optional return>)
              &type (<optional return> pnm type)
              &bps (<optional return>, bits/sample)
              &spp (<optional return>, samples/pixel)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderPnm(*args)
    




class selgen(object):
    """  selgen.c

      This file contains functions that generate hit-miss Sels
      for doing a loose match to a small bitmap.  The hit-miss
      Sel is made from a given bitmap.  Several "knobs"
      are available to control the looseness of the match.
      In general, a tight match will have fewer false positives
      (bad matches) but more false negatives (missed patterns).
      The values to be used depend on the quality and variation
      of the image in which the pattern is to be searched,
      and the relative penalties of false positives and
      false negatives.  Default values for the three knobs --
      minimum distance to boundary pixels, number of extra pixels
      added to selected sides, and minimum acceptable runlength
      in eroded version -- are provided.

      The generated hit-miss Sels can always be used in the
      rasterop implementation of binary morphology (in morph.h).
      If they are small enough (not more than 31 pixels extending
      in any direction from the Sel origin), they can also be used
      to auto-generate dwa code (fmorphauto.c).


      Generate a subsampled structuring element
            SEL     *pixGenerateSelWithRuns()
            SEL     *pixGenerateSelRandom()
            SEL     *pixGenerateSelBoundary()

      Accumulate data on runs along lines
            NUMA    *pixGetRunCentersOnLine()
            NUMA    *pixGetRunsOnLine()

      Subsample boundary pixels in relatively ordered way
            PTA     *pixSubsampleBoundaryPixels()
            PTA     *adjacentOnPixelInRaster()

      Display generated sel with originating image
            PIX     *pixDisplayHitMissSel()

"""
    
    try:
        leptonica.pixGenerateSelBoundary.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateSelBoundary.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateSelBoundary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateSelBoundary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hitdist')       
('l_int32', 'missdist')       
('l_int32', 'hitskip')       
('l_int32', 'missskip')       
('l_int32', 'topflag')       
('l_int32', 'botflag')       
('l_int32', 'leftflag')       
('l_int32', 'rightflag')       
('PIX', '**ppixe')       
  pixGenerateSelBoundary()

      Input:  pix (1 bpp, typically small, to be used as a pattern)
              hitdist (min distance from fg boundary pixel)
              missdist (min distance from bg boundary pixel)
              hitskip (number of boundary pixels skipped between hits)
              missskip (number of boundary pixels skipped between misses)
              topflag (flag for extra pixels of bg added above)
              botflag (flag for extra pixels of bg added below)
              leftflag (flag for extra pixels of bg added to left)
              rightflag (flag for extra pixels of bg added to right)
              &pixe (<optional return> input pix expanded by extra pixels)
      Return: sel (hit-miss for input pattern), or null on error

  Notes:
    (1) All fg elements selected are exactly hitdist pixels away from
        the nearest fg boundary pixel, and ditto for bg elements.
        Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.
        For example, a hitdist of 0 puts the hits at the fg boundary.
        Usually, the distances should be > 0 avoid the effect of
        noise at the boundary.
    (2) Set hitskip < 0 if no hits are to be used.  Ditto for missskip.
        If both hitskip and missskip are < 0, the sel would be empty,
        and NULL is returned.
    (3) The 4 flags determine whether the sel is increased on that side
        to allow bg misses to be placed all along that boundary.
        The increase in sel size on that side is the minimum necessary
        to allow the misses to be placed at mindist.  For text characters,
        the topflag and botflag are typically set to 1, and the leftflag
        and rightflag to 0.
    (4) The input pix, as extended by the extra pixels on selected sides,
        can optionally be returned.  For debugging, call
        pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
        on the generating bitmap.
    (5) This is probably the best of the three sel generators, in the
        sense that you have the most flexibility with the smallest number
        of hits and misses.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateSelBoundary(*args)
    
    

    try:
        leptonica.pixGenerateSelWithRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateSelWithRuns.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateSelWithRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateSelWithRuns(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nhlines')       
('l_int32', 'nvlines')       
('l_int32', 'distance')       
('l_int32', 'minlength')       
('l_int32', 'toppix')       
('l_int32', 'botpix')       
('l_int32', 'leftpix')       
('l_int32', 'rightpix')       
('PIX', '**ppixe')       
  pixGenerateSelWithRuns()

      Input:  pix (1 bpp, typically small, to be used as a pattern)
              nhlines (number of hor lines along which elements are found)
              nvlines (number of vert lines along which elements are found)
              distance (min distance from boundary pixel; use 0 for default)
              minlength (min runlength to set hit or miss; use 0 for default)
              toppix (number of extra pixels of bg added above)
              botpix (number of extra pixels of bg added below)
              leftpix (number of extra pixels of bg added to left)
              rightpix (number of extra pixels of bg added to right)
              &pixe (<optional return> input pix expanded by extra pixels)
      Return: sel (hit-miss for input pattern), or null on error

  Notes:
    (1) The horizontal and vertical lines along which elements are
        selected are roughly equally spaced.  The actual locations of
        the hits and misses are the centers of respective run-lengths.
    (2) No elements are selected that are less than 'distance' pixels away
        from a boundary pixel of the same color.  This makes the
        match much more robust to edge noise.  Valid inputs of
        'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
        greater than 4, we reset it to the default value.
    (3) The 4 numbers for adding rectangles of pixels outside the fg
        can be use if the pattern is expected to be surrounded by bg
        (white) pixels.  On the other hand, if the pattern may be near
        other fg (black) components on some sides, use 0 for those sides.
    (4) The pixels added to a side allow you to have miss elements there.
        There is a constraint between distance, minlength, and
        the added pixels for this to work.  We illustrate using the
        default values.  If you add 5 pixels to the top, and use a
        distance of 1, then you end up with a vertical run of at least
        4 bg pixels along the top edge of the image.  If you use a
        minimum runlength of 3, each vertical line will always find
        a miss near the center of its run.  However, if you use a
        minimum runlength of 5, you will not get a miss on every vertical
        line.  As another example, if you have 7 added pixels and a
        distance of 2, you can use a runlength up to 5 to guarantee
        that the miss element is recorded.  We give a warning if the
        contraint does not guarantee a miss element outside the
        image proper.
    (5) The input pix, as extended by the extra pixels on selected sides,
        can optionally be returned.  For debugging, call
        pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
        on the generating bitmap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateSelWithRuns(*args)
    
    

    try:
        leptonica.pixDisplayHitMissSel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixDisplayHitMissSel.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayHitMissSel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayHitMissSel(*args):
        """
        ('PIX', '*pixs')       
('SEL', '*sel')       
('l_int32', 'scalefactor')       
('l_uint32', 'hitcolor')       
('l_uint32', 'misscolor')       
  pixDisplayHitMissSel()

      Input:  pixs (1 bpp)
              sel (hit-miss in general)
              scalefactor (an integer >= 1; use 0 for default)
              hitcolor (RGB0 color for center of hit pixels)
              misscolor (RGB0 color for center of miss pixels)
      Return: pixd (RGB showing both pixs and sel), or null on error
  Notes:
    (1) We don't allow scalefactor to be larger than MAX_SEL_SCALEFACTOR
    (2) The colors are conveniently given as 4 bytes in hex format,
        such as 0xff008800.  The least significant byte is ignored.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayHitMissSel(*args)
    
    

    try:
        leptonica.adjacentOnPixelInRaster.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.adjacentOnPixelInRaster.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function adjacentOnPixelInRaster not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def adjacentOnPixelInRaster(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxa')       
('l_int32', '*pya')       
  adjacentOnPixelInRaster()

      Input:  pixs (1 bpp)
              x, y (current pixel)
              xa, ya (adjacent ON pixel, found by simple CCW search)
      Return: 1 if a pixel is found; 0 otherwise or on error

  Notes:
      (1) Search is in 4-connected directions first; then on diagonals.
          This allows traversal along a 4-connected boundary.


        """
        args = _convert_params(*args)
        
        return leptonica.adjacentOnPixelInRaster(*args)
    
    

    try:
        leptonica.pixGetRunsOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetRunsOnLine.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetRunsOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRunsOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
  pixGetRunsOnLine()

      Input:  pixs (1 bpp)
              x1, y1, x2, y2
      Return: numa, or null on error

  Notes:
      (1) Action: this function uses the bresenham algorithm to compute
          the pixels along the specified line.  It returns a Numa of the
          runlengths of the fg (black) and bg (white) runs, always
          starting with a white run.
      (2) If the first pixel on the line is black, the length of the
          first returned run (which is white) is 0.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRunsOnLine(*args)
    
    

    try:
        leptonica.pixGetRunCentersOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetRunCentersOnLine.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetRunCentersOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRunCentersOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'minlength')       
  pixGetRunCentersOnLine()

      Input:  pixs (1 bpp)
              x, y (set one of these to -1; see notes)
              minlength (minimum length of acceptable run)
      Return: numa of fg runs, or null on error

  Notes:
      (1) Action: this function computes the fg (black) and bg (white)
          pixel runlengths along the specified horizontal or vertical line,
          and returns a Numa of the "center" pixels of each fg run
          whose length equals or exceeds the minimum length.
      (2) This only works on horizontal and vertical lines.
      (3) For horizontal runs, set x = -1 and y to the value
          for all points along the raster line.  For vertical runs,
          set y = -1 and x to the value for all points along the
          pixel column.
      (4) For horizontal runs, the points in the Numa are the x
          values in the center of fg runs that are of length at
          least 'minlength'.  For vertical runs, the points in the
          Numa are the y values in the center of fg runs, again
          of length 'minlength' or greater.
      (5) If there are no fg runs along the line that satisfy the
          minlength constraint, the returned Numa is empty.  This
          is not an error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRunCentersOnLine(*args)
    
    

    try:
        leptonica.pixSubsampleBoundaryPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSubsampleBoundaryPixels.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSubsampleBoundaryPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSubsampleBoundaryPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'skip')       
  pixSubsampleBoundaryPixels()

      Input:  pixs (1 bpp, with only boundary pixels in fg)
              skip (number to skip between samples as you traverse boundary)
      Return: pta, or null on error

  Notes:
      (1) If skip = 0, we take all the fg pixels.
      (2) We try to traverse the boundaries in a regular way.
          Some pixels may be missed, and these are then subsampled
          randomly with a fraction determined by 'skip'.
      (3) The most natural approach is to use a depth first (stack-based)
          method to find the fg pixels.  However, the pixel runs are
          4-connected and there are relatively few branches.  So
          instead of doing a proper depth-first search, we get nearly
          the same result using two nested while loops: the outer
          one continues a raster-based search for the next fg pixel,
          and the inner one does a reasonable job running along
          each 4-connected coutour.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSubsampleBoundaryPixels(*args)
    
    

    try:
        leptonica.pixGenerateSelRandom.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateSelRandom.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGenerateSelRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateSelRandom(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'hitfract')       
('l_float32', 'missfract')       
('l_int32', 'distance')       
('l_int32', 'toppix')       
('l_int32', 'botpix')       
('l_int32', 'leftpix')       
('l_int32', 'rightpix')       
('PIX', '**ppixe')       
  pixGenerateSelRandom()

      Input:  pix (1 bpp, typically small, to be used as a pattern)
              hitfract (fraction of allowable fg pixels that are hits)
              missfract (fraction of allowable bg pixels that are misses)
              distance (min distance from boundary pixel; use 0 for default)
              toppix (number of extra pixels of bg added above)
              botpix (number of extra pixels of bg added below)
              leftpix (number of extra pixels of bg added to left)
              rightpix (number of extra pixels of bg added to right)
              &pixe (<optional return> input pix expanded by extra pixels)
      Return: sel (hit-miss for input pattern), or null on error

  Notes:
    (1) Either of hitfract and missfract can be zero.  If both are zero,
        the sel would be empty, and NULL is returned.
    (2) No elements are selected that are less than 'distance' pixels away
        from a boundary pixel of the same color.  This makes the
        match much more robust to edge noise.  Valid inputs of
        'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
        greater than 4, we reset it to the default value.
    (3) The 4 numbers for adding rectangles of pixels outside the fg
        can be use if the pattern is expected to be surrounded by bg
        (white) pixels.  On the other hand, if the pattern may be near
        other fg (black) components on some sides, use 0 for those sides.
    (4) The input pix, as extended by the extra pixels on selected sides,
        can optionally be returned.  For debugging, call
        pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
        on the generating bitmap.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateSelRandom(*args)
    




class pnmiostub(object):
    """  pnmiostub.c

     Stubs for pnmio.c functions

"""
    



class zlibmemstub(object):
    """  zlibmemstub.c

     Stubs for zlibmem.c functions

"""
    



class convertfiles(object):
    """  convertfiles.c

      Conversion to 1 bpp
          l_int32    convertFilesTo1bpp()

  These are utility functions that will perform depth conversion
  on selected files, writing the results to a specified directory.
  We start with conversion to 1 bpp.

"""
    
    try:
        leptonica.convertFilesTo1bpp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.convertFilesTo1bpp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertFilesTo1bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFilesTo1bpp(*args):
        """
        ('const char', '*dirin')       
('const char', '*substr')       
('l_int32', 'upscaling')       
('l_int32', 'thresh')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
('const char', '*dirout')       
('l_int32', 'outformat')       
  convertFilesTo1bpp()

      Input:  dirin
              substr (<optional> substring filter on filenames; can be NULL)
              upscaling (1, 2 or 4; only for input color or grayscale)
              thresh  (global threshold for binarization; use 0 for default)
              firstpage
              npages (use 0 to do all from @firstpage to the end)
              dirout
              outformat (IFF_PNG, IFF_TIFF_G4)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Images are sorted lexicographically, and the names in the
          output directory are retained except for the extension.


        """
        args = _convert_params(*args)
        
        return leptonica.convertFilesTo1bpp(*args)
    




class spixio(object):
    """  spixio.c

    This does fast serialization of a pix in memory to file,
    copying the raw data for maximum speed.  The underlying
    function serializes it to memory, and it is wrapped to be
    callable from standard pixRead and pixWrite functions.

      Reading spix from file
           PIX        *pixReadStreamSpix()
           l_int32     readHeaderSpix()
           l_int32     freadHeaderSpix()
           l_int32     sreadHeaderSpix()

      Writing spix to file
           l_int32     pixWriteStreamSpix()

      Low-level serialization of pix to/from memory (uncompressed)
           PIX        *pixReadMemSpix()
           l_int32     pixWriteMemSpix()
           l_int32     pixSerializeToMemory()
           PIX        *pixDeserializeFromMemory()


"""
    
    try:
        leptonica.pixWriteMemSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemSpix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemSpix(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
  pixWriteMemSpix()

      Input:  &data (<return> data of serialized, uncompressed pix)
              &size (<return> size of returned data)
              pix (all depths; colormap OK)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemSpix(*args)
    
    

    try:
        leptonica.pixReadStreamSpix.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamSpix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamSpix(*args):
        """
        ('FILE', '*fp')       
  pixReadStreamSpix()

      Input:  stream
      Return: pix, or null on error.

  Notes:
      (1) If called from pixReadStream(), the stream is positioned
          at the beginning of the file.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamSpix(*args)
    
    

    try:
        leptonica.pixSerializeToMemory.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSerializeToMemory.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSerializeToMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSerializeToMemory(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', '**pdata')       
('size_t', '*pnbytes')       
  pixSerializeToMemory()

      Input:  pixs (all depths, colormap OK)
              &data (<return> serialized data in memory)
              &nbytes (<return> number of bytes in data string)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This does a fast serialization of the principal elements
          of the pix, as follows:
            "spix"    (4 bytes) -- ID for file type
            w         (4 bytes)
            h         (4 bytes)
            d         (4 bytes)
            wpl       (4 bytes)
            ncolors   (4 bytes) -- in colormap; 0 if there is no colormap
            cdata     (4 * ncolors)  -- size of serialized colormap array
            rdatasize (4 bytes) -- size of serialized raster data
                                   = 4 * wpl * h
            rdata     (rdatasize)


        """
        args = _convert_params(*args)
        
        return leptonica.pixSerializeToMemory(*args)
    
    

    try:
        leptonica.freadHeaderSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderSpix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function freadHeaderSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderSpix(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  freadHeaderSpix()

      Input:  stream
              &width (<return>)
              &height (<return>)
              &bps (<return>, bits/sample)
              &spp (<return>, samples/pixel)
              &iscmap (<optional return>; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If there is a colormap, iscmap is returned as 1; else 0.


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderSpix(*args)
    
    

    try:
        leptonica.pixDeserializeFromMemory.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixDeserializeFromMemory.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDeserializeFromMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeserializeFromMemory(*args):
        """
        ('const l_uint32', '*data')       
('size_t', 'nbytes')       
  pixDeserializeFromMemory()

      Input:  data (serialized data in memory)
              nbytes (number of bytes in data string)
      Return: pix, or NULL on error

  Notes:
      (1) See pixSerializeToMemory() for the binary format.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeserializeFromMemory(*args)
    
    

    try:
        leptonica.pixReadMemSpix.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemSpix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemSpix(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
  pixReadMemSpix()

      Input:  data (const; uncompressed)
              size (of data)
      Return: pix, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemSpix(*args)
    
    

    try:
        leptonica.readHeaderSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderSpix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderSpix(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  readHeaderSpix()

      Input:  filename
              &width (<return>)
              &height (<return>)
              &bps (<return>, bits/sample)
              &spp (<return>, samples/pixel)
              &iscmap (<optional return>; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If there is a colormap, iscmap is returned as 1; else 0.


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderSpix(*args)
    
    

    try:
        leptonica.pixWriteStreamSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamSpix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamSpix(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
  pixWriteStreamSpix()

      Input:  stream
              pix
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamSpix(*args)
    
    

    try:
        leptonica.sreadHeaderSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sreadHeaderSpix.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sreadHeaderSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sreadHeaderSpix(*args):
        """
        ('const l_uint32', '*data')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       
  sreadHeaderSpix()

      Input:  data
              &width (<return>)
              &height (<return>)
              &bps (<return>, bits/sample)
              &spp (<return>, samples/pixel)
              &iscmap (<optional return>; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If there is a colormap, iscmap is returned as 1; else 0.


        """
        args = _convert_params(*args)
        
        return leptonica.sreadHeaderSpix(*args)
    




class baseline(object):
    """  baseline.c

      Locate text baselines in an image
           NUMA     *pixFindBaselines()

      Projective transform to remove local skew
           PIX      *pixDeskewLocal()

      Determine local skew
           l_int32   pixGetLocalSkewTransform()
           NUMA     *pixGetLocalSkewAngles()

  We have two apparently different functions here:
    - finding baselines
    - finding a projective transform to remove keystone warping
  The function pixGetLocalSkewAngles() returns an array of angles,
  one for each raster line, and the baselines of the text lines
  should intersect the left edge of the image with that angle.

"""
    
    try:
        leptonica.pixFindBaselines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFindBaselines.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFindBaselines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindBaselines(*args):
        """
        ('PIX', '*pixs')       
('PTA', '**ppta')       
('l_int32', 'debug')       
  pixFindBaselines()

      Input:  pixs (1 bpp)
              &pta (<optional return> pairs of pts corresponding to
                    approx. ends of each text line)
              debug (usually 0; set to 1 for debugging output)
      Return: na (of baseline y values), or null on error

  Notes:
      (1) Input binary image must have text lines already aligned
          horizontally.  This can be done by either rotating the
          image with pixDeskew(), or, if a projective transform
          is required, by doing pixDeskewLocal() first.
      (2) Input null for &pta if you don't want this returned.
          The pta will come in pairs of points (left and right end
          of each baseline).
      (3) Caution: this will not work properly on text with multiple
          columns, where the lines are not aligned between columns.
          If there are multiple columns, they should be extracted
          separately before finding the baselines.
      (4) This function constructs different types of output
          for baselines; namely, a set of raster line values and
          a set of end points of each baseline.
      (5) This function was designed to handle short and long text lines
          without using dangerous thresholds on the peak heights.  It does
          this by combining the differential signal with a morphological
          analysis of the locations of the text lines.  One can also
          combine this data to normalize the peak heights, by weighting
          the differential signal in the region of each baseline
          by the inverse of the width of the text line found there.
      (6) There are various debug sections that can be turned on
          with the debug flag.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindBaselines(*args)
    
    

    try:
        leptonica.pixDeskewLocal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixDeskewLocal.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDeskewLocal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewLocal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nslices')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
  pixDeskewLocal()

      Input:  pixs
              nslices  (the number of horizontal overlapping slices; must
                  be larger than 1 and not exceed 20; use 0 for default)
              redsweep (sweep reduction factor: 1, 2, 4 or 8;
                        use 0 for default value)
              redsearch (search reduction factor: 1, 2, 4 or 8, and
                         not larger than redsweep; use 0 for default value)
              sweeprange (half the full range, assumed about 0; in degrees;
                          use 0.0 for default value)
              sweepdelta (angle increment of sweep; in degrees;
                          use 0.0 for default value)
              minbsdelta (min binary search increment angle; in degrees;
                          use 0.0 for default value)
      Return: pixd, or null on error

  Notes:
      (1) This function allows deskew of a page whose skew changes
          approximately linearly with vertical position.  It uses
          a projective tranform that in effect does a differential
          shear about the LHS of the page, and makes all text lines
          horizontal.
      (2) The origin of the keystoning can be either a cheap document
          feeder that rotates the page as it is passed through, or a
          camera image taken from either the left or right side
          of the vertical.
      (3) The image transformation is a projective warping,
          not a rotation.  Apart from this function, the text lines
          must be properly aligned vertically with respect to each
          other.  This can be done by pre-processing the page; e.g.,
          by rotating or horizontally shearing it.
          Typically, this can be achieved by vertically aligning
          the page edge.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewLocal(*args)
    
    

    try:
        leptonica.pixGetLocalSkewTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetLocalSkewTransform.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetLocalSkewTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetLocalSkewTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nslices')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
('PTA', '**pptas')       
('PTA', '**pptad')       
  pixGetLocalSkewTransform()

      Input:  pixs
              nslices  (the number of horizontal overlapping slices; must
                  be larger than 1 and not exceed 20; use 0 for default)
              redsweep (sweep reduction factor: 1, 2, 4 or 8;
                        use 0 for default value)
              redsearch (search reduction factor: 1, 2, 4 or 8, and
                         not larger than redsweep; use 0 for default value)
              sweeprange (half the full range, assumed about 0; in degrees;
                          use 0.0 for default value)
              sweepdelta (angle increment of sweep; in degrees;
                          use 0.0 for default value)
              minbsdelta (min binary search increment angle; in degrees;
                          use 0.0 for default value)
              &ptas  (<return> 4 points in the source)
              &ptad  (<return> the corresponding 4 pts in the dest)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This generates two pairs of points in the src, each pair
          corresponding to a pair of points that would lie along
          the same raster line in a transformed (dewarped) image.
      (2) The sets of 4 src and 4 dest points returned by this function
          can then be used, in a projective or bilinear transform,
          to remove keystoning in the src.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetLocalSkewTransform(*args)
    
    

    try:
        leptonica.pixGetLocalSkewAngles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetLocalSkewAngles.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetLocalSkewAngles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetLocalSkewAngles(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nslices')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
  pixGetLocalSkewAngles()

      Input:  pixs
              nslices  (the number of horizontal overlapping slices; must
                  be larger than 1 and not exceed 20; use 0 for default)
              redsweep (sweep reduction factor: 1, 2, 4 or 8;
                        use 0 for default value)
              redsearch (search reduction factor: 1, 2, 4 or 8, and
                         not larger than redsweep; use 0 for default value)
              sweeprange (half the full range, assumed about 0; in degrees;
                          use 0.0 for default value)
              sweepdelta (angle increment of sweep; in degrees;
                          use 0.0 for default value)
              minbsdelta (min binary search increment angle; in degrees;
                          use 0.0 for default value)
              &a (<optional return> slope of skew as fctn of y)
              &b (<optional return> intercept at y=0 of skew as fctn of y)
      Return: naskew, or null on error

  Notes:
      (1) The local skew is measured in a set of overlapping strips.
          We then do a least square linear fit parameters to get
          the slope and intercept parameters a and b in
              skew-angle = a * y + b  (degrees)
          for the local skew as a function of raster line y.
          This is then used to make naskew, which can be interpreted
          as the computed skew angle (in degrees) at the left edge
          of each raster line.
      (2) naskew can then be used to find the baselines of text, because
          each text line has a baseline that should intersect
          the left edge of the image with the angle given by this
          array, evaluated at the raster line of intersection.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetLocalSkewAngles(*args)
    




class ptabasic(object):
    """   ptabasic.c

      Pta creation, destruction, copy, clone, empty
           PTA            *ptaCreate()
           PTA            *ptaCreateFromNuma()
           void            ptaDestroy()
           PTA            *ptaCopy()
           PTA            *ptaCopyRange()
           PTA            *ptaClone()
           l_int32         ptaEmpty()

      Pta array extension
           l_int32         ptaAddPt()
           static l_int32  ptaExtendArrays()

      Pta insertion and removal
           l_int32         ptaInsertPt()
           l_int32         ptaRemovePt()

      Pta accessors
           l_int32         ptaGetRefcount()
           l_int32         ptaChangeRefcount()
           l_int32         ptaGetCount()
           l_int32         ptaGetPt()
           l_int32         ptaGetIPt()
           l_int32         ptaSetPt()
           l_int32         ptaGetArrays()

      Pta serialized for I/O
           PTA            *ptaRead()
           PTA            *ptaReadStream()
           l_int32         ptaWrite()
           l_int32         ptaWriteStream()

      Ptaa creation, destruction
           PTAA           *ptaaCreate()
           void            ptaaDestroy()

      Ptaa array extension
           l_int32         ptaaAddPta()
           static l_int32  ptaaExtendArray()

      Ptaa accessors
           l_int32         ptaaGetCount()
           l_int32         ptaaGetPta()
           l_int32         ptaaGetPt()

      Ptaa array modifiers
           l_int32         ptaaInitFull()
           l_int32         ptaaReplacePta()
           l_int32         ptaaAddPt()
           l_int32         ptaaTruncate()

      Ptaa serialized for I/O
           PTAA           *ptaaRead()
           PTAA           *ptaaReadStream()
           l_int32         ptaaWrite()
           l_int32         ptaaWriteStream()

"""
    
    try:
        leptonica.ptaaGetPta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaaGetPta.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaaGetPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetPta(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       
  ptaaGetPta()

      Input:  ptaa
              index  (to the i-th pta)
              accessflag  (L_COPY or L_CLONE)
      Return: pta, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetPta(*args)
    
    

    try:
        leptonica.ptaClone.argtypes = [ctypes.c_void_p]
        leptonica.ptaClone.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaClone(*args):
        """
        ('PTA', '*pta')       
  ptaClone()

      Input:  pta
      Return: ptr to same pta, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaClone(*args)
    
    

    try:
        leptonica.ptaaReplacePta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaaReplacePta.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaReplacePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaReplacePta(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'index')       
('PTA', '*pta')       
  ptaaReplacePta()

      Input:  ptaa
              index  (to the index-th pta)
              pta (insert and replace any existing one)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Any existing pta is destroyed, and the input one
          is inserted in its place.
      (2) If the index is invalid, return 1 (error)


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaReplacePta(*args)
    
    

    try:
        leptonica.ptaaRead.argtypes = [ctypes.c_void_p]
        leptonica.ptaaRead.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaRead(*args):
        """
        ('const char', '*filename')       
  ptaaRead()

      Input:  filename
      Return: ptaa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaRead(*args)
    
    

    try:
        leptonica.ptaaAddPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.ptaaAddPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaAddPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaAddPt(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'ipta')       
('l_float32', 'x')       
('l_float32', 'y')       
  ptaaAddPt()

      Input:  ptaa
              ipta  (to the i-th pta)
              x,y (point coordinates)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaAddPt(*args)
    
    

    try:
        leptonica.ptaCreate.argtypes = [ctypes.c_int32]
        leptonica.ptaCreate.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCreate(*args):
        """
        ('l_int32', 'n')       
  ptaCreate()

      Input:  n  (initial array sizes)
      Return: pta, or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCreate(*args)
    
    

    try:
        leptonica.ptaCopy.argtypes = [ctypes.c_void_p]
        leptonica.ptaCopy.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCopy(*args):
        """
        ('PTA', '*pta')       
  ptaCopy()

      Input:  pta
      Return: copy of pta, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCopy(*args)
    
    

    try:
        leptonica.ptaAddPt.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.ptaAddPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaAddPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaAddPt(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'x')       
('l_float32', 'y')       
  ptaAddPt()

      Input:  pta
              x, y
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaAddPt(*args)
    
    

    try:
        leptonica.ptaSetPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.ptaSetPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaSetPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSetPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_float32', 'x')       
('l_float32', 'y')       
  ptaSetPt()

      Input:  pta
              index  (into arrays)
              x, y
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSetPt(*args)
    
    

    try:
        leptonica.ptaCopyRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaCopyRange.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaCopyRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCopyRange(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'istart')       
('l_int32', 'iend')       
  ptaCopyRange()

      Input:  ptas
              istart  (starting index in ptas)
              iend  (ending index in ptas; use 0 to copy to end)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCopyRange(*args)
    
    

    try:
        leptonica.ptaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.ptaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetCount(*args):
        """
        ('PTA', '*pta')       
  ptaGetCount()

      Input:  pta
      Return: count, or 0 if no pta


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetCount(*args)
    
    

    try:
        leptonica.ptaEmpty.argtypes = [ctypes.c_void_p]
        leptonica.ptaEmpty.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaEmpty not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaEmpty(*args):
        """
        ('PTA', '*pta')       
  ptaEmpty()

      Input:  pta
      Return: 0 if OK, 1 on error

  Note: this only resets the "n" field, for reuse


        """
        args = _convert_params(*args)
        
        return leptonica.ptaEmpty(*args)
    
    

    try:
        leptonica.ptaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaWrite(*args):
        """
        ('const char', '*filename')       
('PTA', '*pta')       
('l_int32', 'type')       
  ptaWrite()

      Input:  filename
              pta
              type  (0 for float values; 1 for integer values)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaWrite(*args)
    
    

    try:
        leptonica.ptaaCreate.argtypes = [ctypes.c_int32]
        leptonica.ptaaCreate.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaCreate(*args):
        """
        ('l_int32', 'n')       
  ptaaCreate()

      Input:  n  (initial number of ptrs)
      Return: ptaa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaCreate(*args)
    
    

    try:
        leptonica.ptaGetArrays.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetArrays.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetArrays(*args):
        """
        ('PTA', '*pta')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       
  ptaGetArrays()

      Input:  pta
              &nax (<optional return> numa of x array)
              &nay (<optional return> numa of y array)
      Return: 0 if OK; 1 on error or if pta is empty

  Notes:
      (1) This copies the internal arrays into new Numas.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetArrays(*args)
    
    

    try:
        leptonica.ptaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ptaaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function ptaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaDestroy(*args):
        """
        ('PTAA', '**pptaa')       
  ptaaDestroy()

      Input:  &ptaa <to be nulled>
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaDestroy(*args)
    
    

    try:
        leptonica.ptaaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaInitFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaInitFull(*args):
        """
        ('PTAA', '*ptaa')       
('PTA', '*pta')       
  ptaaInitFull()

      Input:  ptaa (can have non-null ptrs in the ptr array)
              pta (to be replicated into the entire ptr array)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaInitFull(*args)
    
    

    try:
        leptonica.ptaInsertPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaInsertPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaInsertPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaInsertPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_int32', 'x')       
('l_int32', 'y')       
  ptaInsertPt()

      Input:  pta
              index (at which pt is to be inserted)
              x, y (point values)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaInsertPt(*args)
    
    

    try:
        leptonica.ptaaGetPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaGetPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaGetPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetPt(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'ipta')       
('l_int32', 'jpt')       
('l_float32', '*px')       
('l_float32', '*py')       
  ptaaGetPt()

      Input:  ptaa
              ipta  (to the i-th pta)
              jpt (index to the j-th pt in the pta)
              &x (<optional return> float x value)
              &y (<optional return> float y value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetPt(*args)
    
    

    try:
        leptonica.ptaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PTA', '*pta')       
('l_int32', 'type')       
  ptaWriteStream()

      Input:  stream
              pta
              type  (0 for float values; 1 for integer values)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaWriteStream(*args)
    
    

    try:
        leptonica.ptaaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaWrite(*args):
        """
        ('const char', '*filename')       
('PTAA', '*ptaa')       
('l_int32', 'type')       
  ptaaWrite()

      Input:  filename
              ptaa
              type  (0 for float values; 1 for integer values)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaWrite(*args)
    
    

    try:
        leptonica.ptaRead.argtypes = [ctypes.c_void_p]
        leptonica.ptaRead.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRead(*args):
        """
        ('const char', '*filename')       
  ptaRead()

      Input:  filename
      Return: pta, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRead(*args)
    
    

    try:
        leptonica.ptaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.ptaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetCount(*args):
        """
        ('PTAA', '*ptaa')       
  ptaaGetCount()

      Input:  ptaa
      Return: count, or 0 if no ptaa


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetCount(*args)
    
    

    try:
        leptonica.ptaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ptaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function ptaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaDestroy(*args):
        """
        ('PTA', '**ppta')       
  ptaDestroy()

      Input:  &pta (<to be nulled>)
      Return: void

  Note:
      - Decrements the ref count and, if 0, destroys the pta.
      - Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaDestroy(*args)
    
    

    try:
        leptonica.ptaGetPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_float32', '*px')       
('l_float32', '*py')       
  ptaGetPt()

      Input:  pta
              index  (into arrays)
              &x (<optional return> float x value)
              &y (<optional return> float y value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetPt(*args)
    
    

    try:
        leptonica.ptaaAddPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaAddPta.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaAddPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaAddPta(*args):
        """
        ('PTAA', '*ptaa')       
('PTA', '*pta')       
('l_int32', 'copyflag')       
  ptaaAddPta()

      Input:  ptaa
              pta  (to be added)
              copyflag  (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaAddPta(*args)
    
    

    try:
        leptonica.ptaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.ptaaReadStream.restype = lambda address: PTAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaReadStream(*args):
        """
        ('FILE', '*fp')       
  ptaaReadStream()

      Input:  stream
      Return: ptaa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaReadStream(*args)
    
    

    try:
        leptonica.ptaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.ptaaTruncate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaTruncate(*args):
        """
        ('PTAA', '*ptaa')       
  ptaaTruncate()

      Input:  ptaa
      Return: 0 if OK, 1 on error

  Notes:
      (1) This identifies the largest index containing a pta that
          has any points within it, destroys all pta above that index,
          and resets the count.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaTruncate(*args)
    
    

    try:
        leptonica.ptaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PTAA', '*ptaa')       
('l_int32', 'type')       
  ptaaWriteStream()

      Input:  stream
              ptaa
              type  (0 for float values; 1 for integer values)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaWriteStream(*args)
    
    

    try:
        leptonica.ptaCreateFromNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaCreateFromNuma.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaCreateFromNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCreateFromNuma(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
  ptaCreateFromNuma()

      Input:  nax (<optional> can be null)
              nay
      Return: pta, or null on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCreateFromNuma(*args)
    
    

    try:
        leptonica.ptaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.ptaReadStream.restype = lambda address: PTA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReadStream(*args):
        """
        ('FILE', '*fp')       
  ptaReadStream()

      Input:  stream
      Return: pta, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaReadStream(*args)
    
    

    try:
        leptonica.ptaRemovePt.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaRemovePt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaRemovePt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRemovePt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
  ptaRemovePt()

      Input:  pta
              index (of point to be removed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts pta[i] --> pta[i - 1] for all i > index.
      (2) It should not be used repeatedly on large arrays,
          because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRemovePt(*args)
    
    

    try:
        leptonica.ptaGetIPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetIPt.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptaGetIPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetIPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
  ptaGetIPt()

      Input:  pta
              index  (into arrays)
              &x (<optional return> integer x value)
              &y (<optional return> integer y value)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetIPt(*args)
    




class edge(object):
    """  edge.c

      Sobel edge detecting filter
          PIX      *pixSobelEdgeFilter()

      Two-sided edge gradient filter
          PIX      *pixTwoSidedEdgeFilter()

      Measurement of edge smoothness
          l_int32   pixMeasureEdgeSmoothness()
          NUMA     *pixGetEdgeProfile()
          l_int32   pixGetLastOffPixelInRun()
          l_int32   pixGetLastOnPixelInRun()


  The Sobel edge detector uses these two simple gradient filters.

       1    2    1             1    0   -1
       0    0    0             2    0   -2
      -1   -2   -1             1    0   -1

      (horizontal)             (vertical)

  To use both the vertical and horizontal filters, set the orientation
  flag to L_ALL_EDGES; this sums the abs. value of their outputs,
  clipped to 255.

  See comments below for displaying the resulting image with
  the edges dark, both for 8 bpp and 1 bpp.

"""
    
    try:
        leptonica.pixGetEdgeProfile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetEdgeProfile.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetEdgeProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetEdgeProfile(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'side')       
('const char', '*debugfile')       
  pixGetEdgeProfile()

      Input:  pixs (1 bpp)
              side (L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT)
              debugfile (<optional> displays constructed edge; use NULL
                         for no output)
      Return: na (of fg edge pixel locations), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetEdgeProfile(*args)
    
    

    try:
        leptonica.pixMeasureEdgeSmoothness.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMeasureEdgeSmoothness.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixMeasureEdgeSmoothness not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeasureEdgeSmoothness(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'side')       
('l_int32', 'minjump')       
('l_int32', 'minreversal')       
('l_float32', '*pjpl')       
('l_float32', '*pjspl')       
('l_float32', '*prpl')       
('const char', '*debugfile')       
  pixMeasureEdgeSmoothness()

      Input:  pixs (1 bpp)
              side (L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT)
              minjump (minimum jump to be counted; >= 1)
              minreversal (minimum reversal size for new peak or valley)
              &jpl (<optional return> jumps/length: number of jumps,
                    normalized to length of component side)
              &jspl (<optional return> jumpsum/length: sum of all
                     sufficiently large jumps, normalized to length
                     of component side)
              &rpl (<optional return> reversals/length: number of
                    peak-to-valley or valley-to-peak reversals,
                    normalized to length of component side)
              debugfile (<optional> displays constructed edge; use NULL
                         for no output)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes three measures of smoothness of the edge of a
          connected component:
            * jumps/length: (jpl) the number of jumps of size >= @minjump,
              normalized to the length of the side
            * jump sum/length: (jspl) the sum of all jump lengths of
              size >= @minjump, normalized to the length of the side
            * reversals/length: (rpl) the number of peak <--> valley
              reversals, using @minreverse as a minimum deviation of
              the peak or valley from its preceeding extremum,
              normalized to the length of the side
      (2) The input pix should be a single connected component, but
          this is not required.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeasureEdgeSmoothness(*args)
    
    

    try:
        leptonica.pixSobelEdgeFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSobelEdgeFilter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSobelEdgeFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSobelEdgeFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'orientflag')       
  pixSobelEdgeFilter()

      Input:  pixs (8 bpp; no colormap)
              orientflag (L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES)
      Return: pixd (8 bpp, edges are brighter), or null on error

  Notes:
      (1) Invert pixd to see larger gradients as darker (grayscale).
      (2) To generate a binary image of the edges, threshold
          the result using pixThresholdToBinary().  If the high
          edge values are to be fg (1), invert after running
          pixThresholdToBinary().
      (3) Label the pixels as follows:
              1    4    7
              2    5    8
              3    6    9
          Read the data incrementally across the image and unroll
          the loop.
      (4) This runs at about 45 Mpix/sec on a 3 GHz processor.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSobelEdgeFilter(*args)
    
    

    try:
        leptonica.pixTwoSidedEdgeFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixTwoSidedEdgeFilter.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixTwoSidedEdgeFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTwoSidedEdgeFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'orientflag')       
  pixTwoSidedEdgeFilter()

      Input:  pixs (8 bpp; no colormap)
              orientflag (L_HORIZONTAL_EDGES, L_VERTICAL_EDGES)
      Return: pixd (8 bpp, edges are brighter), or null on error

  Notes:
      (1) For detecting vertical edges, this considers the
          difference of the central pixel from those on the left
          and right.  For situations where the gradient is the same
          sign on both sides, this computes and stores the minimum
          (absolute value of the) difference.  The reason for
          checking the sign is that we are looking for pixels within
          a transition.  By contrast, for single pixel noise, the pixel
          value is either larger than or smaller than its neighbors,
          so the gradient would change direction on each side.  Horizontal
          edges are handled similarly, looking for vertical gradients.
      (2) To generate a binary image of the edges, threshold
          the result using pixThresholdToBinary().  If the high
          edge values are to be fg (1), invert after running
          pixThresholdToBinary().
      (3) This runs at about 60 Mpix/sec on a 3 GHz processor.
          It is about 30% faster than Sobel, and the results are
          similar.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTwoSidedEdgeFilter(*args)
    




class boxbasic(object):
    """   boxbasic.c

   Basic 'class' functions for box, boxa and boxaa,
   including accessors and serialization.

      Box creation, copy, clone, destruction
           BOX      *boxCreate()
           BOX      *boxCreateValid()
           BOX      *boxCopy()
           BOX      *boxClone()
           void      boxDestroy()

      Box accessors
           l_int32   boxGetGeometry()
           l_int32   boxSetGeometry()
           l_int32   boxGetSideLocation()
           l_int32   boxGetRefcount()
           l_int32   boxChangeRefcount()
           l_int32   boxIsValid()

      Boxa creation, copy, destruction
           BOXA     *boxaCreate()
           BOXA     *boxaCopy()
           void      boxaDestroy()

      Boxa array extension
           l_int32   boxaAddBox()
           l_int32   boxaExtendArray()
           l_int32   boxaExtendArrayToSize()

      Boxa accessors
           l_int32   boxaGetCount()
           l_int32   boxaGetValidCount()
           BOX      *boxaGetBox()
           BOX      *boxaGetValidBox()
           l_int32   boxaGetBoxGeometry()
           l_int32   boxaIsFull()

      Boxa array modifiers
           l_int32   boxaReplaceBox()
           l_int32   boxaInsertBox()
           l_int32   boxaRemoveBox()
           l_int32   boxaRemoveBoxAndSave()
           BOXA     *boxaSaveValid()
           l_int32   boxaInitFull()
           l_int32   boxaClear()

      Boxaa creation, copy, destruction
           BOXAA    *boxaaCreate()
           BOXAA    *boxaaCopy()
           void      boxaaDestroy()

      Boxaa array extension
           l_int32   boxaaAddBoxa()
           l_int32   boxaaExtendArray()
           l_int32   boxaaExtendArrayToSize()

      Boxaa accessors
           l_int32   boxaaGetCount()
           l_int32   boxaaGetBoxCount()
           BOXA     *boxaaGetBoxa()
           BOX      *boxaaGetBox()

      Boxaa array modifiers
           l_int32   boxaaInitFull()
           l_int32   boxaaExtendWithInit()
           l_int32   boxaaReplaceBoxa()
           l_int32   boxaaInsertBoxa()
           l_int32   boxaaRemoveBoxa()
           l_int32   boxaaAddBox()

      Boxaa serialized I/O
           BOXAA    *boxaaReadFromFiles()
           BOXAA    *boxaaRead()
           BOXAA    *boxaaReadStream()
           l_int32   boxaaWrite()
           l_int32   boxaaWriteStream()

      Boxa serialized I/O
           BOXA     *boxaRead()
           BOXA     *boxaReadStream()
           BOXA     *boxaReadMem()
           l_int32   boxaWrite()
           l_int32   boxaWriteStream()
           l_int32   boxaWriteMem()

      Box print (for debug)
           l_int32   boxPrintStreamInfo()

   Most functions use only valid boxes, which are boxes that have both
   width and height > 0.  However, a few functions, such as
   boxaGetMedian() do not assume that all boxes are valid.  For any
   function that can use a boxa with invalid boxes, it is convenient
   to use these accessors:
       boxaGetValidCount()   :  count of valid boxes
       boxaGetValidBox()     :  returns NULL for invalid boxes

"""
    
    try:
        leptonica.boxaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetCount(*args):
        """
        ('BOXAA', '*baa')       
  boxaaGetCount()

      Input:  boxaa
      Return: count (number of boxa), or 0 if no boxa or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetCount(*args)
    
    

    try:
        leptonica.boxaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWriteStream(*args):
        """
        ('FILE', '*fp')       
('BOXA', '*boxa')       
  boxaWriteStream()

      Input: stream
             boxa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWriteStream(*args)
    
    

    try:
        leptonica.boxaaAddBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaAddBoxa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaAddBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaAddBoxa(*args):
        """
        ('BOXAA', '*baa')       
('BOXA', '*ba')       
('l_int32', 'copyflag')       
  boxaaAddBoxa()

      Input:  boxaa
              boxa     (to be added)
              copyflag  (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaAddBoxa(*args)
    
    

    try:
        leptonica.boxaaReadFromFiles.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaReadFromFiles.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaReadFromFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReadFromFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'first')       
('l_int32', 'nfiles')       
  boxaaReadFromFiles()

      Input:  dirname (directory)
              substr (<optional> substring filter on filenames; can be NULL)
              first (0-based)
              nfiles (use 0 for everything from @first to the end)
      Return: baa, or null on error or if no boxa files are found.

  Notes:
      (1) The files must be serialized boxa files (e.g., *.ba).
          If some files cannot be read, warnings are issued.
      (2) Use @substr to filter filenames in the directory.  If
          @substr == NULL, this takes all files.
      (3) After filtering, use @first and @nfiles to select
          a contiguous set of files, that have been lexically
          sorted in increasing order.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReadFromFiles(*args)
    
    

    try:
        leptonica.boxPrintStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxPrintStreamInfo.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxPrintStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxPrintStreamInfo(*args):
        """
        ('FILE', '*fp')       
('BOX', '*box')       
  boxPrintStreamInfo()

      Input:  stream
              box
      Return: 0 if OK, 1 on error

  Notes:
      (1) This outputs debug info.  Use serialization functions to
          write to file if you want to read the data back.


        """
        args = _convert_params(*args)
        
        return leptonica.boxPrintStreamInfo(*args)
    
    

    try:
        leptonica.boxaaGetBoxCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaaGetBoxCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaGetBoxCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetBoxCount(*args):
        """
        ('BOXAA', '*baa')       
  boxaaGetBoxCount()

      Input:  boxaa
      Return: count (number of boxes), or 0 if no boxes or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetBoxCount(*args)
    
    

    try:
        leptonica.boxaaExtendWithInit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaExtendWithInit.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaExtendWithInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaExtendWithInit(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'maxindex')       
('BOXA', '*boxa')       
  boxaaExtendWithInit()

      Input:  boxaa
              maxindex
              boxa (to be replicated into the extended ptr array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This should be used on an existing boxaa that has been
          fully loaded with boxa.  It then extends the boxaa,
          loading all the additional ptrs with copies of boxa.
          Typically, boxa will be empty.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaExtendWithInit(*args)
    
    

    try:
        leptonica.boxaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetCount(*args):
        """
        ('BOXA', '*boxa')       
  boxaGetCount()

      Input:  boxa
      Return: count (of all boxes); 0 if no boxes or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetCount(*args)
    
    

    try:
        leptonica.boxaSaveValid.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaSaveValid.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaSaveValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSaveValid(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'copyflag')       
  boxaSaveValid()

      Input:  boxa
              copyflag (L_COPY or L_CLONE)
      Return: boxad if OK, null on error

  Notes:
      (1) This makes a copy/clone of each valid box.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSaveValid(*args)
    
    

    try:
        leptonica.boxaaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaInitFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaInitFull(*args):
        """
        ('BOXAA', '*baa')       
('BOXA', '*boxa')       
  boxaaInitFull()

      Input:  boxaa (typically empty)
              boxa (to be replicated into the entire ptr array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This initializes a boxaa by filling up the entire boxa ptr array
          with copies of @boxa.  Any existing boxa are destroyed.
          After this operation, the number of boxa is equal to
          the number of allocated ptrs.
      (2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().
          They both have the same effect when inserting into a NULL ptr
          in the boxa ptr array
      (3) Example usage.  This function is useful to prepare for a
          random insertion (or replacement) of boxa into a boxaa.
          To randomly insert boxa into a boxaa, up to some index "max":
             Boxaa *baa = boxaaCreate(max);
               // initialize the boxa
             Boxa *boxa = boxaCreate(...);
             ...  [optionally fix with boxes]
             boxaaInitFull(baa, boxa);
          A typical use is to initialize the array with empty boxa,
          and to replace only a subset that must be aligned with
          something else, such as a pixa.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaInitFull(*args)
    
    

    try:
        leptonica.boxCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxCreate.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCreate(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'w')       
('l_int32', 'h')       
  boxCreate()

      Input:  x, y, w, h
      Return: box, or null on error

  Notes:
      (1) This clips the box to the +quad.  If no part of the
          box is in the +quad, this returns NULL.
      (2) We allow you to make a box with w = 0 and/or h = 0.
          This does not represent a valid region, but it is useful
          as a placeholder in a boxa for which the index of the
          box in the boxa is important.  This is an atypical
          situation; usually you want to put only valid boxes with
          nonzero width and height in a boxa.  If you have a boxa
          with invalid boxes, the accessor boxaGetValidBox()
          will return NULL on each invalid box.
      (3) If you want to create only valid boxes, use boxCreateValid(),
          which returns NULL if either w or h is 0.


        """
        args = _convert_params(*args)
        
        return leptonica.boxCreate(*args)
    
    

    try:
        leptonica.boxaaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaCopy.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaCopy(*args):
        """
        ('BOXAA', '*baas')       
('l_int32', 'copyflag')       
  boxaaCopy()

      Input:  baas (input boxaa to be copied)
              copyflag (L_COPY, L_CLONE)
      Return: baad (new boxaa, composed of copies or clones of the boxa
                    in baas), or null on error

  Notes:
      (1) L_COPY makes a copy of each boxa in baas.
          L_CLONE makes a clone of each boxa in baas.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaCopy(*args)
    
    

    try:
        leptonica.boxaReplaceBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaReplaceBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaReplaceBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReplaceBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('BOX', '*box')       
  boxaReplaceBox()

      Input:  boxa
              index  (to the index-th box)
              box (insert to replace existing one)
      Return: 0 if OK, 1 on error

  Notes:
      (1) In-place replacement of one box.
      (2) The previous box at that location, if any, is destroyed.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReplaceBox(*args)
    
    

    try:
        leptonica.boxaCreate.argtypes = [ctypes.c_int32]
        leptonica.boxaCreate.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCreate(*args):
        """
        ('l_int32', 'n')       
  boxaCreate()

      Input:  n  (initial number of ptrs)
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCreate(*args)
    
    

    try:
        leptonica.boxGetSideLocation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxGetSideLocation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxGetSideLocation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetSideLocation(*args):
        """
        ('BOX', '*box')       
('l_int32', 'side')       
('l_int32', '*ploc')       
  boxGetSideLocation()

      Input:  box
              side (L_GET_LEFT, L_GET_RIGHT, L_GET_TOP, L_GET_BOT)
              &loc (<return> location)
      Return: 0 if OK, 1 on error

  Notes:
      (1) All returned values are within the box.  In particular:
            right = left + width - 1
            bottom = top + height - 1


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetSideLocation(*args)
    
    

    try:
        leptonica.boxaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaWriteMem.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('BOXA', '*boxa')       
  boxaWriteMem()

      Input:  &data (<return> data of serialized boxa; ascii)
              &size (<return> size of returned data)
              boxa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWriteMem(*args)
    
    

    try:
        leptonica.boxaaCreate.argtypes = [ctypes.c_int32]
        leptonica.boxaaCreate.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaCreate(*args):
        """
        ('l_int32', 'n')       
  boxaaCreate()

      Input:  size of boxa ptr array to be alloc'd (0 for default)
      Return: baa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaCreate(*args)
    
    

    try:
        leptonica.boxaaExtendArrayToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaExtendArrayToSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaExtendArrayToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaExtendArrayToSize(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'size')       
  boxaaExtendArrayToSize()

      Input:  boxaa
              size (new size of boxa array)
      Return: 0 if OK; 1 on error

  Notes:
      (1) If necessary, reallocs the boxa ptr array to @size.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaExtendArrayToSize(*args)
    
    

    try:
        leptonica.boxaGetBoxGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetBoxGeometry.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaGetBoxGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetBoxGeometry(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  boxaGetBoxGeometry()

      Input:  boxa
              index  (to the index-th box)
              &x, &y, &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetBoxGeometry(*args)
    
    

    try:
        leptonica.boxaExtendArray.argtypes = [ctypes.c_void_p]
        leptonica.boxaExtendArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtendArray(*args):
        """
        ('BOXA', '*boxa')       
  boxaExtendArray()

      Input:  boxa
      Return: 0 if OK; 1 on error

  Notes:
      (1) Reallocs with doubled size of ptr array.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtendArray(*args)
    
    

    try:
        leptonica.boxaExtendArrayToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaExtendArrayToSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaExtendArrayToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtendArrayToSize(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'size')       
  boxaExtendArrayToSize()

      Input:  boxa
              size (new size of boxa array)
      Return: 0 if OK; 1 on error

  Notes:
      (1) If necessary, reallocs new boxa ptr array to @size.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtendArrayToSize(*args)
    
    

    try:
        leptonica.boxaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.boxaaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function boxaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaDestroy(*args):
        """
        ('BOXAA', '**pbaa')       
  boxaaDestroy()

      Input:  &boxaa (<will be set to null before returning>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaDestroy(*args)
    
    

    try:
        leptonica.boxaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaCopy.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCopy(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'copyflag')       
  boxaCopy()

      Input:  boxa
              copyflag (L_COPY, L_CLONE, L_COPY_CLONE)
      Return: new boxa, or null on error

  Notes:
      (1) See pix.h for description of the copyflag.
      (2) The copy-clone makes a new boxa that holds clones of each box.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCopy(*args)
    
    

    try:
        leptonica.boxDestroy.argtypes = [ctypes.c_void_p]
        leptonica.boxDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function boxDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxDestroy(*args):
        """
        ('BOX', '**pbox')       
  boxDestroy()

      Input:  &box (<will be set to null before returning>)
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the box.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.boxDestroy(*args)
    
    

    try:
        leptonica.boxaClear.argtypes = [ctypes.c_void_p]
        leptonica.boxaClear.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaClear(*args):
        """
        ('BOXA', '*boxa')       
  boxaClear()

      Input:  boxa
      Return: 0 if OK, 1 on error

  Notes:
      (1) This destroys all boxes in the boxa, setting the ptrs
          to null.  The number of allocated boxes, n, is set to 0.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaClear(*args)
    
    

    try:
        leptonica.boxCopy.argtypes = [ctypes.c_void_p]
        leptonica.boxCopy.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCopy(*args):
        """
        ('BOX', '*box')       
  boxCopy()

      Input:  box
      Return: copy of box, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxCopy(*args)
    
    

    try:
        leptonica.boxaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaAddBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAddBox(*args):
        """
        ('BOXA', '*boxa')       
('BOX', '*box')       
('l_int32', 'copyflag')       
  boxaAddBox()

      Input:  boxa
              box  (to be added)
              copyflag (L_INSERT, L_COPY, L_CLONE)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAddBox(*args)
    
    

    try:
        leptonica.boxGetGeometry.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxGetGeometry.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxGetGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetGeometry(*args):
        """
        ('BOX', '*box')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  boxGetGeometry()

      Input:  box
              &x, &y, &w, &h (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetGeometry(*args)
    
    

    try:
        leptonica.boxClone.argtypes = [ctypes.c_void_p]
        leptonica.boxClone.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxClone(*args):
        """
        ('BOX', '*box')       
  boxClone()

      Input:  box
      Return: ptr to same box, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxClone(*args)
    
    

    try:
        leptonica.boxSetGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxSetGeometry.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxSetGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSetGeometry(*args):
        """
        ('BOX', '*box')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'w')       
('l_int32', 'h')       
  boxSetGeometry()

      Input:  box
              x, y, w, h (use -1 to leave unchanged)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxSetGeometry(*args)
    
    

    try:
        leptonica.boxaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.boxaReadMem.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
  boxaReadMem()

      Input:  data (ascii)
              size (of data; can use strlen to get it)
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReadMem(*args)
    
    

    try:
        leptonica.boxaaGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaGetBox.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetBox(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'iboxa')       
('l_int32', 'ibox')       
('l_int32', 'accessflag')       
  boxaaGetBox()

      Input:  baa
              iboxa  (index into the boxa array in the boxaa)
              ibox  (index into the box array in the boxa)
              accessflag   (L_COPY or L_CLONE)
      Return: box, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetBox(*args)
    
    

    try:
        leptonica.boxaaRead.argtypes = [ctypes.c_void_p]
        leptonica.boxaaRead.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaRead(*args):
        """
        ('const char', '*filename')       
  boxaaRead()

      Input:  filename
      Return: boxaa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaRead(*args)
    
    

    try:
        leptonica.boxaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.boxaReadStream.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReadStream(*args):
        """
        ('FILE', '*fp')       
  boxaReadStream()

      Input:  stream
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReadStream(*args)
    
    

    try:
        leptonica.boxaInsertBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaInsertBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaInsertBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaInsertBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('BOX', '*box')       
  boxaInsertBox()

      Input:  boxa
              index (location in boxa to insert new value)
              box (new box to be inserted)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts box[i] --> box[i + 1] for all i >= index,
          and then inserts box as box[index].
      (2) To insert at the beginning of the array, set index = 0.
      (3) To append to the array, it's easier to use boxaAddBox().
      (4) This should not be used repeatedly to insert into large arrays,
          because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.boxaInsertBox(*args)
    
    

    try:
        leptonica.boxaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWrite(*args):
        """
        ('const char', '*filename')       
('BOXA', '*boxa')       
  boxaWrite()

      Input:  filename
              boxa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWrite(*args)
    
    

    try:
        leptonica.boxaGetValidCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaGetValidCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaGetValidCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetValidCount(*args):
        """
        ('BOXA', '*boxa')       
  boxaGetValidCount()

      Input:  boxa
      Return: count (of valid boxes); 0 if no valid boxes or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetValidCount(*args)
    
    

    try:
        leptonica.boxaaExtendArray.argtypes = [ctypes.c_void_p]
        leptonica.boxaaExtendArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaExtendArray(*args):
        """
        ('BOXAA', '*baa')       
  boxaaExtendArray()

      Input:  boxaa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaExtendArray(*args)
    
    

    try:
        leptonica.boxCreateValid.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxCreateValid.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxCreateValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCreateValid(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'w')       
('l_int32', 'h')       
  boxCreateValid()

      Input:  x, y, w, h
      Return: box, or null on error

  Notes:
      (1) This returns NULL if either w = 0 or h = 0.


        """
        args = _convert_params(*args)
        
        return leptonica.boxCreateValid(*args)
    
    

    try:
        leptonica.boxaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('BOXAA', '*baa')       
  boxaaWriteStream()

      Input: stream
             boxaa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaWriteStream(*args)
    
    

    try:
        leptonica.boxaRead.argtypes = [ctypes.c_void_p]
        leptonica.boxaRead.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRead(*args):
        """
        ('const char', '*filename')       
  boxaRead()

      Input:  filename
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRead(*args)
    
    

    try:
        leptonica.boxIsValid.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxIsValid.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxIsValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxIsValid(*args):
        """
        ('BOX', '*box')       
('l_int32', '*pvalid')       
  boxIsValid()

      Input:  box
              &valid (<return> 1 if valid; 0 otherwise)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxIsValid(*args)
    
    

    try:
        leptonica.boxaGetValidBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetValidBox.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaGetValidBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetValidBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       
  boxaGetValidBox()

      Input:  boxa
              index  (to the index-th box)
              accessflag  (L_COPY or L_CLONE)
      Return: box, or null if box is not valid or on error

  Notes:
      (1) This returns NULL for an invalid box in a boxa.
          For a box to be valid, both the width and height must be > 0.
      (2) We allow invalid boxes, with w = 0 or h = 0, as placeholders
          in boxa for which the index of the box in the boxa is important.
          This is an atypical situation; usually you want to put only
          valid boxes in a boxa.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetValidBox(*args)
    
    

    try:
        leptonica.boxaaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaWrite(*args):
        """
        ('const char', '*filename')       
('BOXAA', '*baa')       
  boxaaWrite()

      Input:  filename
              boxaa
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaWrite(*args)
    
    

    try:
        leptonica.boxaaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaAddBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaAddBox(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('BOX', '*box')       
('l_int32', 'accessflag')       
  boxaaAddBox()

      Input:  boxaa
              index (of boxa with boxaa)
              box (to be added)
              accessflag (L_INSERT, L_COPY or L_CLONE)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Adds to an existing boxa only.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaAddBox(*args)
    
    

    try:
        leptonica.boxaaReplaceBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaReplaceBoxa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaReplaceBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReplaceBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('BOXA', '*boxa')       
  boxaaReplaceBoxa()

      Input:  boxaa
              index  (to the index-th boxa)
              boxa (insert and replace any existing one)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Any existing boxa is destroyed, and the input one
          is inserted in its place.
      (2) If the index is invalid, return 1 (error)


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReplaceBoxa(*args)
    
    

    try:
        leptonica.boxaaRemoveBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaRemoveBoxa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaRemoveBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaRemoveBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
  boxaaRemoveBoxa()

      Input:  boxaa
              index  (of the boxa to be removed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This removes boxa[index] and then shifts
          boxa[i] --> boxa[i - 1] for all i > index.
      (2) The removed boxaa is destroyed.
      (2) This should not be used repeatedly on large arrays,
          because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaRemoveBoxa(*args)
    
    

    try:
        leptonica.boxaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.boxaaReadStream.restype = lambda address: BOXAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReadStream(*args):
        """
        ('FILE', '*fp')       
  boxaaReadStream()

      Input:  stream
      Return: boxaa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReadStream(*args)
    
    

    try:
        leptonica.boxaIsFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaIsFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaIsFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaIsFull(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*pfull')       
  boxaIsFull()

      Input:  boxa
              &full (return> 1 if boxa is full)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaIsFull(*args)
    
    

    try:
        leptonica.boxaaGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaGetBoxa.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaaGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       
  boxaaGetBoxa()

      Input:  boxaa
              index  (to the index-th boxa)
              accessflag   (L_COPY or L_CLONE)
      Return: boxa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetBoxa(*args)
    
    

    try:
        leptonica.boxaRemoveBoxAndSave.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaRemoveBoxAndSave.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaRemoveBoxAndSave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRemoveBoxAndSave(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('BOX', '**pbox')       
  boxaRemoveBoxAndSave()

      Input:  boxa
              index (of box to be removed)
              &box (<optional return> removed box)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This removes box[index] and then shifts
          box[i] --> box[i - 1] for all i > index.
      (2) It should not be used repeatedly to remove boxes from
          large arrays, because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRemoveBoxAndSave(*args)
    
    

    try:
        leptonica.boxaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaInitFull.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaInitFull(*args):
        """
        ('BOXA', '*boxa')       
('BOX', '*box')       
  boxaInitFull()

      Input:  boxa (typically empty)
              box (<optional> to be replicated into the entire ptr array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This initializes a boxa by filling up the entire box ptr array
          with copies of @box.  If @box == NULL, use a placeholder box
          of zero size.  Any existing boxes are destroyed.
          After this opepration, the number of boxes is equal to
          the number of allocated ptrs.
      (2) Note that we use boxaReplaceBox() instead of boxaInsertBox().
          They both have the same effect when inserting into a NULL ptr
          in the boxa ptr array:
      (3) Example usage.  This function is useful to prepare for a
          random insertion (or replacement) of boxes into a boxa.
          To randomly insert boxes into a boxa, up to some index "max":
             Boxa *boxa = boxaCreate(max);
             boxaInitFull(boxa, NULL);
          If you want placeholder boxes of non-zero size:
             Boxa *boxa = boxaCreate(max);
             Box *box = boxCreate(...);
             boxaInitFull(boxa, box);
             boxDestroy(&box);
          If we have an existing boxa with a smaller ptr array, it can
          be reused for up to max boxes:
             boxaExtendArrayToSize(boxa, max);
             boxaInitFull(boxa, NULL);
          The initialization allows the boxa to always be properly
          filled, even if all the boxes are not later replaced.
          If you want to know which boxes have been replaced,
          and you initialized with invalid zero-sized boxes,
          use boxaGetValidBox() to return NULL for the invalid boxes.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaInitFull(*args)
    
    

    try:
        leptonica.boxaGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetBox.restype = lambda address: BOX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       
  boxaGetBox()

      Input:  boxa
              index  (to the index-th box)
              accessflag  (L_COPY or L_CLONE)
      Return: box, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetBox(*args)
    
    

    try:
        leptonica.boxaaInsertBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaInsertBoxa.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaaInsertBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaInsertBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('BOXA', '*boxa')       
  boxaaInsertBoxa()

      Input:  boxaa
              index (location in boxaa to insert new boxa)
              boxa (new boxa to be inserted)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This shifts boxa[i] --> boxa[i + 1] for all i >= index,
          and then inserts boxa as boxa[index].
      (2) To insert at the beginning of the array, set index = 0.
      (3) To append to the array, it's easier to use boxaaAddBoxa().
      (4) This should not be used repeatedly to insert into large arrays,
          because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaInsertBoxa(*args)
    
    

    try:
        leptonica.boxaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.boxaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function boxaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaDestroy(*args):
        """
        ('BOXA', '**pboxa')       
  boxaDestroy()

      Input:  &boxa (<will be set to null before returning>)
      Return: void

  Note:
      - Decrements the ref count and, if 0, destroys the boxa.
      - Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaDestroy(*args)
    
    

    try:
        leptonica.boxaRemoveBox.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaRemoveBox.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function boxaRemoveBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRemoveBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
  boxaRemoveBox()

      Input:  boxa
              index (of box to be removed)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This removes box[index] and then shifts
          box[i] --> box[i - 1] for all i > index.
      (2) It should not be used repeatedly to remove boxes from
          large arrays, because the function is O(n).


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRemoveBox(*args)
    




class ptra(object):
    """   ptra.c

      Ptra creation and destruction
          L_PTRA      *ptraCreate()
          void        *ptraDestroy()

      Add/insert/remove/replace generic ptr object
          l_int32      ptraAdd()
          static l_int32  ptraExtendArray()
          l_int32      ptraInsert()
          void        *ptraRemove()
          void        *ptraRemoveLast()
          void        *ptraReplace()
          l_int32      ptraSwap()
          l_int32      ptraCompactArray()

      Other array operations
          l_int32      ptraReverse()
          l_int32      ptraJoin()

      Simple Ptra accessors
          l_int32      ptraGetMaxIndex()
          l_int32      ptraGetActualCount()
          void        *ptraGetPtrToItem()

      Ptraa creation and destruction
          L_PTRAA     *ptraaCreate()
          void        *ptraaDestroy()

      Ptraa accessors
          l_int32      ptraaGetSize()
          l_int32      ptraaInsertPtra()
          L_PTRA      *ptraaGetPtra()

      Ptraa conversion
          L_PTRA      *ptraaFlattenToPtra()

    Notes on the Ptra:

    (1) The Ptra is a struct, not an array.  Always use the accessors
        in this file, never the fields directly.
    (2) Items can be placed anywhere in the allocated ptr array,
        including one index beyond the last ptr (in which case the
        ptr array is realloc'd).
    (3) Thus, the items on the ptr array need not be compacted.  In
        general there will be null pointers in the ptr array.
    (4) A compacted array will remain compacted on removal if
        arbitrary items are removed with compaction, or if items
        are removed from the end of the array.
    (5) For addition to and removal from the end of the array, this
        functions exactly like a stack, and with the same O(1) cost.
    (6) This differs from the generic stack in that we allow
        random access for insertion, removal and replacement.
        Removal can be done without compacting the array.
        Insertion into a null ptr in the array has no effect on
        the other pointers, but insertion into a location already
        occupied by an item has a cost proportional to the
        distance to the next null ptr in the array.
    (7) Null ptrs are valid input args for both insertion and
        replacement; this allows arbitrary swapping.
    (8) The item in the array with the largest index is at pa->imax.
        This can be any value from -1 (initialized; all array ptrs
        are null) up to pa->nalloc - 1 (the last ptr in the array).
    (9) In referring to the array: the first ptr is the "top" or
        "beginning"; the last pointer is the "bottom" or "end";
        items are shifted "up" towards the top when compaction occurs;
        and items are shifted "down" towards the bottom when forced to
        move due to an insertion.
   (10) It should be emphasized that insertion, removal and replacement
        are general:
         * You can insert an item into any ptr location in the
           allocated ptr array, as well as into the next ptr address
           beyond the allocated array (in which case a realloc will occur).
         * You can remove or replace an item from any ptr location
           in the allocated ptr array.
         * When inserting into an occupied location, you have
           three options for downshifting.
         * When removing, you can either leave the ptr null or
           compact the array.

    Notes on the Ptraa:

    (1) The Ptraa is a fixed size ptr array for holding Ptra.
        In that respect, it is different from other pointer arrays, which
        are extensible and grow using the *Add*() functions.
    (2) In general, the Ptra ptrs in the Ptraa can be randomly occupied.
        A typical usage is to allow an O(n) horizontal sort of Pix,
        where the size of the Ptra array is the width of the image,
        and each Ptra is an array of all the Pix at a specific x location.

"""
    
    try:
        leptonica.ptraCreate.argtypes = [ctypes.c_int32]
        leptonica.ptraCreate.restype = lambda address: L_PTRA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptraCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraCreate(*args):
        """
        ('l_int32', 'n')       
  ptraCreate()

      Input:  size of ptr array to be alloc'd (0 for default)
      Return: pa, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraCreate(*args)
    
    

    try:
        leptonica.ptraaDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function ptraaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaDestroy(*args):
        """
        ('L_PTRAA', '**ppaa')       
('l_int32', 'freeflag')       
('l_int32', 'warnflag')       
  ptraaDestroy()

      Input:  &paa (<to be nulled>)
              freeflag (TRUE to free each remaining item in each ptra)
              warnflag (TRUE to warn if any remaining items are not destroyed)
      Return: void

  Notes:
      (1) See ptraDestroy() for use of @freeflag and @warnflag.
      (2) To destroy the ptraa, we destroy each ptra, then the ptr array,
          then the ptraa, and then null the contents of the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaDestroy(*args)
    
    

    try:
        leptonica.ptraaGetSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraaGetSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraaGetSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaGetSize(*args):
        """
        ('L_PTRAA', '*paa')       
('l_int32', '*psize')       
  ptraaGetSize()

      Input:  ptraa
              &size (<return> size of ptr array)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaGetSize(*args)
    
    

    try:
        leptonica.ptraGetMaxIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraGetMaxIndex.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraGetMaxIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraGetMaxIndex(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', '*pmaxindex')       
  ptraGetMaxIndex()

      Input:  ptra
              &maxindex (<return> index of last item in the array);
      Return: 0 if OK; 1 on error

  Notes:
      (1) The largest index to an item in the array is @maxindex.
          @maxindex is one less than the number of items that would be
          in the array if there were no null pointers between 0
          and @maxindex - 1.  However, because the internal ptr array
          need not be compacted, there may be null pointers at
          indices below @maxindex; for example, if items have
          been removed.
      (2) When an item is added to the end of the array, it goes
          into pa->array[maxindex + 1], and maxindex is then
          incremented by 1.
      (3) If there are no items in the array, this returns @maxindex = -1.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraGetMaxIndex(*args)
    
    

    try:
        leptonica.ptraaGetPtra.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraaGetPtra.restype = lambda address: L_PTRA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptraaGetPtra not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaGetPtra(*args):
        """
        ('L_PTRAA', '*paa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       
  ptraaGetPtra()

      Input:  ptraa
              index (location in array)
              accessflag (L_HANDLE_ONLY, L_REMOVE)
      Return: ptra (at index location), or NULL on error or if there
              is no ptra there.

  Notes:
      (1) This returns the ptra ptr.  If @accessflag == L_HANDLE_ONLY,
          the ptra is left on the ptraa.  If @accessflag == L_REMOVE,
          the ptr in the ptraa is set to NULL, and the caller
          is responsible for disposing of the ptra (either putting it
          back on the ptraa, or destroying it).
      (2) This returns NULL if there is no Ptra at the index location.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaGetPtra(*args)
    
    

    try:
        leptonica.ptraCompactArray.argtypes = [ctypes.c_void_p]
        leptonica.ptraCompactArray.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraCompactArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraCompactArray(*args):
        """
        ('L_PTRA', '*pa')       
  ptraCompactArray()

      Input:  ptra
      Return: 0 if OK, 1 on error

  Notes:
      (1) This compacts the items on the array, filling any empty ptrs.
      (2) This does not change the size of the array of ptrs.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraCompactArray(*args)
    
    

    try:
        leptonica.ptraDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function ptraDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraDestroy(*args):
        """
        ('L_PTRA', '**ppa')       
('l_int32', 'freeflag')       
('l_int32', 'warnflag')       
  ptraDestroy()

      Input:  &ptra (<to be nulled>)
              freeflag (TRUE to free each remaining item in the array)
              warnflag (TRUE to warn if any remaining items are not destroyed)
      Return: void

  Notes:
      (1) If @freeflag == TRUE, frees each item in the array.
      (2) If @freeflag == FALSE and warnflag == TRUE, and there are
          items on the array, this gives a warning and destroys the array.
          If these items are not owned elsewhere, this will cause
          a memory leak of all the items that were on the array.
          So if the items are not owned elsewhere and require their
          own destroy function, they must be destroyed before the ptra.
      (3) If warnflag == FALSE, no warnings will be issued.  This is
          useful if the items are owned elsewhere, such as a
          PixMemoryStore().
      (4) To destroy the ptra, we destroy the ptr array, then
          the ptra, and then null the contents of the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraDestroy(*args)
    
    

    try:
        leptonica.ptraRemoveLast.argtypes = [ctypes.c_void_p]
        leptonica.ptraRemoveLast.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function ptraRemoveLast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraRemoveLast(*args):
        """
        ('L_PTRA', '*pa')       
  ptraRemoveLast()

      Input:  ptra
      Return: item, or null on error or if the array is empty


        """
        args = _convert_params(*args)
        
        return leptonica.ptraRemoveLast(*args)
    
    

    try:
        leptonica.ptraGetActualCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraGetActualCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraGetActualCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraGetActualCount(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', '*pcount')       
  ptraGetActualCount()

      Input:  ptra
              &count (<return> actual number of items on the ptr array)
      Return: 0 if OK; 1 on error

  Notes:
      (1) The actual number of items on the ptr array, pa->nactual,
          will be smaller than pa->n if the array is not compacted.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraGetActualCount(*args)
    
    

    try:
        leptonica.ptraGetPtrToItem.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptraGetPtrToItem.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function ptraGetPtrToItem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraGetPtrToItem(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
  ptraGetPtrToItem()

      Input:  ptra
              index (of element to be retrieved)
      Return: a ptr to the element, or null on error

  Notes:
      (1) This returns a ptr to the item.  You must cast it to
          the type of item.  Do not destroy it; the item belongs
          to the Ptra.
      (2) This can access all possible items on the ptr array.
          If an item doesn't exist, it returns null.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraGetPtrToItem(*args)
    
    

    try:
        leptonica.ptraaInsertPtra.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptraaInsertPtra.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraaInsertPtra not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaInsertPtra(*args):
        """
        ('L_PTRAA', '*paa')       
('l_int32', 'index')       
('L_PTRA', '*pa')       
  ptraaInsertPtra()

      Input:  ptraa
              index (location in array for insertion)
              ptra (to be inserted)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Caller should check return value.  On success, the Ptra
          is inserted in the Ptraa and is owned by it.  However,
          on error, the Ptra remains owned by the caller.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaInsertPtra(*args)
    
    

    try:
        leptonica.ptraSwap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraSwap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraSwap(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index1')       
('l_int32', 'index2')       
  ptraSwap()

      Input:  ptra
              index1
              index2
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraSwap(*args)
    
    

    try:
        leptonica.ptraRemove.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function ptraRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraRemove(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
('l_int32', 'flag')       
  ptraRemove()

      Input:  ptra
              index (element to be removed)
              flag (L_NO_COMPACTION, L_COMPACTION)
      Return: item, or null on error

  Notes:
      (1) If flag == L_NO_COMPACTION, this removes the item and
          nulls the ptr on the array.  If it takes the last item
          in the array, pa->n is reduced to the next item.
      (2) If flag == L_COMPACTION, this compacts the array for
          for all i >= index.  It should not be used repeatedly on
          large arrays, because compaction is O(n).
      (3) The ability to remove without automatic compaction allows
          removal with cost O(1).


        """
        args = _convert_params(*args)
        
        return leptonica.ptraRemove(*args)
    
    

    try:
        leptonica.ptraReplace.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptraReplace.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function ptraReplace not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraReplace(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
('void', '*item')       
('l_int32', 'freeflag')       
  ptraReplace()

      Input:  ptra
              index (element to be replaced)
              item  (new generic ptr to a struct; can be null)
              freeflag (TRUE to free old item; FALSE to return it)
      Return: item  (old item, if it exists and is not freed),
                     or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraReplace(*args)
    
    

    try:
        leptonica.ptraaCreate.argtypes = [ctypes.c_int32]
        leptonica.ptraaCreate.restype = lambda address: L_PTRAA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptraaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaCreate(*args):
        """
        ('l_int32', 'n')       
  ptraaCreate()

      Input:  size of ptr array to be alloc'd
      Return: paa, or null on error

  Notes:
      (1) The ptraa is generated with a fixed size, that can not change.
          The ptra can be generated and inserted randomly into this array.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaCreate(*args)
    
    

    try:
        leptonica.ptraReverse.argtypes = [ctypes.c_void_p]
        leptonica.ptraReverse.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraReverse(*args):
        """
        ('L_PTRA', '*pa')       
  ptraReverse()

      Input:  ptra
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraReverse(*args)
    
    

    try:
        leptonica.ptraaFlattenToPtra.argtypes = [ctypes.c_void_p]
        leptonica.ptraaFlattenToPtra.restype = lambda address: L_PTRA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function ptraaFlattenToPtra not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaFlattenToPtra(*args):
        """
        ('L_PTRAA', '*paa')       
  ptraaFlattenToPtra()

      Input:  ptraa
      Return: ptra, or null on error

  Notes:
      (1) This 'flattens' the ptraa to a ptra, taking the items in
          each ptra, in order, starting with the first ptra, etc.
      (2) As a side-effect, the ptra are all removed from the ptraa
          and destroyed, leaving an empty ptraa.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaFlattenToPtra(*args)
    
    

    try:
        leptonica.ptraJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraJoin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraJoin(*args):
        """
        ('L_PTRA', '*pa1')       
('L_PTRA', '*pa2')       
  ptraJoin()

      Input:  ptra1 (add to this one)
              ptra2 (appended to ptra1, and emptied of items; can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraJoin(*args)
    
    

    try:
        leptonica.ptraInsert.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptraInsert.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraInsert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraInsert(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
('void', '*item')       
('l_int32', 'shiftflag')       
  ptraInsert()

      Input:  ptra
              index (location in ptra to insert new value)
              item  (generic ptr to a struct; can be null)
              shiftflag (L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This checks first to see if the location is valid, and
          then if there is presently an item there.  If there is not,
          it is simply inserted into that location.
      (2) If there is an item at the insert location, items must be
          moved down to make room for the insert.  In the downward
          shift there are three options, given by @shiftflag.
            - If @shiftflag == L_AUTO_DOWNSHIFT, a decision is made
              whether, in a cascade of items, to downshift a minimum
              amount or for all items above @index.  The decision is
              based on the expectation of finding holes (null ptrs)
              between @index and the bottom of the array.
              Assuming the holes are distributed uniformly, if 2 or more
              holes are expected, we do a minimum shift.
            - If @shiftflag == L_MIN_DOWNSHIFT, the downward shifting
              cascade of items progresses a minimum amount, until
              the first empty slot is reached.  This mode requires
              some computation before the actual shifting is done.
            - If @shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is
              performed where pa[i] --> pa[i + 1] for all i >= index.
              Then, the item is inserted at pa[index].
      (3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is
          to use L_FULL_DOWNSHIFT if the array is compacted (each
          element points to an item), and to use L_MIN_DOWNSHIFT
          if there are a significant number of null pointers.
          There is no penalty to using L_MIN_DOWNSHIFT for a
          compacted array, however, because the full shift is required
          and we don't do the O(n) computation to look for holes.
      (4) This should not be used repeatedly on large arrays,
          because the function is generally O(n).
      (5) However, it can be used repeatedly if we start with an empty
          ptr array and insert only once at each location.  For example,
          you can support an array of Numa, where at each ptr location
          you store either 0 or 1 Numa, and the Numa can be added
          randomly to the ptr array.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraInsert(*args)
    
    

    try:
        leptonica.ptraAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraAdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function ptraAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraAdd(*args):
        """
        ('L_PTRA', '*pa')       
('void', '*item')       
  ptraAdd()

      Input:  ptra
              item  (generic ptr to a struct)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This adds the element to the next location beyond imax,
          which is the largest occupied ptr in the array.  This is
          what you expect from a stack, where all ptrs up to and
          including imax are occupied, but here the occuption of
          items in the array is entirely arbitrary.


        """
        args = _convert_params(*args)
        
        return leptonica.ptraAdd(*args)
    




class sarray(object):
    """   sarray.c

      Create/Destroy/Copy
          SARRAY    *sarrayCreate()
          SARRAY    *sarrayCreateInitialized()
          SARRAY    *sarrayCreateWordsFromString()
          SARRAY    *sarrayCreateLinesFromString()
          void      *sarrayDestroy()
          SARRAY    *sarrayCopy()
          SARRAY    *sarrayClone()

      Add/Remove string
          l_int32    sarrayAddString()
          static l_int32  sarrayExtendArray()
          char      *sarrayRemoveString()
          l_int32    sarrayReplaceString()
          l_int32    sarrayClear()

      Accessors
          l_int32    sarrayGetCount()
          char     **sarrayGetArray()
          char      *sarrayGetString()
          l_int32    sarrayGetRefcount()
          l_int32    sarrayChangeRefcount()

      Conversion back to string
          char      *sarrayToString()
          char      *sarrayToStringRange()

      Concatenate 2 sarrays
          l_int32    sarrayConcatenate()
          l_int32    sarrayAppendRange()

      Pad an sarray to be the same size as another sarray
          l_int32    sarrayPadToSameSize()

      Convert word sarray to (formatted) line sarray
          SARRAY    *sarrayConvertWordsToLines()

      Split string on separator list
          SARRAY    *sarraySplitString()

      Filter sarray
          SARRAY    *sarraySelectBySubstring()
          SARRAY    *sarraySelectByRange()
          l_int32    sarrayParseRange()

      Sort
          SARRAY    *sarraySort()
          SARRAY    *sarraySortByIndex()
          l_int32    stringCompareLexical()

      Serialize for I/O
          SARRAY    *sarrayRead()
          SARRAY    *sarrayReadStream()
          l_int32    sarrayWrite()
          l_int32    sarrayWriteStream()
          l_int32    sarrayAppend()

      Directory filenames
          SARRAY    *getNumberedPathnamesInDirectory()
          SARRAY    *getSortedPathnamesInDirectory()
          SARRAY    *convertSortedToNumberedPathnames()
          SARRAY    *getFilenamesInDirectory()

      These functions are important for efficient manipulation
      of string data, and they have found widespread use in
      leptonica.  For example:
         (1) to generate text files: e.g., PostScript and PDF
             wrappers around sets of images
         (2) to parse text files: e.g., extracting prototypes
             from the source to generate allheaders.h
         (3) to generate code for compilation: e.g., the fast
             dwa code for arbitrary structuring elements.

      Comments on usage:

          The user is responsible for correctly disposing of strings
          that have been extracted from sarrays:
            - When you want a string from an Sarray to inspect it, or
              plan to make a copy of it later, use sarrayGetString()
              with copyflag = 0.  In this case, you must neither free
              the string nor put it directly in another array.
              We provide the copyflag constant L_NOCOPY, which is 0,
              for this purpose:
                 str-not-owned = sarrayGetString(sa, index, L_NOCOPY);
              To extract a copy of a string, use:
                 str-owned = sarrayGetString(sa, index, L_COPY);

            - When you want to insert a string that is in one
              array into another array (always leaving the first
              array intact), you have two options:
                 (1) use copyflag = L_COPY to make an immediate copy,
                     which you must then add to the second array
                     by insertion; namely,
                       str-owned = sarrayGetString(sa, index, L_COPY);
                       sarrayAddString(sa, str-owned, L_INSERT);
                 (2) use copyflag = L_NOCOPY to get another handle to
                     the string, in which case you must add
                     a copy of it to the second string array:
                       str-not-owned = sarrayGetString(sa, index, L_NOCOPY);
                       sarrayAddString(sa, str-not-owned, L_COPY).

              In all cases, when you use copyflag = L_COPY to extract
              a string from an array, you must either free it
              or insert it in an array that will be freed later.

"""
    
    try:
        leptonica.getNumberedPathnamesInDirectory.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.getNumberedPathnamesInDirectory.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function getNumberedPathnamesInDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getNumberedPathnamesInDirectory(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       
('l_int32', 'maxnum')       
  getNumberedPathnamesInDirectory()

      Input:  directory name
              substr (<optional> substring filter on filenames; can be NULL)
              numpre (number of characters in name before number)
              numpost (number of characters in name after the number,
                       up to a dot before an extension)
              maxnum (only consider page numbers up to this value)
      Return: sarray of numbered pathnames, or NULL on error

  Notes:
      (1) Returns the full pathnames of the numbered filenames in
          the directory.  The number in the filename is the index
          into the sarray.  For indices for which there are no filenames,
          an empty string ("") is placed into the sarray.
          This makes reading numbered files very simple.  For example,
          the image whose filename includes number N can be retrieved using
               pixReadIndexed(sa, N);
      (2) If @substr is not NULL, only filenames that contain
          the substring can be included.  If @substr is NULL,
          all matching filenames are used.
      (3) If no numbered files are found, it returns an empty sarray,
          with no initialized strings.
      (4) It is assumed that the page number is contained within
          the basename (the filename without directory or extension).
          @numpre is the number of characters in the basename
          preceeding the actual page number; @numpost is the number
          following the page number, up to either the end of the
          basename or a ".", whichever comes first.
      (5) This is useful when all filenames contain numbers that are
          not necessarily consecutive.  0-padding is not required.
      (6) To use a O(n) matching algorithm, the largest page number
          is found and two internal arrays of this size are created.
          This maximum is constrained not to exceed @maxsum,
          to make sure that an unrealistically large number is not
          accidentally used to determine the array sizes.


        """
        args = _convert_params(*args)
        
        return leptonica.getNumberedPathnamesInDirectory(*args)
    
    

    try:
        leptonica.sarrayConcatenate.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayConcatenate.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayConcatenate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayConcatenate(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       
  sarrayConcatenate()

      Input:  sa1  (to be added to)
              sa2  (append to sa1)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Copies of the strings in sarray2 are added to sarray1.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayConcatenate(*args)
    
    

    try:
        leptonica.sarrayCreate.argtypes = [ctypes.c_int32]
        leptonica.sarrayCreate.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreate(*args):
        """
        ('l_int32', 'n')       
  sarrayCreate()

      Input:  size of string ptr array to be alloc'd
              (use 0 for default)
      Return: sarray, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreate(*args)
    
    

    try:
        leptonica.sarrayGetArray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayGetArray.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_char))
    except AttributeError:
        os.stderr.write("Warning - function sarrayGetArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetArray(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', '*pnalloc')       
('l_int32', '*pn')       
  sarrayGetArray()

      Input:  sarray
              &nalloc  (<optional return> number allocated string ptrs)
              &n  (<optional return> number allocated strings)
      Return: ptr to string array, or null on error

  Notes:
      (1) Caution: the returned array is not a copy, so caller
          must not destroy it!


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetArray(*args)
    
    

    try:
        leptonica.sarrayCreateWordsFromString.argtypes = [ctypes.c_void_p]
        leptonica.sarrayCreateWordsFromString.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayCreateWordsFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreateWordsFromString(*args):
        """
        ('const char', '*string')       
  sarrayCreateWordsFromString()

      Input:  string
      Return: sarray, or null on error

  Notes:
      (1) This finds the number of word substrings, creates an sarray
          of this size, and puts copies of each substring into the sarray.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreateWordsFromString(*args)
    
    

    try:
        leptonica.sarrayParseRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayParseRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayParseRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayParseRange(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'start')       
('l_int32', '*pactualstart')       
('l_int32', '*pend')       
('l_int32', '*pnewstart')       
('const char', '*substr')       
('l_int32', 'loc')       
  sarrayParseRange()

      Input:  sa (input sarray)
              start (index to start range search)
             &actualstart (<return> index of actual start; may be > 'start')
             &end (<return> index of end)
             &newstart (<return> index of start of next range)
              substr (substring for matching at beginning of string)
              loc (byte offset within the string for the pattern; use
                   -1 if the location does not matter);
      Return: 0 if valid range found; 1 otherwise

  Notes:
      (1) This finds the range of the next set of strings in SA,
          beginning the search at 'start', that does NOT have
          the substring 'substr' either at the indicated location
          in the string or anywhere in the string.  The input
          variable 'loc' is the specified offset within the string;
          use -1 to indicate 'anywhere in the string'.
      (2) Always check the return value to verify that a valid range
          was found.
      (3) If a valid range is not found, the values of actstart,
          end and newstart are all set to the size of sa.
      (4) If this is the last valid range, newstart returns the value n.
          In use, this should be tested before calling the function.
      (5) Usage example.  To find all the valid ranges in a file
          where the invalid lines begin with two dashes, copy each
          line in the file to a string in an sarray, and do:
             start = 0;
             while (!sarrayParseRange(sa, start, &actstart, &end, &start,
                    "--", 0))
                 fprintf(stderr, "start = %d, end = %d\n", actstart, end);


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayParseRange(*args)
    
    

    try:
        leptonica.sarrayToString.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayToString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function sarrayToString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayToString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'addnlflag')       
  sarrayToString()

      Input:  sarray
              addnlflag (flag: 0 adds nothing to each substring
                               1 adds '\n' to each substring
                               2 adds ' ' to each substring)
      Return: dest string, or null on error

  Notes:
      (1) Concatenates all the strings in the sarray, preserving
          all white space.
      (2) If addnlflag != 0, adds either a '\n' or a ' ' after
          each substring.
      (3) This function was NOT implemented as:
            for (i = 0; i < n; i++)
                     strcat(dest, sarrayGetString(sa, i, L_NOCOPY));
          Do you see why?


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayToString(*args)
    
    

    try:
        leptonica.convertSortedToNumberedPathnames.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertSortedToNumberedPathnames.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function convertSortedToNumberedPathnames not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertSortedToNumberedPathnames(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       
('l_int32', 'maxnum')       
  convertSortedToNumberedPathnames()

      Input:  sorted pathnames (including zero-padded integers)
              numpre (number of characters in name before number)
              numpost (number of characters in name after the number,
                       up to a dot before an extension)
              maxnum (only consider page numbers up to this value)
      Return: sarray of numbered pathnames, or NULL on error

  Notes:
      (1) Typically, numpre = numpost = 0; e.g., when the filename
          just has a number followed by an optional extension.


        """
        args = _convert_params(*args)
        
        return leptonica.convertSortedToNumberedPathnames(*args)
    
    

    try:
        leptonica.sarraySort.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarraySort.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarraySort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySort(*args):
        """
        ('SARRAY', '*saout')       
('SARRAY', '*sain')       
('l_int32', 'sortorder')       
  sarraySort()

      Input:  saout (output sarray; can be NULL or equal to sain)
              sain (input sarray)
              sortorder (L_SORT_INCREASING or L_SORT_DECREASING)
      Return: saout (output sarray, sorted by ascii value), or null on error

  Notes:
      (1) Set saout = sain for in-place; otherwise, set naout = NULL.
      (2) Shell sort, modified from K&R, 2nd edition, p.62.
          Slow but simple O(n logn) sort.


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySort(*args)
    
    

    try:
        leptonica.sarraySortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarraySortByIndex.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarraySortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySortByIndex(*args):
        """
        ('SARRAY', '*sain')       
('NUMA', '*naindex')       
  sarraySortByIndex()

      Input:  sain
              naindex (na that maps from the new sarray to the input sarray)
      Return: saout (sorted), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySortByIndex(*args)
    
    

    try:
        leptonica.sarrayChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayChangeRefcount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayChangeRefcount(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'delta')       
  sarrayChangeRefCount()

      Input:  sarray
              delta (change to be applied)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayChangeRefcount(*args)
    
    

    try:
        leptonica.sarrayCopy.argtypes = [ctypes.c_void_p]
        leptonica.sarrayCopy.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCopy(*args):
        """
        ('SARRAY', '*sa')       
  sarrayCopy()

      Input:  sarray
      Return: copy of sarray, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCopy(*args)
    
    

    try:
        leptonica.sarrayClear.argtypes = [ctypes.c_void_p]
        leptonica.sarrayClear.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayClear(*args):
        """
        ('SARRAY', '*sa')       
  sarrayClear()

      Input:  sarray
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayClear(*args)
    
    

    try:
        leptonica.sarrayClone.argtypes = [ctypes.c_void_p]
        leptonica.sarrayClone.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayClone(*args):
        """
        ('SARRAY', '*sa')       
  sarrayClone()

      Input:  sarray
      Return: ptr to same sarray, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayClone(*args)
    
    

    try:
        leptonica.sarrayCreateLinesFromString.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayCreateLinesFromString.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayCreateLinesFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreateLinesFromString(*args):
        """
        ('char', '*string')       
('l_int32', 'blankflag')       
  sarrayCreateLinesFromString()

      Input:  string
              blankflag  (0 to exclude blank lines; 1 to include)
      Return: sarray, or null on error

  Notes:
      (1) This finds the number of line substrings, each of which
          ends with a newline, and puts a copy of each substring
          in a new sarray.
      (2) The newline characters are removed from each substring.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreateLinesFromString(*args)
    
    

    try:
        leptonica.sarrayWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayWriteStream(*args):
        """
        ('FILE', '*fp')       
('SARRAY', '*sa')       
  sarrayWriteStream()

      Input:  stream
              sarray
      Returns 0 if OK; 1 on error

  Notes:
      (1) This appends a '\n' to each string, which is stripped
          off by sarrayReadStream().


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayWriteStream(*args)
    
    

    try:
        leptonica.sarrayRemoveString.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayRemoveString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function sarrayRemoveString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayRemoveString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       
  sarrayRemoveString()

      Input:  sarray
              index (of string within sarray)
      Return: removed string, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayRemoveString(*args)
    
    

    try:
        leptonica.sarrayAppendRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarrayAppendRange.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayAppendRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayAppendRange(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       
('l_int32', 'start')       
('l_int32', 'end')       
  sarrayAppendRange()

      Input:  sa1  (to be added to)
              sa2  (append specified range of strings in sa2 to sa1)
              start (index of first string of sa2 to append)
              end (index of last string of sa2 to append; -1 to end of array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Copies of the strings in sarray2 are added to sarray1.
      (2) The [start ... end] range is truncated if necessary.
      (3) Use end == -1 to append to the end of sa2.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayAppendRange(*args)
    
    

    try:
        leptonica.sarraySelectBySubstring.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarraySelectBySubstring.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarraySelectBySubstring not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySelectBySubstring(*args):
        """
        ('SARRAY', '*sain')       
('const char', '*substr')       
  sarraySelectBySubstring()

      Input:  sain (input sarray)
              substr (<optional> substring for matching; can be NULL)
      Return: saout (output sarray, filtered with substring) or null on error

  Notes:
      (1) This selects all strings in sain that have substr as a substring.
          Note that we can't use strncmp() because we're looking for
          a match to the substring anywhere within each filename.
      (2) If substr == NULL, returns a copy of the sarray.


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySelectBySubstring(*args)
    
    

    try:
        leptonica.sarrayReadStream.argtypes = [ctypes.c_void_p]
        leptonica.sarrayReadStream.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayReadStream(*args):
        """
        ('FILE', '*fp')       
  sarrayReadStream()

      Input:  stream
      Return: sarray, or null on error

  Notes:
      (1) We store the size of each string along with the string.
      (2) This allows a string to have embedded newlines.  By reading
          the entire string, as determined by its size, we are
          not affected by any number of embedded newlines.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayReadStream(*args)
    
    

    try:
        leptonica.sarrayGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.sarrayGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetRefcount(*args):
        """
        ('SARRAY', '*sa')       
  sarrayGetRefCount()

      Input:  sarray
      Return: refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetRefcount(*args)
    
    

    try:
        leptonica.sarrayRead.argtypes = [ctypes.c_void_p]
        leptonica.sarrayRead.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayRead(*args):
        """
        ('const char', '*filename')       
  sarrayRead()

      Input:  filename
      Return: sarray, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayRead(*args)
    
    

    try:
        leptonica.sarrayReplaceString.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayReplaceString.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayReplaceString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayReplaceString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       
('char', '*newstr')       
('l_int32', 'copyflag')       
  sarrayReplaceString()

      Input:  sarray
              index (of string within sarray to be replaced)
              newstr (string to replace existing one)
              copyflag (L_INSERT, L_COPY)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This destroys an existing string and replaces it with
          the new string or a copy of it.
      (2) By design, an sarray is always compacted, so there are
          never any holes (null ptrs) in the ptr array up to the
          current count.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayReplaceString(*args)
    
    

    try:
        leptonica.getFilenamesInDirectory.argtypes = [ctypes.c_void_p]
        leptonica.getFilenamesInDirectory.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function getFilenamesInDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getFilenamesInDirectory(*args):
        """
        ('const char', '*dirname')       
  getFilenamesInDirectory()

      Input:  directory name
      Return: sarray of file names, or NULL on error

  Notes:
      (1) The versions compiled under unix and cygwin use the POSIX C
          library commands for handling directories.  For windows,
          there is a separate implementation.
      (2) It returns an array of filename tails; i.e., only the part of
          the path after the last slash.
      (3) Use of the d_type field of dirent is not portable:
          "According to POSIX, the dirent structure contains a field
          char d_name[] of unspecified size, with at most NAME_MAX
          characters preceding the terminating null character.  Use
          of other fields will harm the portability of your programs."
      (4) As a consequence of (3), we note several things:
           - MINGW doesn't have a d_type member.
           - Older versions of gcc (e.g., 2.95.3) return DT_UNKNOWN
             for d_type from all files.
          On these systems, this function will return directories
          (except for '.' and '..', which are eliminated using
          the d_name field).


        """
        args = _convert_params(*args)
        
        return leptonica.getFilenamesInDirectory(*args)
    
    

    try:
        leptonica.sarrayPadToSameSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayPadToSameSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayPadToSameSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayPadToSameSize(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       
('char', '*padstring')       
  sarrayPadToSameSize()

      Input:  sa1, sa2
              padstring
      Return: 0 if OK, 1 on error

  Notes:
      (1) If two sarrays have different size, this adds enough
          instances of @padstring to the smaller so that they are
          the same size.  It is useful when two or more sarrays
          are being sequenced in parallel, and it is necessary to
          find a valid string at each index.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayPadToSameSize(*args)
    
    

    try:
        leptonica.getSortedPathnamesInDirectory.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.getSortedPathnamesInDirectory.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function getSortedPathnamesInDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getSortedPathnamesInDirectory(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'first')       
('l_int32', 'nfiles')       
  getSortedPathnamesInDirectory()

      Input:  directory name
              substr (<optional> substring filter on filenames; can be NULL)
              first (0-based)
              nfiles (use 0 for all to the end)
      Return: sarray of sorted pathnames, or NULL on error

  Notes:
      (1) Use @substr to filter filenames in the directory.  If
          @substr == NULL, this takes all files.
      (2) The files in the directory, after optional filtering by
          the substring, are lexically sorted in increasing order.
          Use @first and @nfiles to select a contiguous set of files.
      (3) The full pathnames are returned for the requested sequence.
          If no files are found after filtering, returns an empty sarray.


        """
        args = _convert_params(*args)
        
        return leptonica.getSortedPathnamesInDirectory(*args)
    
    

    try:
        leptonica.sarrayGetString.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarrayGetString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function sarrayGetString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       
('l_int32', 'copyflag')       
  sarrayGetString()

      Input:  sarray
              index   (to the index-th string)
              copyflag  (L_NOCOPY or L_COPY)
      Return: string, or null on error

  Notes:
      (1) Legacy usage decrees that we always use 0 to get the
          pointer to the string itself, and 1 to get a copy of
          the string.
      (2) See usage comments at the top of this file.
      (3) To get a pointer to the string itself, use for copyflag:
             L_NOCOPY or 0 or FALSE
          To get a copy of the string, use for copyflag:
             L_COPY or 1 or TRUE
          The const values of L_NOCOPY and L_COPY are guaranteed not
          to change.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetString(*args)
    
    

    try:
        leptonica.sarraySelectByRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarraySelectByRange.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarraySelectByRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySelectByRange(*args):
        """
        ('SARRAY', '*sain')       
('l_int32', 'first')       
('l_int32', 'last')       
  sarraySelectByRange()

      Input:  sain (input sarray)
              first (index of first string to be selected)
              last (index of last string to be selected; use 0 to go to the
                    end of the sarray)
      Return: saout (output sarray), or null on error

  Notes:
      (1) This makes @saout consisting of copies of all strings in @sain
          in the index set [first ... last].  Use @last == 0 to get all
          strings from @first to the last string in the sarray.


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySelectByRange(*args)
    
    

    try:
        leptonica.sarrayGetCount.argtypes = [ctypes.c_void_p]
        leptonica.sarrayGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetCount(*args):
        """
        ('SARRAY', '*sa')       
  sarrayGetCount()

      Input:  sarray
      Return: count, or 0 if no strings or on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetCount(*args)
    
    

    try:
        leptonica.sarrayWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayWrite(*args):
        """
        ('const char', '*filename')       
('SARRAY', '*sa')       
  sarrayWrite()

      Input:  filename
              sarray
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayWrite(*args)
    
    

    try:
        leptonica.sarrayToStringRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarrayToStringRange.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function sarrayToStringRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayToStringRange(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'first')       
('l_int32', 'nstrings')       
('l_int32', 'addnlflag')       
  sarrayToStringRange()

      Input: sarray
             first  (index of first string to use; starts with 0)
             nstrings (number of strings to append into the result; use
                       0 to append to the end of the sarray)
             addnlflag (flag: 0 adds nothing to each substring
                              1 adds '\n' to each substring
                              2 adds ' ' to each substring)
      Return: dest string, or null on error

  Notes:
      (1) Concatenates the specified strings inthe sarray, preserving
          all white space.
      (2) If addnlflag != 0, adds either a '\n' or a ' ' after
          each substring.
      (3) If the sarray is empty, this returns a string with just
          the character corresponding to @addnlflag.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayToStringRange(*args)
    
    

    try:
        leptonica.stringCompareLexical.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringCompareLexical.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function stringCompareLexical not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCompareLexical(*args):
        """
        ('const char', '*str1')       
('const char', '*str2')       
  stringCompareLexical()

      Input:  str1
              str2
      Return: 1 if str1 > str2 (lexically); 0 otherwise

  Notes:
      (1) If the lexical values are identical, return a 0, to
          indicate that no swapping is required to sort the strings.


        """
        args = _convert_params(*args)
        
        return leptonica.stringCompareLexical(*args)
    
    

    try:
        leptonica.sarrayConvertWordsToLines.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayConvertWordsToLines.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayConvertWordsToLines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayConvertWordsToLines(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'linesize')       
  sarrayConvertWordsToLines()

      Input:  sa  (sa of individual words)
              linesize  (max num of chars in each line)
      Return: saout (sa of formatted lines), or null on error

  This is useful for re-typesetting text to a specific maximum
  line length.  The individual words in the input sarray
  are concatenated into textlines.  An input word string of zero
  length is taken to be a paragraph separator.  Each time
  such a string is found, the current line is ended and
  a new line is also produced that contains just the
  string of zero length ("").  When the output sarray
  of lines is eventually converted to a string with newlines
  (typically) appended to each line string, the empty
  strings are just converted to newlines, producing the visible
  paragraph separation.

  What happens when a word is larger than linesize?
  We write it out as a single line anyway!  Words preceding
  or following this long word are placed on lines preceding
  or following the line with the long word.  Why this choice?
  Long "words" found in text documents are typically URLs, and
  it's often desirable not to put newlines in the middle of a URL.
  The text display program (e.g., text editor) will typically
  wrap the long "word" to fit in the window.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayConvertWordsToLines(*args)
    
    

    try:
        leptonica.sarrayAppend.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayAppend.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayAppend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayAppend(*args):
        """
        ('const char', '*filename')       
('SARRAY', '*sa')       
  sarrayAppend()

      Input:  filename
              sarray
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayAppend(*args)
    
    

    try:
        leptonica.sarrayCreateInitialized.argtypes = [ctypes.c_int32, ctypes.c_void_p]
        leptonica.sarrayCreateInitialized.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sarrayCreateInitialized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreateInitialized(*args):
        """
        ('l_int32', 'n')       
('char', '*initstr')       
  sarrayCreateInitialized()

      Input:  n (size of string ptr array to be alloc'd)
              initstr (string to be initialized on the full array)
      Return: sarray, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreateInitialized(*args)
    
    

    try:
        leptonica.sarrayAddString.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayAddString.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sarrayAddString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayAddString(*args):
        """
        ('SARRAY', '*sa')       
('char', '*string')       
('l_int32', 'copyflag')       
  sarrayAddString()

      Input:  sarray
              string  (string to be added)
              copyflag (L_INSERT, L_COPY)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Legacy usage decrees that we always use 0 to insert a string
          directly and 1 to insert a copy of the string.  The
          enums for L_INSERT and L_COPY agree with this convention,
          and will not change in the future.
      (2) See usage comments at the top of this file.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayAddString(*args)
    
    

    try:
        leptonica.sarrayDestroy.argtypes = [ctypes.c_void_p]
        leptonica.sarrayDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function sarrayDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayDestroy(*args):
        """
        ('SARRAY', '**psa')       
  sarrayDestroy()

      Input:  &sarray <to be nulled>
      Return: void

  Notes:
      (1) Decrements the ref count and, if 0, destroys the sarray.
      (2) Always nulls the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayDestroy(*args)
    




class graymorph(object):
    """  graymorph.c

      Top-level binary morphological operations (van Herk / Gil-Werman)
            PIX     *pixErodeGray()
            PIX     *pixDilateGray()
            PIX     *pixOpenGray()
            PIX     *pixCloseGray()

      Special operations for 1x3, 3x1 and 3x3 Sels  (direct)
            PIX     *pixErodeGray3()
            PIX     *pixDilateGray3()
            PIX     *pixOpenGray3()
            PIX     *pixCloseGray3()


      Method: Algorithm by van Herk and Gil and Werman, 1992

      Measured speed of the vH/G-W implementation is about 1 output
      pixel per 120 PIII clock cycles, for a horizontal or vertical
      erosion or dilation.  The computation time doubles for opening
      or closing, or for a square SE, as expected, and is independent
      of the size of the SE.

      A faster implementation can be made directly for brick Sels
      of maximum size 3.  We unroll the computation for sets of 8 bytes.
      It needs to be called explicitly; the general functions do not
      default for the size 3 brick Sels.

"""
    
    try:
        leptonica.pixCloseGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseGray()

      Input:  pixs
              hsize  (of Sel; must be odd; origin implicitly in center)
              vsize  (ditto)
      Return: pixd

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseGray(*args)
    
    

    try:
        leptonica.pixDilateGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateGray3.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateGray3()

      Input:  pixs (8 bpp, not cmapped)
              hsize  (1 or 3)
              vsize  (1 or 3)
      Return: pixd, or null on error

  Notes:
      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
      (2) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateGray3(*args)
    
    

    try:
        leptonica.pixOpenGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenGray()

      Input:  pixs
              hsize  (of Sel; must be odd; origin implicitly in center)
              vsize  (ditto)
      Return: pixd

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenGray(*args)
    
    

    try:
        leptonica.pixDilateGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDilateGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixDilateGray()

      Input:  pixs
              hsize  (of Sel; must be odd; origin implicitly in center)
              vsize  (ditto)
      Return: pixd

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateGray(*args)
    
    

    try:
        leptonica.pixErodeGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeGray3.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeGray3()

      Input:  pixs (8 bpp, not cmapped)
              hsize  (1 or 3)
              vsize  (1 or 3)
      Return: pixd, or null on error

  Notes:
      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
      (2) If hsize = vsize = 1, just returns a copy.
      (3) It would be nice not to add a border, but it is required
          if we want the same results as from the general case.
          We add 4 bytes on the left to speed up the copying, and
          8 bytes at the right and bottom to allow unrolling of
          the computation of 8 pixels.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeGray3(*args)
    
    

    try:
        leptonica.pixOpenGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenGray3.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOpenGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixOpenGray3()

      Input:  pixs (8 bpp, not cmapped)
              hsize  (1 or 3)
              vsize  (1 or 3)
      Return: pixd, or null on error

  Notes:
      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
      (2) If hsize = vsize = 1, just returns a copy.
      (3) It would be nice not to add a border, but it is required
          to get the same results as for the general case.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenGray3(*args)
    
    

    try:
        leptonica.pixCloseGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseGray3.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixCloseGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixCloseGray3()

      Input:  pixs (8 bpp, not cmapped)
              hsize  (1 or 3)
              vsize  (1 or 3)
      Return: pixd, or null on error

  Notes:
      (1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
      (2) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseGray3(*args)
    
    

    try:
        leptonica.pixErodeGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixErodeGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  pixErodeGray()

      Input:  pixs
              hsize  (of Sel; must be odd; origin implicitly in center)
              vsize  (ditto)
      Return: pixd

  Notes:
      (1) Sel is a brick with all elements being hits
      (2) If hsize = vsize = 1, just returns a copy.


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeGray(*args)
    




class tiffio(object):
    """  tiffio.c

     Reading tiff:
             PIX       *pixReadTiff()    [ special top level ]
             PIX       *pixReadStreamTiff()
      static PIX       *pixReadFromTiffStream()

     Writing tiff:
             l_int32    pixWriteTiff()   [ special top level ]
             l_int32    pixWriteTiffCustom()   [ special top level ]
             l_int32    pixWriteStreamTiff()
      static l_int32    pixWriteToTiffStream()
      static l_int32    writeCustomTiffTags()

     Reading and writing multipage tiff
             PIXA       pixaReadMultipageTiff()
             l_int32    writeMultipageTiff()  [ special top level ]
             l_int32    writeMultipageTiffSA()

     Information about tiff file
             l_int32    fprintTiffInfo()
             l_int32    tiffGetCount()
             l_int32    getTiffResolution()
      static l_int32    getTiffStreamResolution()
             l_int32    readHeaderTiff()
             l_int32    freadHeaderTiff()
             l_int32    readHeaderMemTiff()
      static l_int32    tiffReadHeaderTiff()
             l_int32    findTiffCompression()
      static l_int32    getTiffCompressedFormat()

     Extraction of tiff g4 data:
             l_int32    extractG4DataFromFile()

     Open tiff stream from file stream
      static TIFF      *fopenTiff()

     Wrapper for TIFFOpen:
      static TIFF      *openTiff()

     Memory I/O: reading memory --> pix and writing pix --> memory
             [10 static helper functions]
             l_int32    pixReadMemTiff();
             l_int32    pixWriteMemTiff();
             l_int32    pixWriteMemTiffCustom();

   Note:  You should be using version 3.7.4 of libtiff to be certain
          that all the necessary functions are included.

"""
    
    try:
        leptonica.pixWriteMemTiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteMemTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemTiff(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'comptype')       
  pixWriteMemTiff()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
                        IFF_TIFF_G3, IFF_TIFF_G4,
                        IFF_TIFF_LZW, IFF_TIFF_ZIP)
      Return: 0 if OK, 1 on error

  Usage:
      (1) See pixWriteTiff().  This version writes to
          memory instead of to a file.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemTiff(*args)
    
    

    try:
        leptonica.pixWriteTiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixWriteTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteTiff(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('const char', '*modestring')       
  pixWriteTiff()

      Input:  filename (to write to)
              pix
              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
                        IFF_TIFF_G3, IFF_TIFF_G4,
                        IFF_TIFF_LZW, IFF_TIFF_ZIP)
              modestring ("a" or "w")
      Return: 0 if OK, 1 on error

  Notes:
      (1) For multi-page tiff, write the first pix with mode "w" and
          all subsequent pix with mode "a".


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteTiff(*args)
    
    

    try:
        leptonica.findTiffCompression.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findTiffCompression.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function findTiffCompression not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findTiffCompression(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pcomptype')       
  findTiffCompression()

      Input:  stream (must be rewound to BOF)
              &comptype (<return> compression type)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The returned compression type is that defined in
          the enum in imageio.h.  It is not the tiff flag value.
      (2) The compression type is initialized to IFF_UNKNOWN.
          If it is not one of the specified types, the returned
          type is IFF_TIFF, which indicates no compression.
      (3) When this function is called, the stream must be at BOF.
          If the opened stream is to be used again to read the
          file, it must be rewound to BOF after calling this function.


        """
        args = _convert_params(*args)
        
        return leptonica.findTiffCompression(*args)
    
    

    try:
        leptonica.pixReadStreamTiff.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadStreamTiff.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamTiff(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'n')       
  pixReadStreamTiff()

      Input:  stream
              n (page number: 0 based)
      Return: pix, or null on error (e.g., if the page number is invalid)


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamTiff(*args)
    
    

    try:
        leptonica.pixWriteTiffCustom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteTiffCustom.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteTiffCustom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteTiffCustom(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('const char', '*modestring')       
('NUMA', '*natags')       
('SARRAY', '*savals')       
('SARRAY', '*satypes')       
('NUMA', '*nasizes')       
  pixWriteTiffCustom()

      Input:  filename (to write to)
              pix
              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
                        IFF_TIFF_G3, IFF_TIFF_G4)
                        IFF_TIFF_LZW, IFF_TIFF_ZIP)
              modestring ("a" or "w")
              natags (<optional> NUMA of custom tiff tags)
              savals (<optional> SARRAY of values)
              satypes (<optional> SARRAY of types)
              nasizes (<optional> NUMA of sizes)
      Return: 0 if OK, 1 on error

  Usage:
      (1) This writes a page image to a tiff file, with optional
          extra tags defined in tiff.h
      (2) For multi-page tiff, write the first pix with mode "w" and
          all subsequent pix with mode "a".
      (3) For the custom tiff tags:
          (a) The three arrays {natags, savals, satypes} must all be
              either NULL or defined and of equal size.
          (b) If they are defined, the tags are an array of integers,
              the vals are an array of values in string format, and
              the types are an array of types in string format.
          (c) All valid tags are definined in tiff.h.
          (d) The types allowed are the set of strings:
                "char*"
                "l_uint8*"
                "l_uint16"
                "l_uint32"
                "l_int32"
                "l_float64"
                "l_uint16-l_uint16" (note the dash; use it between the
                                    two l_uint16 vals in the val string)
              Of these, "char*" and "l_uint16" are the most commonly used.
          (e) The last array, nasizes, is also optional.  It is for
              tags that take an array of bytes for a value, a number of
              elements in the array, and a type that is either "char*"
              or "l_uint8*" (probably either will work).
              Use NULL if there are no such tags.
          (f) VERY IMPORTANT: if there are any tags that require the
              extra size value, stored in nasizes, they must be
              written first!


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteTiffCustom(*args)
    
    

    try:
        leptonica.freadHeaderTiff.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function freadHeaderTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderTiff(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'n')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*pres')       
('l_int32', '*pcmap')       
('l_int32', '*pformat')       
  freadHeaderTiff()

      Input:  stream
              n (page image number: 0-based)
              &width (<return>)
              &height (<return>)
              &bps (<return> bits per sample -- 1, 2, 4 or 8)
              &spp (<return>; samples per pixel -- 1 or 3)
              &res (<optional return>; resolution in x dir; NULL to ignore)
              &cmap (<optional return>; colormap exists; input NULL to ignore)
              &format (<optional return>; tiff format; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If there is a colormap, cmap is returned as 1; else 0.
      (2) If @n is equal to or greater than the number of images, returns 1.


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderTiff(*args)
    
    

    try:
        leptonica.pixWriteMemTiffCustom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemTiffCustom.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemTiffCustom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemTiffCustom(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('NUMA', '*natags')       
('SARRAY', '*savals')       
('SARRAY', '*satypes')       
('NUMA', '*nasizes')       
  pixWriteMemTiffCustom()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
                        IFF_TIFF_G3, IFF_TIFF_G4,
                        IFF_TIFF_LZW, IFF_TIFF_ZIP)
              natags (<optional> NUMA of custom tiff tags)
              savals (<optional> SARRAY of values)
              satypes (<optional> SARRAY of types)
              nasizes (<optional> NUMA of sizes)
      Return: 0 if OK, 1 on error

  Usage:
      (1) See pixWriteTiffCustom().  This version writes to
          memory instead of to a file.
      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemTiffCustom(*args)
    
    

    try:
        leptonica.readHeaderTiff.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderTiff(*args):
        """
        ('const char', '*filename')       
('l_int32', 'n')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*pres')       
('l_int32', '*pcmap')       
('l_int32', '*pformat')       
  readHeaderTiff()

      Input:  filename
              n (page image number: 0-based)
              &width (<return>)
              &height (<return>)
              &bps (<return> bits per sample -- 1, 2, 4 or 8)
              &spp (<return>; samples per pixel -- 1 or 3)
              &res (<optional return>; resolution in x dir; NULL to ignore)
              &cmap (<optional return>; colormap exists; input NULL to ignore)
              &format (<optional return>; tiff format; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) If there is a colormap, cmap is returned as 1; else 0.
      (2) If @n is equal to or greater than the number of images, returns 1.


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderTiff(*args)
    
    

    try:
        leptonica.extractG4DataFromFile.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.extractG4DataFromFile.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function extractG4DataFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractG4DataFromFile(*args):
        """
        ('const char', '*filein')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pminisblack')       
  extractG4DataFromFile()

      Input:  filein
              &data (<return> binary data of ccitt g4 encoded stream)
              &nbytes (<return> size of binary data)
              &w (<return optional> image width)
              &h (<return optional> image height)
              &minisblack (<return optional> boolean)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.extractG4DataFromFile(*args)
    
    

    try:
        leptonica.pixReadTiff.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadTiff.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadTiff(*args):
        """
        ('const char', '*filename')       
('l_int32', 'n')       
  pixReadTiff()

      Input:  filename
              page number (0 based)
      Return: pix, or null on error

  Notes:
      (1) This is a version of pixRead(), specialized for tiff
          files, that allows specification of the page to be returned


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadTiff(*args)
    
    

    try:
        leptonica.readHeaderMemTiff.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function readHeaderMemTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemTiff(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
('l_int32', 'n')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*pres')       
('l_int32', '*pcmap')       
('l_int32', '*pformat')       
  readHeaderMemTiff()

      Input:  cdata (const; tiff-encoded)
              size (size of data)
              n (page image number: 0-based)
              &width (<return>)
              &height (<return>)
              &bps (<return> bits per sample -- 1, 2, 4 or 8)
              &spp (<return>; samples per pixel -- 1 or 3)
              &res (<optional return>; resolution in x dir; NULL to ignore)
              &cmap (<optional return>; colormap exists; input NULL to ignore)
              &format (<optional return>; tiff format; input NULL to ignore)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemTiff(*args)
    
    

    try:
        leptonica.pixReadMemTiff.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.pixReadMemTiff.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemTiff(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
('l_int32', 'n')       
  pixReadMemTiff()

      Input:  data (const; tiff-encoded)
              datasize (size of data)
              n (page image number: 0-based)
      Return: pix, or null on error

  Notes:
      (1) This is a version of pixReadTiff(), where the data is read
          from a memory buffer and uncompressed.
      (2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemTiff(*args)
    
    

    try:
        leptonica.pixWriteStreamTiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteStreamTiff.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamTiff(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'comptype')       
  pixWriteStreamTiff()

      Input:  stream (opened for append or write)
              pix
              comptype (IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
                        IFF_TIFF_G3, IFF_TIFF_G4,
                        IFF_TIFF_LZW, IFF_TIFF_ZIP)
      Return: 0 if OK, 1 on error

  Notes:
      (1) For images with bpp > 1, this resets the comptype, if
          necessary, to write uncompressed data.
      (2) G3 and G4 are only defined for 1 bpp.
      (3) We only allow PACKBITS for bpp = 1, because for bpp > 1
          it typically expands images that are not synthetically generated.
      (4) G4 compression is typically about twice as good as G3.
          G4 is excellent for binary compression of text/line-art,
          but terrible for halftones and dithered patterns.  (In
          fact, G4 on halftones can give a file that is larger
          than uncompressed!)  If a binary image has dithered
          regions, it is usually better to compress with png.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamTiff(*args)
    




class colorcontent(object):
    """  colorcontent.c

      Builds an image of the color content, on a per-pixel basis,
      as a measure of the amount of divergence of each color
      component (R,G,B) from gray.
         l_int32    pixColorContent()

      Finds the 'amount' of color in an image, on a per-pixel basis,
      as a measure of the difference of the pixel color from gray.
         PIX       *pixColorMagnitude()

      Generates a mask over pixels that have sufficient color and
      are not too close to gray pixels.
         PIX       *pixMaskOverColorPixels()

      Finds the fraction of pixels with "color" that are not close to black
         l_int32    pixColorFraction()

      Finds the number of perceptually significant gray intensities
      in a grayscale image.
         l_int32    pixNumSignificantGrayColors()

      Identifies images where color quantization will cause posterization
      due to the existence of many colors in low-gradient regions.
         l_int32    pixColorsForQuantization()

      Finds the number of unique colors in an image
         l_int32    pixNumColors()

      Find the most "populated" colors in the image (and quantize)
         l_int32    pixGetMostPopulatedColors()
         PIX       *pixSimpleColorQuantize()

      Constructs a color histogram based on rgb indices
         NUMA      *pixGetRGBHistogram()
         l_int32    makeRGBIndexTables()
         l_int32    getRGBFromIndex()

      Identify images that have highlight (red) color
         l_int32    pixHasHighlightRed()

  Color is tricky.  If we consider gray (r = g = b) to have no color
  content, how should we define the color content in each component
  of an arbitrary pixel, as well as the overall color magnitude?

  I can think of three ways to define the color content in each component:

  (1) Linear.  For each component, take the difference from the average
      of all three.
  (2) Linear.  For each component, take the difference from the average
      of the other two.
  (3) Nonlinear.  For each component, take the minimum of the differences
      from the other two.

  How might one choose from among these?  Consider two different situations:
  (a) r = g = 0, b = 255            {255}   /255/
  (b) r = 0, g = 127, b = 255       {191}   /128/
  How much g is in each of these?  The three methods above give:
  (a)  1: 85   2: 127   3: 0        [85]
  (b)  1: 0    2: 0     3: 127      [0]
  How much b is in each of these?
  (a)  1: 170  2: 255   3: 255      [255]
  (b)  1: 127  2: 191   3: 127      [191]
  The number I'd "like" to give is in [].  (Please don't ask why, it's
  just a feeling.

  So my preferences seem to be somewhere between (1) and (2).
  (3) is just too "decisive!"  Let's pick (2).

  We also allow compensation for white imbalance.  For each
  component, we do a linear TRC (gamma = 1.0), where the black
  point remains at 0 and the white point is given by the input
  parameter.  This is equivalent to doing a global remapping,
  as with pixGlobalNormRGB(), followed by color content (or magnitude)
  computation, but without the overhead of first creating the
  white point normalized image.

  Another useful property is the overall color magnitude in the pixel.
  For this there are again several choices, such as:
      (a) rms deviation from the mean
      (b) the average L1 deviation from the mean
      (c) the maximum (over components) of one of the color
          content measures given above.

  For now, we will choose two of the methods in (c):
     L_MAX_DIFF_FROM_AVERAGE_2
        Define the color magnitude as the maximum over components
        of the difference between the component value and the
        average of the other two.  It is easy to show that
        this is equivalent to selecting the two component values
        that are closest to each other, averaging them, and
        using the distance from that average to the third component.
        For (a) and (b) above, this value is in {..}.
    L_MAX_MIN_DIFF_FROM_2
        Define the color magnitude as the maximum over components
        of the minimum difference between the component value and the
        other two values.  It is easy to show that this is equivalent
        to selecting the intermediate value of the three differences
        between the three components.  For (a) and (b) above,
        this value is in /../.

"""
    
    try:
        leptonica.pixColorFraction.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixColorFraction.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorFraction(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       
('l_int32', 'factor')       
('l_float32', '*ppixfract')       
('l_float32', '*pcolorfract')       
  pixColorFraction()

      Input:  pixs  (32 bpp rgb)
              darkthresh (threshold near black; if the lightest component
                          is below this, the pixel is not considered in
                          the statistics; typ. 20)
              lightthresh (threshold near white; if the darkest component
                           is above this, the pixel is not considered in
                           the statistics; typ. 244)
              diffthresh (thresh for the maximum difference between
                          component value; below this the pixel is not
                          considered to have sufficient color)
              factor (subsampling factor)
              &pixfract (<return> fraction of pixels in intermediate
                         brightness range that were considered
                         for color content)
              &colorfract (<return> fraction of pixels that meet the
                           criterion for sufficient color; 0.0 on error)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function is asking the question: to what extent does the
          image appear to have color?   The amount of color a pixel
          appears to have depends on both the deviation of the
          individual components from their average and on the average
          intensity itself.  For example, the color will be much more
          obvious with a small deviation from white than the same
          deviation from black.
      (2) Any pixel that meets these three tests is considered a
          colorful pixel:
            (a) the lightest component must equal or exceed @darkthresh
            (b) the darkest component must not exceed @lightthresh
            (c) the max difference between components must equal or
                exceed @diffthresh.
      (3) The dark pixels are removed from consideration because
          they don't appear to have color.
      (4) The very lightest pixels are removed because if an image
          has a lot of "white", the color fraction will be artificially
          low, even if all the other pixels are colorful.
      (5) If pixfract is very small, there are few pixels that are neither
          black nor white.  If colorfract is very small, the pixels
          that are neither black nor white have very little color
          content.  The product 'pixfract * colorfract' gives the
          fraction of pixels with significant color content.
      (6) One use of this function is as a preprocessing step for median
          cut quantization (colorquant2.c), which does a very poor job
          splitting the color space into rectangular volume elements when
          all the pixels are near the diagonal of the color cube.  For
          octree quantization of an image with only gray values, the
          2^(level) octcubes on the diagonal are the only ones
          that can be occupied.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorFraction(*args)
    
    

    try:
        leptonica.pixColorsForQuantization.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixColorsForQuantization.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorsForQuantization not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorsForQuantization(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('l_int32', '*pncolors')       
('l_int32', '*piscolor')       
('l_int32', 'debug')       
  pixColorsForQuantization()
      Input:  pixs (8 bpp gray or 32 bpp rgb; with or without colormap)
              thresh (binary threshold on edge gradient; 0 for default)
              &ncolors (<return> the number of colors found)
              &iscolor (<optional return> 1 if significant color is found;
                        0 otherwise.  If pixs is 8 bpp, and does not have
                        a colormap with color entries, this is 0)
              debug (1 to output masked image that is tested for colors;
                     0 otherwise)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) This function finds a measure of the number of colors that are
          found in low-gradient regions of an image.  By its
          magnitude relative to some threshold (not specified in
          this function), it gives a good indication of whether
          quantization will generate posterization.   This number
          is larger for images with regions of slowly varying
          intensity (if 8 bpp) or color (if rgb). Such images, if
          quantized, may require dithering to avoid posterization,
          and lossless compression is then expected to be poor.
      (2) If pixs has a colormap, the number of colors returned is
          the number in the colormap.
      (3) It is recommended that document images be reduced to a width
          of 800 pixels before applying this function.  Then it can
          be expected that color detection will be fairly accurate
          and the number of colors will reflect both the content and
          the type of compression to be used.  For less than 15 colors,
          there is unlikely to be a halftone image, and lossless
          quantization should give both a good visual result and
          better compression.
      (4) When using the default threshold on the gradient (15),
          images (both gray and rgb) where ncolors is greater than
          about 15 will compress poorly with either lossless
          compression or dithered quantization, and they may be
          posterized with non-dithered quantization.
      (5) For grayscale images, or images without significant color,
          this returns the number of significant gray levels in
          the low-gradient regions.  The actual number of gray levels
          can be large due to jpeg compression noise in the background.
      (6) Similarly, for color images, the actual number of different
          (r,g,b) colors in the low-gradient regions (rather than the
          number of occupied level 4 octcubes) can be quite large, e.g.,
          due to jpeg compression noise, even for regions that appear
          to be of a single color.  By quantizing to level 4 octcubes,
          most of these superfluous colors are removed from the counting.
      (7) The image is tested for color.  If there is very little color,
          it is thresholded to gray and the number of gray levels in
          the low gradient regions is found.  If the image has color,
          the number of occupied level 4 octcubes is found.
      (8) The number of colors in the low-gradient regions increases
          monotonically with the threshold @thresh on the edge gradient.
      (9) Background: grayscale and color quantization is often useful
          to achieve highly compressed images with little visible
          distortion.  However, gray or color washes (regions of
          low gradient) can defeat this approach to high compression.
          How can one determine if an image is expected to compress
          well using gray or color quantization?  We use the fact that
            * gray washes, when quantized with less than 50 intensities,
              have posterization (visible boundaries between regions
              of uniform 'color') and poor lossless compression
            * color washes, when quantized with level 4 octcubes,
              typically result in both posterization and the occupancy
              of many level 4 octcubes.
          Images can have colors either intrinsically or as jpeg
          compression artifacts.  This function reduces but does not
          completely eliminate measurement of jpeg quantization noise
          in the white background of grayscale or color images.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorsForQuantization(*args)
    
    

    try:
        leptonica.pixGetMostPopulatedColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetMostPopulatedColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixGetMostPopulatedColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetMostPopulatedColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'factor')       
('l_int32', 'ncolors')       
('l_uint32', '**parray')       
('PIXCMAP', '**pcmap')       
  pixGetMostPopulatedColors()
      Input:  pixs (32 bpp rgb)
              sigbits (2-6, significant bits retained in the quantizer
                       for each component of the input image)
              factor (subsampling factor; use 1 for no subsampling)
              ncolors (the number of most populated colors to select)
              &array (<optional return> array of colors, each as 0xrrggbb00)
              &cmap (<optional return> colormap of the colors)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This finds the @ncolors most populated cubes in rgb colorspace,
          where the cube size depends on @sigbits as
               cube side = (256 >> sigbits)
      (2) The rgb color components are found at the center of the cube.
      (3) The output array of colors can be displayed using
               pixDisplayColorArray(array, ncolors, ...);


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetMostPopulatedColors(*args)
    
    

    try:
        leptonica.pixColorContent.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixColorContent.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixColorContent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorContent(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rwhite')       
('l_int32', 'gwhite')       
('l_int32', 'bwhite')       
('l_int32', 'mingray')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       
  pixColorContent()

      Input:  pixs  (32 bpp rgb or 8 bpp colormapped)
              rwhite, gwhite, bwhite (color value associated with white point)
              mingray (min gray value for which color is measured)
              &pixr (<optional return> 8 bpp red 'content')
              &pixg (<optional return> 8 bpp green 'content')
              &pixb (<optional return> 8 bpp blue 'content')
      Return: 0 if OK, 1 on error

  Notes:
      (1) This returns the color content in each component, which is
          a measure of the deviation from gray, and is defined
          as the difference between the component and the average of
          the other two components.  See the discussion at the
          top of this file.
      (2) The three numbers (rwhite, gwhite and bwhite) can be thought
          of as the values in the image corresponding to white.
          They are used to compensate for an unbalanced color white point.
          They must either be all 0 or all non-zero.  To turn this
          off, set them all to 0.
      (3) If the maximum component after white point correction,
          max(r,g,b), is less than mingray, all color components
          for that pixel are set to zero.
          Use mingray = 0 to turn off this filtering of dark pixels.
      (4) Therefore, use 0 for all four input parameters if the color
          magnitude is to be calculated without either white balance
          correction or dark filtering.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorContent(*args)
    
    

    try:
        leptonica.pixHasHighlightRed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixHasHighlightRed.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixHasHighlightRed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHasHighlightRed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', 'fract')       
('l_float32', 'fthresh')       
('l_int32', '*phasred')       
('l_float32', '*pratio')       
('PIX', '**ppixdb')       
  pixHasHighlightRed()

      Input:  pixs  (32 bpp rgb)
              factor (subsampling; an integer >= 1; use 1 for all pixels)
              fract (threshold fraction of all image pixels)
              fthresh (threshold on a function of the components; typ. ~2.5)
              &hasred (<return> 1 if red pixels are above threshold)
              &ratio (<optional return> normalized fraction of threshold
                      red pixels that is actually observed)
              &pixdb (<optional return> seed pixel mask)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Pixels are identified as red if they satisfy two conditions:
          (a) The components satisfy (R-B)/B > @fthresh   (red or dark fg)
          (b) The red component satisfied R > 128  (red or light bg)
          Masks are generated for (a) and (b), and the intersection
          gives the pixels that are red but not either light bg or
          dark fg.
      (2) A typical value for fract = 0.0001, which gives sensitivity
          to an image where a small fraction of the pixels are printed
          in red.
      (3) A typical value for fthresh = 2.5.  Higher values give less
          sensitivity to red, and fewer false positives.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHasHighlightRed(*args)
    
    

    try:
        leptonica.pixSimpleColorQuantize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSimpleColorQuantize.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSimpleColorQuantize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSimpleColorQuantize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'factor')       
('l_int32', 'ncolors')       
  pixSimpleColorQuantize()
      Input:  pixs (32 bpp rgb)
              sigbits (2-4, significant bits retained in the quantizer
                       for each component of the input image)
              factor (subsampling factor; use 1 for no subsampling)
              ncolors (the number of most populated colors to select)
      Return: pixd (8 bpp cmapped) or NULL on error

  Notes:
      (1) If you want to do color quantization for real, use octcube
          or modified median cut.  This function shows that it is
          easy to make a simple quantizer based solely on the population
          in cells of a given size in rgb color space.
      (2) The @ncolors most populated cells at the @sigbits level form
          the colormap for quantizing, and this uses octcube indexing
          under the covers to assign each pixel to the nearest color.
      (3) @sigbits is restricted to 2, 3 and 4.  At the low end, the
          color discrimination is very crude; at the upper end, a set of
          similar colors can dominate the result.  Interesting results
          are generally found for @sigbits = 3 and ncolors ~ 20.
      (4) See also pixColorSegment() for a method of quantizing the
          colors to generate regions of similar color.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSimpleColorQuantize(*args)
    
    

    try:
        leptonica.makeRGBIndexTables.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.makeRGBIndexTables.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function makeRGBIndexTables not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeRGBIndexTables(*args):
        """
        ('l_uint32', '**prtab')       
('l_uint32', '**pgtab')       
('l_uint32', '**pbtab')       
('l_int32', 'sigbits')       
  makeRGBIndexTables()

      Input:  &rtab, &gtab, &btab (<return> 256-entry index tables)
              sigbits (2-6, significant bits retained in the quantizer
                       for each component of the input image)
      Return: 0 if OK, 1 on error

  Notes:
      (1) These tables are used to map from rgb sample values to
          an rgb index, using
             rgbindex = rtab[rval] | gtab[gval] | btab[bval]
          where, e.g., if sigbits = 3, the index is a 9 bit integer:
             r7 r6 r5 g7 g6 g5 b7 b6 b5


        """
        args = _convert_params(*args)
        
        return leptonica.makeRGBIndexTables(*args)
    
    

    try:
        leptonica.pixNumSignificantGrayColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixNumSignificantGrayColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixNumSignificantGrayColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixNumSignificantGrayColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_float32', 'minfract')       
('l_int32', 'factor')       
('l_int32', '*pncolors')       
  pixNumSignificantGrayColors()

      Input:  pixs  (8 bpp gray)
              darkthresh (dark threshold for minimum intensity to be
                          considered; typ. 20)
              lightthresh (threshold near white, for maximum intensity
                           to be considered; typ. 236)
              minfract (minimum fraction of all pixels to include a level
                        as significant; typ. 0.0001; should be < 0.001)
              factor (subsample factor; integer >= 1)
              &ncolors (<return> number of significant colors; 0 on error)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function is asking the question: how many perceptually
          significant gray color levels is in this pix?
          A color level must meet 3 criteria to be significant:
            - it can't be too close to black
            - it can't be too close to white
            - it must have at least some minimum fractional population
      (2) Use -1 for default values for darkthresh, lightthresh and minfract.
      (3) Choose default of darkthresh = 20, because variations in very
          dark pixels are not visually significant.
      (4) Choose default of lightthresh = 236, because document images
          that have been jpeg'd typically have near-white pixels in the
          8x8 jpeg blocks, and these should not be counted.  It is desirable
          to obtain a clean image by quantizing this noise away.


        """
        args = _convert_params(*args)
        
        return leptonica.pixNumSignificantGrayColors(*args)
    
    

    try:
        leptonica.pixNumColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixNumColors.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixNumColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixNumColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', '*pncolors')       
  pixNumColors()
      Input:  pixs (2, 4, 8, 32 bpp)
              factor (subsampling factor; integer)
              &ncolors (<return> the number of colors found, or 0 if
                        there are more than 256)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) This returns the actual number of colors found in the image,
          even if there is a colormap.  If @factor == 1 and the
          number of colors differs from the number of entries
          in the colormap, a warning is issued.
      (2) Use @factor == 1 to find the actual number of colors.
          Use @factor > 1 to quickly find the approximate number of colors.
      (3) For d = 2, 4 or 8 bpp grayscale, this returns the number
          of colors found in the image in 'ncolors'.
      (4) For d = 32 bpp (rgb), if the number of colors is
          greater than 256, this returns 0 in 'ncolors'.


        """
        args = _convert_params(*args)
        
        return leptonica.pixNumColors(*args)
    
    

    try:
        leptonica.pixGetRGBHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetRGBHistogram.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixGetRGBHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'factor')       
  pixGetRGBHistogram()
      Input:  pixs (32 bpp rgb)
              sigbits (2-6, significant bits retained in the quantizer
                       for each component of the input image)
              factor (subsampling factor; use 1 for no subsampling)
      Return: numa (histogram of colors, indexed by RGB
                    components), or null on error

  Notes:
      (1) This uses a simple, fast method of indexing into an rgb image.
      (2) The output is a 1D histogram of count vs. rgb-index, which
          uses red sigbits as the most significant and blue as the least.
      (3) This function produces the same result as pixMedianCutHisto().


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBHistogram(*args)
    
    

    try:
        leptonica.pixColorMagnitude.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorMagnitude.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixColorMagnitude not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorMagnitude(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rwhite')       
('l_int32', 'gwhite')       
('l_int32', 'bwhite')       
('l_int32', 'type')       
  pixColorMagnitude()

      Input:  pixs  (32 bpp rgb or 8 bpp colormapped)
              rwhite, gwhite, bwhite (color value associated with white point)
              type (chooses the method for calculating the color magnitude:
                    L_MAX_DIFF_FROM_AVERAGE_2, L_MAX_MIN_DIFF_FROM_2,
                    L_MAX_DIFF)
      Return: pixd (8 bpp, amount of color in each source pixel),
                    or NULL on error

  Notes:
      (1) For an RGB image, a gray pixel is one where all three components
          are equal.  We define the amount of color in an RGB pixel by
          considering the absolute value of the differences between the
          three color components.  Consider the two largest
          of these differences.  The pixel component in common to these
          two differences is the color farthest from the other two.
          The color magnitude in an RGB pixel can be taken as:
              * the average of these two differences; i.e., the
                average distance from the two components that are
                nearest to each other to the third component, or
              * the minimum value of these two differences; i.e., the
                maximum over all components of the minimum distance
                from that component to the other two components.
          Even more simply, the color magnitude can be taken as
              * the maximum difference between component values
      (2) As an example, suppose that R and G are the closest in
          magnitude.  Then the color is determined as:
              * the average distance of B from these two; namely,
                (|B - R| + |B - G|) / 2, which can also be found
                from |B - (R + G) / 2|, or
              * the minimum distance of B from these two; namely,
                min(|B - R|, |B - G|).
              * the max(|B - R|, |B - G|)
      (3) The three numbers (rwhite, gwhite and bwhite) can be thought
          of as the values in the image corresponding to white.
          They are used to compensate for an unbalanced color white point.
          They must either be all 0 or all non-zero.  To turn this
          off, set them all to 0.
      (4) We allow the following methods for choosing the color
          magnitude from the three components:
              * L_MAX_DIFF_FROM_AVERAGE_2
              * L_MAX_MIN_DIFF_FROM_2
              * L_MAX_DIFF
          These are described above in (1) and (2), as well as at
          the top of this file.


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorMagnitude(*args)
    
    

    try:
        leptonica.getRGBFromIndex.argtypes = [ctypes.c_uint32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getRGBFromIndex.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getRGBFromIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getRGBFromIndex(*args):
        """
        ('l_uint32', 'index')       
('l_int32', 'sigbits')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
  getRGBFromIndex()

      Input:  index (rgbindex)
              sigbits (2-6, significant bits retained in the quantizer
                       for each component of the input image)
              &rval, &gval, &bval (<return> rgb values)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The @index is expressed in bits, based on the the
          @sigbits of the r, g and b components, as
             r7 r6 ... g7 g6 ... b7 b6 ...
      (2) The computed rgb values are in the center of the quantized cube.
          The extra bit that is OR'd accomplishes this.


        """
        args = _convert_params(*args)
        
        return leptonica.getRGBFromIndex(*args)
    
    

    try:
        leptonica.pixMaskOverColorPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMaskOverColorPixels.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMaskOverColorPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskOverColorPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'threshdiff')       
('l_int32', 'mindist')       
  pixMaskOverColorPixels()

      Input:  pixs  (32 bpp rgb or 8 bpp colormapped)
              threshdiff (threshold for minimum of the max difference
                          between components)
              mindist (minimum allowed distance from nearest non-color pixel)
      Return: pixd (1 bpp, mask over color pixels), or null on error

  Notes:
      (1) The generated mask identifies each pixel as either color or
          non-color.  For a pixel to be color, it must satisfy two
          constraints:
            (a) The max difference between the r,g and b components must
                equal or exceed a threshold @threshdiff.
            (b) It must be at least @mindist (in an 8-connected way)
                from the nearest non-color pixel.
      (2) The distance constraint (b) is only applied if @mindist > 1.
          For example, if @mindist == 2, the color pixels identified
          by (a) are eroded by a 3x3 Sel.  In general, the Sel size
          for erosion is 2 * (@mindist - 1) + 1.
          Why have this constraint?  In scanned images that are
          essentially gray, color artifacts are typically introduced
          in transition regions near sharp edges that go from dark
          to light, so this allows these transition regions to be removed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskOverColorPixels(*args)
    




class xtractprotos(object):
    """ xtractprotos.c

   This program accepts a list of C files on the command line
   and outputs the C prototypes to stdout.  It uses cpp to
   handle the preprocessor macros, and then parses the cpp output.
   In leptonica, it is used to make allheaders.h (and optionally
   leptprotos.h, which contains just the function prototypes.)
   In leptonica, only the file allheaders.h is included with
   source files.

   An optional 'prestring' can be prepended to each declaration.
   And the function prototypes can either be sent to stdout, written
   to a named file, or placed in-line within allheaders.h.

   The signature is:

     xtractprotos [-prestring=<string>] [-protos=<where>] [list of C files]

   Without -protos, the prototypes are written to stdout.
   With -protos, allheaders.h is rewritten:
      * if you use -protos=inline, the prototypes are placed within
        allheaders.h.
      * if you use -protos=leptprotos.h, the prototypes written to
        the file leptprotos.h, and alltypes.h has
           #include "leptprotos.h"

   For constructing allheaders.h, two text files are provided:
      allheaders_top.txt
      allheaders_bot.txt
   The former contains the leptonica version number, so it must
   be updated when a new version is made.

   For simple C prototype extraction, xtractprotos has essentially
   the same functionality as Adam Bryant's cextract, but the latter
   has not been officially supported for over 15 years, has been
   patched numerous times, and doesn't work with sys/sysmacros.h
   for 64 bit architecture.

   This is used to extract all prototypes in liblept.
   The function that does all the work is parseForProtos(),
   which takes as input the output from cpp.

   xtractprotos can run in leptonica to do an 'ab initio' generation
   of allheaders.h; that is, it can make allheaders.h without
   leptprotos.h and with an allheaders.h file of 0 length.
   Of course, the usual situation is to run it with a valid allheaders.h,
   which includes all the function prototypes.  To avoid including
   all the prototypes in the input for each file, cpp runs here
   with -DNO_PROTOS, so the prototypes are not included -- this is
   much faster.

   The xtractprotos version number, defined below, is incremented
   whenever a new version is made.

   N.B. This uses cpp to preprocess the input.

"""
    



class rotateam(object):
    """  rotateam.c

     Grayscale and color rotation for area mapping (== interpolation)

         Rotation about the image center
                  PIX     *pixRotateAM()
                  PIX     *pixRotateAMColor()
                  PIX     *pixRotateAMGray()

         Rotation about the UL corner of the image
                  PIX     *pixRotateAMCorner()
                  PIX     *pixRotateAMColorCorner()
                  PIX     *pixRotateAMGrayCorner()

         Faster color rotation about the image center
                  PIX     *pixRotateAMColorFast()

     Rotations are measured in radians; clockwise is positive.

     The basic area mapping grayscale rotation works on 8 bpp images.
     For color, the same method is applied to each color separately.
     This can be done in two ways: (1) as here, computing each dest
     rgb pixel from the appropriate four src rgb pixels, or (2) separating
     the color image into three 8 bpp images, rotate each of these,
     and then combine the result.  Method (1) is about 2.5x faster.
     We have also implemented a fast approximation for color area-mapping
     rotation (pixRotateAMColorFast()), which is about 25% faster
     than the standard color rotator.  If you need the extra speed,
     use it.

     Area mapping works as follows.  For each dest
     pixel you find the 4 source pixels that it partially
     covers.  You then compute the dest pixel value as
     the area-weighted average of those 4 source pixels.
     We make two simplifying approximations:

       -  For simplicity, compute the areas as if the dest
          pixel were translated but not rotated.

       -  Compute area overlaps on a discrete sub-pixel grid.
          Because we are using 8 bpp images with 256 levels,
          it is convenient to break each pixel into a
          16x16 sub-pixel grid, and count the number of
          overlapped sub-pixels.

     It is interesting to note that the digital filter that
     implements the area mapping algorithm for rotation
     is identical to the digital filter used for linear
     interpolation when arbitrarily scaling grayscale images.

     The advantage of area mapping over pixel sampling
     in grayscale rotation is that the former naturally
     blurs sharp edges ("anti-aliasing"), so that stair-step
     artifacts are not introduced.  The disadvantage is that
     it is significantly slower.

     But it is still pretty fast.  With standard 3 GHz hardware,
     the anti-aliased (area-mapped) color rotation speed is
     about 15 million pixels/sec.

     The function pixRotateAMColorFast() is about 10-20% faster
     than pixRotateAMColor().  The quality is slightly worse,
     and if you make many successive small rotations, with a
     total angle of 360 degrees, it has been noted that the
     center wanders -- it seems to be doing a 1 pixel translation
     in addition to the rotation.

"""
    
    try:
        leptonica.pixRotateAMColor.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixRotateAMColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAMColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint32', 'colorval')       
  pixRotateAMColor()

      Input:  pixs (32 bpp)
              angle (radians; clockwise is positive)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error

  Notes:
      (1) Rotates about image center.
      (2) A positive angle gives a clockwise rotation.
      (3) Specify the color to be brought in from outside the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMColor(*args)
    
    

    try:
        leptonica.pixRotateAMColorFast.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixRotateAMColorFast.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAMColorFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMColorFast(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint32', 'colorval')       
  pixRotateAMColorFast()

      Input:  pixs
              angle (radians; clockwise is positive)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error

  Notes:
      (1) This rotates a color image about the image center.
      (2) A positive angle gives a clockwise rotation.
      (3) It uses area mapping, dividing each pixel into
          16 subpixels.
      (4) It is about 10% to 20% faster than the more accurate linear
          interpolation function pixRotateAMColor(),
          which uses 256 subpixels.
      (5) For some reason it shifts the image center.
          No attempt is made to rotate the alpha component.

  *** Warning: implicit assumption about RGB component ordering ***


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMColorFast(*args)
    
    

    try:
        leptonica.pixRotateAMGrayCorner.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_ubyte]
        leptonica.pixRotateAMGrayCorner.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAMGrayCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMGrayCorner(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint8', 'grayval')       
  pixRotateAMGrayCorner()

      Input:  pixs
              angle (radians; clockwise is positive)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error

  Notes:
      (1) Rotates the image about the UL corner.
      (2) A positive angle gives a clockwise rotation.
      (3) Specify the grayvalue to be brought in from outside the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMGrayCorner(*args)
    
    

    try:
        leptonica.pixRotateAMGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_ubyte]
        leptonica.pixRotateAMGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAMGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint8', 'grayval')       
  pixRotateAMGray()

      Input:  pixs (8 bpp)
              angle (radians; clockwise is positive)
              grayval (0 to bring in BLACK, 255 for WHITE)
      Return: pixd, or null on error

  Notes:
      (1) Rotates about image center.
      (2) A positive angle gives a clockwise rotation.
      (3) Specify the grayvalue to be brought in from outside the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMGray(*args)
    
    

    try:
        leptonica.pixRotateAM.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateAM.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAM not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAM(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateAM()

      Input:  pixs (2, 4, 8 bpp gray or colormapped, or 32 bpp RGB)
              angle (radians; clockwise is positive)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Rotates about image center.
      (2) A positive angle gives a clockwise rotation.
      (3) Brings in either black or white pixels from the boundary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAM(*args)
    
    

    try:
        leptonica.pixRotateAMColorCorner.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixRotateAMColorCorner.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAMColorCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMColorCorner(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint32', 'fillval')       
  pixRotateAMColorCorner()

      Input:  pixs
              angle (radians; clockwise is positive)
              colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE)
      Return: pixd, or null on error

  Notes:
      (1) Rotates the image about the UL corner.
      (2) A positive angle gives a clockwise rotation.
      (3) Specify the color to be brought in from outside the image.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMColorCorner(*args)
    
    

    try:
        leptonica.pixRotateAMCorner.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateAMCorner.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixRotateAMCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMCorner(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
  pixRotateAMCorner()

      Input:  pixs (1, 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB)
              angle (radians; clockwise is positive)
              incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) Rotates about the UL corner of the image.
      (2) A positive angle gives a clockwise rotation.
      (3) Brings in either black or white pixels from the boundary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMCorner(*args)
    




class writefile(object):
    """ writefile.c

     High-level procedures for writing images to file:
        l_int32     pixaWriteFiles()
        l_int32     pixWrite()    [behavior depends on WRITE_AS_NAMED]
        l_int32     pixWriteStream()
        l_int32     pixWriteImpliedFormat()
        l_int32     pixWriteTempfile()

     Selection of output format if default is requested
        l_int32     pixChooseOutputFormat()
        l_int32     getImpliedFileFormat()
        const char *getFormatExtension()

     Write to memory
        l_int32     pixWriteMem()

     Image display for debugging
        l_int32     pixDisplay()
        l_int32     pixDisplayWithTitle()
        l_int32     pixDisplayMultiple()
        l_int32     pixDisplayWrite()
        l_int32     pixDisplayWriteFormat()
        l_int32     pixSaveTiled()
        l_int32     pixSaveTiledOutline()
        l_int32     pixSaveTiledWithText()
        void        l_chooseDisplayProg()

  Supported file formats:
  (1) Writing is supported without any external libraries:
          bmp
          pnm   (including pbm, pgm, etc)
          spix  (raw serialized)
  (2) Writing is supported with installation of external libraries:
          png
          jpg   (standard jfif version)
          tiff  (including most varieties of compression)
          gif
          webp
  (3) Writing is supported through special interfaces:
          ps (PostScript, in psio1.c, psio2.c):
              level 1 (uncompressed)
              level 2 (g4 and dct encoding: requires tiff, jpg)
              level 3 (g4, dct and flate encoding: requires tiff, jpg, zlib)
          pdf (PDF, in pdfio.c):
              level 1 (g4 and dct encoding: requires tiff, jpg)
              level 2 (g4, dct and flate encoding: requires tiff, jpg, zlib)
  (4) No other output formats are supported, such as jp2 (jpeg2000)

"""
    
    try:
        leptonica.pixWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteMem.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'format')       
  pixWriteMem()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
              format  (defined in imageio.h)
      Return: 0 if OK, 1 on error

  Notes:
      (1) On windows, this will only write tiff and PostScript to memory.
          For other formats, it requires open_memstream(3).
      (2) PostScript output is uncompressed, in hex ascii.
          Most printers support level 2 compression (tiff_g4 for 1 bpp,
          jpeg for 8 and 32 bpp).


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMem(*args)
    
    

    try:
        leptonica.pixWriteTempfile.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixWriteTempfile.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteTempfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteTempfile(*args):
        """
        ('const char', '*dir')       
('const char', '*tail')       
('PIX', '*pix')       
('l_int32', 'format')       
('char', '**pfilename')       
  pixWriteTempfile()

      Input:  dir (directory name; use '.' for local dir; no trailing '/')
              tail (<optional> tailname, including extension if any)
              pix
              format
              &filename (<optional> return actual filename used; use
                         null to skip)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This generates a temp filename, writes the pix to it,
          and optionally returns the temp filename.
      (2) If the filename is returned to a windows program from a DLL,
          use lept_free() to free it.
      (3) See genTempFilename() for details.  We omit the time and pid
          here.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteTempfile(*args)
    
    

    try:
        leptonica.getImpliedFileFormat.argtypes = [ctypes.c_void_p]
        leptonica.getImpliedFileFormat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getImpliedFileFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getImpliedFileFormat(*args):
        """
        ('const char', '*filename')       
  getImpliedFileFormat()

      Input:  filename
      Return: output format, or IFF_UNKNOWN on error or invalid extension.

  Notes:
      (1) This determines the output file format from the extension
          of the input filename.


        """
        args = _convert_params(*args)
        
        return leptonica.getImpliedFileFormat(*args)
    
    

    try:
        leptonica.pixaWriteFiles.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaWriteFiles.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixaWriteFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteFiles(*args):
        """
        ('const char', '*rootname')       
('PIXA', '*pixa')       
('l_int32', 'format')       
  pixaWriteFiles()

      Input:  rootname
              pixa
              format  (defined in imageio.h; see notes for default)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Use @format = IFF_DEFAULT to decide the output format
          individually for each pix.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteFiles(*args)
    
    

    try:
        leptonica.pixDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDisplay.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplay(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixDisplay()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              x, y  (location of display frame on the screen)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This displays the image using xzgv, xli or xv on Unix,
          or i_view on Windows.  The display program must be on
          your $PATH variable.  It is chosen by setting the global
          var_DISPLAY_PROG, using l_chooseDisplayProg().
          Default on Unix is xzgv.
      (2) Images with dimensions larger than MAX_DISPLAY_WIDTH or
          MAX_DISPLAY_HEIGHT are downscaled to fit those constraints.
          This is particulary important for displaying 1 bpp images
          with xv, because xv automatically downscales large images
          by subsampling, which looks poor.  For 1 bpp, we use
          scale-to-gray to get decent-looking anti-aliased images.
          In all cases, we write a temporary file to /tmp, that is
          read by the display program.
      (3) For spp == 4, we call pixDisplayLayersRGBA() to show 3
          versions of the image: the image with a fully opaque
          alpha, the alpha, and the image as it would appear with
          a white background.
      (4) Note: this function uses a static internal variable to number
          output files written by a single process.  Behavior with a
          shared library may be unpredictable.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplay(*args)
    
    

    try:
        leptonica.pixWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWrite(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'format')       
  pixWrite()

      Input:  filename
              pix
              format  (defined in imageio.h)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Open for write using binary mode (with the "b" flag)
          to avoid having Windows automatically translate the NL
          into CRLF, which corrupts image files.  On non-windows
          systems this flag should be ignored, per ISO C90.
          Thanks to Dave Bryan for pointing this out.
      (2) If the default image format IFF_DEFAULT is requested:
          use the input format if known; otherwise, use a lossless format.
      (3) There are two modes with respect to file naming.
          (a) The default code writes to @filename.
          (b) If WRITE_AS_NAMED is defined to 0, it's a bit fancier.
              Then, if @filename does not have a file extension, one is
              automatically appended, depending on the requested format.
          The original intent for providing option (b) was to insure
          that filenames on Windows have an extension that matches
          the image compression.  However, this is not the default.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWrite(*args)
    
    

    try:
        leptonica.pixDisplayWriteFormat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDisplayWriteFormat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayWriteFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayWriteFormat(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'reduction')       
('l_int32', 'format')       
  pixDisplayWriteFormat()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              reduction (-1 to reset/erase; 0 to disable;
                         otherwise this is a reduction factor)
              format (IFF_PNG or IFF_JFIF_JPEG)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This writes files if reduction > 0.  These can be displayed using
            pixDisplayMultiple("/tmp/display/file*");
      (2) All previously written files can be erased by calling with
          reduction < 0; the value of pixs is ignored.
      (3) If reduction > 1 and depth == 1, this does a scale-to-gray
          reduction.
      (4) This function uses a static internal variable to number
          output files written by a single process.  Behavior
          with a shared library may be unpredictable.
      (5) Output file format is as follows:
            format == IFF_JFIF_JPEG:
                png if d < 8 or d == 16 or if the output pix
                has a colormap.   Otherwise, output is jpg.
            format == IFF_PNG:
                png (lossless) on all images.
      (6) For 16 bpp, the choice of full dynamic range with log scale
          is the best for displaying these images.  Alternative outputs are
             pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE);
             pix8 = pixConvert16To8(pixt, 0);  // low order byte
             pix8 = pixConvert16To8(pixt, 1);  // high order byte


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayWriteFormat(*args)
    
    

    try:
        leptonica.pixDisplayMultiple.argtypes = [ctypes.c_void_p]
        leptonica.pixDisplayMultiple.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayMultiple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayMultiple(*args):
        """
        ('const char', '*filepattern')       
  pixDisplayMultiple()

      Input:  filepattern
      Return: 0 if OK; 1 on error

  Notes:
      (1) This allows display of multiple images using gthumb on unix
          and i_view32 on windows.  The @filepattern is a regular
          expression that is expanded by the shell.
      (2) _fullpath automatically changes '/' to '\' if necessary.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayMultiple(*args)
    
    

    try:
        leptonica.pixWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'format')       
  pixWriteStream()

      Input:  stream
              pix
              format
      Return: 0 if OK; 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStream(*args)
    
    

    try:
        leptonica.pixSaveTiledWithText.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSaveTiledWithText.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSaveTiledWithText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSaveTiledWithText(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_int32', 'outwidth')       
('l_int32', 'newrow')       
('l_int32', 'space')       
('l_int32', 'linewidth')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       
  pixSaveTiledWithText()

      Input:  pixs (1, 2, 4, 8, 32 bpp)
              pixa (the pix are accumulated here; as 32 bpp)
              outwidth (in pixels; use 0 to disable entirely)
              newrow (1 to start a new row; 0 to go on same row as previous)
              space (horizontal and vertical spacing, in pixels)
              linewidth (width of added outline for image; 0 for no outline)
              bmf (<optional> font struct)
              textstr (<optional> text string to be added)
              val (color to set the text)
              location (L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) Before calling this function for the first time, use
          pixaCreate() to make the @pixa that will accumulate the pix.
          This is passed in each time pixSaveTiled() is called.
      (2) @outwidth is the scaled width.  After scaling, the image is
          saved in the input pixa, along with a box that specifies
          the location to place it when tiled later.  Disable saving
          the pix by setting @outwidth == 0.
      (3) @newrow and @space specify the location of the new pix
          with respect to the last one(s) that were entered.
      (4) All pix are saved as 32 bpp RGB.
      (5) If both @bmf and @textstr are defined, this generates a pix
          with the additional text; otherwise, no text is written.
      (6) The text is written before scaling, so it is properly
          antialiased in the scaled pix.  However, if the pix on
          different calls have different widths, the size of the
          text will vary.
      (7) See pixSaveTiledOutline() for other implementation details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSaveTiledWithText(*args)
    
    

    try:
        leptonica.pixWriteImpliedFormat.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteImpliedFormat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteImpliedFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteImpliedFormat(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'progressive')       
  pixWriteImpliedFormat()

      Input:  filename
              pix
              quality (iff JPEG; 1 - 100, 0 for default)
              progressive (iff JPEG; 0 for baseline seq., 1 for progressive)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This determines the output format from the filename extension.
      (2) The last two args are ignored except for requests for jpeg files.
      (3) The jpeg default quality is 75.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteImpliedFormat(*args)
    
    

    try:
        leptonica.pixSaveTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSaveTiled.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSaveTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSaveTiled(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_float32', 'scalefactor')       
('l_int32', 'newrow')       
('l_int32', 'space')       
('l_int32', 'dp')       
  pixSaveTiled()

      Input:  pixs (1, 2, 4, 8, 32 bpp)
              pixa (the pix are accumulated here)
              scalefactor (0.0 to disable; otherwise this is a scale factor)
              newrow (0 if placed on the same row as previous; 1 otherwise)
              space (horizontal and vertical spacing, in pixels)
              dp (depth of pixa; 8 or 32 bpp; only used on first call)
      Return: 0 if OK, 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSaveTiled(*args)
    
    

    try:
        leptonica.pixSaveTiledOutline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSaveTiledOutline.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSaveTiledOutline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSaveTiledOutline(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_float32', 'scalefactor')       
('l_int32', 'newrow')       
('l_int32', 'space')       
('l_int32', 'linewidth')       
('l_int32', 'dp')       
  pixSaveTiledOutline()

      Input:  pixs (1, 2, 4, 8, 32 bpp)
              pixa (the pix are accumulated here)
              scalefactor (0.0 to disable; otherwise this is a scale factor)
              newrow (0 if placed on the same row as previous; 1 otherwise)
              space (horizontal and vertical spacing, in pixels)
              linewidth (width of added outline for image; 0 for no outline)
              dp (depth of pixa; 8 or 32 bpp; only used on first call)
      Return: 0 if OK, 1 on error.

  Notes:
      (1) Before calling this function for the first time, use
          pixaCreate() to make the @pixa that will accumulate the pix.
          This is passed in each time pixSaveTiled() is called.
      (2) @scalefactor scales the input image.  After scaling and
          possible depth conversion, the image is saved in the input
          pixa, along with a box that specifies the location to
          place it when tiled later.  Disable saving the pix by
          setting @scalefactor == 0.0.
      (3) @newrow and @space specify the location of the new pix
          with respect to the last one(s) that were entered.
      (4) @dp specifies the depth at which all pix are saved.  It can
          be only 8 or 32 bpp.  Any colormap is removed.  This is only
          used at the first invocation.
      (5) This function uses two variables from call to call.
          If they were static, the function would not be .so or thread
          safe, and furthermore, there would be interference with two or
          more pixa accumulating images at a time.  Consequently,
          we use the first pix in the pixa to store and obtain both
          the depth and the current position of the bottom (one pixel
          below the lowest image raster line when laid out using
          the boxa).  The bottom variable is stored in the input format
          field, which is the only field available for storing an int.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSaveTiledOutline(*args)
    
    

    try:
        leptonica.pixDisplayWithTitle.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDisplayWithTitle.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayWithTitle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayWithTitle(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('const char', '*title')       
('l_int32', 'dispflag')       
  pixDisplayWithTitle()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              x, y  (location of display frame)
              title (<optional> on frame; can be NULL);
              dispflag (1 to write, else disabled)
      Return: 0 if OK; 1 on error

  Notes:
      (1) See notes for pixDisplay().
      (2) This displays the image if dispflag == 1.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayWithTitle(*args)
    
    

    try:
        leptonica.pixDisplayWrite.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDisplayWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixDisplayWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayWrite(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'reduction')       
  pixDisplayWrite()

      Input:  pix (1, 2, 4, 8, 16, 32 bpp)
              reduction (-1 to reset/erase; 0 to disable;
                         otherwise this is a reduction factor)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This defaults to jpeg output for pix that are 32 bpp or
          8 bpp without a colormap.  If you want to write all images
          losslessly, use format == IFF_PNG in pixDisplayWriteFormat().
      (2) See pixDisplayWriteFormat() for usage details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayWrite(*args)
    
    

    try:
        leptonica.getFormatExtension.argtypes = [ctypes.c_int32]
        leptonica.getFormatExtension.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function getFormatExtension not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getFormatExtension(*args):
        """
        ('l_int32', 'format')       
  getFormatExtension()

      Input:  format (integer)
      Return: extension (string), or null if format is out of range

  Notes:
      (1) This string is NOT owned by the caller; it is just a pointer
          to a global string.  Do not free it.


        """
        args = _convert_params(*args)
        
        return leptonica.getFormatExtension(*args)
    
    

    try:
        leptonica.pixChooseOutputFormat.argtypes = [ctypes.c_void_p]
        leptonica.pixChooseOutputFormat.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixChooseOutputFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixChooseOutputFormat(*args):
        """
        ('PIX', '*pix')       
  pixChooseOutputFormat()

      Input:  pix
      Return: output format, or 0 on error

  Notes:
      (1) This should only be called if the requested format is IFF_DEFAULT.
      (2) If the pix wasn't read from a file, its input format value
          will be IFF_UNKNOWN, and in that case it is written out
          in a compressed but lossless format.


        """
        args = _convert_params(*args)
        
        return leptonica.pixChooseOutputFormat(*args)
    




class readbarcode(object):
    """  readbarcode.c

      Basic operations to locate and identify the line widths
      in 1D barcodes.

      Top level
          SARRAY          *pixProcessBarcodes()

      Next levels
          PIXA            *pixExtractBarcodes()
          SARRAY          *pixReadBarcodes()
          l_int32          pixReadBarcodeWidths()

      Location
          BOXA            *pixLocateBarcodes()
          static PIX      *pixGenerateBarcodeMask()

      Extraction and deskew
          PIXA            *pixDeskewBarcodes()

      Process to get line widths
          NUMA            *pixExtractBarcodeWidths1()
          NUMA            *pixExtractBarcodeWidths2()
          NUMA            *pixExtractBarcodeCrossings()

      Average adjacent rasters
          static NUMA     *pixAverageRasterScans()

      Signal processing for barcode widths
          NUMA            *numaQuantizeCrossingsByWidth()
          static l_int32   numaGetCrossingDistances()
          static NUMA     *numaLocatePeakRanges()
          static NUMA     *numaGetPeakCentroids()
          static NUMA     *numaGetPeakWidthLUT()
          NUMA            *numaQuantizeCrossingsByWindow()
          static l_int32   numaEvalBestWidthAndShift()
          static l_int32   numaEvalSyncError()


  NOTE CAREFULLY: This is "early beta" code.  It has not been tuned
  to work robustly on a large database of barcode images.  I'm putting
  it out so that people can play with it, find out how it breaks, and
  contribute decoders for other barcode formats.  Both the functional
  interfaces and ABI will almost certainly change in the coming
  few months.  The actual decoder, in bardecode.c, at present only
  works on the following codes: Code I2of5, Code 2of5, Code 39, Code 93
  Codabar and UPCA.  To add another barcode format, it is necessary
  to make changes in readbarcode.h and bardecode.c.
  The program prog/barcodetest shows how to run from the top level
  (image --> decoded data).

"""
    
    try:
        leptonica.pixExtractBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBarcodes.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodes(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'debugflag')       
  pixExtractBarcodes()

      Input:  pixs (8 bpp, no colormap)
              debugflag (use 1 to generate debug output)
      Return: pixa (deskewed and cropped barcodes), or null if
                    none found or on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodes(*args)
    
    

    try:
        leptonica.pixDeskewBarcode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDeskewBarcode.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixDeskewBarcode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewBarcode(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('BOX', '*box')       
('l_int32', 'margin')       
('l_int32', 'threshold')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
  pixDeskewBarcode()

      Input:  pixs (input image; 8 bpp)
              pixb (binarized edge-filtered input image)
              box (identified region containing barcode)
              margin (of extra pixels around box to extract)
              threshold (for binarization; ~20)
              &angle (<optional return> in degrees, clockwise is positive)
              &conf (<optional return> confidence)
      Return: pixd (deskewed barcode), or null on error

  Note:
     (1) The (optional) angle returned is the angle in degrees (cw positive)
         necessary to rotate the image so that it is deskewed.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewBarcode(*args)
    
    

    try:
        leptonica.pixReadBarcodeWidths.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReadBarcodeWidths.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadBarcodeWidths not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadBarcodeWidths(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'method')       
('l_int32', 'debugflag')       
  pixReadBarcodeWidths()

      Input:  pixs (of 8 bpp deskewed and cropped barcode)
              method (L_USE_WIDTHS, L_USE_WINDOWS);
              debugflag (use 1 to generate debug output)
      Return: na (numa of widths (each in set {1,2,3,4}), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadBarcodeWidths(*args)
    
    

    try:
        leptonica.pixLocateBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixLocateBarcodes.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixLocateBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLocateBarcodes(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('PIX', '**ppixb')       
('PIX', '**ppixm')       
  pixLocateBarcodes()

      Input:  pixs (any depth)
              thresh (for binarization of edge filter output; typ. 20)
              &pixb (<optional return> binarized edge filtered input image)
              &pixm (<optional return> mask over barcodes)
      Return: boxa (location of barcodes), or null if none found or on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixLocateBarcodes(*args)
    
    

    try:
        leptonica.numaQuantizeCrossingsByWidth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaQuantizeCrossingsByWidth.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaQuantizeCrossingsByWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaQuantizeCrossingsByWidth(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'binfract')       
('NUMA', '**pnaehist')       
('NUMA', '**pnaohist')       
('l_int32', 'debugflag')       
  numaQuantizeCrossingsByWidth()

      Input:  nas (numa of crossing locations, in pixel units)
              binfract (histo binsize as a fraction of minsize; e.g., 0.25)
              &naehist (<optional return> histo of even (black) bar widths)
              &naohist (<optional return> histo of odd (white) bar widths)
              debugflag (1 to generate plots of histograms of bar widths)
      Return: nad (sequence of widths, in unit sizes), or null on error

  Notes:
      (1) This first computes the histogram of black and white bar widths,
          binned in appropriate units.  There should be well-defined
          peaks, each corresponding to a specific width.  The sequence
          of barcode widths (namely, the integers from the set {1,2,3,4})
          is returned.
      (2) The optional returned histograms are binned in width units
          that are inversely proportional to @binfract.  For example,
          if @binfract = 0.25, there are 4.0 bins in the distance of
          the width of the narrowest bar.


        """
        args = _convert_params(*args)
        
        return leptonica.numaQuantizeCrossingsByWidth(*args)
    
    

    try:
        leptonica.pixProcessBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProcessBarcodes.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixProcessBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProcessBarcodes(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'format')       
('l_int32', 'method')       
('SARRAY', '**psaw')       
('l_int32', 'debugflag')       
  pixProcessBarcodes()

      Input:  pixs (any depth)
              format (L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...)
              method (L_USE_WIDTHS, L_USE_WINDOWS)
              &saw (<optional return> sarray of bar widths)
              debugflag (use 1 to generate debug output)
      Return: sarray (text of barcodes), or null if none found or on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProcessBarcodes(*args)
    
    

    try:
        leptonica.pixExtractBarcodeWidths2.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBarcodeWidths2.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractBarcodeWidths2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodeWidths2(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_float32', '*pwidth')       
('NUMA', '**pnac')       
('l_int32', 'debugflag')       
  pixExtractBarcodeWidths2()

      Input:  pixs (input image; 8 bpp)
              thresh (estimated pixel threshold for crossing
                      white <--> black; typ. ~120)
              &width (<optional return> best decoding window width, in pixels)
              &nac (<optional return> number of transitions in each window)
              debugflag (use 1 to generate debug output)
      Return: nad (numa of barcode widths in encoded integer units),
                  or null on error

  Notes:
      (1) The widths are alternating black/white, starting with black
          and ending with black.
      (2) The optional best decoding window width is the width of the window
          that is used to make a decision about whether a transition occurs.
          It is approximately the average width in pixels of the narrowest
          white and black bars (i.e., those corresponding to unit width).
      (3) The optional return signal @nac is a sequence of 0s, 1s,
          and perhaps a few 2s, giving the number of crossings in each window.
          On the occasion where there is a '2', it is interpreted as
          as ending two runs: the previous one and another one that has length 1.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodeWidths2(*args)
    
    

    try:
        leptonica.pixExtractBarcodeWidths1.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBarcodeWidths1.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractBarcodeWidths1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodeWidths1(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_float32', 'binfract')       
('NUMA', '**pnaehist')       
('NUMA', '**pnaohist')       
('l_int32', 'debugflag')       
  pixExtractBarcodeWidths1()

      Input:  pixs (input image; 8 bpp)
              thresh (estimated pixel threshold for crossing
                      white <--> black; typ. ~120)
              binfract (histo binsize as a fraction of minsize; e.g., 0.25)
              &naehist (<optional return> histogram of black widths; NULL ok)
              &naohist (<optional return> histogram of white widths; NULL ok)
              debugflag (use 1 to generate debug output)
      Return: nad (numa of barcode widths in encoded integer units),
                  or null on error

  Note:
     (1) The widths are alternating black/white, starting with black
         and ending with black.
     (2) This method uses the widths of the bars directly, in terms
         of the (float) number of pixels between transitions.
         The histograms of these widths for black and white bars is
         generated and interpreted.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodeWidths1(*args)
    
    

    try:
        leptonica.pixReadBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadBarcodes.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadBarcodes(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'format')       
('l_int32', 'method')       
('SARRAY', '**psaw')       
('l_int32', 'debugflag')       
  pixReadBarcodes()

      Input:  pixa (of 8 bpp deskewed and cropped barcodes)
              format (L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...)
              method (L_USE_WIDTHS, L_USE_WINDOWS);
              &saw (<optional return> sarray of bar widths)
              debugflag (use 1 to generate debug output)
      Return: sa (sarray of widths, one string for each barcode found),
                  or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadBarcodes(*args)
    
    

    try:
        leptonica.pixExtractBarcodeCrossings.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixExtractBarcodeCrossings.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExtractBarcodeCrossings not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodeCrossings(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'debugflag')       
  pixExtractBarcodeCrossings()

      Input:  pixs (input image; 8 bpp)
              thresh (estimated pixel threshold for crossing
                      white <--> black; typ. ~120)
              debugflag (use 1 to generate debug output)
      Return: numa (of crossings, in pixel units), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodeCrossings(*args)
    
    

    try:
        leptonica.numaQuantizeCrossingsByWindow.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaQuantizeCrossingsByWindow.restype = lambda address: NUMA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function numaQuantizeCrossingsByWindow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaQuantizeCrossingsByWindow(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'ratio')       
('l_float32', '*pwidth')       
('l_float32', '*pfirstloc')       
('NUMA', '**pnac')       
('l_int32', 'debugflag')       
  numaQuantizeCrossingsByWindow()

      Input:  nas (numa of crossing locations)
              ratio (of max window size over min window size in search;
                     typ. 2.0)
              &width (<optional return> best window width)
              &firstloc (<optional return> center of window for first xing)
              &nac (<optional return> array of window crossings (0, 1, 2))
              debugflag (1 to generate various plots of intermediate results)
      Return: nad (sequence of widths, in unit sizes), or null on error

  Notes:
      (1) The minimum size of the window is set by the minimum
          distance between zero crossings.
      (2) The optional return signal @nac is a sequence of 0s, 1s,
          and perhaps a few 2s, giving the number of crossings in each window.
          On the occasion where there is a '2', it is interpreted as
          ending two runs: the previous one and another one that has length 1.


        """
        args = _convert_params(*args)
        
        return leptonica.numaQuantizeCrossingsByWindow(*args)
    




class binexpand(object):
    """  binexpand.c

      Replicated expansion (integer scaling)
         PIX     *pixExpandBinaryReplicate()

      Special case: power of 2 replicated expansion
         PIX     *pixExpandBinaryPower2()

      Expansion tables for power of 2 expansion
         static l_uint16    *makeExpandTab2x()
         static l_uint32    *makeExpandTab4x()
         static l_uint32    *makeExpandTab8x()

"""
    
    try:
        leptonica.pixExpandBinaryReplicate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExpandBinaryReplicate.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExpandBinaryReplicate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExpandBinaryReplicate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixExpandBinaryReplicate()

      Input:  pixs (1 bpp)
              factor (integer scale factor for replicative expansion)
      Return: pixd (scaled up), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExpandBinaryReplicate(*args)
    
    

    try:
        leptonica.pixExpandBinaryPower2.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExpandBinaryPower2.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixExpandBinaryPower2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExpandBinaryPower2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
  pixExpandBinaryPower2()

      Input:  pixs (1 bpp)
              factor (expansion factor: 1, 2, 4, 8, 16)
      Return: pixd (expanded 1 bpp by replication), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExpandBinaryPower2(*args)
    




class stack(object):
    """  stack.c

      Generic stack

      The lstack is an array of void * ptrs, onto which
      objects can be stored.  At any time, the number of
      stored objects is lstack->n.  The object at the bottom
      of the lstack is at array[0]; the object at the top of
      the lstack is at array[n-1].  New objects are added
      to the top of the lstack; i.e., the first available
      location, which is at array[n].  The lstack is expanded
      by doubling, when needed.  Objects are removed
      from the top of the lstack.  When an attempt is made
      to remove an object from an empty lstack, the result is null.

      Create/Destroy
           L_STACK        *lstackCreate()
           void            lstackDestroy()

      Accessors
           l_int32         lstackAdd()
           void           *lstackRemove()
           static l_int32  lstackExtendArray()
           l_int32         lstackGetCount()

      Text description
           l_int32         lstackPrint()

"""
    
    try:
        leptonica.lstackDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lstackDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function lstackDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackDestroy(*args):
        """
        ('L_STACK', '**plstack')       
('l_int32', 'freeflag')       
  lstackDestroy()

      Input:  &lstack (<to be nulled>)
              freeflag (TRUE to free each remaining struct in the array)
      Return: void

  Notes:
      (1) If freeflag is TRUE, frees each struct in the array.
      (2) If freeflag is FALSE but there are elements on the array,
          gives a warning and destroys the array.  This will
          cause a memory leak of all the items that were on the lstack.
          So if the items require their own destroy function, they
          must be destroyed before the lstack.
      (3) To destroy the lstack, we destroy the ptr array, then
          the lstack, and then null the contents of the input ptr.


        """
        args = _convert_params(*args)
        
        return leptonica.lstackDestroy(*args)
    
    

    try:
        leptonica.lstackPrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lstackPrint.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lstackPrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackPrint(*args):
        """
        ('FILE', '*fp')       
('L_STACK', '*lstack')       
  lstackPrint()

      Input:  stream
              lstack
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackPrint(*args)
    
    

    try:
        leptonica.lstackGetCount.argtypes = [ctypes.c_void_p]
        leptonica.lstackGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lstackGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackGetCount(*args):
        """
        ('L_STACK', '*lstack')       
  lstackGetCount()

      Input:  lstack
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackGetCount(*args)
    
    

    try:
        leptonica.lstackAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lstackAdd.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function lstackAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackAdd(*args):
        """
        ('L_STACK', '*lstack')       
('void', '*item')       
  lstackAdd()

      Input:  lstack
              item to be added to the lstack
      Return: 0 if OK; 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.lstackAdd(*args)
    
    

    try:
        leptonica.lstackRemove.argtypes = [ctypes.c_void_p]
        leptonica.lstackRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        os.stderr.write("Warning - function lstackRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackRemove(*args):
        """
        ('L_STACK', '*lstack')       
  lstackRemove()

      Input:  lstack
      Return: ptr to item popped from the top of the lstack,
              or null if the lstack is empty or on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackRemove(*args)
    
    

    try:
        leptonica.lstackCreate.argtypes = [ctypes.c_int32]
        leptonica.lstackCreate.restype = lambda address: L_STACK(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function lstackCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackCreate(*args):
        """
        ('l_int32', 'nalloc')       
  lstackCreate()

      Input:  nalloc (initial ptr array size; use 0 for default)
      Return: lstack, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackCreate(*args)
    




class finditalic(object):
    """ finditalic.c

      l_int32   pixItalicWords()

    Locate italic words.  This is an example of the use of
    hit-miss binary morphology with binary reconstruction
    (filling from a seed into a mask).

    To see how this works, run with prog/italic.png.

"""
    
    try:
        leptonica.pixItalicWords.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixItalicWords.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixItalicWords not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixItalicWords(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxaw')       
('PIX', '*pixw')       
('BOXA', '**pboxa')       
('l_int32', 'debugflag')       
  pixItalicWords()

      Input:  pixs (1 bpp)
              boxaw (<optional> word bounding boxes; can be NULL)
              pixw (<optional> word box mask; can be NULL)
              &boxa (<return> boxa of italic words)
              debugflag (1 for debug output; 0 otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) You can input the bounding boxes for the words in one of
          two forms: as bounding boxes (@boxaw) or as a word mask with
          the word bounding boxes filled (@pixw).  For example,
          to compute @pixw, you can use pixWordMaskByDilation().
      (2) Alternatively, you can set both of these inputs to NULL,
          in which case the word mask is generated here.  This is
          done by dilating and closing the input image to connect
          letters within a word, while leaving the words separated.
          The parameters are chosen under the assumption that the
          input is 10 to 12 pt text, scanned at about 300 ppi.
      (3) sel_ital1 and sel_ital2 detect the right edges that are
          nearly vertical, at approximately the angle of italic
          strokes.  We use the right edge to avoid getting seeds
          from lower-case 'y'.  The typical italic slant has a smaller
          angle with the vertical than the 'W', so in most cases we
          will not trigger on the slanted lines in the 'W'.
      (4) Note that sel_ital2 is shorter than sel_ital1.  It is
          more appropriate for a typical font scanned at 200 ppi.


        """
        args = _convert_params(*args)
        
        return leptonica.pixItalicWords(*args)
    




class sudoku(object):
    """  sudoku.c

      Solve a sudoku by brute force search

      Read input data from file or string
          l_int32         *sudokuReadFile()
          l_int32         *sudokuReadString()

      Create/destroy
          L_SUDOKU        *sudokuCreate()
          void             sudokuDestroy()

      Solve the puzzle
          l_int32          sudokuSolve()
          static l_int32   sudokuValidState()
          static l_int32   sudokuNewGuess()
          static l_int32   sudokuTestState()

      Test for uniqueness
          l_int32          sudokuTestUniqueness()
          static l_int32   sudokuCompareState()
          static l_int32  *sudokuRotateArray()

      Generation
          L_SUDOKU        *sudokuGenerate()

      Output
          l_int32          sudokuOutput()

  Solving sudokus is a somewhat addictive pastime.  The rules are
  simple but it takes just enough concentration to make it rewarding
  when you find a number.  And you get 50 to 60 such rewards each time
  you complete one.  The downside is that you could have been doing
  something more creative, like keying out a new plant, staining
  the deck, or even writing a computer program to discourage your
  wife from doing sudokus.

  My original plan for the sudoku solver was somewhat grandiose.
  The program would model the way a person solves the problem.
  It would examine each empty position and determine how many possible
  numbers could fit.  The empty positions would be entered in a priority
  queue keyed on the number of possible numbers that could fit.
  If there existed a position where only a single number would work,
  it would greedily take it.  Otherwise it would consider a
  positions that could accept two and make a guess, with backtracking
  if an impossible state were reached.  And so on.

  Then one of my colleagues announced she had solved the problem
  by brute force and it was fast.  At that point the original plan was
  dead in the water, because the two top requirements for a leptonica
  algorithm are (1) as simple as possible and (2) fast.  The brute
  force approach starts at the UL corner, and in succession at each
  blank position it finds the first valid number (testing in
  sequence from 1 to 9).  When no number will fit a blank position
  it backtracks, choosing the next valid number in the previous
  blank position.

  This is an inefficient method for pruning the space of solutions
  (imagine backtracking from the LR corner back to the UL corner
  and starting over with a new guess), but it nevertheless gets
  the job done quickly.  I have made no effort to optimize
  it, because it is fast: a 5-star (highest difficulty) sudoku might
  require a million guesses and take 0.05 sec.  (This BF implementation
  does about 20M guesses/sec at 3 GHz.)

  Proving uniqueness of a sudoku solution is tricker than finding
  a solution (or showing that no solution exists).  A good indication
  that a solution is unique is if we get the same result solving
  by brute force when the puzzle is also rotated by 90, 180 and 270
  degrees.  If there are multiple solutions, it seems unlikely
  that you would get the same solution four times in a row, using a
  brute force method that increments guesses and scans LR/TB.
  The function sudokuTestUniqueness() does this.

  And given a function that can determine uniqueness, it is
  easy to generate valid sudokus.  We provide sudokuGenerate(),
  which starts with some valid initial solution, and randomly
  removes numbers, stopping either when a minimum number of non-zero
  elements are left, or when it becomes difficult to remove another
  element without destroying the uniqueness of the solution.

  For further reading, see the Wikipedia articles:
     (1) http://en.wikipedia.org/wiki/Algorithmics_of_sudoku
     (2) http://en.wikipedia.org/wiki/Sudoku

  How many 9x9 sudokus are there?  Here are the numbers.
   - From ref(1), there are about 6 x 10^27 "latin squares", where
     each row and column has all 9 digits.
   - There are 7.2 x 10^21 actual solutions, having the added
     constraint in each of the 9 3x3 squares.  (The constraint
     reduced the number by the fraction 1.2 x 10^(-6).)
   - There are a mere 5.5 billion essentially different solutions (EDS),
     when symmetries (rotation, reflection, permutation and relabelling)
     are removed.
   - Thus there are 1.3 x 10^12 solutions that can be derived by
     symmetry from each EDS.  Can we account for these?
   - Sort-of.  From an EDS, you can derive (3!)^8 = 1.7 million solutions
     by simply permuting rows and columns.  (Do you see why it is
     not (3!)^6 ?)
   - Also from an EDS, you can derive 9! solutions by relabelling,
     and 4 solutions by rotation, for a total of 1.45 million solutions
     by relabelling and rotation.  Then taking the product, by symmetry
     we can derive 1.7M x 1.45M = 2.45 trillion solutions from each EDS.
     (Something is off by about a factor of 2 -- close enough.)

  Another interesting fact is that there are apparently 48K EDS sudokus
  (with unique solutions) that have only 17 givens.  No sudokus are known
  with less than 17, but there exists no proof that this is the minimum.

"""
    
    try:
        leptonica.sudokuOutput.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sudokuOutput.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sudokuOutput not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuOutput(*args):
        """
        ('L_SUDOKU', '*sud')       
('l_int32', 'arraytype')       
  sudokuOutput()

      Input:  l_sudoku (at any stage)
              arraytype (L_SUDOKU_INIT, L_SUDOKU_STATE)
      Return: void

  Notes:
      (1) Prints either the initial array or the current state
          of the solution.


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuOutput(*args)
    
    

    try:
        leptonica.sudokuCreate.argtypes = [ctypes.c_void_p]
        leptonica.sudokuCreate.restype = lambda address: L_SUDOKU(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sudokuCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuCreate(*args):
        """
        ('l_int32', '*array')       
  sudokuCreate()

      Input:  array (of 81 numbers, 9 rows of 9 numbers each)
      Return: l_sudoku, or null on error

  Notes:
      (1) The input array has 0 for the unknown values, and 1-9
          for the known initial values.  It is generated from
          a file using sudokuReadInput(), which checks that the file
          data has 81 numbers in 9 rows.


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuCreate(*args)
    
    

    try:
        leptonica.sudokuTestUniqueness.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sudokuTestUniqueness.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sudokuTestUniqueness not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuTestUniqueness(*args):
        """
        ('l_int32', '*array')       
('l_int32', '*punique')       
  sudokuTestUniqueness()

      Input:  array (of 81 numbers, 9 lines of 9 numbers each)
              &punique (<return> 1 if unique, 0 if not)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This applies the brute force method to all four 90 degree
          rotations.  If there is more than one solution, it is highly
          unlikely that all four results will be the same;
          consequently, if they are the same, the solution is
          most likely to be unique.


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuTestUniqueness(*args)
    
    

    try:
        leptonica.sudokuReadFile.argtypes = [ctypes.c_void_p]
        leptonica.sudokuReadFile.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function sudokuReadFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuReadFile(*args):
        """
        ('const char', '*filename')       
  sudokuReadFile()

      Input:  filename (of formatted sudoku file)
      Return: array (of 81 numbers), or null on error

  Notes:
      (1) The file format has:
          * any number of comment lines beginning with '#'
          * a set of 9 lines, each having 9 digits (0-9) separated
            by a space


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuReadFile(*args)
    
    

    try:
        leptonica.sudokuGenerate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.sudokuGenerate.restype = lambda address: L_SUDOKU(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function sudokuGenerate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuGenerate(*args):
        """
        ('l_int32', '*array')       
('l_int32', 'seed')       
('l_int32', 'minelems')       
('l_int32', 'maxtries')       
  sudokuGenerate()

      Input:  array (of 81 numbers, 9 rows of 9 numbers each)
              seed (random number)
              minelems (min non-zero elements allowed; <= 80)
              maxtries (max tries to remove a number and get a valid sudoku)
      Return: l_sudoku, or null on error

  Notes:
      (1) This is a brute force generator.  It starts with a completed
          sudoku solution and, by removing elements (setting them to 0),
          generates a valid (unique) sudoku initial condition.
      (2) The process stops when either @minelems, the minimum
          number of non-zero elements, is reached, or when the
          number of attempts to remove the next element exceeds @maxtries.
      (3) No sudoku is known with less than 17 nonzero elements.


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuGenerate(*args)
    
    

    try:
        leptonica.sudokuReadString.argtypes = [ctypes.c_void_p]
        leptonica.sudokuReadString.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        os.stderr.write("Warning - function sudokuReadString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuReadString(*args):
        """
        ('const char', '*str')       
  sudokuReadString()

      Input:  str (of input data)
      Return: array (of 81 numbers), or null on error

  Notes:
      (1) The string is formatted as 81 single digits, each separated
          by 81 spaces.


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuReadString(*args)
    
    

    try:
        leptonica.sudokuDestroy.argtypes = [ctypes.c_void_p]
        leptonica.sudokuDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function sudokuDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuDestroy(*args):
        """
        ('L_SUDOKU', '**psud')       
  sudokuDestroy()

      Input:  &l_sudoku (<to be nulled>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuDestroy(*args)
    
    

    try:
        leptonica.sudokuSolve.argtypes = [ctypes.c_void_p]
        leptonica.sudokuSolve.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function sudokuSolve not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuSolve(*args):
        """
        ('L_SUDOKU', '*sud')       
  sudokuSolve()

      Input:  l_sudoku (starting in initial state)
      Return: 1 on success, 0 on failure to solve (note reversal of
              typical unix returns)


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuSolve(*args)
    




class jbclass(object):
    """ jbclass.c

     These are functions for unsupervised classification of
     collections of connected components -- either characters or
     words -- in binary images.  They can be used as image
     processing steps in jbig2 compression.

     Initialization

         JBCLASSER         *jbRankHausInit()      [rank hausdorff encoder]
         JBCLASSER         *jbCorrelationInit()   [correlation encoder]
         JBCLASSER         *jbCorrelationInitWithoutComponents()  [ditto]
         static JBCLASSER  *jbCorrelationInitInternal()

     Classify the pages

         l_int32     jbAddPages()
         l_int32     jbAddPage()
         l_int32     jbAddPageComponents()

     Rank hausdorff classifier

         l_int32     jbClassifyRankHaus()
         l_int32     pixHaustest()
         l_int32     pixRankHaustest()

     Binary correlation classifier

         l_int32     jbClassifyCorrelation()

     Determine the image components we start with

         l_int32     jbGetComponents()
         l_int32     pixWordMaskByDilation()
         l_int32     pixWordBoxesByDilation()

     Build grayscale composites (templates)

         PIXA       *jbAccumulateComposites
         PIXA       *jbTemplatesFromComposites

     Utility functions for Classer

         JBCLASSER  *jbClasserCreate()
         void        jbClasserDestroy()

     Utility functions for Data

         JBDATA     *jbDataSave()
         void        jbDataDestroy()
         l_int32     jbDataWrite()
         JBDATA     *jbDataRead()
         PIXA       *jbDataRender()
         l_int32     jbGetULCorners()
         l_int32     jbGetLLCorners()

     Static helpers

         static JBFINDCTX *findSimilarSizedTemplatesInit()
         static l_int32    findSimilarSizedTemplatesNext()
         static void       findSimilarSizedTemplatesDestroy()
         static l_int32    finalPositioningForAlignment()

     Note: this is NOT an implementation of the JPEG jbig2
     proposed standard encoder, the specifications for which
     can be found at http://www.jpeg.org/jbigpt2.html.
     (See below for a full implementation.)
     It is an implementation of the lower-level part of an encoder that:

        (1) identifies connected components that are going to be used
        (2) puts them in similarity classes (this is an unsupervised
            classifier), and
        (3) stores the result in a simple file format (2 files,
            one for templates and one for page/coordinate/template-index
            quartets).

     An actual implementation of the official jbig2 encoder could
     start with parts (1) and (2), and would then compress the quartets
     according to the standards requirements (e.g., Huffman or
     arithmetic coding of coordinate differences and image templates).

     The low-level part of the encoder provided here has the
     following useful features:

         - It is accurate in the identification of templates
           and classes because it uses a windowed hausdorff
           distance metric.
         - It is accurate in the placement of the connected
           components, doing a two step process of first aligning
           the the centroids of the template with those of each instance,
           and then making a further correction of up to +- 1 pixel
           in each direction to best align the templates.
         - It is fast because it uses a morphologically based
           matching algorithm to implement the hausdorff criterion,
           and it selects the patterns that are possible matches
           based on their size.

     We provide two different matching functions, one using Hausdorff
     distance and one using a simple image correlation.
     The Hausdorff method sometimes produces better results for the
     same number of classes, because it gives a relatively small
     effective weight to foreground pixels near the boundary,
     and a relatively  large weight to foreground pixels that are
     not near the boundary.  By effectively ignoring these boundary
     pixels, Hausdorff weighting corresponds better to the expected
     probabilities of the pixel values in a scanned image, where the
     variations in instances of the same printed character are much
     more likely to be in pixels near the boundary.  By contrast,
     the correlation method gives equal weight to all foreground pixels.

     For best results, use the correlation method.  Correlation takes
     the number of fg pixels in the AND of instance and template,
     divided by the product of the number of fg pixels in instance
     and template.  It compares this with a threshold that, in
     general, depends on the fractional coverage of the template.
     For heavy text, the threshold is raised above that for light
     text,  By using both these parameters (basic threshold and
     adjustment factor for text weight), one has more flexibility
     and can arrive at the fewest substitution errors, although
     this comes at the price of more templates.

     The strict Hausdorff scoring is not a rank weighting, because a
     single pixel beyond the given distance will cause a match
     failure.  A rank Hausdorff is more robust to non-boundary noise,
     but it is also more susceptible to confusing components that
     should be in different classes.  For implementing a jbig2
     application for visually lossless binary image compression,
     you have two choices:

        (1) use a 3x3 structuring element (size = 3) and a strict
            Hausdorff comparison (rank = 1.0 in the rank Hausdorff
            function).  This will result in a minimal number of classes,
            but confusion of small characters, such as italic and
            non-italic lower-case 'o', can still occur.
        (2) use the correlation method with a threshold of 0.85
            and a weighting factor of about 0.7.  This will result in
            a larger number of classes, but should not be confused
            either by similar small characters or by extremely
            thick sans serif characters, such as in prog/cootoots.png.

     As mentioned above, if visual substitution errors must be
     avoided, you should use the correlation method.

     We provide executables that show how to do the encoding:
         prog/jbrankhaus.c
         prog/jbcorrelation.c

     The basic flow for correlation classification goes as follows,
     where specific choices have been made for parameters (Hausdorff
     is the same except for initialization):

             // Initialize and save data in the classer
         JBCLASSER *classer =
             jbCorrelationInit(JB_CONN_COMPS, 0, 0, 0.8, 0.7);
         SARRAY *safiles = getSortedPathnamesInDirectory(directory,
                                                         NULL, 0, 0);
         jbAddPages(classer, safiles);

             // Save the data in a data structure for serialization,
             // and write it into two files.
         JBDATA *data = jbDataSave(classer);
         jbDataWrite(rootname, data);

             // Reconstruct (render) the pages from the encoded data.
         PIXA *pixa = jbDataRender(data, FALSE);

     Adam Langley has built a jbig2 standards-compliant encoder, the
     first one to appear in open source.  You can get this encoder at:
          http://www.imperialviolet.org/jbig2.html

     It uses arithmetic encoding throughout.  It encodes binary images
     losslessly with a single arithmetic coding over the full image.
     It also does both lossy and lossless encoding from connected
     components, using leptonica to generate the templates representing
     each cluster.

"""
    
    try:
        leptonica.jbGetLLCorners.argtypes = [ctypes.c_void_p]
        leptonica.jbGetLLCorners.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbGetLLCorners not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbGetLLCorners(*args):
        """
        ('JBCLASSER', '*classer')       
  jbGetLLCorners()

      Input:  jbclasser
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes the ptall field, which has the global LL corners,
          adjusted for each specific component, so that each component
          can be replaced by the template for its class and have the
          centroid in the template in the same position as the
          centroid of the original connected component. It is important
          that this be done properly to avoid a wavy baseline in the result.
      (2) It is computed here from the corresponding UL corners, where
          the input templates and stored instances are all bordered.
          This should be done after all pages have been processed.
      (3) For proper substitution, the templates whose LL corners are
          placed in these locations must be UN-bordered.
          This is available for a realistic jbig2 encoder, which would
          (1) encode each template without a border, and (2) encode
          the position using the LL corner (rather than the UL
          corner) because the difference between y-values
          of successive instances is typically close to zero.


        """
        args = _convert_params(*args)
        
        return leptonica.jbGetLLCorners(*args)
    
    

    try:
        leptonica.pixHaustest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHaustest.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixHaustest not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHaustest(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('PIX', '*pix3')       
('PIX', '*pix4')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
  pixHaustest()

      Input:  pix1   (new pix, not dilated)
              pix2   (new pix, dilated)
              pix3   (exemplar pix, not dilated)
              pix4   (exemplar pix, dilated)
              delx   (x comp of centroid difference)
              dely   (y comp of centroid difference)
              maxdiffw (max width difference of pix1 and pix2)
              maxdiffh (max height difference of pix1 and pix2)
      Return: 0 (FALSE) if no match, 1 (TRUE) if the new
              pix is in the same class as the exemplar.

  Note: we check first that the two pix are roughly
  the same size.  Only if they meet that criterion do
  we compare the bitmaps.  The Hausdorff is a 2-way
  check.  The centroid difference is used to align the two
  images to the nearest integer for each of the checks.
  These check that the dilated image of one contains
  ALL the pixels of the undilated image of the other.
  Checks are done in both direction.  A single pixel not
  contained in either direction results in failure of the test.


        """
        args = _convert_params(*args)
        
        return leptonica.pixHaustest(*args)
    
    

    try:
        leptonica.jbCorrelationInitWithoutComponents.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.jbCorrelationInitWithoutComponents.restype = lambda address: JBCLASSER(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbCorrelationInitWithoutComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbCorrelationInitWithoutComponents(*args):
        """
        ('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_float32', 'thresh')       
('l_float32', 'weightfactor')       
  jbCorrelationInitWithoutComponents()

      Input:  same as jbCorrelationInit
      Output: same as jbCorrelationInit

  Note: acts the same as jbCorrelationInit(), but the resulting
        object doesn't keep a list of all the components.


        """
        args = _convert_params(*args)
        
        return leptonica.jbCorrelationInitWithoutComponents(*args)
    
    

    try:
        leptonica.jbDataRender.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.jbDataRender.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbDataRender not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataRender(*args):
        """
        ('JBDATA', '*data')       
('l_int32', 'debugflag')       
  jbDataRender()

      Input:  jbdata
              debugflag (if TRUE, writes into 2 bpp pix and adds
                         component outlines in color)
      Return: pixa (reconstruction of original images, using templates) or
              null on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataRender(*args)
    
    

    try:
        leptonica.jbAccumulateComposites.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAccumulateComposites.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbAccumulateComposites not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAccumulateComposites(*args):
        """
        ('PIXAA', '*pixaa')       
('NUMA', '**pna')       
('PTA', '**pptat')       
  jbAccumulateComposites()

      Input:  pixaa (one pixa for each class)
              &pna (<return> number of samples used to build each composite)
              &ptat (<return> centroids of bordered composites)
      Return: pixad (accumulated sum of samples in each class),
                     or null on error



        """
        args = _convert_params(*args)
        
        return leptonica.jbAccumulateComposites(*args)
    
    

    try:
        leptonica.jbGetULCorners.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbGetULCorners.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbGetULCorners not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbGetULCorners(*args):
        """
        ('JBCLASSER', '*classer')       
('PIX', '*pixs')       
('BOXA', '*boxa')       
  jbGetULCorners()

      Input:  jbclasser
              pixs (full res image)
              boxa (of c.c. bounding rectangles for this page)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This computes the ptaul field, which has the global UL corners,
          adjusted for each specific component, so that each component
          can be replaced by the template for its class and have the
          centroid in the template in the same position as the
          centroid of the original connected component.  It is important
          that this be done properly to avoid a wavy baseline in the
          result.
      (2) The array fields ptac and ptact give the centroids of
          those components relative to the UL corner of each component.
          Here, we compute the difference in each component, round to
          nearest integer, and correct the box->x and box->y by
          the appropriate integral difference.
      (3) The templates and stored instances are all bordered.


        """
        args = _convert_params(*args)
        
        return leptonica.jbGetULCorners(*args)
    
    

    try:
        leptonica.jbClasserCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.jbClasserCreate.restype = lambda address: JBCLASSER(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbClasserCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbClasserCreate(*args):
        """
        ('l_int32', 'method')       
('l_int32', 'components')       
  jbClasserCreate()

      Input:  method (JB_RANKHAUS, JB_CORRELATION)
              components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)
      Return: jbclasser, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbClasserCreate(*args)
    
    

    try:
        leptonica.jbAddPages.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAddPages.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbAddPages not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAddPages(*args):
        """
        ('JBCLASSER', '*classer')       
('SARRAY', '*safiles')       
  jbAddPages()

      Input:  jbclasser
              safiles (of page image file names)
      Return: 0 if OK; 1 on error

  Note:
      (1) jbclasser makes a copy of the array of file names.
      (2) The caller is still responsible for destroying the input array.


        """
        args = _convert_params(*args)
        
        return leptonica.jbAddPages(*args)
    
    

    try:
        leptonica.jbRankHausInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.jbRankHausInit.restype = lambda address: JBCLASSER(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbRankHausInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbRankHausInit(*args):
        """
        ('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_int32', 'size')       
('l_float32', 'rank')       
  jbRankHausInit()

      Input:  components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)
              maxwidth (of component; use 0 for default)
              maxheight (of component; use 0 for default)
              size  (of square structuring element; 2, representing
                     2x2 sel, is necessary for reasonable accuracy of
                     small components; combine this with rank ~ 0.97
                     to avoid undue class expansion)
              rank (rank val of match, each way; in [0.5 - 1.0];
                    when using size = 2, 0.97 is a reasonable value)
      Return: jbclasser if OK; NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbRankHausInit(*args)
    
    

    try:
        leptonica.jbDataRead.argtypes = [ctypes.c_void_p]
        leptonica.jbDataRead.restype = lambda address: JBDATA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbDataRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataRead(*args):
        """
        ('const char', '*rootname')       
  jbDataRead()

      Input:  rootname (for template and data files)
      Return: jbdata, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataRead(*args)
    
    

    try:
        leptonica.jbDataSave.argtypes = [ctypes.c_void_p]
        leptonica.jbDataSave.restype = lambda address: JBDATA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbDataSave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataSave(*args):
        """
        ('JBCLASSER', '*classer')       
  jbDataSave()

      Input:  jbclasser
              latticew, latticeh (cell size used to store each
                  connected component in the composite)
      Return: jbdata, or null on error

  Notes:
      (1) This routine stores the jbig2-type data required for
          generating a lossy jbig2 version of the image.
          It can be losslessly written to (and read from) two files.
      (2) It generates and stores the mosaic of templates.
      (3) It clones the Numa and Pta arrays, so these must all
          be destroyed by the caller.
      (4) Input 0 to use the default values for latticew and/or latticeh,


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataSave(*args)
    
    

    try:
        leptonica.jbClassifyRankHaus.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbClassifyRankHaus.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbClassifyRankHaus not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbClassifyRankHaus(*args):
        """
        ('JBCLASSER', '*classer')       
('BOXA', '*boxa')       
('PIXA', '*pixas')       
  jbClassifyRankHaus()

      Input:  jbclasser
              boxa (of new components for classification)
              pixas (of new components for classification)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbClassifyRankHaus(*args)
    
    

    try:
        leptonica.jbDataWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbDataWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbDataWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataWrite(*args):
        """
        ('const char', '*rootout')       
('JBDATA', '*jbdata')       
  jbDataWrite()

      Input:  rootname (for output files; everything but the extension)
              jbdata
      Return: 0 if OK, 1 on error

  Notes:
      (1) Serialization function that writes data in jbdata to file.


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataWrite(*args)
    
    

    try:
        leptonica.jbAddPageComponents.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAddPageComponents.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbAddPageComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAddPageComponents(*args):
        """
        ('JBCLASSER', '*classer')       
('PIX', '*pixs')       
('BOXA', '*boxas')       
('PIXA', '*pixas')       
  jbAddPageComponents()

      Input:  jbclasser
              pixs (of input page)
              boxas (b.b. of components for this page)
              pixas (components for this page)
      Return: 0 if OK; 1 on error

  Notes:
      (1) If there are no components on the page, we don't require input
          of empty boxas or pixas, although that's the typical situation.


        """
        args = _convert_params(*args)
        
        return leptonica.jbAddPageComponents(*args)
    
    

    try:
        leptonica.jbAddPage.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAddPage.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbAddPage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAddPage(*args):
        """
        ('JBCLASSER', '*classer')       
('PIX', '*pixs')       
  jbAddPage()

      Input:  jbclasser
              pixs (of input page)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbAddPage(*args)
    
    

    try:
        leptonica.pixWordMaskByDilation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWordMaskByDilation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWordMaskByDilation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWordMaskByDilation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxdil')       
('PIX', '**ppixm')       
('l_int32', '*psize')       
  pixWordMaskByDilation()

      Input:  pixs (1 bpp; typ. at 75 to 150 ppi)
              maxdil (maximum dilation; 0 for default; warning if > 20)
              &mask (<optional return> dilated word mask)
              &size (<optional return> size of optimal horiz Sel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This gives a crude estimate of the word masks.  See
          pixWordBoxesByDilation() for further filtering of the word boxes.
      (2) For 75 to 150 ppi, the optimal dilation will be between 5 and 11.
          For 200 to 300 ppi, it is advisable to use a larger value
          for @maxdil, say between 10 and 20.  Setting maxdil <= 0
          results in a default dilation of 16.
      (3) The best size for dilating to get word masks is optionally returned.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWordMaskByDilation(*args)
    
    

    try:
        leptonica.jbGetComponents.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbGetComponents.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbGetComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbGetComponents(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxad')       
('PIXA', '**ppixad')       
  jbGetComponents()

      Input:  pixs (1 bpp)
              components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)
              maxwidth, maxheight (of saved components; larger are discarded)
              &pboxa (<return> b.b. of component items)
              &ppixa (<return> component items)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbGetComponents(*args)
    
    

    try:
        leptonica.jbTemplatesFromComposites.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbTemplatesFromComposites.restype = lambda address: PIXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbTemplatesFromComposites not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbTemplatesFromComposites(*args):
        """
        ('PIXA', '*pixac')       
('NUMA', '*na')       
  jbTemplatesFromComposites()

      Input:  pixac (one pix of composites for each class)
              na (number of samples used for each class composite)
      Return: pixad (8 bpp templates for each class), or null on error



        """
        args = _convert_params(*args)
        
        return leptonica.jbTemplatesFromComposites(*args)
    
    

    try:
        leptonica.jbCorrelationInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.jbCorrelationInit.restype = lambda address: JBCLASSER(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function jbCorrelationInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbCorrelationInit(*args):
        """
        ('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_float32', 'thresh')       
('l_float32', 'weightfactor')       
  jbCorrelationInit()

      Input:  components (JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS)
              maxwidth (of component; use 0 for default)
              maxheight (of component; use 0 for default)
              thresh (value for correlation score: in [0.4 - 0.98])
              weightfactor (corrects thresh for thick characters [0.0 - 1.0])
      Return: jbclasser if OK; NULL on error

  Notes:
      (1) For scanned text, suggested input values are:
            thresh ~ [0.8 - 0.85]
            weightfactor ~ [0.5 - 0.6]
      (2) For electronically generated fonts (e.g., rasterized pdf),
          a very high thresh (e.g., 0.95) will not cause a significant
          increase in the number of classes.


        """
        args = _convert_params(*args)
        
        return leptonica.jbCorrelationInit(*args)
    
    

    try:
        leptonica.pixRankHaustest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixRankHaustest.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixRankHaustest not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankHaustest(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('PIX', '*pix3')       
('PIX', '*pix4')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', 'area1')       
('l_int32', 'area3')       
('l_float32', 'rank')       
('l_int32', '*tab8')       
  pixRankHaustest()

      Input:  pix1   (new pix, not dilated)
              pix2   (new pix, dilated)
              pix3   (exemplar pix, not dilated)
              pix4   (exemplar pix, dilated)
              delx   (x comp of centroid difference)
              dely   (y comp of centroid difference)
              maxdiffw (max width difference of pix1 and pix2)
              maxdiffh (max height difference of pix1 and pix2)
              area1  (fg pixels in pix1)
              area3  (fg pixels in pix3)
              rank   (rank value of test, each way)
              tab8   (table of pixel sums for byte)
      Return: 0 (FALSE) if no match, 1 (TRUE) if the new
                 pix is in the same class as the exemplar.

  Note: we check first that the two pix are roughly
  the same size.  Only if they meet that criterion do
  we compare the bitmaps.  We convert the rank value to
  a number of pixels by multiplying the rank fraction by the number
  of pixels in the undilated image.  The Hausdorff is a 2-way
  check.  The centroid difference is used to align the two
  images to the nearest integer for each of the checks.
  The rank hausdorff checks that the dilated image of one
  contains the rank fraction of the pixels of the undilated
  image of the other.   Checks are done in both direction.
  Failure of the test in either direction results in failure
  of the test.


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankHaustest(*args)
    
    

    try:
        leptonica.pixWordBoxesByDilation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWordBoxesByDilation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWordBoxesByDilation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWordBoxesByDilation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxdil')       
('l_int32', 'minwidth')       
('l_int32', 'minheight')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxa')       
('l_int32', '*psize')       
  pixWordBoxesByDilation()

      Input:  pixs (1 bpp; typ. at 75 to 150 ppi)
              maxdil (maximum dilation; 0 for default; warning if > 20)
              minwidth, minheight (of saved components; smaller are discarded)
              maxwidth, maxheight (of saved components; larger are discarded)
              &boxa (<return> dilated word mask)
              &size (<optional return> size of optimal horiz Sel)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Returns a pruned set of word boxes.
      (2) See pixWordMaskByDilation().


        """
        args = _convert_params(*args)
        
        return leptonica.pixWordBoxesByDilation(*args)
    
    

    try:
        leptonica.jbClassifyCorrelation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbClassifyCorrelation.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function jbClassifyCorrelation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbClassifyCorrelation(*args):
        """
        ('JBCLASSER', '*classer')       
('BOXA', '*boxa')       
('PIXA', '*pixas')       
  jbClassifyCorrelation()

      Input:  jbclasser
              boxa (of new components for classification)
              pixas (of new components for classification)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbClassifyCorrelation(*args)
    




class bmpio(object):
    """  bmpio.c

      Read bmp from file
           PIX          *pixReadStreamBmp()

      Write bmp to file
           l_int32       pixWriteStreamBmp()

      Read/write to memory
           PIX          *pixReadMemBmp()
           l_int32       pixWriteMemBmp()

    On systems like windows without fmemopen() and open_memstream(),
    we write data to a temp file and read it back for operations
    between pix and compressed-data, such as pixReadMemPng() and
    pixWriteMemPng().

"""
    
    try:
        leptonica.pixWriteStreamBmp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamBmp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamBmp(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
  pixWriteStreamBmp()

      Input:  stream opened for write
              pix (1, 4, 8, 32 bpp)
      Return: 0 if OK, 1 on error

  Notes:
      (1) We position fp at the beginning of the stream, so it
          truncates any existing data
      (2) 2 bpp Bmp files are apparently not valid!.  We can
          write and read them, but nobody else can read ours.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamBmp(*args)
    
    

    try:
        leptonica.pixReadMemBmp.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemBmp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadMemBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemBmp(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
  pixReadMemBmp()

      Input:  cdata (const; bmp-encoded)
              size (of data)
      Return: pix, or null on error

  Notes:
      (1) The @size byte of @data must be a null character.


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemBmp(*args)
    
    

    try:
        leptonica.pixReadStreamBmp.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamBmp.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixReadStreamBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamBmp(*args):
        """
        ('FILE', '*fp')       
  pixReadStreamBmp()

      Input:  stream opened for read
      Return: pix, or null on error

  Notes:
      (1) Here are references on the bmp file format:
          http://en.wikipedia.org/wiki/BMP_file_format
          http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamBmp(*args)
    
    

    try:
        leptonica.pixWriteMemBmp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemBmp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemBmp(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
  pixWriteMemBmp()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixWriteStreamBmp() for usage.  This version writes to
          memory instead of to a file stream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemBmp(*args)
    




class ccthin(object):
    """  ccthin.c

     PIX    *pixThin()
     PIX    *pixThinGeneral()
     PIX    *pixThinExamples()

"""
    
    try:
        leptonica.pixThinExamples.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixThinExamples.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThinExamples not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThinExamples(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'index')       
('l_int32', 'maxiters')       
('const char', '*selfile')       
  pixThinExamples()

      Input:  pixs (1 bpp)
              type (L_THIN_FG, L_THIN_BG)
              index (into specific examples; valid 1-9; see notes)
              maxiters (max number of iters allowed; use 0 to iterate
                        until completion)
              selfile (<optional> filename for output sel display)
      Return: pixd, or null on error

  Notes:
      (1) See notes in pixThin().  The examples are taken from
          the paper referenced there.
      (2) Here we allow specific sets of HMTs to be used in
          parallel for thinning from each of four directions.
          One iteration consists of four such parallel thins.
      (3) The examples are indexed as follows:
          Thinning  (e.g., run to completion):
              index = 1     sel_4_1, sel_4_5, sel_4_6
              index = 2     sel_4_1, sel_4_7, sel_4_7_rot
              index = 3     sel_48_1, sel_48_1_rot, sel_48_2
              index = 4     sel_8_2, sel_8_3, sel_48_2
              index = 5     sel_8_1, sel_8_5, sel_8_6
              index = 6     sel_8_2, sel_8_3, sel_8_8, sel_8_9
              index = 7     sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot
          Thickening:
              index = 8     sel_4_2, sel_4_3 (e.g,, do just a few iterations)
              index = 9     sel_8_4 (e.g., do just a few iterations)


        """
        args = _convert_params(*args)
        
        return leptonica.pixThinExamples(*args)
    
    

    try:
        leptonica.pixThinGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixThinGeneral.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThinGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThinGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('SELA', '*sela')       
('l_int32', 'maxiters')       
  pixThinGeneral()

      Input:  pixs (1 bpp)
              type (L_THIN_FG, L_THIN_BG)
              sela (of Sels for parallel composite HMTs)
              maxiters (max number of iters allowed; use 0 to iterate
                        until completion)
      Return: pixd, or null on error

  Notes:
      (1) See notes in pixThin().  That function chooses among
          the best of the Sels for thinning.
      (2) This is a general function that takes a Sela of HMTs
          that are used in parallel for thinning from each
          of four directions.  One iteration consists of four
          such parallel thins.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThinGeneral(*args)
    
    

    try:
        leptonica.pixThin.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThin.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixThin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThin(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('l_int32', 'maxiters')       
  pixThin()

      Input:  pixs (1 bpp)
              type (L_THIN_FG, L_THIN_BG)
              connectivity (4 or 8)
              maxiters (max number of iters allowed; use 0 to iterate
                        until completion)
      Return: pixd, or null on error

  Notes:
      (1) See "Connectivity-preserving morphological image transformations,"
          Dan S. Bloomberg, in SPIE Visual Communications and Image
          Processing, Conference 1606, pp. 320-334, November 1991,
          Boston, MA.   A web version is available at
              http://www.leptonica.com/papers/conn.pdf
      (2) We implement here two of the best iterative
          morphological thinning algorithms, for 4 c.c and 8 c.c.
          Each iteration uses a mixture of parallel operations
          (using several different 3x3 Sels) and serial operations.
          Specifically, each thinning iteration consists of
          four sequential thinnings from each of four directions.
          Each of these thinnings is a parallel composite
          operation, where the union of a set of HMTs are set
          subtracted from the input.  For 4-cc thinning, we
          use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.
      (3) A "good" thinning algorithm is one that generates a skeleton
          that is near the medial axis and has neither pruned
          real branches nor left extra dendritic branches.
      (4) To thin the foreground, which is the usual situation,
          use type == L_THIN_FG.  Thickening the foreground is equivalent
          to thinning the background (type == L_THIN_BG), where the
          opposite connectivity gets preserved.  For example, to thicken
          the fg using 4-connectivity, we thin the bg using Sels that
          preserve 8-connectivity.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThin(*args)
    




class partition(object):
    """   partition.c

      Whitespace block extraction
          BOXA            *boxaGetWhiteblocks()

      Helpers
          static PARTEL   *partelCreate()
          static void      partelDestroy()
          static l_int32   partelSetSize()
          static BOXA     *boxaGenerateSubboxes()
          static BOX      *boxaSelectPivotBox()
          static l_int32   boxaCheckIfOverlapIsSmall()
          BOXA            *boxaPruneSortedOnOverlap()

"""
    
    try:
        leptonica.boxaPruneSortedOnOverlap.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.boxaPruneSortedOnOverlap.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaPruneSortedOnOverlap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaPruneSortedOnOverlap(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'maxoverlap')       
  boxaPruneSortedOnOverlap()

      Input:  boxas (sorted by size in decreasing order)
              maxoverlap (maximum fractional overlap of a box by any
                          of the larger boxes)
      Return: boxad (pruned), or null on error

  Notes:
      (1) This selectively removes smaller boxes when they are overlapped
          by any larger box by more than the input 'maxoverlap' fraction.
      (2) To avoid all pruning, use maxoverlap = 1.0.  To select only
          boxes that have no overlap with each other (maximal pruning),
          set maxoverlap = 0.0.
      (3) If there are no boxes in boxas, returns an empty boxa.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaPruneSortedOnOverlap(*args)
    
    

    try:
        leptonica.boxaGetWhiteblocks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaGetWhiteblocks.restype = lambda address: BOXA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function boxaGetWhiteblocks not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetWhiteblocks(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       
('l_int32', 'sortflag')       
('l_int32', 'maxboxes')       
('l_float32', 'maxoverlap')       
('l_int32', 'maxperim')       
('l_float32', 'fract')       
('l_int32', 'maxpops')       
  boxaGetWhiteblocks()

      Input:  boxas (typically, a set of bounding boxes of fg components)
              box (initial region; typically including all boxes in boxas;
                   if null, it computes the region to include all boxes
                   in boxas)
              sortflag (L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,
                        L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,
                        L_SORT_BY_PERIMETER, L_SORT_BY_AREA)
              maxboxes (maximum number of output whitespace boxes; e.g., 100)
              maxoverlap (maximum fractional overlap of a box by any
                          of the larger boxes; e.g., 0.2)
              maxperim (maximum half-perimeter, in pixels, for which
                        pivot is selected by proximity to box centroid;
                        e.g., 200)
              fract (fraction of box diagonal that is an acceptable
                     distance from the box centroid to select the pivot;
                     e.g., 0.2)
              maxpops (maximum number of pops from the heap; use 0 as default)
      Return: boxa (of sorted whitespace boxes), or null on error

  Notes:
      (1) This uses the elegant Breuel algorithm, found in "Two
          Geometric Algorithms for Layout Analysis", 2002,
          url: "citeseer.ist.psu.edu/breuel02two.html".
          It starts with the bounding boxes (b.b.) of the connected
          components (c.c.) in a region, along with the rectangle
          representing that region.  It repeatedly divides the
          rectangle into four maximal rectangles that exclude a
          pivot rectangle, sorting them in a priority queue
          according to one of the six sort flags.  It returns a boxa
          of the "largest" set that have no intersection with boxes
          from the input boxas.
      (2) If box == NULL, the initial region is the minimal region
          that includes the origin and every box in boxas.
      (3) maxboxes is the maximum number of whitespace boxes that will
          be returned.  The actual number will depend on the image
          and the values chosen for maxoverlap and maxpops.  In many
          cases, the actual number will be 'maxboxes'.
      (4) maxoverlap allows pruning of whitespace boxes depending on
          the overlap.  To avoid all pruning, use maxoverlap = 1.0.
          To select only boxes that have no overlap with each other
          (maximal pruning), choose maxoverlap = 0.0.
          Otherwise, no box can have more than the 'maxoverlap' fraction
          of its area overlapped by any larger (in the sense of the
          sortflag) box.
      (5) Choose maxperim (actually, maximum half-perimeter) to
          represent a c.c. that is small enough so that you don't care
          about the white space that could be inside of it.  For all such
          c.c., the pivot for 'quadfurcation' of a rectangle is selected
          as having a reasonable proximity to the rectangle centroid.
      (6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
          to choose the small box nearest the centroid as the pivot.
          If you choose fract > 0.0, it is suggested that you call
          boxaPermuteRandom() first, to permute the boxes (see usage below).
          This should reduce the search time for each of the pivot boxes.
      (7) Choose maxpops to be the maximum number of rectangles that
          are popped from the heap.  This is an indirect way to limit the
          execution time.  Use 0 for default (a fairly large number).
          At any time, you can expect the heap to contain about
          2.5 times as many boxes as have been popped off.
      (8) The output result is a sorted set of overlapping
          boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.
      (9) The main defect of the method is that it abstracts out the
          actual components, retaining only the b.b. for analysis.
          Consider a component with a large b.b.  If this is chosen
          as a pivot, all white space inside is immediately taken
          out of consideration.  Furthermore, even if it is never chosen
          as a pivot, as the partitioning continues, at no time will
          any of the whitespace inside this component be part of a
          rectangle with zero overlapping boxes.  Thus, the interiors
          of all boxes are necessarily excluded from the union of
          the returned whitespace boxes.
     (10) USAGE: One way to accommodate to this weakness is to remove such
          large b.b. before starting the computation.  For example,
          if 'box' is an input image region containing 'boxa' b.b. of c.c.:

                   // Faster pivot choosing
               boxaPermuteRandom(boxa, boxa);

                   // Remove anything either large width or height
               boxat = boxaSelectBySize(boxa, maxwidth, maxheight,
                                        L_SELECT_IF_BOTH, L_SELECT_IF_LT,
                                        NULL);

               boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,
                                          maxoverlap, maxperim, fract,
                                          maxpops);

          The result will be rectangular regions of "white space" that
          extend into (and often through) the excluded components.
     (11) As a simple example, suppose you wish to find the columns on a page.
          First exclude large c.c. that may block the columns, and then call:

               boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,
                                          20, 0.15, 200, 0.2, 2000);

          to get the 20 tallest boxes with no more than 0.15 overlap
          between a box and any of the taller ones, and avoiding the
          use of any c.c. with a b.b. half perimeter greater than 200
          as a pivot.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetWhiteblocks(*args)
    




class jpegiostub(object):
    """  jpegiostub.c

     Stubs for jpegio.c functions

"""
    



class binarize(object):
    """  binarize.c

  ===================================================================
  Image binarization algorithms are found in:
    grayquant.c:   standard, simple, general grayscale quantization
    adaptmap.c:    local adaptive; mostly gray-to-gray in preparation
                   for binarization
    binarize.c:    special binarization methods, locally adaptive and
                   global.
  ===================================================================

      Adaptive Otsu-based thresholding
          l_int32    pixOtsuAdaptiveThreshold()       8 bpp

      Otsu thresholding on adaptive background normalization
          PIX       *pixOtsuThreshOnBackgroundNorm()  8 bpp

      Masking and Otsu estimate on adaptive background normalization
          PIX       *pixMaskedThreshOnBackgroundNorm()  8 bpp

      Sauvola local thresholding
          l_int32    pixSauvolaBinarizeTiled()
          l_int32    pixSauvolaBinarize()
          PIX       *pixSauvolaGetThreshold()
          PIX       *pixApplyLocalThreshold();

      Thresholding using connected components
          PIX       *pixThresholdByConnComp()

  Notes:
      (1) pixOtsuAdaptiveThreshold() computes a global threshold over each
          tile and performs the threshold operation, resulting in a
          binary image for each tile.  These are stitched into the
          final result.
      (2) pixOtsuThreshOnBackgroundNorm() and
          pixMaskedThreshOnBackgroundNorm() are binarization functions
          that use background normalization with other techniques.
      (3) Sauvola binarization computes a local threshold based on
          the local average and square average.  It takes two constants:
          the window size for the measurment at each pixel and a
          parameter that determines the amount of normalized local
          standard deviation to subtract from the local average value.
      (4) pixThresholdByCC() uses the numbers of 4 and 8 connected
          components at different thresholding to determine if a
          global threshold can be used (for text or line-art) and the
          value it should have.

"""
    
    try:
        leptonica.pixSauvolaBinarizeTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSauvolaBinarizeTiled.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSauvolaBinarizeTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSauvolaBinarizeTiled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'whsize')       
('l_float32', 'factor')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('PIX', '**ppixth')       
('PIX', '**ppixd')       
  pixSauvolaBinarizeTiled()

      Input:  pixs (8 bpp grayscale, not colormapped)
              whsize (window half-width for measuring local statistics)
              factor (factor for reducing threshold due to variance; >= 0)
              nx, ny (subdivision into tiles; >= 1)
              &pixth (<optional return> Sauvola threshold values)
              &pixd (<optional return> thresholded image)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The window width and height are 2 * @whsize + 1.  The minimum
          value for @whsize is 2; typically it is >= 7..
      (2) For nx == ny == 1, this defaults to pixSauvolaBinarize().
      (3) Why a tiled version?
          (a) Because the mean value accumulator is a uint32, overflow
              can occur for an image with more than 16M pixels.
          (b) The mean value accumulator array for 16M pixels is 64 MB.
              The mean square accumulator array for 16M pixels is 128 MB.
              Using tiles reduces the size of these arrays.
          (c) Each tile can be processed independently, in parallel,
              on a multicore processor.
      (4) The Sauvola threshold is determined from the formula:
              t = m * (1 - k * (1 - s / 128))
          See pixSauvolaBinarize() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSauvolaBinarizeTiled(*args)
    
    

    try:
        leptonica.pixOtsuAdaptiveThreshold.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOtsuAdaptiveThreshold.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixOtsuAdaptiveThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOtsuAdaptiveThreshold(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'scorefract')       
('PIX', '**ppixth')       
('PIX', '**ppixd')       
  pixOtsuAdaptiveThreshold()

      Input:  pixs (8 bpp)
              sx, sy (desired tile dimensions; actual size may vary)
              smoothx, smoothy (half-width of convolution kernel applied to
                                threshold array: use 0 for no smoothing)
              scorefract (fraction of the max Otsu score; typ. 0.1;
                          use 0.0 for standard Otsu)
              &pixth (<optional return> array of threshold values
                      found for each tile)
              &pixd (<optional return> thresholded input pixs, based on
                     the threshold array)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The Otsu method finds a single global threshold for an image.
          This function allows a locally adapted threshold to be
          found for each tile into which the image is broken up.
      (2) The array of threshold values, one for each tile, constitutes
          a highly downscaled image.  This array is optionally
          smoothed using a convolution.  The full width and height of the
          convolution kernel are (2 * @smoothx + 1) and (2 * @smoothy + 1).
      (3) The minimum tile dimension allowed is 16.  If such small
          tiles are used, it is recommended to use smoothing, because
          without smoothing, each small tile determines the splitting
          threshold independently.  A tile that is entirely in the
          image bg will then hallucinate fg, resulting in a very noisy
          binarization.  The smoothing should be large enough that no
          tile is only influenced by one type (fg or bg) of pixels,
          because it will force a split of its pixels.
      (4) To get a single global threshold for the entire image, use
          input values of @sx and @sy that are larger than the image.
          For this situation, the smoothing parameters are ignored.
      (5) The threshold values partition the image pixels into two classes:
          one whose values are less than the threshold and another
          whose values are greater than or equal to the threshold.
          This is the same use of 'threshold' as in pixThresholdToBinary().
      (6) The scorefract is the fraction of the maximum Otsu score, which
          is used to determine the range over which the histogram minimum
          is searched.  See numaSplitDistribution() for details on the
          underlying method of choosing a threshold.
      (7) This uses enables a modified version of the Otsu criterion for
          splitting the distribution of pixels in each tile into a
          fg and bg part.  The modification consists of searching for
          a minimum in the histogram over a range of pixel values where
          the Otsu score is within a defined fraction, @scorefract,
          of the max score.  To get the original Otsu algorithm, set
          @scorefract == 0.
      (8) N.B. This method is NOT recommended for images with weak text
          and significant background noise, such as bleedthrough, because
          of the problem noted in (3) above for tiling.  Use Sauvola.


        """
        args = _convert_params(*args)
        
        return leptonica.pixOtsuAdaptiveThreshold(*args)
    
    

    try:
        leptonica.pixThresholdByConnComp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixThresholdByConnComp.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixThresholdByConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdByConnComp(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'start')       
('l_int32', 'end')       
('l_int32', 'incr')       
('l_float32', 'thresh48')       
('l_float32', 'threshdiff')       
('l_int32', '*pglobthresh')       
('PIX', '**ppixd')       
('l_int32', 'debugflag')       
  pixThresholdByConnComp()

      Input:  pixs (depth > 1, colormap OK)
              pixm (<optional> 1 bpp mask giving region to ignore by setting
                    pixels to white; use NULL if no mask)
              start, end, incr (binarization threshold levels to test)
              thresh48 (threshold on normalized difference between the
                        numbers of 4 and 8 connected components)
              threshdiff (threshold on normalized difference between the
                          number of 4 cc at successive iterations)
              &globthresh (<optional return> best global threshold; 0
                           if no threshold is found)
              &pixd (<optional return> image thresholded to binary, or
                     null if no threshold is found)
              debugflag (1 for plotted results)
      Return: 0 if OK, 1 on error or if no threshold is found

  Notes:
      (1) This finds a global threshold based on connected components.
          Although slow, it is reasonable to use it in a situation where
          (a) the background in the image is relatively uniform, and
          (b) the result will be fed to an OCR program that accepts 1 bpp
              images and works best with easily segmented characters.
          The reason for (b) is that this selects a threshold with a
          minimum number of both broken characters and merged characters.
      (2) If the pix has color, it is converted to gray using the
          max component.
      (3) Input 0 to use default values for any of these inputs:
          @start, @end, @incr, @thresh48, @threshdiff.
      (4) This approach can be understood as follows.  When the
          binarization threshold is varied, the numbers of c.c. identify
          four regimes:
          (a) For low thresholds, text is broken into small pieces, and
              the number of c.c. is large, with the 4 c.c. significantly
              exceeding the 8 c.c.
          (b) As the threshold rises toward the optimum value, the text
              characters coalesce and there is very little difference
              between the numbers of 4 and 8 c.c, which both go
              through a minimum.
          (c) Above this, the image background gets noisy because some
              pixels are(thresholded to foreground, and the numbers
              of c.c. quickly increase, with the 4 c.c. significantly
              larger than the 8 c.c.
          (d) At even higher thresholds, the image background noise
              coalesces as it becomes mostly foreground, and the
              number of c.c. drops quickly.
      (5) If there is no global threshold that distinguishes foreground
          text from background (e.g., weak text over a background that
          has significant variation and/or bleedthrough), this returns 1,
          which the caller should check.


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdByConnComp(*args)
    
    

    try:
        leptonica.pixSauvolaBinarize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSauvolaBinarize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixSauvolaBinarize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSauvolaBinarize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'whsize')       
('l_float32', 'factor')       
('l_int32', 'addborder')       
('PIX', '**ppixm')       
('PIX', '**ppixsd')       
('PIX', '**ppixth')       
('PIX', '**ppixd')       
  pixSauvolaBinarize()

      Input:  pixs (8 bpp grayscale; not colormapped)
              whsize (window half-width for measuring local statistics)
              factor (factor for reducing threshold due to variance; >= 0)
              addborder (1 to add border of width (@whsize + 1) on all sides)
              &pixm (<optional return> local mean values)
              &pixsd (<optional return> local standard deviation values)
              &pixth (<optional return> threshold values)
              &pixd (<optional return> thresholded image)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The window width and height are 2 * @whsize + 1.  The minimum
          value for @whsize is 2; typically it is >= 7..
      (2) The local statistics, measured over the window, are the
          average and standard deviation.
      (3) The measurements of the mean and standard deviation are
          performed inside a border of (@whsize + 1) pixels.  If pixs does
          not have these added border pixels, use @addborder = 1 to add
          it here; otherwise use @addborder = 0.
      (4) The Sauvola threshold is determined from the formula:
            t = m * (1 - k * (1 - s / 128))
          where:
            t = local threshold
            m = local mean
            k = @factor (>= 0)   [ typ. 0.35 ]
            s = local standard deviation, which is maximized at
                127.5 when half the samples are 0 and half are 255.
      (5) The basic idea of Niblack and Sauvola binarization is that
          the local threshold should be less than the median value,
          and the larger the variance, the closer to the median
          it should be chosen.  Typical values for k are between
          0.2 and 0.5.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSauvolaBinarize(*args)
    
    

    try:
        leptonica.pixApplyLocalThreshold.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixApplyLocalThreshold.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixApplyLocalThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyLocalThreshold(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixth')       
('l_int32', 'redfactor')       
  pixApplyLocalThreshold()

      Input:  pixs (8 bpp grayscale; not colormapped)
              pixth (8 bpp array of local thresholds)
              redfactor ( ... )
      Return: pixd (1 bpp, thresholded image), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyLocalThreshold(*args)
    
    

    try:
        leptonica.pixMaskedThreshOnBackgroundNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixMaskedThreshOnBackgroundNorm.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMaskedThreshOnBackgroundNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskedThreshOnBackgroundNorm(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'scorefract')       
('l_int32', '*pthresh')       
  pixMaskedThreshOnBackgroundNorm()

      Input:  pixs (8 bpp grayscale; not colormapped)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              smoothx (half-width of block convolution kernel width)
              smoothy (half-width of block convolution kernel height)
              scorefract (fraction of the max Otsu score; typ. ~ 0.1)
              &thresh (<optional return> threshold value that was
                       used on the normalized image)
      Return: pixd (1 bpp thresholded image), or null on error

  Notes:
      (1) This begins with a standard background normalization.
          Additionally, there is a flexible background norm, that
          will adapt to a rapidly varying background, and this
          puts white pixels in the background near regions with
          significant foreground.  The white pixels are turned into
          a 1 bpp selection mask by binarization followed by dilation.
          Otsu thresholding is performed on the input image to get an
          estimate of the threshold in the non-mask regions.
          The background normalized image is thresholded with two
          different values, and the result is combined using
          the selection mask.
      (2) Note that the numbers 255 (for bgval target) and 190 (for
          thresholding on pixn) are tied together, and explicitly
          defined in this function.
      (3) See pixBackgroundNorm() for meaning and typical values
          of input parameters.  For a start, you can try:
            sx, sy = 10, 15
            thresh = 100
            mincount = 50
            smoothx, smoothy = 2


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskedThreshOnBackgroundNorm(*args)
    
    

    try:
        leptonica.pixSauvolaGetThreshold.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixSauvolaGetThreshold.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSauvolaGetThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSauvolaGetThreshold(*args):
        """
        ('PIX', '*pixm')       
('PIX', '*pixms')       
('l_float32', 'factor')       
('PIX', '**ppixsd')       
  pixSauvolaGetThreshold()

      Input:  pixm (8 bpp grayscale; not colormapped)
              pixms (32 bpp)
              factor (factor for reducing threshold due to variance; >= 0)
              &pixsd (<optional return> local standard deviation)
      Return: pixd (8 bpp, sauvola threshold values), or null on error

  Notes:
      (1) The Sauvola threshold is determined from the formula:
            t = m * (1 - k * (1 - s / 128))
          where:
            t = local threshold
            m = local mean
            k = @factor (>= 0)   [ typ. 0.35 ]
            s = local standard deviation, which is maximized at
                127.5 when half the samples are 0 and half are 255.
      (2) See pixSauvolaBinarize() for other details.
      (3) Important definitions and relations for computing averages:
            v == pixel value
            E(p) == expected value of p == average of p over some pixel set
            S(v) == square of v == v * v
            mv == E(v) == expected pixel value == mean value
            ms == E(S(v)) == expected square of pixel values
               == mean square value
            var == variance == expected square of deviation from mean
                == E(S(v - mv)) = E(S(v) - 2 * S(v * mv) + S(mv))
                                = E(S(v)) - S(mv)
                                = ms - mv * mv
            s == standard deviation = sqrt(var)
          So for evaluating the standard deviation in the Sauvola
          threshold, we take
            s = sqrt(ms - mv * mv)


        """
        args = _convert_params(*args)
        
        return leptonica.pixSauvolaGetThreshold(*args)
    
    

    try:
        leptonica.pixOtsuThreshOnBackgroundNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixOtsuThreshOnBackgroundNorm.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixOtsuThreshOnBackgroundNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOtsuThreshOnBackgroundNorm(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'scorefract')       
('l_int32', '*pthresh')       
  pixOtsuThreshOnBackgroundNorm()

      Input:  pixs (8 bpp grayscale; not colormapped)
              pixim (<optional> 1 bpp 'image' mask; can be null)
              sx, sy (tile size in pixels)
              thresh (threshold for determining foreground)
              mincount (min threshold on counts in a tile)
              bgval (target bg val; typ. > 128)
              smoothx (half-width of block convolution kernel width)
              smoothy (half-width of block convolution kernel height)
              scorefract (fraction of the max Otsu score; typ. 0.1)
              &thresh (<optional return> threshold value that was
                       used on the normalized image)
      Return: pixd (1 bpp thresholded image), or null on error

  Notes:
      (1) This does background normalization followed by Otsu
          thresholding.  Otsu binarization attempts to split the
          image into two roughly equal sets of pixels, and it does
          a very poor job when there are large amounts of dark
          background.  By doing a background normalization first,
          to get the background near 255, we remove this problem.
          Then we use a modified Otsu to estimate the best global
          threshold on the normalized image.
      (2) See pixBackgroundNorm() for meaning and typical values
          of input parameters.  For a start, you can try:
            sx, sy = 10, 15
            thresh = 100
            mincount = 50
            bgval = 255
            smoothx, smoothy = 2


        """
        args = _convert_params(*args)
        
        return leptonica.pixOtsuThreshOnBackgroundNorm(*args)
    




class pixtiling(object):
    """   pixtiling.c

        PIXTILING       *pixTilingCreate()
        void            *pixTilingDestroy()
        l_int32          pixTilingGetCount()
        l_int32          pixTilingGetSize()
        PIX             *pixTilingGetTile()
        l_int32          pixTilingNoStripOnPaint()
        l_int32          pixTilingPaintTile()


   This provides a simple way to split an image into tiles
   and to perform operations independently on each tile.

   The tile created with pixTilingGetTile() can have pixels in
   adjacent tiles for computation.  The number of extra pixels
   on each side of the tile is given by an 'overlap' parameter
   to pixTilingCreate().  For tiles at the boundary of
   the input image, quasi-overlap pixels are created by reflection
   symmetry into the tile.

   Here's a typical intended usage.  Suppose you want to parallelize
   the operation on an image, by operating on tiles.  For each
   tile, you want to generate an in-place image result at the same
   resolution.  Suppose you choose a one-dimensional vertical tiling,
   where the desired tile width is 256 pixels and the overlap is
   30 pixels on left and right sides:

     PIX *pixd = pixCreateTemplateNoInit(pixs);  // output
     PIXTILING  *pt = pixTilingCreate(pixs, 0, 1, 256, 30, 0);
     pixTilingGetCount(pt, &nx, NULL);
     for (j = 0; j < nx; j++) {
         PIX *pixt = pixTilingGetTile(pt, 0, j);
         SomeInPlaceOperation(pixt, 30, 0, ...);
         pixTilingPaintTile(pixd, 0, j, pixt, pt);
         pixDestroy(&pixt);
     }

   In this example, note the following:
    - The unspecfified in-place operation could instead generate
      a new pix.  If this is done, the resulting pix must be the
      same size as pixt, because pixTilingPaintTile() makes that
      assumption, removing the overlap pixels before painting
      into the destination.
    - The 'overlap' parameters have been included in your function,
      to indicate which pixels are not in the exterior overlap region.
      You will need to change only pixels that are not in the overlap
      region, because those are the pixels that will be painted
      into the destination.
    - For tiles on the outside of the image, mirrored pixels are
      added to substitute for the overlap that is added to interior
      tiles.  This allows you to implement your function without
      reference to which tile it is; no special coding is necessary
      for pixels that are near the image boundary.
    - The tiles are labeled by (i, j) = (row, column),
      and in this example there is one row and nx columns.

"""
    
    try:
        leptonica.pixTilingDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixTilingDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function pixTilingDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingDestroy(*args):
        """
        ('PIXTILING', '**ppt')       
  pixTilingDestroy()

      Input:  &pt (<will be set to null before returning>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingDestroy(*args)
    
    

    try:
        leptonica.pixTilingCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTilingCreate.restype = lambda address: PIXTILING(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixTilingCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingCreate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'xoverlap')       
('l_int32', 'yoverlap')       
  pixTilingCreate()

      Input:  pixs  (pix to be tiled; any depth; colormap OK)
              nx    (number of tiles across image)
              ny    (number of tiles down image)
              w     (desired width of each tile)
              h     (desired height of each tile)
              overlap (amount of overlap into neighboring tile on each side)
      Return: pixtiling, or null on error

  Notes:
      (1) We put a clone of pixs in the PixTiling.
      (2) The input to pixTilingCreate() for horizontal tiling can be
          either the number of tiles across the image or the approximate
          width of the tiles.  If the latter, the actual width will be
          determined by making all tiles but the last of equal width, and
          making the last as close to the others as possible.  The same
          consideration is applied independently to the vertical tiling.
          To specify tile width, set nx = 0; to specify the number of
          tiles horizontally across the image, set w = 0.
      (3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for
          vertical strips and nx = 1 for horizontal strips.
      (4) The overlap must not be larger than the width or height of
          the leftmost or topmost tile(s).


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingCreate(*args)
    
    

    try:
        leptonica.pixTilingGetSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTilingGetSize.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTilingGetSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingGetSize(*args):
        """
        ('PIXTILING', '*pt')       
('l_int32', '*pw')       
('l_int32', '*ph')       
  pixTilingGetSize()

      Input:  pt (pixtiling)
              &w (<optional return> tile width; can be null)
              &h (<optional return> tile height; can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingGetSize(*args)
    
    

    try:
        leptonica.pixTilingGetTile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTilingGetTile.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixTilingGetTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingGetTile(*args):
        """
        ('PIXTILING', '*pt')       
('l_int32', 'i')       
('l_int32', 'j')       
  pixTilingGetTile()

      Input:  pt (pixtiling)
              i (tile row index)
              j (tile column index)
      Return: pixd (tile with appropriate boundary (overlap) pixels added),
                    or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingGetTile(*args)
    
    

    try:
        leptonica.pixTilingPaintTile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTilingPaintTile.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTilingPaintTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingPaintTile(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'i')       
('l_int32', 'j')       
('PIX', '*pixs')       
('PIXTILING', '*pt')       
  pixTilingPaintTile()

      Input:  pixd (dest: paint tile onto this, without overlap)
              i (tile row index)
              j (tile column index)
              pixs (source: tile to be painted from)
              pt (pixtiling struct)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingPaintTile(*args)
    
    

    try:
        leptonica.pixTilingGetCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTilingGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTilingGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingGetCount(*args):
        """
        ('PIXTILING', '*pt')       
('l_int32', '*pnx')       
('l_int32', '*pny')       
  pixTilingGetCount()

      Input:  pt (pixtiling)
              &nx (<optional return> nx; can be null)
              &ny (<optional return> ny; can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingGetCount(*args)
    
    

    try:
        leptonica.pixTilingNoStripOnPaint.argtypes = [ctypes.c_void_p]
        leptonica.pixTilingNoStripOnPaint.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixTilingNoStripOnPaint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingNoStripOnPaint(*args):
        """
        ('PIXTILING', '*pt')       
  pixTilingNoStripOnPaint()

      Input:  pt (pixtiling)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The default for paint is to strip out the overlap pixels
          that are added by pixTilingGetTile().  However, some
          operations will generate an image with these pixels
          stripped off.  This tells the paint operation not
          to strip the added boundary pixels when painting.


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingNoStripOnPaint(*args)
    




class endiantest(object):
    """    endiantest.c

    This test was contributed by Bill Janssen.  When used with the
    gnu compiler, it allows efficient computation of the endian
    flag as part of the normal compilation process.  As a result,
    it is not necessary to set this flag either manually or
    through the configure Makefile generator.

"""
    



class psio1(object):
    """  psio1.c

    |=============================================================|
    |                         Important note                      |
    |=============================================================|
    | Some of these functions require libtiff, libjpeg and libz.  |
    | If you do not have these libraries, you must set            |
    |     #define  USE_PSIO     0                                 |
    | in environ.h.  This will link psio1stub.c                   |
    |=============================================================|

     This is a PostScript "device driver" for wrapping images
     in PostScript.  The images can be rendered by a PostScript
     interpreter for viewing, using evince or gv.  They can also be
     rasterized for printing, using gs or an embedded interpreter
     in a PostScript printer.  And they can be converted to a pdf
     using gs (ps2pdf).

     Convert specified files to PS
          l_int32          convertFilesToPS()
          l_int32          sarrayConvertFilesToPS()
          l_int32          convertFilesFittedToPS()
          l_int32          sarrayConvertFilesFittedToPS()
          l_int32          writeImageCompressedToPSFile()

     Convert mixed text/image files to PS
          l_int32          convertSegmentedPagesToPS()
          l_int32          pixWriteSegmentedPageToPS()
          l_int32          pixWriteMixedToPS()

     Convert any image file to PS for embedding
          l_int32          convertToPSEmbed()

     Write all images in a pixa out to PS
          l_int32          pixaWriteCompressedToPS()

  These PostScript converters are used in three different ways.

  (1) For embedding a PS file in a program like TeX.
      convertToPSEmbed() handles this for levels 1, 2 and 3 output,
      and prog/converttops wraps this in an executable.
      converttops is a generalization of Thomas Merz's jpeg2ps wrapper,
      in that it works for all types (formats, depth, colormap)
      of input images and gives PS output in one of these formats
        * level 1 (uncompressed)
        * level 2 (compressed ccittg4 or dct)
        * level 3 (compressed flate)

  (2) For composing a set of pages with any number of images
      painted on them, in either level 2 or level 3 formats.

  (3) For printing a page image or a set of page images, at a
      resolution that optimally fills the page, using
      convertFilesFittedToPS().

  The top-level calls of utilities in category 2, which can compose
  multiple images on a page, and which generate a PostScript file for
  printing or display (e.g., conversion to pdf), are:
      convertFilesToPS()
      convertFilesFittedToPS()
      convertSegmentedPagesToPS()

  All images are output with page numbers.  Bounding box hints are
  more subtle.  They must be included for embeding images in
  TeX, for example, and the low-level writers include bounding
  box hints by default.  However, these hints should not be included for
  multi-page PostScript that is composed of a sequence of images;
  consequently, they are not written when calling higher level
  functions such as convertFilesToPS(), convertFilesFittedToPS()
  and convertSegmentedPagesToPS().  The function l_psWriteBoundingBox()
  sets a flag to give low-level control over this.

"""
    



class psio2(object):
    """  psio2.c

    |=============================================================|
    |                         Important note                      |
    |=============================================================|
    | Some of these functions require libtiff, libjpeg and libz.  |
    | If you do not have these libraries, you must set            |
    |     #define  USE_PSIO     0                                 |
    | in environ.h.  This will link psio2stub.c                   |
    |=============================================================|

     These are lower-level functions that implement a PostScript
     "device driver" for wrapping images in PostScript.  The images
     can be rendered by a PostScript interpreter for viewing,
     using evince or gv.  They can also be rasterized for printing,
     using gs or an embedded interpreter in a PostScript printer.
     And they can be converted to a pdf using gs (ps2pdf).

     For uncompressed images
          l_int32              pixWritePSEmbed()
          l_int32              pixWriteStreamPS()
          char                *pixWriteStringPS()
          char                *generateUncompressedPS()
          void                 getScaledParametersPS()
          l_int32              convertByteToHexAscii()

     For jpeg compressed images (use dct compression)
          l_int32              convertJpegToPSEmbed()
          l_int32              convertJpegToPS()
          l_int32              convertJpegToPSString()
          char                *generateJpegPS()

     For g4 fax compressed images (use ccitt g4 compression)
          l_int32              convertG4ToPSEmbed()
          l_int32              convertG4ToPS()
          l_int32              convertG4ToPSString()
          char                *generateG4PS()

     For multipage tiff images
          l_int32              convertTiffMultipageToPS()

     For flate (gzip) compressed images (e.g., png)
          l_int32              convertFlateToPSEmbed()
          l_int32              convertFlateToPS()
          l_int32              convertFlateToPSString()
          char                *generateFlatePS()

     Write to memory
          l_int32              pixWriteMemPS()

     Converting resolution
          l_int32              getResLetterPage()
          l_int32              getResA4Page()

     Utility for encoding and decoding data with ascii85
          char                *encodeAscii85()
          static l_int32      *convertChunkToAscii85()
          l_uint8             *decodeAscii85()

     Setting flag for writing bounding box hint
          void                 l_psWriteBoundingBox()

  See psio1.c for higher-level functions and their usage.

"""
    
    try:
        leptonica.convertJpegToPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertJpegToPS.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertJpegToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertJpegToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*operation')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  convertJpegToPS()

      Input:  filein (input jpeg file)
              fileout (output ps file)
              operation ("w" for write; "a" for append)
              x, y (location of LL corner of image, in pixels, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              res (resolution of the input image, in ppi; use 0 for default)
              scale (scaling by printer; use 0.0 or 1.0 for no scaling)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is simpler to use than pixWriteStringPS(), and
          it outputs in level 2 PS as compressed DCT (overlaid
          with ascii85 encoding).
      (2) An output file can contain multiple pages, each with
          multiple images.  The arguments to convertJpegToPS()
          allow you to control placement of jpeg images on multiple
          pages within a PostScript file.
      (3) For the first image written to a file, use "w", which
          opens for write and clears the file.  For all subsequent
          images written to that file, use "a".
      (4) The (x, y) parameters give the LL corner of the image
          relative to the LL corner of the page.  They are in
          units of pixels if scale = 1.0.  If you use (e.g.)
          scale = 2.0, the image is placed at (2x, 2y) on the page,
          and the image dimensions are also doubled.
      (5) Display vs printed resolution:
           * If your display is 75 ppi and your image was created
             at a resolution of 300 ppi, you can get the image
             to print at the same size as it appears on your display
             by either setting scale = 4.0 or by setting  res = 75.
             Both tell the printer to make a 4x enlarged image.
           * If your image is generated at 150 ppi and you use scale = 1,
             it will be rendered such that 150 pixels correspond
             to 72 pts (1 inch on the printer).  This function does
             the conversion from pixels (with or without scaling) to
             pts, which are the units that the printer uses.
           * The printer will choose its own resolution to use
             in rendering the image, which will not affect the size
             of the rendered image.  That is because the output
             PostScript file describes the geometry in terms of pts,
             which are defined to be 1/72 inch.  The printer will
             only see the size of the image in pts, through the
             scale and translate parameters and the affine
             transform (the ImageMatrix) of the image.
      (6) To render multiple images on the same page, set
          endpage = FALSE for each image until you get to the
          last, for which you set endpage = TRUE.  This causes the
          "showpage" command to be invoked.  Showpage outputs
          the entire page and clears the raster buffer for the
          next page to be added.  Without a "showpage",
          subsequent images from the next page will overlay those
          previously put down.
      (7) For multiple pages, increment the page number, starting
          with page 1.  This allows PostScript (and PDF) to build
          a page directory, which viewers use for navigation.


        """
        args = _convert_params(*args)
        
        return leptonica.convertJpegToPS(*args)
    
    

    try:
        leptonica.decodeAscii85.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.decodeAscii85.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        os.stderr.write("Warning - function decodeAscii85 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def decodeAscii85(*args):
        """
        ('char', '*ina')       
('l_int32', 'insize')       
('l_int32', '*poutsize')       
  decodeAscii85()

      Input:  inarray (ascii85 input data)
              insize (number of bytes in input array)
              &outsize (<return> number of bytes in output l_uint8 array)
      Return: outarray (binary)

  Notes:
      (1) We assume the data is properly encoded, so we do not check
          for invalid characters or the final '>' character.
      (2) We permit whitespace to be added to the encoding in an
          arbitrary way.


        """
        args = _convert_params(*args)
        
        return leptonica.decodeAscii85(*args)
    
    

    try:
        leptonica.pixWriteMemPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixWriteMemPS.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteMemPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPS(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'res')       
('l_float32', 'scale')       
  pixWriteMemPS()

      Input:  &data (<return> data of tiff compressed image)
              &size (<return> size of returned data)
              pix
              box  (<optional>)
              res  (can use 0 for default of 300 ppi)
              scale (to prevent scaling, use either 1.0 or 0.0)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See pixWriteStringPS() for usage.
      (2) This is just a wrapper for pixWriteStringPS(), which
          writes uncompressed image data to memory.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPS(*args)
    
    

    try:
        leptonica.convertByteToHexAscii.argtypes = [ctypes.c_ubyte, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertByteToHexAscii.restype = None
    except AttributeError:
        os.stderr.write("Warning - function convertByteToHexAscii not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertByteToHexAscii(*args):
        """
        ('l_uint8', 'byteval')       
('char', '*pnib1')       
('char', '*pnib2')       
  convertByteToHexAscii()

      Input:  byteval  (input byte)
              &nib1, &nib2  (<return> two hex ascii characters)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.convertByteToHexAscii(*args)
    
    

    try:
        leptonica.pixWriteStreamPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixWriteStreamPS.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStreamPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPS(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'res')       
('l_float32', 'scale')       
  pixWriteStreamPS()

      Input:  stream
              pix
              box  (<optional>)
              res  (can use 0 for default of 300 ppi)
              scale (to prevent scaling, use either 1.0 or 0.0)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This writes image in PS format, optionally scaled,
          adjusted for the printer resolution, and with
          a bounding box.
      (2) For details on use of parameters, see pixWriteStringPS().


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPS(*args)
    
    

    try:
        leptonica.encodeAscii85.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.encodeAscii85.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function encodeAscii85 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def encodeAscii85(*args):
        """
        ('l_uint8', '*inarray')       
('l_int32', 'insize')       
('l_int32', '*poutsize')       
  encodeAscii85()

      Input:  inarray (input data)
              insize (number of bytes in input array)
              &outsize (<return> number of bytes in output char array)
      Return: chara (with 64 characters + \n in each line)

  Notes:
      (1) Ghostscript has a stack break if the last line of
          data only has a '>', so we avoid the problem by
          always putting '~>' on the last line.


        """
        args = _convert_params(*args)
        
        return leptonica.encodeAscii85(*args)
    
    

    try:
        leptonica.convertG4ToPSEmbed.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertG4ToPSEmbed.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertG4ToPSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertG4ToPSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
  convertG4ToPSEmbed()

      Input:  filein (input tiff file)
              fileout (output ps file)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function takes a g4 compressed tif file as input and
          generates a g4 compressed, ascii85 encoded PS file, with
          a bounding box.
      (2) The bounding box is required when a program such as TeX
          (through epsf) places and rescales the image.
      (3) The bounding box is sized for fitting the image to an
          8.5 x 11.0 inch page.
      (4) We paint this through a mask, over whatever is below.


        """
        args = _convert_params(*args)
        
        return leptonica.convertG4ToPSEmbed(*args)
    
    

    try:
        leptonica.convertG4ToPSString.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertG4ToPSString.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertG4ToPSString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertG4ToPSString(*args):
        """
        ('const char', '*filein')       
('char', '**poutstr')       
('l_int32', '*pnbytes')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'maskflag')       
('l_int32', 'endpage')       
  convertG4ToPSString()

      Input:  filein (input tiff g4 file)
              &poutstr (<return> PS string)
              &nbytes (<return> number of bytes in PS string)
              x, y (location of LL corner of image, in pixels, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              res (resolution of the input image, in ppi; typ. values
                   are 300 and 600; use 0 for automatic determination
                   based on image size)
              scale (scaling by printer; use 0.0 or 1.0 for no scaling)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page.)
              maskflag (boolean: use TRUE if just painting through fg;
                        FALSE if painting both fg and bg.
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Generates PS string in G4 compressed tiff format from G4 tiff file.
      (2) For usage, see convertG4ToPS().


        """
        args = _convert_params(*args)
        
        return leptonica.convertG4ToPSString(*args)
    
    

    try:
        leptonica.convertFlateToPSEmbed.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertFlateToPSEmbed.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertFlateToPSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFlateToPSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
  convertFlateToPSEmbed()

      Input:  filein (input file -- any format)
              fileout (output ps file)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function takes any image file as input and generates a
          flate-compressed, ascii85 encoded PS file, with a bounding box.
      (2) The bounding box is required when a program such as TeX
          (through epsf) places and rescales the image.
      (3) The bounding box is sized for fitting the image to an
          8.5 x 11.0 inch page.


        """
        args = _convert_params(*args)
        
        return leptonica.convertFlateToPSEmbed(*args)
    
    

    try:
        leptonica.getScaledParametersPS.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getScaledParametersPS.restype = None
    except AttributeError:
        os.stderr.write("Warning - function getScaledParametersPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getScaledParametersPS(*args):
        """
        ('BOX', '*box')       
('l_int32', 'wpix')       
('l_int32', 'hpix')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_float32', '*pxpt')       
('l_float32', '*pypt')       
('l_float32', '*pwpt')       
('l_float32', '*phpt')       
  getScaledParametersPS()

      Input:  box (<optional> location of image in mils; with
                   (x,y) being the LL corner)
              wpix (pix width in pixels)
              hpix (pix height in pixels)
              res (of printer; use 0 for default)
              scale (use 1.0 or 0.0 for no scaling)
              &xpt (location of llx in pts)
              &ypt (location of lly in pts)
              &wpt (image width in pts)
              &hpt (image height in pts)
      Return: void (no arg checking)

  Notes:
      (1) The image is always scaled, depending on res and scale.
      (2) If no box, the image is centered on the page.
      (3) If there is a box, the image is placed within it.


        """
        args = _convert_params(*args)
        
        return leptonica.getScaledParametersPS(*args)
    
    

    try:
        leptonica.convertJpegToPSEmbed.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertJpegToPSEmbed.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertJpegToPSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertJpegToPSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
  convertJpegToPSEmbed()

      Input:  filein (input jpeg file)
              fileout (output ps file)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This function takes a jpeg file as input and generates a DCT
          compressed, ascii85 encoded PS file, with a bounding box.
      (2) The bounding box is required when a program such as TeX
          (through epsf) places and rescales the image.
      (3) The bounding box is sized for fitting the image to an
          8.5 x 11.0 inch page.


        """
        args = _convert_params(*args)
        
        return leptonica.convertJpegToPSEmbed(*args)
    
    

    try:
        leptonica.generateJpegPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.generateJpegPS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function generateJpegPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateJpegPS(*args):
        """
        ('const char', '*filein')       
('L_COMP_DATA', '*cid')       
('l_float32', 'xpt')       
('l_float32', 'ypt')       
('l_float32', 'wpt')       
('l_float32', 'hpt')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  generateJpegPS()

      Input:  filein (<optional> input jpeg filename; can be null)
              cid (jpeg compressed image data)
              xpt, ypt (location of LL corner of image, in pts, relative
                        to the PostScript origin (0,0) at the LL corner
                        of the page)
              wpt, hpt (rendered image size in pts)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page.)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: PS string, or null on error

  Notes:
      (1) Low-level function.


        """
        args = _convert_params(*args)
        
        return leptonica.generateJpegPS(*args)
    
    

    try:
        leptonica.convertFlateToPSString.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertFlateToPSString.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertFlateToPSString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFlateToPSString(*args):
        """
        ('const char', '*filein')       
('char', '**poutstr')       
('l_int32', '*pnbytes')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  convertFlateToPSString()

      Generates level 3 PS string in flate compressed format.

      Input:  filein (input image file)
              &poutstr (<return> PS string)
              &nbytes (<return> number of bytes in PS string)
              x, y (location of LL corner of image, in pixels, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              res (resolution of the input image, in ppi; use 0 for default)
              scale (scaling by printer; use 0.0 or 1.0 for no scaling)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page.)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) The returned PS character array is a null-terminated
          ascii string.  All the raster data is ascii85 encoded, so
          there are no null bytes embedded in it.
      (2) The raster encoding is made with gzip, the same as that
          in a png file that is compressed without prediction.
          The raster data itself is 25% larger than that in the
          binary form, due to the ascii85 encoding.

  Usage:  See convertFlateToPS()


        """
        args = _convert_params(*args)
        
        return leptonica.convertFlateToPSString(*args)
    
    

    try:
        leptonica.generateFlatePS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.generateFlatePS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function generateFlatePS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateFlatePS(*args):
        """
        ('const char', '*filein')       
('L_COMP_DATA', '*cid')       
('l_float32', 'xpt')       
('l_float32', 'ypt')       
('l_float32', 'wpt')       
('l_float32', 'hpt')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  generateFlatePS()

      Input:  filein (<optional> input filename; can be null)
              cid (flate compressed image data)
              xpt, ypt (location of LL corner of image, in pts, relative
                        to the PostScript origin (0,0) at the LL corner
                        of the page)
              wpt, hpt (rendered image size in pts)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: PS string, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.generateFlatePS(*args)
    
    

    try:
        leptonica.convertJpegToPSString.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertJpegToPSString.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertJpegToPSString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertJpegToPSString(*args):
        """
        ('const char', '*filein')       
('char', '**poutstr')       
('l_int32', '*pnbytes')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  convertJpegToPSString()

      Generates PS string in jpeg format from jpeg file

      Input:  filein (input jpeg file)
              &poutstr (<return> PS string)
              &nbytes (<return> number of bytes in PS string)
              x, y (location of LL corner of image, in pixels, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              res (resolution of the input image, in ppi; use 0 for default)
              scale (scaling by printer; use 0.0 or 1.0 for no scaling)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) For usage, see convertJpegToPS()


        """
        args = _convert_params(*args)
        
        return leptonica.convertJpegToPSString(*args)
    
    

    try:
        leptonica.generateUncompressedPS.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.generateUncompressedPS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function generateUncompressedPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateUncompressedPS(*args):
        """
        ('char', '*hexdata')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'd')       
('l_int32', 'psbpl')       
('l_int32', 'bps')       
('l_float32', 'xpt')       
('l_float32', 'ypt')       
('l_float32', 'wpt')       
('l_float32', 'hpt')       
('l_int32', 'boxflag')       
  generateUncompressedPS()

      Input:  hexdata
              w, h  (raster image size in pixels)
              d (image depth in bpp; rgb is 32)
              psbpl (raster bytes/line, when packed to the byte boundary)
              bps (bits/sample: either 1 or 8)
              xpt, ypt (location of LL corner of image, in pts, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              wpt, hpt (rendered image size in pts)
              boxflag (1 to print out bounding box hint; 0 to skip)
      Return: PS string, or null on error

  Notes:
      (1) Low-level function.


        """
        args = _convert_params(*args)
        
        return leptonica.generateUncompressedPS(*args)
    
    

    try:
        leptonica.convertG4ToPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertG4ToPS.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertG4ToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertG4ToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*operation')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'maskflag')       
('l_int32', 'endpage')       
  convertG4ToPS()

      Input:  filein (input tiff g4 file)
              fileout (output ps file)
              operation ("w" for write; "a" for append)
              x, y (location of LL corner of image, in pixels, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              res (resolution of the input image, in ppi; typ. values
                   are 300 and 600; use 0 for automatic determination
                   based on image size)
              scale (scaling by printer; use 0.0 or 1.0 for no scaling)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page.)
              maskflag (boolean: use TRUE if just painting through fg;
                        FALSE if painting both fg and bg.
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) See the usage comments in convertJpegToPS(), some of
          which are repeated here.
      (2) This is a wrapper for tiff g4.  The PostScript that
          is generated is expanded by about 5/4 (due to the
          ascii85 encoding.  If you convert to pdf (ps2pdf), the
          ascii85 decoder is automatically invoked, so that the
          pdf wrapped g4 file is essentially the same size as
          the original g4 file.  It's useful to have the PS
          file ascii85 encoded, because many printers will not
          print binary PS files.
      (3) For the first image written to a file, use "w", which
          opens for write and clears the file.  For all subsequent
          images written to that file, use "a".
      (4) To render multiple images on the same page, set
          endpage = FALSE for each image until you get to the
          last, for which you set endpage = TRUE.  This causes the
          "showpage" command to be invoked.  Showpage outputs
          the entire page and clears the raster buffer for the
          next page to be added.  Without a "showpage",
          subsequent images from the next page will overlay those
          previously put down.
      (5) For multiple images to the same page, where you are writing
          both jpeg and tiff-g4, you have two options:
           (a) write the g4 first, as either image (maskflag == FALSE)
               or imagemask (maskflag == TRUE), and then write the
               jpeg over it.
           (b) write the jpeg first and as the last item, write
               the g4 as an imagemask (maskflag == TRUE), to paint
               through the foreground only.
          We have this flexibility with the tiff-g4 because it is 1 bpp.
      (6) For multiple pages, increment the page number, starting
          with page 1.  This allows PostScript (and PDF) to build
          a page directory, which viewers use for navigation.


        """
        args = _convert_params(*args)
        
        return leptonica.convertG4ToPS(*args)
    
    

    try:
        leptonica.convertTiffMultipageToPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.convertTiffMultipageToPS.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertTiffMultipageToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertTiffMultipageToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*tempfile')       
('l_float32', 'fillfract')       
  convertTiffMultipageToPS()

      Input:  filein (input tiff multipage file)
              fileout (output ps file)
              tempfile (<optional> for temporary g4 tiffs;
                        use NULL for default)
              factor (for filling 8.5 x 11 inch page;
                      use 0.0 for DEFAULT_FILL_FRACTION)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This converts a multipage tiff file of binary page images
          into a ccitt g4 compressed PS file.
      (2) If the images are generated from a standard resolution fax,
          the vertical resolution is doubled to give a normal-looking
          aspect ratio.


        """
        args = _convert_params(*args)
        
        return leptonica.convertTiffMultipageToPS(*args)
    
    

    try:
        leptonica.getResLetterPage.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.getResLetterPage.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getResLetterPage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getResLetterPage(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'fillfract')       
  getResLetterPage()

      Input:  w (image width, pixels)
              h (image height, pixels)
              fillfract (fraction in linear dimension of full page, not
                         to be exceeded; use 0 for default)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.getResLetterPage(*args)
    
    

    try:
        leptonica.getResA4Page.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.getResA4Page.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getResA4Page not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getResA4Page(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'fillfract')       
  getResA4Page()

      Input:  w (image width, pixels)
              h (image height, pixels)
              fillfract (fraction in linear dimension of full page, not
                        to be exceeded; use 0 for default)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.getResA4Page(*args)
    
    

    try:
        leptonica.pixWritePSEmbed.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWritePSEmbed.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixWritePSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWritePSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
  pixWritePSEmbed()

      Input:  filein (input file, all depths, colormap OK)
              fileout (output ps file)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This is a simple wrapper function that generates an
          uncompressed PS file, with a bounding box.
      (2) The bounding box is required when a program such as TeX
          (through epsf) places and rescales the image.
      (3) The bounding box is sized for fitting the image to an
          8.5 x 11.0 inch page.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWritePSEmbed(*args)
    
    

    try:
        leptonica.pixWriteStringPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixWriteStringPS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function pixWriteStringPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStringPS(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'res')       
('l_float32', 'scale')       
  pixWriteStringPS()

      Input:  pixs:  all depths, colormap OK
              box:  (a) If box == null, image is placed, optionally scaled,
                        in a standard b.b. at the center of the page.
                        This is to be used when another program like
                        TeX (through epsf) places the image.
                    (b) If box != null, image is placed without a
                        b.b. at the specified page location and with
                        (optional) scaling.  This is to be used when
                        you want to specify exactly where (and optionally
                        how big) you want the image to be.
                        Note that all coordinates are in PS convention,
                        with (0,0) at LL corner of the page:
                            (x,y)    location of LL corner of image, in mils.
                            (w,h)    scaled size, in mils.  Use 0 to
                                     scale with "scale" and "res" input.
              res:  resolution, in printer ppi.  Use 0 for default (300 ppi).
              scale: scale factor.  If no scaling is desired, use
                     either 1.0 or 0.0.   Scaling just resets the resolution
                     parameter; the actual scaling is done in the
                     interpreter at rendering time.  This is important:
                     it allows you to scale the image up without
                     increasing the file size.
      Return: ps string if OK, or null on error

  Notes:
      (1) OK, this seems a bit complicated, because there are various
          ways to scale and not to scale.  Here's a summary:
      (2) If you don't want any scaling at all:
           * if you are using a box:
               set w = 0, h = 0, and use scale = 1.0; it will print
               each pixel unscaled at printer resolution
           * if you are not using a box:
               set scale = 1.0; it will print at printer resolution
      (3) If you want the image to be a certain size in inches:
           * you must use a box and set the box (w,h) in mils
      (4) If you want the image to be scaled by a scale factor != 1.0:
           * if you are using a box:
               set w = 0, h = 0, and use the desired scale factor;
               the higher the printer resolution, the smaller the
               image will actually appear.
           * if you are not using a box:
               set the desired scale factor; the higher the printer
               resolution, the smaller the image will actually appear.
      (5) Another complication is the proliferation of distance units:
           * The interface distances are in milli-inches.
           * Three different units are used internally:
              - pixels  (units of 1/res inch)
              - printer pts (units of 1/72 inch)
              - inches
           * Here is a quiz on volume units from a reviewer:
             How many UK milli-cups in a US kilo-teaspoon?
               (Hint: 1.0 US cup = 0.75 UK cup + 0.2 US gill;
                      1.0 US gill = 24.0 US teaspoons)


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStringPS(*args)
    
    

    try:
        leptonica.generateG4PS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generateG4PS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function generateG4PS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateG4PS(*args):
        """
        ('const char', '*filein')       
('L_COMP_DATA', '*cid')       
('l_float32', 'xpt')       
('l_float32', 'ypt')       
('l_float32', 'wpt')       
('l_float32', 'hpt')       
('l_int32', 'maskflag')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  generateG4PS()

      Input:  filein (<optional> input tiff g4 file; can be null)
              cid (g4 compressed image data)
              xpt, ypt (location of LL corner of image, in pts, relative
                        to the PostScript origin (0,0) at the LL corner
                        of the page)
              wpt, hpt (rendered image size in pts)
              maskflag (boolean: use TRUE if just painting through fg;
                        FALSE if painting both fg and bg.
              pageno (page number; must start with 1; you can use 0
                      if there is only one page.)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: PS string, or null on error

  Notes:
      (1) Low-level function.


        """
        args = _convert_params(*args)
        
        return leptonica.generateG4PS(*args)
    
    

    try:
        leptonica.convertFlateToPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertFlateToPS.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function convertFlateToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFlateToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*operation')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       
  convertFlateToPS()

      Input:  filein (input file -- any format)
              fileout (output ps file)
              operation ("w" for write; "a" for append)
              x, y (location of LL corner of image, in pixels, relative
                    to the PostScript origin (0,0) at the LL corner
                    of the page)
              res (resolution of the input image, in ppi; use 0 for default)
              scale (scaling by printer; use 0.0 or 1.0 for no scaling)
              pageno (page number; must start with 1; you can use 0
                      if there is only one page.)
              endpage (boolean: use TRUE if this is the last image to be
                       added to the page; FALSE otherwise)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This outputs level 3 PS as flate compressed (overlaid
          with ascii85 encoding).
      (2) An output file can contain multiple pages, each with
          multiple images.  The arguments to convertFlateToPS()
          allow you to control placement of png images on multiple
          pages within a PostScript file.
      (3) For the first image written to a file, use "w", which
          opens for write and clears the file.  For all subsequent
          images written to that file, use "a".
      (4) The (x, y) parameters give the LL corner of the image
          relative to the LL corner of the page.  They are in
          units of pixels if scale = 1.0.  If you use (e.g.)
          scale = 2.0, the image is placed at (2x, 2y) on the page,
          and the image dimensions are also doubled.
      (5) Display vs printed resolution:
           * If your display is 75 ppi and your image was created
             at a resolution of 300 ppi, you can get the image
             to print at the same size as it appears on your display
             by either setting scale = 4.0 or by setting  res = 75.
             Both tell the printer to make a 4x enlarged image.
           * If your image is generated at 150 ppi and you use scale = 1,
             it will be rendered such that 150 pixels correspond
             to 72 pts (1 inch on the printer).  This function does
             the conversion from pixels (with or without scaling) to
             pts, which are the units that the printer uses.
           * The printer will choose its own resolution to use
             in rendering the image, which will not affect the size
             of the rendered image.  That is because the output
             PostScript file describes the geometry in terms of pts,
             which are defined to be 1/72 inch.  The printer will
             only see the size of the image in pts, through the
             scale and translate parameters and the affine
             transform (the ImageMatrix) of the image.
      (6) To render multiple images on the same page, set
          endpage = FALSE for each image until you get to the
          last, for which you set endpage = TRUE.  This causes the
          "showpage" command to be invoked.  Showpage outputs
          the entire page and clears the raster buffer for the
          next page to be added.  Without a "showpage",
          subsequent images from the next page will overlay those
          previously put down.
      (7) For multiple pages, increment the page number, starting
          with page 1.  This allows PostScript (and PDF) to build
          a page directory, which viewers use for navigation.


        """
        args = _convert_params(*args)
        
        return leptonica.convertFlateToPS(*args)
    




class blend(object):
    """  blend.c

      Blending two images that are not colormapped
           PIX             *pixBlend()
           PIX             *pixBlendMask()
           PIX             *pixBlendGray()
           PIX             *pixBlendGrayInverse()
           PIX             *pixBlendColor()
           PIX             *pixBlendColorByChannel()
           PIX             *pixBlendGrayAdapt()
           static l_int32   blendComponents()
           PIX             *pixFadeWithGray()
           PIX             *pixBlendHardLight()
           static l_int32   blendHardLightComponents()

      Blending two colormapped images
           l_int32          pixBlendCmap()

      Blending two images using a third (alpha mask)
           PIX             *pixBlendWithGrayMask()

      Blending background to a specific color
           PIX             *pixBlendBackgroundToColor()

      Multiplying by a specific color
           PIX             *pixMultiplyByColor()

      Rendering with alpha blending over a uniform background
           PIX             *pixAlphaBlendUniform()

      Adding an alpha layer for blending
           PIX             *pixAddAlphaToBlend()

      Setting a transparent alpha component over a white background
           PIX             *pixSetAlphaOverWhite()

  In blending operations a new pix is produced where typically
  a subset of pixels in src1 are changed by the set of pixels
  in src2, when src2 is located in a given position relative
  to src1.  This is similar to rasterop, except that the
  blending operations we allow are more complex, and typically
  result in dest pixels that are a linear combination of two
  pixels, such as src1 and its inverse.  I find it convenient
  to think of src2 as the "blender" (the one that takes the action)
  and src1 as the "blendee" (the one that changes).

  Blending works best when src1 is 8 or 32 bpp.  We also allow
  src1 to be colormapped, but the colormap is removed before blending,
  so if src1 is colormapped, we can't allow in-place blending.

  Because src2 is typically smaller than src1, we can implement by
  clipping src2 to src1 and then transforming some of the dest
  pixels that are under the support of src2.  In practice, we
  do the clipping in the inner pixel loop.  For grayscale and
  color src2, we also allow a simple form of transparency, where
  pixels of a particular value in src2 are transparent; for those pixels,
  no blending is done.

  The blending functions are categorized by the depth of src2,
  the blender, and not that of src1, the blendee.

   - If src2 is 1 bpp, we can do one of three things:
     (1) L_BLEND_WITH_INVERSE: Blend a given fraction of src1 with its
         inverse color for those pixels in src2 that are fg (ON),
         and leave the dest pixels unchanged for pixels in src2 that
         are bg (OFF).
     (2) L_BLEND_TO_WHITE: Fade the src1 pixels toward white by a
         given fraction for those pixels in src2 that are fg (ON),
         and leave the dest pixels unchanged for pixels in src2 that
         are bg (OFF).
     (3) L_BLEND_TO_BLACK: Fade the src1 pixels toward black by a
         given fraction for those pixels in src2 that are fg (ON),
         and leave the dest pixels unchanged for pixels in src2 that
         are bg (OFF).
     The blending function is pixBlendMask().

   - If src2 is 8 bpp grayscale, we can do one of two things
     (but see pixFadeWithGray() below):
     (1) L_BLEND_GRAY: If src1 is 8 bpp, mix the two values, using
         a fraction of src2 and (1 - fraction) of src1.
         If src1 is 32 bpp (rgb), mix the fraction of src2 with
         each of the color components in src1.
     (2) L_BLEND_GRAY_WITH_INVERSE: Use the grayscale value in src2
         to determine how much of the inverse of a src1 pixel is
         to be combined with the pixel value.  The input fraction
         further acts to scale the change in the src1 pixel.
     The blending function is pixBlendGray().

   - If src2 is color, we blend a given fraction of src2 with
     src1.  If src1 is 8 bpp, the resulting image is 32 bpp.
     The blending function is pixBlendColor().

   - For all three blending functions -- pixBlendMask(), pixBlendGray()
     and pixBlendColor() -- you can apply the blender to the blendee
     either in-place or generating a new pix.  For the in-place
     operation, this requires that the depth of the resulting pix
     must equal that of the input pixs1.

   - We remove colormaps from src1 and src2 before blending.
     Any quantization would have to be done after blending.

  We include another function, pixFadeWithGray(), that blends
  a gray or color src1 with a gray src2.  It does one of these things:
     (1) L_BLEND_TO_WHITE: Fade the src1 pixels toward white by
         a number times the value in src2.
     (2) L_BLEND_TO_BLACK: Fade the src1 pixels toward black by
         a number times the value in src2.

  Also included is a generalization of the so-called "hard light"
  blending: pixBlendHardLight().  We generalize by allowing a fraction < 1.0
  of the blender to be admixed with the blendee.  The standard function
  does full mixing.

"""
    
    try:
        leptonica.pixSetAlphaOverWhite.argtypes = [ctypes.c_void_p]
        leptonica.pixSetAlphaOverWhite.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixSetAlphaOverWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAlphaOverWhite(*args):
        """
        ('PIX', '*pixs')       
  pixSetAlphaOverWhite()

      Input:  pixs (colormapped or 32 bpp rgb; no alpha)
      Return: pixd (new pix with meaningful alpha component),
                   or null on error

  Notes:
      (1) The generated alpha component is transparent over white
          (background) pixels in pixs, and quickly grades to opaque
          away from the transparent parts.  This is a cheap and
          dirty alpha generator.  The 2 pixel gradation is useful
          to blur the boundary between the transparent region
          (that will render entirely from a backing image) and
          the remainder which renders from pixs.
      (2) All alpha component bits in pixs are overwritten.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAlphaOverWhite(*args)
    
    

    try:
        leptonica.pixBlendGrayAdapt.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixBlendGrayAdapt.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendGrayAdapt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendGrayAdapt(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'shift')       
  pixBlendGrayAdapt()

      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)
              pixs1 (blendee, depth > 1)
              pixs2 (blender, any depth; typ. smaller in size than pixs1)
              x,y  (origin (UL corner) of pixs2 relative to
                    the origin of pixs1; can be < 0)
              fract (blending fraction)
              shift (>= 0 but <= 128: shift of zero blend value from
                     median source; use -1 for default value; )
      Return: pixd if OK; pixs1 on error

  Notes:
      (1) For inplace operation (pixs1 not cmapped), call it this way:
            pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)
          For generating a new pixd:
            pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)
      (2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
      (3) If pixs1 has a colormap, it is removed.
      (4) If pixs1 has depth < 8, it is unpacked to generate a 8 bpp pix.
      (5) This does a blend with inverse.  Whereas in pixGlendGray(), the
          zero blend point is where the blendee pixel is 128, here
          the zero blend point is found adaptively, with respect to the
          median of the blendee region.  If the median is < 128,
          the zero blend point is found from
              median + shift.
          Otherwise, if the median >= 128, the zero blend point is
              median - shift.
          The purpose of shifting the zero blend point away from the
          median is to prevent a situation in pixBlendGray() where
          the median is 128 and the blender is not visible.
          The default value of shift is 64.
      (6) After processing pixs1, it is either 8 bpp or 32 bpp:
          - if 8 bpp, the fraction of pixs2 is mixed with pixs1.
          - if 32 bpp, each component of pixs1 is mixed with
            the same fraction of pixs2.
      (7) The darker the blender, the more it mixes with the blendee.
          A blender value of 0 has maximum mixing; a value of 255
          has no mixing and hence is transparent.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendGrayAdapt(*args)
    
    

    try:
        leptonica.pixFadeWithGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixFadeWithGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixFadeWithGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFadeWithGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('l_float32', 'factor')       
('l_int32', 'type')       
  pixFadeWithGray()

      Input:  pixs (colormapped or 8 bpp or 32 bpp)
              pixb (8 bpp blender)
              factor (multiplicative factor to apply to blender value)
              type (L_BLEND_TO_WHITE, L_BLEND_TO_BLACK)
      Return: pixd, or null on error

  Notes:
      (1) This function combines two pix aligned to the UL corner; they
          need not be the same size.
      (2) Each pixel in pixb is multiplied by 'factor' divided by 255, and
          clipped to the range [0 ... 1].  This gives the fade fraction
          to be appied to pixs.  Fade either to white (L_BLEND_TO_WHITE)
          or to black (L_BLEND_TO_BLACK).


        """
        args = _convert_params(*args)
        
        return leptonica.pixFadeWithGray(*args)
    
    

    try:
        leptonica.pixBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixBlend.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlend(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
  pixBlend()

      Input:  pixs1 (blendee)
              pixs2 (blender; typ. smaller)
              x,y  (origin (UL corner) of pixs2 relative to
                    the origin of pixs1; can be < 0)
              fract (blending fraction)
      Return: pixd (blended image), or null on error

  Notes:
      (1) This is a simple top-level interface.  For more flexibility,
          call directly into pixBlendMask(), etc.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlend(*args)
    
    

    try:
        leptonica.pixBlendGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixBlendGray.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'type')       
('l_int32', 'transparent')       
('l_uint32', 'transpix')       
  pixBlendGray()

      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)
              pixs1 (blendee, depth > 1)
              pixs2 (blender, any depth; typ. smaller in size than pixs1)
              x,y  (origin (UL corner) of pixs2 relative to
                    the origin of pixs1; can be < 0)
              fract (blending fraction)
              type (L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE)
              transparent (1 to use transparency; 0 otherwise)
              transpix (pixel grayval in pixs2 that is to be transparent)
      Return: pixd if OK; pixs1 on error

  Notes:
      (1) For inplace operation (pixs1 not cmapped), call it this way:
            pixBlendGray(pixs1, pixs1, pixs2, ...)
      (2) For generating a new pixd:
            pixd = pixBlendGray(NULL, pixs1, pixs2, ...)
      (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
      (4) If pixs1 has a colormap, it is removed; otherwise, if pixs1
          has depth < 8, it is unpacked to generate a 8 bpp pix.
      (5) If transparent = 0, the blending fraction (fract) is
          applied equally to all pixels.
      (6) If transparent = 1, all pixels of value transpix (typically
          either 0 or 0xff) in pixs2 are transparent in the blend.
      (7) After processing pixs1, it is either 8 bpp or 32 bpp:
          - if 8 bpp, the fraction of pixs2 is mixed with pixs1.
          - if 32 bpp, each component of pixs1 is mixed with
            the same fraction of pixs2.
      (8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee
          (cval == 255 in the code below) result in a delta of 0.
          Thus, these pixels are intrinsically transparent!
          The "pivot" value of the src, at which no blending occurs, is
          128.  Compare with the adaptive pivot in pixBlendGrayAdapt().
      (9) Invalid @fract defaults to 0.5 with a warning.
          Invalid @type defaults to L_BLEND_GRAY with a warning.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendGray(*args)
    
    

    try:
        leptonica.pixBlendCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlendCmap.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function pixBlendCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'sindex')       
  pixBlendCmap()

      Input:  pixs (2, 4 or 8 bpp, with colormap)
              pixb (colormapped blender)
              x, y (UL corner of blender relative to pixs)
              sindex (colormap index of pixels in pixs to be changed)
      Return: 0 if OK, 1 on error

  Note:
      (1) This function combines two colormaps, and replaces the pixels
          in pixs that have a specified color value with those in pixb.
      (2) sindex must be in the existing colormap; otherwise an
          error is returned.  In use, sindex will typically be the index
          for white (255, 255, 255).
      (3) Blender colors that already exist in the colormap are used;
          others are added.  If any blender colors cannot be
          stored in the colormap, an error is returned.
      (4) In the implementation, a mapping is generated from each
          original blender colormap index to the corresponding index
          in the expanded colormap for pixs.  Then for each pixel in
          pixs with value sindex, and which is covered by a blender pixel,
          the new index corresponding to the blender pixel is substituted
          for sindex.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendCmap(*args)
    
    

    try:
        leptonica.pixBlendGrayInverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixBlendGrayInverse.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendGrayInverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendGrayInverse(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
  pixBlendGrayInverse()

      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)
              pixs1 (blendee, depth > 1)
              pixs2 (blender, any depth; typ. smaller in size than pixs1)
              x,y  (origin (UL corner) of pixs2 relative to
                    the origin of pixs1; can be < 0)
              fract (blending fraction)
      Return: pixd if OK; pixs1 on error

  Notes:
      (1) For inplace operation (pixs1 not cmapped), call it this way:
            pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)
      (2) For generating a new pixd:
            pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)
      (3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
      (4) If pixs1 has a colormap, it is removed; otherwise if pixs1
          has depth < 8, it is unpacked to generate a 8 bpp pix.
      (5) This is a no-nonsense blender.  It changes the src1 pixel except
          when the src1 pixel is midlevel gray.  Use fract == 1 for the most
          aggressive blending, where, if the gray pixel in pixs2 is 0,
          we get a complete inversion of the color of the src pixel in pixs1.
      (6) The basic logic is that each component transforms by:
               d  -->  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))
          where c is the blender pixel from pixs2,
                f is @fract,
                c and d are normalized to [0...1]
          This has the property that for f == 0 (no blend) or c == 1 (white):
               d  -->  d
          For c == 0 (black) we get maximum inversion:
               d  -->  f * (1 - d) + d * (1 - f)   [inversion by fraction f]


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendGrayInverse(*args)
    
    

    try:
        leptonica.pixAddAlphaToBlend.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixAddAlphaToBlend.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAddAlphaToBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddAlphaToBlend(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'invert')       
  pixAddAlphaToBlend()

      Input:  pixs (any depth)
              fract (fade fraction in the alpha component)
              invert (1 to photometrically invert pixs)
      Return: pixd (32 bpp with alpha), or null on error

  Notes:
      (1) This is a simple alpha layer generator, where typically white has
          maximum transparency and black has minimum.
      (2) If @invert == 1, generate the same alpha layer but invert
          the input image photometrically.  This is useful for blending
          over dark images, where you want dark regions in pixs, such
          as text, to be lighter in the blended image.
      (3) The fade @fract gives the minimum transparency (i.e.,
          maximum opacity).  A small fraction is useful for adding
          a watermark to an image.
      (4) If pixs has a colormap, it is removed to rgb.
      (5) If pixs already has an alpha layer, it is overwritten.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddAlphaToBlend(*args)
    
    

    try:
        leptonica.pixBlendMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixBlendMask.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendMask(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'type')       
  pixBlendMask()

      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)
              pixs1 (blendee, depth > 1)
              pixs2 (blender, 1 bpp; typ. smaller in size than pixs1)
              x,y  (origin (UL corner) of pixs2 relative to
                    the origin of pixs1; can be < 0)
              fract (blending fraction)
              type (L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE, L_BLEND_TO_BLACK)
      Return: pixd if OK; null on error

  Notes:
      (1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
      (2) If pixs1 has a colormap, it is removed.
      (3) For inplace operation (pixs1 not cmapped), call it this way:
            pixBlendMask(pixs1, pixs1, pixs2, ...)
      (4) For generating a new pixd:
            pixd = pixBlendMask(NULL, pixs1, pixs2, ...)
      (5) Only call in-place if pixs1 does not have a colormap.
      (6) Invalid @fract defaults to 0.5 with a warning.
          Invalid @type defaults to L_BLEND_WITH_INVERSE with a warning.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendMask(*args)
    
    

    try:
        leptonica.pixAlphaBlendUniform.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixAlphaBlendUniform.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixAlphaBlendUniform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAlphaBlendUniform(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'color')       
  pixAlphaBlendUniform()

      Input:  pixs (32 bpp rgba, with alpha)
              color (32 bit color in 0xrrggbb00 format)
      Return: pixd (32 bpp rgb: pixs blended over uniform color @color),
                    a clone of pixs if no alpha, and null on error

  Notes:
      (1) This is a convenience function that renders 32 bpp RGBA images
          (with an alpha channel) over a uniform background of
          value @color.  To render over a white background,
          use @color = 0xffffff00.  The result is an RGB image.
      (2) If pixs does not have an alpha channel, it returns a clone
          of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixAlphaBlendUniform(*args)
    
    

    try:
        leptonica.pixBlendWithGrayMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlendWithGrayMask.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendWithGrayMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendWithGrayMask(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('PIX', '*pixg')       
('l_int32', 'x')       
('l_int32', 'y')       
  pixBlendWithGrayMask()

      Input:  pixs1 (8 bpp gray, rgb, rgba or colormapped)
              pixs2 (8 bpp gray, rgb, rgba or colormapped)
              pixg (<optional> 8 bpp gray, for transparency of pixs2;
                    can be null)
              x, y (UL corner of pixs2 and pixg with respect to pixs1)
      Return: pixd (blended image), or null on error

  Notes:
      (1) The result is 8 bpp grayscale if both pixs1 and pixs2 are
          8 bpp gray.  Otherwise, the result is 32 bpp rgb.
      (2) pixg is an 8 bpp transparency image, where 0 is transparent
          and 255 is opaque.  It determines the transparency of pixs2
          when applied over pixs1.  It can be null if pixs2 is rgba,
          in which case we use the alpha component of pixs2.
      (3) If pixg exists, it need not be the same size as pixs2.
          However, we assume their UL corners are aligned with each other,
          and placed at the location (x, y) in pixs1.
      (4) The pixels in pixd are a combination of those in pixs1
          and pixs2, where the amount from pixs2 is proportional to
          the value of the pixel (p) in pixg, and the amount from pixs1
          is proportional to (255 - p).  Thus pixg is a transparency
          image (usually called an alpha blender) where each pixel
          can be associated with a pixel in pixs2, and determines
          the amount of the pixs2 pixel in the final result.
          For example, if pixg is all 0, pixs2 is transparent and
          the result in pixd is simply pixs1.
      (5) A typical use is for the pixs2/pixg combination to be
          a small watermark that is applied to pixs1.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendWithGrayMask(*args)
    
    

    try:
        leptonica.pixBlendColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixBlendColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'transparent')       
('l_uint32', 'transpix')       
  pixBlendColor()

      Input:  pixd (<optional>; either NULL or equal to pixs1 for in-place)
              pixs1 (blendee; depth > 1)
              pixs2 (blender, any depth;; typ. smaller in size than pixs1)
              x,y  (origin (UL corner) of pixs2 relative to
                    the origin of pixs1)
              fract (blending fraction)
              transparent (1 to use transparency; 0 otherwise)
              transpix (pixel color in pixs2 that is to be transparent)
      Return: pixd, or null on error

  Notes:
      (1) For inplace operation (pixs1 must be 32 bpp), call it this way:
            pixBlendColor(pixs1, pixs1, pixs2, ...)
      (2) For generating a new pixd:
            pixd = pixBlendColor(NULL, pixs1, pixs2, ...)
      (3) If pixs2 is not 32 bpp rgb, it is converted.
      (4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
      (5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.
      (6) If pixs1 has depth < 32, it is unpacked to generate a 32 bpp pix.
      (7) If transparent = 0, the blending fraction (fract) is
          applied equally to all pixels.
      (8) If transparent = 1, all pixels of value transpix (typically
          either 0 or 0xffffff00) in pixs2 are transparent in the blend.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendColor(*args)
    
    

    try:
        leptonica.pixBlendBackgroundToColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlendBackgroundToColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixBlendBackgroundToColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendBackgroundToColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', 'color')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
  pixBlendBackgroundToColor()

      Input:  pixd (can be NULL or pixs)
              pixs (32 bpp rgb)
              box (region for blending; can be NULL))
              color (32 bit color in 0xrrggbb00 format)
              gamma, minval, maxval (args for grayscale TRC mapping)
      Return: pixd always

  Notes:
      (1) This in effect replaces light background pixels in pixs
          by the input color.  It does it by alpha blending so that
          there are no visible artifacts from hard cutoffs.
      (2) If pixd == pixs, this is done in-place.
      (3) If box == NULL, this is performed on all of pixs.
      (4) The alpha component for blending is derived from pixs,
          by converting to grayscale and enhancing with a TRC.
      (5) The last three arguments specify the TRC operation.
          Suggested values are: @gamma = 0.3, @minval = 50, @maxval = 200.
          To skip the TRC, use @gamma == 1, @minval = 0, @maxval = 255.
          See pixGammaTRC() for details.


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendBackgroundToColor(*args)
    
    

    try:
        leptonica.pixMultiplyByColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixMultiplyByColor.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function pixMultiplyByColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultiplyByColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', 'color')       
  pixMultiplyByColor()

      Input:  pixd (can be NULL or pixs)
              pixs (32 bpp rgb)
              box (region for filtering; can be NULL))
              color (32 bit color in 0xrrggbb00 format)
      Return: pixd always

  Notes:
      (1) This filters all pixels in the specified region by
          multiplying each component by the input color.
          This leaves black invariant and transforms white to the
          input color.
      (2) If pixd == pixs, this is done in-place.
      (3) If box == NULL, this is performed on all of pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultiplyByColor(*args)
    




class sel1(object):
    """  sel1.c

      Basic ops on Sels and Selas

         Create/destroy/copy:
            SELA      *selaCreate()
            void       selaDestroy()
            SEL       *selCreate()
            void       selDestroy()
            SEL       *selCopy()
            SEL       *selCreateBrick()
            SEL       *selCreateComb()

         Helper proc:
            l_int32  **create2dIntArray()

         Extension of sela:
            SELA      *selaAddSel()
            static l_int32  selaExtendArray()

         Accessors:
            l_int32    selaGetCount()
            SEL       *selaGetSel()
            char      *selGetName()
            l_int32    selSetName()
            l_int32    selaFindSelByName()
            l_int32    selGetElement()
            l_int32    selSetElement()
            l_int32    selGetParameters()
            l_int32    selSetOrigin()
            l_int32    selGetTypeAtOrigin()
            char      *selaGetBrickName()
            char      *selaGetCombName()
     static char      *selaComputeCompositeParameters()
            l_int32    getCompositeParameters()
            SARRAY    *selaGetSelnames()

         Max translations for erosion and hmt
            l_int32    selFindMaxTranslations()

         Rotation by multiples of 90 degrees
            SEL       *selRotateOrth()

         Sela and Sel serialized I/O
            SELA      *selaRead()
            SELA      *selaReadStream()
            SEL       *selRead()
            SEL       *selReadStream()
            l_int32    selaWrite()
            l_int32    selaWriteStream()
            l_int32    selWrite()
            l_int32    selWriteStream()

         Building custom hit-miss sels from compiled strings
            SEL       *selCreateFromString()
            char      *selPrintToString()     [for debugging]

         Building custom hit-miss sels from a simple file format
            SELA      *selaCreateFromFile()
            static SEL *selCreateFromSArray()

         Making hit-only sels from Pta and Pix
            SEL       *selCreateFromPta()
            SEL       *selCreateFromPix()

         Making hit-miss sels from Pix and image files
            SEL       *selReadFromColorImage()
            SEL       *selCreateFromColorPix()

         Printable display of sel
            PIX       *selDisplayInPix()
            PIX       *selaDisplayInPix()

     Usage notes:
        In this file we have seven functions that make sels:
          (1)  selCreate(), with input (h, w, [name])
               The generic function.  Roll your own, using selSetElement().
          (2)  selCreateBrick(), with input (h, w, cy, cx, val)
               The most popular function.  Makes a rectangular sel of
               all hits, misses or don't-cares.  We have many morphology
               operations that create a sel of all hits, use it, and
               destroy it.
          (3)  selCreateFromString() with input (text, h, w, [name])
               Adam Langley's clever function, allows you to make a hit-miss
               sel from a string in code that is geometrically laid out
               just like the actual sel.
          (4)  selaCreateFromFile() with input (filename)
               This parses a simple file format to create an array of
               hit-miss sels.  The sel data uses the same encoding
               as in (3), with geometrical layout enforced.
          (5)  selCreateFromPta() with input (pta, cy, cx, [name])
               Another way to make a sel with only hits.
          (6)  selCreateFromPix() with input (pix, cy, cx, [name])
               Yet another way to make a sel from hits.
          (7)  selCreateFromColorPix() with input (pix, name).
               Another way to make a general hit-miss sel, starting with
               an image editor.
        In addition, there are three functions in selgen.c that
        automatically generate a hit-miss sel from a pix and
        a number of parameters.  This is useful for problems like
        "find all patterns that look like this one."

        Consistency, being the hobgoblin of small minds,
        is adhered to here in the dimensioning and accessing of sels.
        Everything is done in standard matrix (row, column) order.
        When we set specific elements in a sel, we likewise use
        (row, col) ordering:
             selSetElement(), with input (row, col, type)

"""
    
    try:
        leptonica.selRead.argtypes = [ctypes.c_void_p]
        leptonica.selRead.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selRead(*args):
        """
        ('const char', '*fname')       
  selRead()

      Input:  filename
      Return: sel, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selRead(*args)
    
    

    try:
        leptonica.selCreateBrick.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selCreateBrick.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreateBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateBrick(*args):
        """
        ('l_int32', 'h')       
('l_int32', 'w')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('l_int32', 'type')       
  selCreateBrick()

      Input:  height, width
              cy, cx  (origin, relative to UL corner at 0,0)
              type  (SEL_HIT, SEL_MISS, or SEL_DONT_CARE)
      Return: sel, or null on error

  Notes:
      (1) This is a rectangular sel of all hits, misses or don't cares.


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateBrick(*args)
    
    

    try:
        leptonica.selaGetCombName.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaGetCombName.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function selaGetCombName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetCombName(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'size')       
('l_int32', 'direction')       
  selaGetCombName()

      Input:  sela
              size (the product of sizes of the brick and comb parts)
              direction (L_HORIZ, L_VERT)
      Return: sel name (new string), or null if name not found or on error

  Notes:
      (1) Combs are by definition 1-dimensional, either horiz or vert.
      (2) Use this with comb Sels; e.g., from selaAddDwaCombs().


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetCombName(*args)
    
    

    try:
        leptonica.selaFindSelByName.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selaFindSelByName.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selaFindSelByName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaFindSelByName(*args):
        """
        ('SELA', '*sela')       
('const char', '*name')       
('l_int32', '*pindex')       
('SEL', '**psel')       
  selaFindSelByName()

      Input:  sela
              sel name
              &index (<optional, return>)
              &sel  (<optional, return> sel (not a copy))
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaFindSelByName(*args)
    
    

    try:
        leptonica.selCreateComb.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selCreateComb.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreateComb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateComb(*args):
        """
        ('l_int32', 'factor1')       
('l_int32', 'factor2')       
('l_int32', 'direction')       
  selCreateComb()

      Input:  factor1 (contiguous space between comb tines)
              factor2 (number of comb tines)
              direction (L_HORIZ, L_VERT)
      Return: sel, or null on error

  Notes:
      (1) This generates a comb Sel of hits with the origin as
          near the center as possible.


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateComb(*args)
    
    

    try:
        leptonica.selaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.selaGetCount.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetCount(*args):
        """
        ('SELA', '*sela')       
  selaGetCount()

      Input:  sela
      Return: count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetCount(*args)
    
    

    try:
        leptonica.selaCreateFromFile.argtypes = [ctypes.c_void_p]
        leptonica.selaCreateFromFile.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaCreateFromFile(*args):
        """
        ('const char', '*filename')       
  selaCreateFromFile()

      Input:  filename
      Return: sela, or null on error

  Notes:
      (1) The file contains a sequence of Sel descriptions.
      (2) Each Sel is formatted as follows:
           - Any number of comment lines starting with '#' are ignored
           - The next line contains the selname
           - The next lines contain the Sel data.  They must be
             formatted similarly to the string format in
             selCreateFromString(), with each line beginning and
             ending with a double-quote, and showing the 2D layout.
           - Each Sel ends when a blank line, a comment line, or
             the end of file is reached.
      (3) See selCreateFromString() for a description of the string
          format for the Sel data.  As an example, here are the lines
          of is a valid file for a single Sel.  In the file, all lines
          are left-justified:
                    # diagonal sel
                    sel_5diag
                    "x    "
                    " x   "
                    "  X  "
                    "   x "
                    "    x"


        """
        args = _convert_params(*args)
        
        return leptonica.selaCreateFromFile(*args)
    
    

    try:
        leptonica.selSetName.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selSetName.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selSetName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selSetName(*args):
        """
        ('SEL', '*sel')       
('const char', '*name')       
  selSetName()

      Input:  sel
              name (<optional>; can be null)
      Return: 0 if OK, 1 on error

  Notes:
      (1) Always frees the existing sel name, if defined.
      (2) If name is not defined, just clears any existing sel name.


        """
        args = _convert_params(*args)
        
        return leptonica.selSetName(*args)
    
    

    try:
        leptonica.selReadFromColorImage.argtypes = [ctypes.c_void_p]
        leptonica.selReadFromColorImage.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selReadFromColorImage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selReadFromColorImage(*args):
        """
        ('const char', '*pathname')       

  selReadFromColorImage()

      Input:  pathname
      Return: sel if OK; null on error

  Notes:
      (1) Loads an image from a file and creates a (hit-miss) sel.
      (2) The sel name is taken from the pathname without the directory
          and extension.


        """
        args = _convert_params(*args)
        
        return leptonica.selReadFromColorImage(*args)
    
    

    try:
        leptonica.selGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selGetParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetParameters(*args):
        """
        ('SEL', '*sel')       
('l_int32', '*psy')       
('l_int32', '*psx')       
('l_int32', '*pcy')       
('l_int32', '*pcx')       
  selGetParameters()

      Input:  sel
              &sy, &sx, &cy, &cx (<optional return>; each can be null)
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selGetParameters(*args)
    
    

    try:
        leptonica.selGetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.selGetElement.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selGetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetElement(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_int32', '*ptype')       
  selGetElement()

      Input:  sel
              row
              col
              &type  (<return> SEL_HIT, SEL_MISS, SEL_DONT_CARE)
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selGetElement(*args)
    
    

    try:
        leptonica.selaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.selaReadStream.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaReadStream(*args):
        """
        ('FILE', '*fp')       
  selaReadStream()

      Input:  stream
      Return: sela, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaReadStream(*args)
    
    

    try:
        leptonica.selSetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selSetElement.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selSetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selSetElement(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_int32', 'type')       
  selSetElement()

      Input:  sel
              row
              col
              type  (SEL_HIT, SEL_MISS, SEL_DONT_CARE)
      Return: 0 if OK; 1 on error

  Notes:
      (1) Because we use row and column to index into an array,
          they are always non-negative.  The location of the origin
          (and the type of operation) determine the actual
          direction of the rasterop.


        """
        args = _convert_params(*args)
        
        return leptonica.selSetElement(*args)
    
    

    try:
        leptonica.selGetName.argtypes = [ctypes.c_void_p]
        leptonica.selGetName.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function selGetName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetName(*args):
        """
        ('SEL', '*sel')       
  selGetName()

      Input:  sel
      Return: sel name (not copied), or null if no name or on error


        """
        args = _convert_params(*args)
        
        return leptonica.selGetName(*args)
    
    

    try:
        leptonica.selCopy.argtypes = [ctypes.c_void_p]
        leptonica.selCopy.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCopy(*args):
        """
        ('SEL', '*sel')       
  selCopy()

      Input:  sel
      Return: a copy of the sel, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selCopy(*args)
    
    

    try:
        leptonica.selSetOrigin.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selSetOrigin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selSetOrigin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selSetOrigin(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'cy')       
('l_int32', 'cx')       
  selSetOrigin()

      Input:  sel
              cy, cx
      Return: 0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selSetOrigin(*args)
    
    

    try:
        leptonica.selDestroy.argtypes = [ctypes.c_void_p]
        leptonica.selDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function selDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selDestroy(*args):
        """
        ('SEL', '**psel')       
  selDestroy()

      Input:  &sel (<to be nulled>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.selDestroy(*args)
    
    

    try:
        leptonica.selCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.selCreate.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreate(*args):
        """
        ('l_int32', 'height')       
('l_int32', 'width')       
('const char', '*name')       
  selCreate()

      Input:  height, width
              name (<optional> sel name; can be null)
      Return: sel, or null on error

  Notes:
      (1) selCreate() initializes all values to 0.
      (2) After this call, (cy,cx) and nonzero data values must be
          assigned.  If a text name is not assigned here, it will
          be needed later when the sel is put into a sela.


        """
        args = _convert_params(*args)
        
        return leptonica.selCreate(*args)
    
    

    try:
        leptonica.selFindMaxTranslations.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selFindMaxTranslations.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selFindMaxTranslations not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selFindMaxTranslations(*args):
        """
        ('SEL', '*sel')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       
('l_int32', '*pxn')       
('l_int32', '*pyn')       
  selFindMaxTranslations()

      Input:  sel
              &xp, &yp, &xn, &yn  (<return> max shifts)
      Return: 0 if OK; 1 on error

  Note: these are the maximum shifts for the erosion operation.
        For example, when j < cx, the shift of the image
        is +x to the cx.  This is a positive xp shift.


        """
        args = _convert_params(*args)
        
        return leptonica.selFindMaxTranslations(*args)
    
    

    try:
        leptonica.selWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selWriteStream(*args):
        """
        ('FILE', '*fp')       
('SEL', '*sel')       
  selWriteStream()

      Input:  stream
              sel
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selWriteStream(*args)
    
    

    try:
        leptonica.getCompositeParameters.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getCompositeParameters.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function getCompositeParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getCompositeParameters(*args):
        """
        ('l_int32', 'size')       
('l_int32', '*psize1')       
('l_int32', '*psize2')       
('char', '**pnameh1')       
('char', '**pnameh2')       
('char', '**pnamev1')       
('char', '**pnamev2')       
  getCompositeParameters()

      Input:  size
              &size1 (<optional return> brick factor size)
              &size2 (<optional return> comb factor size)
              &nameh1 (<optional return> name of horiz brick)
              &nameh2 (<optional return> name of horiz comb)
              &namev1 (<optional return> name of vert brick)
              &namev2 (<optional return> name of vert comb)
      Return: 0 if OK, 1 on error

  Notes:
      (1) This uses the big lookup table at the top of this file.
      (2) All returned strings are copies that must be freed.


        """
        args = _convert_params(*args)
        
        return leptonica.getCompositeParameters(*args)
    
    

    try:
        leptonica.selaGetBrickName.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaGetBrickName.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function selaGetBrickName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetBrickName(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
  selaGetBrickName()

      Input:  sela
              hsize, vsize (of brick sel)
      Return: sel name (new string), or null if no name or on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetBrickName(*args)
    
    

    try:
        leptonica.selDisplayInPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selDisplayInPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selDisplayInPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selDisplayInPix(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'size')       
('l_int32', 'gthick')       
  selDisplayInPix()

      Input:  sel
              size (of grid interiors; odd; minimum size of 13 is enforced)
              gthick (grid thickness; minimum size of 2 is enforced)
      Return: pix (display of sel), or null on error

  Notes:
      (1) This gives a visual representation of a general (hit-miss) sel.
      (2) The empty sel is represented by a grid of intersecting lines.
      (3) Three different patterns are generated for the sel elements:
          - hit (solid black circle)
          - miss (black ring; inner radius is radius2)
          - origin (cross, XORed with whatever is there)


        """
        args = _convert_params(*args)
        
        return leptonica.selDisplayInPix(*args)
    
    

    try:
        leptonica.selaGetSel.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.selaGetSel.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaGetSel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetSel(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'i')       
  selaGetSel()

      Input:  sela
              index of sel to be retrieved (not copied)
      Return: sel, or null on error

  Notes:
      (1) This returns a ptr to the sel, not a copy, so the caller
          must not destroy it!


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetSel(*args)
    
    

    try:
        leptonica.selCreateFromString.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.selCreateFromString.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromString(*args):
        """
        ('const char', '*text')       
('l_int32', 'h')       
('l_int32', 'w')       
('const char', '*name')       
  selCreateFromString()

      Input:  text
              height, width
              name (<optional> sel name; can be null)
      Return: sel of the given size, or null on error

  Notes:
      (1) The text is an array of chars (in row-major order) where
          each char can be one of the following:
             'x': hit
             'o': miss
             ' ': don't-care
      (2) Use an upper case char to indicate the origin of the Sel.
          When the origin falls on a don't-care, use 'C' as the uppecase
          for ' '.
      (3) The text can be input in a format that shows the 2D layout; e.g.,
              static const char *seltext = "x    "
                                           "x Oo "
                                           "x    "
                                           "xxxxx";


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromString(*args)
    
    

    try:
        leptonica.selCreateFromPta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.selCreateFromPta.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreateFromPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromPta(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('const char', '*name')       
  selCreateFromPta()

      Input:  pta
              cy, cx (origin of sel)
              name (<optional> sel name; can be null)
      Return: sel (of minimum required size), or null on error

  Notes:
      (1) The origin and all points in the pta must be positive.


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromPta(*args)
    
    

    try:
        leptonica.selaAddSel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.selaAddSel.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selaAddSel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddSel(*args):
        """
        ('SELA', '*sela')       
('SEL', '*sel')       
('const char', '*selname')       
('l_int32', 'copyflag')       
  selaAddSel()

      Input:  sela
              sel to be added
              selname (ignored if already defined in sel;
                       req'd in sel when added to a sela)
              copyflag (for sel: 0 inserts, 1 copies)
      Return: 0 if OK; 1 on error

  Notes:
      (1) This adds a sel, either inserting or making a copy.
      (2) Because every sel in a sela must have a name, it copies
          the input name if necessary.  You can input NULL for
          selname if the sel already has a name.


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddSel(*args)
    
    

    try:
        leptonica.selaCreate.argtypes = [ctypes.c_int32]
        leptonica.selaCreate.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaCreate(*args):
        """
        ('l_int32', 'n')       
  selaCreate()

      Input:  n (initial number of sel ptrs; use 0 for default)
      Return: sela, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaCreate(*args)
    
    

    try:
        leptonica.selaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selaWriteStream.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaWriteStream(*args):
        """
        ('FILE', '*fp')       
('SELA', '*sela')       
  selaWriteStream()

      Input:  stream
              sela
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaWriteStream(*args)
    
    

    try:
        leptonica.selGetTypeAtOrigin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selGetTypeAtOrigin.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selGetTypeAtOrigin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetTypeAtOrigin(*args):
        """
        ('SEL', '*sel')       
('l_int32', '*ptype')       
  selGetTypeAtOrigin()

      Input:  sel
              &type  (<return> SEL_HIT, SEL_MISS, SEL_DONT_CARE)
      Return: 0 if OK; 1 on error or if origin is not found


        """
        args = _convert_params(*args)
        
        return leptonica.selGetTypeAtOrigin(*args)
    
    

    try:
        leptonica.selaGetSelnames.argtypes = [ctypes.c_void_p]
        leptonica.selaGetSelnames.restype = lambda address: SARRAY(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaGetSelnames not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetSelnames(*args):
        """
        ('SELA', '*sela')       
  selaGetSelnames()

      Input:  sela
      Return: sa (of all sel names), or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetSelnames(*args)
    
    

    try:
        leptonica.selPrintToString.argtypes = [ctypes.c_void_p]
        leptonica.selPrintToString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        os.stderr.write("Warning - function selPrintToString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selPrintToString(*args):
        """
        ('SEL', '*sel')       
  selPrintToString()

      Input:  sel
      Return: str (string; caller must free)

  Notes:
      (1) This is an inverse function of selCreateFromString.
          It prints a textual representation of the SEL to a malloc'd
          string.  The format is the same as selCreateFromString
          except that newlines are inserted into the output
          between rows.
      (2) This is useful for debugging.  However, if you want to
          save some Sels in a file, put them in a Sela and write
          them out with selaWrite().  They can then be read in
          with selaRead().


        """
        args = _convert_params(*args)
        
        return leptonica.selPrintToString(*args)
    
    

    try:
        leptonica.selRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.selRotateOrth.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selRotateOrth(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'quads')       
  selRotateOrth()

      Input:  sel
              quads (0 - 4; number of 90 degree cw rotations)
      Return: seld, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selRotateOrth(*args)
    
    

    try:
        leptonica.selaDisplayInPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaDisplayInPix.restype = lambda address: PIX(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaDisplayInPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaDisplayInPix(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'size')       
('l_int32', 'gthick')       
('l_int32', 'spacing')       
('l_int32', 'ncols')       
  selaDisplayInPix()

      Input:  sela
              size (of grid interiors; odd; minimum size of 13 is enforced)
              gthick (grid thickness; minimum size of 2 is enforced)
              spacing (between sels, both horizontally and vertically)
              ncols (number of sels per "line")
      Return: pix (display of all sels in sela), or null on error

  Notes:
      (1) This gives a visual representation of all the sels in a sela.
      (2) See notes in selDisplayInPix() for display params of each sel.
      (3) This gives the nicest results when all sels in the sela
          are the same size.


        """
        args = _convert_params(*args)
        
        return leptonica.selaDisplayInPix(*args)
    
    

    try:
        leptonica.selWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selWrite(*args):
        """
        ('const char', '*fname')       
('SEL', '*sel')       
  selWrite()

      Input:  filename
              sel
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selWrite(*args)
    
    

    try:
        leptonica.create2dIntArray.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.create2dIntArray.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_int32))
    except AttributeError:
        os.stderr.write("Warning - function create2dIntArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def create2dIntArray(*args):
        """
        ('l_int32', 'sy')       
('l_int32', 'sx')       
  create2dIntArray()

      Input:  sy (rows == height)
              sx (columns == width)
      Return: doubly indexed array (i.e., an array of sy row pointers,
              each of which points to an array of sx ints)

  Notes:
      (1) The array[sy][sx] is indexed in standard "matrix notation",
          with the row index first.


        """
        args = _convert_params(*args)
        
        return leptonica.create2dIntArray(*args)
    
    

    try:
        leptonica.selReadStream.argtypes = [ctypes.c_void_p]
        leptonica.selReadStream.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selReadStream(*args):
        """
        ('FILE', '*fp')       
  selReadStream()

      Input:  stream
      Return: sel, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selReadStream(*args)
    
    

    try:
        leptonica.selaWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selaWrite.restype = ctypes.c_int32
    except AttributeError:
        os.stderr.write("Warning - function selaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaWrite(*args):
        """
        ('const char', '*fname')       
('SELA', '*sela')       
  selaWrite()

      Input:  filename
              sela
      Return: 0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaWrite(*args)
    
    

    try:
        leptonica.selCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.selCreateFromPix.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('const char', '*name')       
  selCreateFromPix()

      Input:  pix
              cy, cx (origin of sel)
              name (<optional> sel name; can be null)
      Return: sel, or null on error

  Notes:
      (1) The origin must be positive.


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromPix(*args)
    
    

    try:
        leptonica.selaRead.argtypes = [ctypes.c_void_p]
        leptonica.selaRead.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaRead(*args):
        """
        ('const char', '*fname')       
  selaRead()

      Input:  filename
      Return: sela, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaRead(*args)
    
    

    try:
        leptonica.selaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.selaDestroy.restype = None
    except AttributeError:
        os.stderr.write("Warning - function selaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaDestroy(*args):
        """
        ('SELA', '**psela')       
  selaDestroy()

      Input:  &sela (<to be nulled>)
      Return: void


        """
        args = _convert_params(*args)
        
        return leptonica.selaDestroy(*args)
    
    

    try:
        leptonica.selCreateFromColorPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selCreateFromColorPix.restype = lambda address: SEL(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selCreateFromColorPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromColorPix(*args):
        """
        ('PIX', '*pixs')       
('char', '*selname')       

  selCreateFromColorPix()

      Input:  pixs (cmapped or rgb)
              selname (<optional> sel name; can be null)
      Return: sel if OK, null on error

  Notes:
      (1) The sel size is given by the size of pixs.
      (2) In pixs, hits are represented by green pixels, misses by red
          pixels, and don't-cares by white pixels.
      (3) In pixs, there may be no misses, but there must be at least 1 hit.
      (4) At most there can be only one origin pixel, which is optionally
          specified by using a lower-intensity pixel:
            if a hit:  dark green
            if a miss: dark red
            if a don't care: gray
          If there is no such pixel, the origin defaults to the approximate
          center of the sel.


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromColorPix(*args)
    




class sel2(object):
    """  sel2.c

      Contains definitions of simple structuring elements

          SELA    *selaAddBasic()
               Linear horizontal and vertical
               Square
               Diagonals

          SELA    *selaAddHitMiss()
               Isolated foreground pixel
               Horizontal and vertical edges
               Slanted edge
               Corners

          SELA    *selaAddDwaLinear()
          SELA    *selaAddDwaCombs()
          SELA    *selaAddCrossJunctions()
          SELA    *selaAddTJunctions()

"""
    
    try:
        leptonica.selaAddCrossJunctions.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaAddCrossJunctions.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaAddCrossJunctions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddCrossJunctions(*args):
        """
        ('SELA', '*sela')       
('l_float32', 'hlsize')       
('l_float32', 'mdist')       
('l_int32', 'norient')       
('l_int32', 'debugflag')       
  selaAddCrossJunctions()

      Input:  sela (<optional>)
              hlsize (length of each line of hits from origin)
              mdist (distance of misses from the origin)
              norient (number of orientations; max of 8)
              debugflag (1 for debug output)
      Return: sela with additional sels, or null on error

  Notes:
      (1) Adds hitmiss Sels for the intersection of two lines.
          If the lines are very thin, they must be nearly orthogonal
          to register.
      (2) The number of Sels generated is equal to @norient.
      (3) If @norient == 2, this generates 2 Sels of crosses, each with
          two perpendicular lines of hits.  One Sel has horizontal and
          vertical hits; the other has hits along lines at +-45 degrees.
          Likewise, if @norient == 3, this generates 3 Sels of crosses
          oriented at 30 degrees with each other.
      (4) It is suggested that @hlsize be chosen at least 1 greater
          than @mdist.  Try values of (@hlsize, @mdist) such as
          (6,5), (7,6), (8,7), (9,7), etc.


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddCrossJunctions(*args)
    
    

    try:
        leptonica.selaAddTJunctions.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaAddTJunctions.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaAddTJunctions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddTJunctions(*args):
        """
        ('SELA', '*sela')       
('l_float32', 'hlsize')       
('l_float32', 'mdist')       
('l_int32', 'norient')       
('l_int32', 'debugflag')       
  selaAddTJunctions()

      Input:  sela (<optional>)
              hlsize (length of each line of hits from origin)
              mdist (distance of misses from the origin)
              norient (number of orientations; max of 8)
              debugflag (1 for debug output)
      Return: sela with additional sels, or null on error

  Notes:
      (1) Adds hitmiss Sels for the T-junction of two lines.
          If the lines are very thin, they must be nearly orthogonal
          to register.
      (2) The number of Sels generated is 4 * @norient.
      (3) It is suggested that @hlsize be chosen at least 1 greater
          than @mdist.  Try values of (@hlsize, @mdist) such as
          (6,5), (7,6), (8,7), (9,7), etc.


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddTJunctions(*args)
    
    

    try:
        leptonica.selaAddHitMiss.argtypes = [ctypes.c_void_p]
        leptonica.selaAddHitMiss.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaAddHitMiss not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddHitMiss(*args):
        """
        ('SELA', '*sela')       
  selaAddHitMiss()

      Input:  sela  (<optional>)
      Return: sela with additional sels, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddHitMiss(*args)
    
    

    try:
        leptonica.selaAddDwaCombs.argtypes = [ctypes.c_void_p]
        leptonica.selaAddDwaCombs.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaAddDwaCombs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddDwaCombs(*args):
        """
        ('SELA', '*sela')       
  selaAddDwaCombs()

      Input:  sela (<optional>)
      Return: sela with additional sels, or null on error

  Notes:
      (1) Adds all comb (horizontal, vertical) Sels that are
          used in composite linear morphological operations
          up to 63 pixels in length, which are the sizes over
          which dwa code can be generated.


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddDwaCombs(*args)
    
    

    try:
        leptonica.selaAddDwaLinear.argtypes = [ctypes.c_void_p]
        leptonica.selaAddDwaLinear.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaAddDwaLinear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddDwaLinear(*args):
        """
        ('SELA', '*sela')       
  selaAddDwaLinear()

      Input:  sela (<optional>)
      Return: sela with additional sels, or null on error

  Notes:
      (1) Adds all linear (horizontal, vertical) sels from
          2 to 63 pixels in length, which are the sizes over
          which dwa code can be generated.


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddDwaLinear(*args)
    
    

    try:
        leptonica.selaAddBasic.argtypes = [ctypes.c_void_p]
        leptonica.selaAddBasic.restype = lambda address: SELA(from_address=address)
    except AttributeError:
        os.stderr.write("Warning - function selaAddBasic not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddBasic(*args):
        """
        ('SELA', '*sela')       
  selaAddBasic()

      Input:  sela (<optional>)
      Return: sela with additional sels, or null on error

  Notes:
      (1) Adds the following sels:
            - all linear (horiz, vert) brick sels that are
              necessary for decomposable sels up to size 63
            - square brick sels up to size 10
            - 4 diagonal sels


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddBasic(*args)
    




# In C, you don't have to know in which "module" a function lives
# you should not need in Python - All Leptonica functions are agregated here:
functions = type("all_functions", (object,), dict (
        (function_name, function)
        for cls in globals().values() if isinstance(cls, type)
        for function_name, function in cls.__dict__.items()
            if isinstance(function, staticmethod)
    ))

__all__ = ['pixconv', 'paintcmap', 'graphics', 'morphapp', 'numabasic', 'numafunc1', 'numafunc2', 'gplot', 'colorseg', 'webpio', 'affine', 'fliphmtgen', 'viewfiles', 'pixafunc2', 'pixafunc1', 'correlscore', 'shear', 'freetype', 'boxfunc3', 'boxfunc2', 'boxfunc1', 'textops', 'colorquant2', 'colorquant1', 'rank', 'fmorphauto', 'rotate', 'regutils', 'pageseg', 'list', 'flipdetect', 'fhmtauto', 'morphseq', 'enhance', 'adaptmap', 'kernel', 'pixarith', 'bardecode', 'rotateshear', 'rop', 'watershed', 'colormorph', 'bilinear', 'scale', 'convolve', 'grayquant', 'colormap', 'tiffiostub', 'jpegio', 'binreduce', 'pixacc', 'pngiostub', 'affinecompose', 'queue', 'morph', 'rotateorth', 'warper', 'bbuffer', 'ccbord', 'readfile', 'webpiostub', 'classapp', 'pixcomp', 'seedfill', 'parseprotos', 'psio2stub', 'skew', 'makefile', 'maze', 'pixabasic', 'bmf', 'pix5', 'pix4', 'pix1', 'pix3', 'pix2', 'pngio', 'heap', 'gifio', 'projective', 'arrayaccess', 'morphdwa', 'leptwin', 'zlibmem', 'pixalloc', 'gifiostub', 'fpix2', 'psio1stub', 'fpix1', 'ptafunc1', 'runlength', 'bmpiostub', 'compare', 'conncomp', 'utils', 'pnmio', 'selgen', 'pnmiostub', 'zlibmemstub', 'convertfiles', 'spixio', 'baseline', 'ptabasic', 'edge', 'boxbasic', 'ptra', 'sarray', 'graymorph', 'tiffio', 'colorcontent', 'xtractprotos', 'rotateam', 'writefile', 'readbarcode', 'binexpand', 'stack', 'finditalic', 'sudoku', 'jbclass', 'bmpio', 'ccthin', 'partition', 'jpegiostub', 'binarize', 'pixtiling', 'endiantest', 'psio1', 'psio2', 'blend', 'sel1', 'sel2'] + ["leptonica", "functions"]
